/*
 *
 * Confidential Information of Telekinesys Research Limited (t/a Havok). Not for disclosure or distribution without Havok's
 * prior written consent. This software contains code, techniques and know-how which is confidential and proprietary to Havok.
 * Product and Trade Secret source code contains trade secrets of Havok. Havok Software (C) Copyright 1999-2013 Telekinesys Research Limited t/a Havok. All Rights Reserved. Use of this software is subject to the terms of an end user license agreement.
 *
 */

//HK_REFLECTION_PARSER_EXCLUDE_FILE

// Autogenerated by generateReflections.py (reflectedClasses.py)
// Changes will not be lost unless:
// - The workspace is re-generated using build.py
// - The corresponding reflection database (reflection.db) is deleted
// - The --force-output or --force-rebuild option is added to the pre-build generateReflection.py execution

// Generated from 'Physics2012/Collide/Shape/Deprecated/CompressedMesh/hkpCompressedMeshShape.h'
#include <Physics2012/Collide/hkpCollide.h>
#include <Common/Base/Reflection/hkClass.h>
#include <Common/Base/Reflection/hkInternalClassMember.h>
#include <Common/Base/Reflection/hkTypeInfo.h>
#include <Common/Base/Reflection/Attributes/hkAttributes.h>
#include <Physics2012/Collide/Shape/Deprecated/CompressedMesh/hkpCompressedMeshShape.h>
#define True true
#define False false


// External pointer and enum types
extern const hkClass hkAabbClass;
extern const hkClass hkQsTransformfClass;
extern const hkClass hkVector4fClass;
extern const hkClass hkpCompressedMeshShapeBigTriangleClass;
extern const hkClass hkpCompressedMeshShapeChunkClass;
extern const hkClass hkpCompressedMeshShapeConvexPieceClass;
extern const hkClass hkpMeshMaterialClass;
extern const hkClass hkpNamedMeshMaterialClass;
extern const hkClassEnum* hkpCompressedMeshShapeMaterialTypeEnum;
extern const hkClassEnum* hkpWeldingUtilityWeldingTypeEnum;

//
// Enum hkpCompressedMeshShape::MaterialType
//
static const hkInternalClassEnumItem hkpCompressedMeshShapeMaterialTypeEnumItems[] =
{
	{0, "MATERIAL_NONE"},
	{1, "MATERIAL_SINGLE_VALUE_PER_CHUNK"},
	{2, "MATERIAL_ONE_BYTE_PER_TRIANGLE"},
	{3, "MATERIAL_TWO_BYTES_PER_TRIANGLE"},
	{4, "MATERIAL_FOUR_BYTES_PER_TRIANGLE"},
};
static const hkInternalClassEnum hkpCompressedMeshShapeEnums[] = {
	{"MaterialType", hkpCompressedMeshShapeMaterialTypeEnumItems, 5, HK_NULL, 0 }
};
const hkClassEnum* hkpCompressedMeshShapeMaterialTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkpCompressedMeshShapeEnums[0]);

//
// Class hkpCompressedMeshShape::Chunk
//
static const hkInternalClassMember hkpCompressedMeshShape_ChunkClass_Members[] =
{
	{ "offset", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpCompressedMeshShape::Chunk,m_offset), HK_NULL },
	{ "vertices", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT16, 0, 0, HK_OFFSET_OF(hkpCompressedMeshShape::Chunk,m_vertices), HK_NULL },
	{ "indices", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT16, 0, 0, HK_OFFSET_OF(hkpCompressedMeshShape::Chunk,m_indices), HK_NULL },
	{ "stripLengths", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT16, 0, 0, HK_OFFSET_OF(hkpCompressedMeshShape::Chunk,m_stripLengths), HK_NULL },
	{ "weldingInfo", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT16, 0, 0, HK_OFFSET_OF(hkpCompressedMeshShape::Chunk,m_weldingInfo), HK_NULL },
	{ "materialInfo", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpCompressedMeshShape::Chunk,m_materialInfo), HK_NULL },
	{ "reference", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpCompressedMeshShape::Chunk,m_reference), HK_NULL },
	{ "transformIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpCompressedMeshShape::Chunk,m_transformIndex), HK_NULL }
};
const hkClass hkpCompressedMeshShapeChunkClass(
	"hkpCompressedMeshShapeChunk",
	HK_NULL, // parent
	sizeof(hkpCompressedMeshShape::Chunk),
	HK_NULL,
	0, // interfaces
	HK_NULL,
	0, // enums
	reinterpret_cast<const hkClassMember*>(hkpCompressedMeshShape_ChunkClass_Members),
	HK_COUNT_OF(hkpCompressedMeshShape_ChunkClass_Members),
	HK_NULL, // defaults
	HK_NULL, // attributes
	0, // flags
	hkUint32(4) // version
	);
#ifndef HK_HKCLASS_DEFINITION_ONLY
const hkClass& HK_CALL hkpCompressedMeshShape::Chunk::staticClass()
{
	return hkpCompressedMeshShapeChunkClass;
}
HK_COMPILE_TIME_ASSERT2( \
	sizeof(hkIsVirtual(static_cast<hkpCompressedMeshShape::Chunk*>(0))) == sizeof(hkBool::CompileTimeFalseType), \
	REFLECTION_PARSER_VTABLE_DETECTION_FAILED );
static void HK_CALL finishLoadedObjecthkpCompressedMeshShapeChunk(void* p, int finishing = 1)
{
	hkFinishLoadedObjectFlag f;
	f.m_finishing = finishing;
	new (p) hkpCompressedMeshShape::Chunk(f);
}
static void HK_CALL cleanupLoadedObjecthkpCompressedMeshShapeChunk(void* p)
{
	static_cast<hkpCompressedMeshShape::Chunk*>(p)->~Chunk();
}
extern const hkTypeInfo hkpCompressedMeshShapeChunkTypeInfo;
const hkTypeInfo hkpCompressedMeshShapeChunkTypeInfo(
	"hkpCompressedMeshShapeChunk",
	"!hkpCompressedMeshShape::Chunk",
	finishLoadedObjecthkpCompressedMeshShapeChunk,
	cleanupLoadedObjecthkpCompressedMeshShapeChunk,
	HK_NULL,
	sizeof(hkpCompressedMeshShape::Chunk)
	);
#endif

//
// Class hkpCompressedMeshShape::BigTriangle
//
static const hkInternalClassMember hkpCompressedMeshShape_BigTriangleClass_Members[] =
{
	{ "a", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpCompressedMeshShape::BigTriangle,m_a), HK_NULL },
	{ "b", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpCompressedMeshShape::BigTriangle,m_b), HK_NULL },
	{ "c", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpCompressedMeshShape::BigTriangle,m_c), HK_NULL },
	{ "material", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpCompressedMeshShape::BigTriangle,m_material), HK_NULL },
	{ "weldingInfo", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpCompressedMeshShape::BigTriangle,m_weldingInfo), HK_NULL },
	{ "transformIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpCompressedMeshShape::BigTriangle,m_transformIndex), HK_NULL }
};
namespace
{
	struct hkpCompressedMeshShapeBigTriangle_DefaultStruct
	{
		int s_defaultOffsets[6];
		typedef hkInt8 _hkBool;
		typedef hkFloat32 _hkVector4[4];
		typedef hkReal _hkQuaternion[4];
		typedef hkReal _hkMatrix3[12];
		typedef hkReal _hkRotation[12];
		typedef hkReal _hkQsTransform[12];
		typedef hkReal _hkMatrix4[16];
		typedef hkReal _hkTransform[16];
	};
	const hkpCompressedMeshShapeBigTriangle_DefaultStruct hkpCompressedMeshShapeBigTriangle_Default =
	{
		{-1,-1,-1,-1,hkClassMember::HK_CLASS_ZERO_DEFAULT,-1},
		
	};
}
const hkClass hkpCompressedMeshShapeBigTriangleClass(
	"hkpCompressedMeshShapeBigTriangle",
	HK_NULL, // parent
	sizeof(hkpCompressedMeshShape::BigTriangle),
	HK_NULL,
	0, // interfaces
	HK_NULL,
	0, // enums
	reinterpret_cast<const hkClassMember*>(hkpCompressedMeshShape_BigTriangleClass_Members),
	HK_COUNT_OF(hkpCompressedMeshShape_BigTriangleClass_Members),
	&hkpCompressedMeshShapeBigTriangle_Default,
	HK_NULL, // attributes
	0, // flags
	hkUint32(2) // version
	);
#ifndef HK_HKCLASS_DEFINITION_ONLY
const hkClass& HK_CALL hkpCompressedMeshShape::BigTriangle::staticClass()
{
	return hkpCompressedMeshShapeBigTriangleClass;
}
HK_COMPILE_TIME_ASSERT2( \
	sizeof(hkIsVirtual(static_cast<hkpCompressedMeshShape::BigTriangle*>(0))) == sizeof(hkBool::CompileTimeFalseType), \
	REFLECTION_PARSER_VTABLE_DETECTION_FAILED );
static void HK_CALL cleanupLoadedObjecthkpCompressedMeshShapeBigTriangle(void* p)
{
	static_cast<hkpCompressedMeshShape::BigTriangle*>(p)->~BigTriangle();
}
extern const hkTypeInfo hkpCompressedMeshShapeBigTriangleTypeInfo;
const hkTypeInfo hkpCompressedMeshShapeBigTriangleTypeInfo(
	"hkpCompressedMeshShapeBigTriangle",
	"!hkpCompressedMeshShape::BigTriangle",
	HK_NULL,
	cleanupLoadedObjecthkpCompressedMeshShapeBigTriangle,
	HK_NULL,
	sizeof(hkpCompressedMeshShape::BigTriangle)
	);
#endif

//
// Class hkpCompressedMeshShape::ConvexPiece
//
static const hkInternalClassMember hkpCompressedMeshShape_ConvexPieceClass_Members[] =
{
	{ "offset", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpCompressedMeshShape::ConvexPiece,m_offset), HK_NULL },
	{ "vertices", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT16, 0, 0, HK_OFFSET_OF(hkpCompressedMeshShape::ConvexPiece,m_vertices), HK_NULL },
	{ "reference", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpCompressedMeshShape::ConvexPiece,m_reference), HK_NULL },
	{ "transformIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpCompressedMeshShape::ConvexPiece,m_transformIndex), HK_NULL }
};
const hkClass hkpCompressedMeshShapeConvexPieceClass(
	"hkpCompressedMeshShapeConvexPiece",
	HK_NULL, // parent
	sizeof(hkpCompressedMeshShape::ConvexPiece),
	HK_NULL,
	0, // interfaces
	HK_NULL,
	0, // enums
	reinterpret_cast<const hkClassMember*>(hkpCompressedMeshShape_ConvexPieceClass_Members),
	HK_COUNT_OF(hkpCompressedMeshShape_ConvexPieceClass_Members),
	HK_NULL, // defaults
	HK_NULL, // attributes
	0, // flags
	hkUint32(4) // version
	);
#ifndef HK_HKCLASS_DEFINITION_ONLY
const hkClass& HK_CALL hkpCompressedMeshShape::ConvexPiece::staticClass()
{
	return hkpCompressedMeshShapeConvexPieceClass;
}
HK_COMPILE_TIME_ASSERT2( \
	sizeof(hkIsVirtual(static_cast<hkpCompressedMeshShape::ConvexPiece*>(0))) == sizeof(hkBool::CompileTimeFalseType), \
	REFLECTION_PARSER_VTABLE_DETECTION_FAILED );
static void HK_CALL finishLoadedObjecthkpCompressedMeshShapeConvexPiece(void* p, int finishing = 1)
{
	hkFinishLoadedObjectFlag f;
	f.m_finishing = finishing;
	new (p) hkpCompressedMeshShape::ConvexPiece(f);
}
static void HK_CALL cleanupLoadedObjecthkpCompressedMeshShapeConvexPiece(void* p)
{
	static_cast<hkpCompressedMeshShape::ConvexPiece*>(p)->~ConvexPiece();
}
extern const hkTypeInfo hkpCompressedMeshShapeConvexPieceTypeInfo;
const hkTypeInfo hkpCompressedMeshShapeConvexPieceTypeInfo(
	"hkpCompressedMeshShapeConvexPiece",
	"!hkpCompressedMeshShape::ConvexPiece",
	finishLoadedObjecthkpCompressedMeshShapeConvexPiece,
	cleanupLoadedObjecthkpCompressedMeshShapeConvexPiece,
	HK_NULL,
	sizeof(hkpCompressedMeshShape::ConvexPiece)
	);
#endif

//
// Class hkpCompressedMeshShape
//
extern const hkClass hkpShapeCollectionClass;

// hkpCompressedMeshShape attributes
static const hkInternalClassMember hkpCompressedMeshShapeClass_Members[] =
{
	{ "bitsPerIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpCompressedMeshShape,m_bitsPerIndex), HK_NULL },
	{ "bitsPerWIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpCompressedMeshShape,m_bitsPerWIndex), HK_NULL },
	{ "wIndexMask", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpCompressedMeshShape,m_wIndexMask), HK_NULL },
	{ "indexMask", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpCompressedMeshShape,m_indexMask), HK_NULL },
	{ "radius", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpCompressedMeshShape,m_radius), HK_NULL },
	{ "weldingType", HK_NULL, hkpWeldingUtilityWeldingTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, HK_OFFSET_OF(hkpCompressedMeshShape,m_weldingType), HK_NULL },
	{ "materialType", HK_NULL, hkpCompressedMeshShapeMaterialTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, HK_OFFSET_OF(hkpCompressedMeshShape,m_materialType), HK_NULL },
	{ "materials", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT32, 0, 0, HK_OFFSET_OF(hkpCompressedMeshShape,m_materials), HK_NULL },
	{ "materials16", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT16, 0, 0, HK_OFFSET_OF(hkpCompressedMeshShape,m_materials16), HK_NULL },
	{ "materials8", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT8, 0, 0, HK_OFFSET_OF(hkpCompressedMeshShape,m_materials8), HK_NULL },
	{ "transforms", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_QSTRANSFORM, 0, 0, HK_OFFSET_OF(hkpCompressedMeshShape,m_transforms), HK_NULL },
	{ "bigVertices", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VECTOR4, 0, 0, HK_OFFSET_OF(hkpCompressedMeshShape,m_bigVertices), HK_NULL },
	{ "bigTriangles", &hkpCompressedMeshShapeBigTriangleClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, HK_OFFSET_OF(hkpCompressedMeshShape,m_bigTriangles), HK_NULL },
	{ "chunks", &hkpCompressedMeshShapeChunkClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, HK_OFFSET_OF(hkpCompressedMeshShape,m_chunks), HK_NULL },
	{ "convexPieces", &hkpCompressedMeshShapeConvexPieceClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, HK_OFFSET_OF(hkpCompressedMeshShape,m_convexPieces), HK_NULL },
	{ "error", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpCompressedMeshShape,m_error), HK_NULL },
	{ "bounds", &hkAabbClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpCompressedMeshShape,m_bounds), HK_NULL },
	{ "defaultCollisionFilterInfo", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpCompressedMeshShape,m_defaultCollisionFilterInfo), HK_NULL },
	{ "meshMaterials", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, HK_OFFSET_OF(hkpCompressedMeshShape,m_meshMaterials), HK_NULL },
	{ "materialStriding", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpCompressedMeshShape,m_materialStriding), HK_NULL },
	{ "numMaterials", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpCompressedMeshShape,m_numMaterials), HK_NULL },
	{ "namedMaterials", &hkpNamedMeshMaterialClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, HK_OFFSET_OF(hkpCompressedMeshShape,m_namedMaterials), HK_NULL }
};
namespace
{
	struct hkpCompressedMeshShape_DefaultStruct
	{
		int s_defaultOffsets[22];
		typedef hkInt8 _hkBool;
		typedef hkFloat32 _hkVector4[4];
		typedef hkReal _hkQuaternion[4];
		typedef hkReal _hkMatrix3[12];
		typedef hkReal _hkRotation[12];
		typedef hkReal _hkQsTransform[12];
		typedef hkReal _hkMatrix4[16];
		typedef hkReal _hkTransform[16];
		hkUint8 /* hkEnum< enum hkpWeldingUtility::WeldingType, hkUint8 > */ m_weldingType;
	};
	const hkpCompressedMeshShape_DefaultStruct hkpCompressedMeshShape_Default =
	{
		{-1,-1,-1,-1,-1,HK_OFFSET_OF(hkpCompressedMeshShape_DefaultStruct,m_weldingType),-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,hkClassMember::HK_CLASS_ZERO_DEFAULT,-1,-1,-1},
		hkpWeldingUtility::WELDING_TYPE_NONE
	};
}
extern const hkClass hkpCompressedMeshShapeClass;
const hkClass hkpCompressedMeshShapeClass(
	"hkpCompressedMeshShape",
	&hkpShapeCollectionClass, // parent
	sizeof(::hkpCompressedMeshShape),
	HK_NULL,
	0, // interfaces
	reinterpret_cast<const hkClassEnum*>(hkpCompressedMeshShapeEnums),
	1, // enums
	reinterpret_cast<const hkClassMember*>(hkpCompressedMeshShapeClass_Members),
	HK_COUNT_OF(hkpCompressedMeshShapeClass_Members),
	&hkpCompressedMeshShape_Default,
	HK_NULL, // attributes
	0, // flags
	hkUint32(11) // version
	);
#ifndef HK_HKCLASS_DEFINITION_ONLY
const hkClass& HK_CALL hkpCompressedMeshShape::staticClass()
{
	return hkpCompressedMeshShapeClass;
}
HK_COMPILE_TIME_ASSERT2( \
	sizeof(hkIsVirtual(static_cast<hkpCompressedMeshShape*>(0))) == sizeof(hkBool::CompileTimeTrueType), \
	REFLECTION_PARSER_VTABLE_DETECTION_FAILED );
static void HK_CALL finishLoadedObjecthkpCompressedMeshShape(void* p, int finishing = 1)
{
	hkFinishLoadedObjectFlag f;
	f.m_finishing = finishing;
	new (p) hkpCompressedMeshShape(f);
}
static void HK_CALL cleanupLoadedObjecthkpCompressedMeshShape(void* p)
{
	static_cast<hkpCompressedMeshShape*>(p)->~hkpCompressedMeshShape();
}
static const void* HK_CALL getVtablehkpCompressedMeshShape()
{
	#if HK_LINKONCE_VTABLES==0
	#if HK_HASHCODE_VTABLE_REGISTRY==1
	return ((const void*)(typeid(hkpCompressedMeshShape).hash_code()));
	#else
	return ((const void*)(typeid(hkpCompressedMeshShape).name()));
	#endif
	#else
	union { HK_ALIGN16(void* ptr); char buf[sizeof(hkpCompressedMeshShape)]; } u;
	hkFinishLoadedObjectFlag f;
	new (u.buf) hkpCompressedMeshShape(f);
	return u.ptr;
	#endif
}
extern const hkTypeInfo hkpCompressedMeshShapeTypeInfo;
const hkTypeInfo hkpCompressedMeshShapeTypeInfo(
	"hkpCompressedMeshShape",
	"!hkpCompressedMeshShape",
	finishLoadedObjecthkpCompressedMeshShape,
	cleanupLoadedObjecthkpCompressedMeshShape,
	getVtablehkpCompressedMeshShape(),
	sizeof(hkpCompressedMeshShape)
	);
#endif

/*
 * Havok SDK - Base file, BUILD(#20130912)
 * 
 * Confidential Information of Havok.  (C) Copyright 1999-2013
 * Telekinesys Research Limited t/a Havok. All Rights Reserved. The Havok
 * Logo, and the Havok buzzsaw logo are trademarks of Havok.  Title, ownership
 * rights, and intellectual property rights in the Havok software remain in
 * Havok and/or its suppliers.
 * 
 * Use of this software for evaluation purposes is subject to and indicates
 * acceptance of the End User licence Agreement for this product. A copy of
 * the license is included with this software and is also available from salesteam@havok.com.
 * 
 */
