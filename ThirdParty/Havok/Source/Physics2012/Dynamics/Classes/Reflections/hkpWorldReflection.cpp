/*
 *
 * Confidential Information of Telekinesys Research Limited (t/a Havok). Not for disclosure or distribution without Havok's
 * prior written consent. This software contains code, techniques and know-how which is confidential and proprietary to Havok.
 * Product and Trade Secret source code contains trade secrets of Havok. Havok Software (C) Copyright 1999-2013 Telekinesys Research Limited t/a Havok. All Rights Reserved. Use of this software is subject to the terms of an end user license agreement.
 *
 */

//HK_REFLECTION_PARSER_EXCLUDE_FILE

// Autogenerated by generateReflections.py (reflectedClasses.py)
// Changes will not be lost unless:
// - The workspace is re-generated using build.py
// - The corresponding reflection database (reflection.db) is deleted
// - The --force-output or --force-rebuild option is added to the pre-build generateReflection.py execution

// Generated from 'Physics2012/Dynamics/World/hkpWorld.h'
#include <Physics2012/Dynamics/hkpDynamics.h>
#include <Common/Base/Reflection/hkClass.h>
#include <Common/Base/Reflection/hkInternalClassMember.h>
#include <Common/Base/Reflection/hkTypeInfo.h>
#include <Common/Base/Reflection/Attributes/hkAttributes.h>
#include <Physics2012/Dynamics/World/hkpWorld.h>
#define True true
#define False false

//
// Global
//

//
// Enum ::hkpUpdateCollisionFilterOnWorldMode
//
static const hkInternalClassEnumItem Physics2012_Dynamics_World_hkpWorldhkpUpdateCollisionFilterOnWorldModeEnumItems[] =
{
	{0, "HK_UPDATE_FILTER_ON_WORLD_FULL_CHECK"},
	{1, "HK_UPDATE_FILTER_ON_WORLD_DISABLE_ENTITY_ENTITY_COLLISIONS_ONLY"},
};

//
// Enum ::hkpUpdateCollisionFilterOnEntityMode
//
static const hkInternalClassEnumItem Physics2012_Dynamics_World_hkpWorldhkpUpdateCollisionFilterOnEntityModeEnumItems[] =
{
	{0, "HK_UPDATE_FILTER_ON_ENTITY_FULL_CHECK"},
	{1, "HK_UPDATE_FILTER_ON_ENTITY_DISABLE_ENTITY_ENTITY_COLLISIONS_ONLY"},
};

//
// Enum ::hkpEntityActivation
//
static const hkInternalClassEnumItem Physics2012_Dynamics_World_hkpWorldhkpEntityActivationEnumItems[] =
{
	{0, "HK_ENTITY_ACTIVATION_DO_NOT_ACTIVATE"},
	{1, "HK_ENTITY_ACTIVATION_DO_ACTIVATE"},
};

//
// Enum ::hkpUpdateCollectionFilterMode
//
static const hkInternalClassEnumItem Physics2012_Dynamics_World_hkpWorldhkpUpdateCollectionFilterModeEnumItems[] =
{
	{0, "HK_UPDATE_COLLECTION_FILTER_IGNORE_SHAPE_COLLECTIONS"},
	{1, "HK_UPDATE_COLLECTION_FILTER_PROCESS_SHAPE_COLLECTIONS"},
};

//
// Enum ::hkpStepResult
//
static const hkInternalClassEnumItem Physics2012_Dynamics_World_hkpWorldhkpStepResultEnumItems[] =
{
	{0, "HK_STEP_RESULT_SUCCESS"},
	{1, "HK_STEP_RESULT_MEMORY_FAILURE_BEFORE_INTEGRATION"},
	{2, "HK_STEP_RESULT_MEMORY_FAILURE_DURING_COLLIDE"},
	{3, "HK_STEP_RESULT_MEMORY_FAILURE_DURING_TOI_SOLVE"},
};
static const hkInternalClassEnum Physics2012_Dynamics_World_hkpWorldEnums[] = {
	{"hkpUpdateCollisionFilterOnWorldMode", Physics2012_Dynamics_World_hkpWorldhkpUpdateCollisionFilterOnWorldModeEnumItems, 2, HK_NULL, 0 },
	{"hkpUpdateCollisionFilterOnEntityMode", Physics2012_Dynamics_World_hkpWorldhkpUpdateCollisionFilterOnEntityModeEnumItems, 2, HK_NULL, 0 },
	{"hkpEntityActivation", Physics2012_Dynamics_World_hkpWorldhkpEntityActivationEnumItems, 2, HK_NULL, 0 },
	{"hkpUpdateCollectionFilterMode", Physics2012_Dynamics_World_hkpWorldhkpUpdateCollectionFilterModeEnumItems, 2, HK_NULL, 0 },
	{"hkpStepResult", Physics2012_Dynamics_World_hkpWorldhkpStepResultEnumItems, 4, HK_NULL, 0 }
};
const hkClassEnum* hkpUpdateCollisionFilterOnWorldModeEnum = reinterpret_cast<const hkClassEnum*>(&Physics2012_Dynamics_World_hkpWorldEnums[0]);
const hkClassEnum* hkpUpdateCollisionFilterOnEntityModeEnum = reinterpret_cast<const hkClassEnum*>(&Physics2012_Dynamics_World_hkpWorldEnums[1]);
const hkClassEnum* hkpEntityActivationEnum = reinterpret_cast<const hkClassEnum*>(&Physics2012_Dynamics_World_hkpWorldEnums[2]);
const hkClassEnum* hkpUpdateCollectionFilterModeEnum = reinterpret_cast<const hkClassEnum*>(&Physics2012_Dynamics_World_hkpWorldEnums[3]);
const hkClassEnum* hkpStepResultEnum = reinterpret_cast<const hkClassEnum*>(&Physics2012_Dynamics_World_hkpWorldEnums[4]);

// External pointer and enum types
extern const hkClass hkCriticalSectionClass;
extern const hkClass hkMultiThreadCheckClass;
extern const hkClass hkStepInfoClass;
extern const hkClass hkWorldMemoryAvailableWatchDogClass;
extern const hkClass hkdWorldClass;
extern const hkClass hknpWorldClass;
extern const hkClass hkpActionListenerClass;
extern const hkClass hkpBroadPhaseBorderClass;
extern const hkClass hkpBroadPhaseBorderListenerClass;
extern const hkClass hkpBroadPhaseClass;
extern const hkClass hkpCollisionDispatcherClass;
extern const hkClass hkpCollisionFilterClass;
extern const hkClass hkpConstraintListenerClass;
extern const hkClass hkpContactImpulseLimitBreachedListenerClass;
extern const hkClass hkpContactListenerClass;
extern const hkClass hkpConvexListFilterClass;
extern const hkClass hkpDebugInfoOnPendingOperationQueuesClass;
extern const hkClass hkpEntityEntityBroadPhaseListenerClass;
extern const hkClass hkpEntityListenerClass;
extern const hkClass hkpIslandActivationListenerClass;
extern const hkClass hkpIslandPostCollideListenerClass;
extern const hkClass hkpIslandPostIntegrateListenerClass;
extern const hkClass hkpMtThreadStructureClass;
extern const hkClass hkpPhantomBroadPhaseListenerClass;
extern const hkClass hkpPhantomClass;
extern const hkClass hkpPhantomListenerClass;
extern const hkClass hkpProcessCollisionInputClass;
extern const hkClass hkpRigidBodyClass;
extern const hkClass hkpSimulationClass;
extern const hkClass hkpSimulationIslandClass;
extern const hkClass hkpSolverInfoClass;
extern const hkClass hkpTypedBroadPhaseDispatcherClass;
extern const hkClass hkpViolatedConstraintArrayClass;
extern const hkClass hkpWorldDeletionListenerClass;
extern const hkClass hkpWorldDynamicsStepInfoClass;
extern const hkClass hkpWorldExtensionClass;
extern const hkClass hkpWorldMaintenanceMgrClass;
extern const hkClass hkpWorldOperationQueueClass;
extern const hkClass hkpWorldPostCollideListenerClass;
extern const hkClass hkpWorldPostIntegrateListenerClass;
extern const hkClass hkpWorldPostSimulationListenerClass;
extern const hkClassEnum* hkpWorldCinfoBroadPhaseTypeEnum;
extern const hkClassEnum* hkpWorldCinfoContactPointGenerationEnum;
extern const hkClassEnum* hkpWorldCinfoSimulationTypeEnum;

//
// Enum hkpWorld::ReintegrationRecollideMode
//
static const hkInternalClassEnumItem hkpWorldReintegrationRecollideModeEnumItems[] =
{
	{1, "RR_MODE_REINTEGRATE"},
	{2, "RR_MODE_RECOLLIDE_BROADPHASE"},
	{4, "RR_MODE_RECOLLIDE_NARROWPHASE"},
	{7, "RR_MODE_ALL"},
};

//
// Enum hkpWorld::MtAccessChecking
//
static const hkInternalClassEnumItem hkpWorldMtAccessCheckingEnumItems[] =
{
	{0, "MT_ACCESS_CHECKING_ENABLED"},
	{1, "MT_ACCESS_CHECKING_DISABLED"},
};

//
// Enum hkpWorld::CachedAabbUpdate
//
static const hkInternalClassEnumItem hkpWorldCachedAabbUpdateEnumItems[] =
{
	{0, "SHIFT_BROADPHASE_UPDATE_ENTITY_AABBS"},
	{1, "SHIFT_BROADPHASE_IGNORE_ENTITY_AABBS"},
};
static const hkInternalClassEnum hkpWorldEnums[] = {
	{"ReintegrationRecollideMode", hkpWorldReintegrationRecollideModeEnumItems, 4, HK_NULL, 0 },
	{"MtAccessChecking", hkpWorldMtAccessCheckingEnumItems, 2, HK_NULL, 0 },
	{"CachedAabbUpdate", hkpWorldCachedAabbUpdateEnumItems, 2, HK_NULL, 0 }
};
const hkClassEnum* hkpWorldReintegrationRecollideModeEnum = reinterpret_cast<const hkClassEnum*>(&hkpWorldEnums[0]);
const hkClassEnum* hkpWorldMtAccessCheckingEnum = reinterpret_cast<const hkClassEnum*>(&hkpWorldEnums[1]);
const hkClassEnum* hkpWorldCachedAabbUpdateEnum = reinterpret_cast<const hkClassEnum*>(&hkpWorldEnums[2]);

//
// Class hkpWorld
//
extern const hkClass hkReferencedObjectClass;

static const hkInternalClassMember hkpWorldClass_Members[] =
{
	{ "simulation", &hkpSimulationClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, HK_OFFSET_OF(hkpWorld,m_simulation), HK_NULL },
	{ "gravity", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpWorld,m_gravity), HK_NULL },
	{ "fixedIsland", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, HK_OFFSET_OF(hkpWorld,m_fixedIsland), HK_NULL },
	{ "fixedRigidBody", &hkpRigidBodyClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, HK_OFFSET_OF(hkpWorld,m_fixedRigidBody), HK_NULL },
	{ "activeSimulationIslands", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0|hkClassMember::SERIALIZE_IGNORED, HK_OFFSET_OF(hkpWorld,m_activeSimulationIslands), HK_NULL },
	{ "inactiveSimulationIslands", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0|hkClassMember::SERIALIZE_IGNORED, HK_OFFSET_OF(hkpWorld,m_inactiveSimulationIslands), HK_NULL },
	{ "dirtySimulationIslands", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0|hkClassMember::SERIALIZE_IGNORED, HK_OFFSET_OF(hkpWorld,m_dirtySimulationIslands), HK_NULL },
	{ "maintenanceMgr", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, HK_OFFSET_OF(hkpWorld,m_maintenanceMgr), HK_NULL },
	{ "memoryWatchDog", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, HK_OFFSET_OF(hkpWorld,m_memoryWatchDog), HK_NULL },
	{ "assertOnRunningOutOfSolverMemory", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, HK_OFFSET_OF(hkpWorld,m_assertOnRunningOutOfSolverMemory), HK_NULL },
	{ "broadPhaseType", HK_NULL, HK_NULL, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0|hkClassMember::SERIALIZE_IGNORED, HK_OFFSET_OF(hkpWorld,m_broadPhaseType), HK_NULL },
	{ "broadPhase", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, HK_OFFSET_OF(hkpWorld,m_broadPhase), HK_NULL },
	{ "broadPhaseDispatcher", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, HK_OFFSET_OF(hkpWorld,m_broadPhaseDispatcher), HK_NULL },
	{ "phantomBroadPhaseListener", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, HK_OFFSET_OF(hkpWorld,m_phantomBroadPhaseListener), HK_NULL },
	{ "entityEntityBroadPhaseListener", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, HK_OFFSET_OF(hkpWorld,m_entityEntityBroadPhaseListener), HK_NULL },
	{ "broadPhaseBorderListener", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, HK_OFFSET_OF(hkpWorld,m_broadPhaseBorderListener), HK_NULL },
	{ "multithreadedSimulationJobData", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, HK_OFFSET_OF(hkpWorld,m_multithreadedSimulationJobData), HK_NULL },
	{ "collisionInput", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, HK_OFFSET_OF(hkpWorld,m_collisionInput), HK_NULL },
	{ "collisionFilter", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, HK_OFFSET_OF(hkpWorld,m_collisionFilter), HK_NULL },
	{ "collisionDispatcher", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, HK_OFFSET_OF(hkpWorld,m_collisionDispatcher), HK_NULL },
	{ "convexListFilter", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, HK_OFFSET_OF(hkpWorld,m_convexListFilter), HK_NULL },
	{ "pendingOperations", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, HK_OFFSET_OF(hkpWorld,m_pendingOperations), HK_NULL },
	{ "pendingOperationsCount", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpWorld,m_pendingOperationsCount), HK_NULL },
	{ "pendingBodyOperationsCount", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, HK_OFFSET_OF(hkpWorld,m_pendingBodyOperationsCount), HK_NULL },
	{ "criticalOperationsLockCount", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpWorld,m_criticalOperationsLockCount), HK_NULL },
	{ "criticalOperationsLockCountForPhantoms", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpWorld,m_criticalOperationsLockCountForPhantoms), HK_NULL },
	{ "blockExecutingPendingOperations", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpWorld,m_blockExecutingPendingOperations), HK_NULL },
	{ "criticalOperationsAllowed", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpWorld,m_criticalOperationsAllowed), HK_NULL },
	{ "pendingOperationQueues", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, HK_OFFSET_OF(hkpWorld,m_pendingOperationQueues), HK_NULL },
	{ "pendingOperationQueueCount", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpWorld,m_pendingOperationQueueCount), HK_NULL },
	{ "multiThreadCheck", &hkMultiThreadCheckClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, HK_OFFSET_OF(hkpWorld,m_multiThreadCheck), HK_NULL },
	{ "processActionsInSingleThread", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpWorld,m_processActionsInSingleThread), HK_NULL },
	{ "allowIntegrationOfIslandsWithoutConstraintsInASeparateJob", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpWorld,m_allowIntegrationOfIslandsWithoutConstraintsInASeparateJob), HK_NULL },
	{ "minDesiredIslandSize", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpWorld,m_minDesiredIslandSize), HK_NULL },
	{ "modifyConstraintCriticalSection", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, HK_OFFSET_OF(hkpWorld,m_modifyConstraintCriticalSection), HK_NULL },
	{ "isLocked", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpWorld,m_isLocked), HK_NULL },
	{ "islandDirtyListCriticalSection", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, HK_OFFSET_OF(hkpWorld,m_islandDirtyListCriticalSection), HK_NULL },
	{ "propertyMasterLock", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, HK_OFFSET_OF(hkpWorld,m_propertyMasterLock), HK_NULL },
	{ "wantSimulationIslands", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpWorld,m_wantSimulationIslands), HK_NULL },
	{ "snapCollisionToConvexEdgeThreshold", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpWorld,m_snapCollisionToConvexEdgeThreshold), HK_NULL },
	{ "snapCollisionToConcaveEdgeThreshold", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpWorld,m_snapCollisionToConcaveEdgeThreshold), HK_NULL },
	{ "enableToiWeldRejection", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpWorld,m_enableToiWeldRejection), HK_NULL },
	{ "wantDeactivation", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpWorld,m_wantDeactivation), HK_NULL },
	{ "shouldActivateOnRigidBodyTransformChange", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpWorld,m_shouldActivateOnRigidBodyTransformChange), HK_NULL },
	{ "deactivationReferenceDistance", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpWorld,m_deactivationReferenceDistance), HK_NULL },
	{ "toiCollisionResponseRotateNormal", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpWorld,m_toiCollisionResponseRotateNormal), HK_NULL },
	{ "maxSectorsPerMidphaseCollideTask", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpWorld,m_maxSectorsPerMidphaseCollideTask), HK_NULL },
	{ "maxSectorsPerNarrowphaseCollideTask", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpWorld,m_maxSectorsPerNarrowphaseCollideTask), HK_NULL },
	{ "processToisMultithreaded", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpWorld,m_processToisMultithreaded), HK_NULL },
	{ "maxEntriesPerToiMidphaseCollideTask", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpWorld,m_maxEntriesPerToiMidphaseCollideTask), HK_NULL },
	{ "maxEntriesPerToiNarrowphaseCollideTask", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpWorld,m_maxEntriesPerToiNarrowphaseCollideTask), HK_NULL },
	{ "maxNumToiCollisionPairsSinglethreaded", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpWorld,m_maxNumToiCollisionPairsSinglethreaded), HK_NULL },
	{ "simulationType", HK_NULL, HK_NULL, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT32, 0, 0|hkClassMember::SERIALIZE_IGNORED, HK_OFFSET_OF(hkpWorld,m_simulationType), HK_NULL },
	{ "numToisTillAllowedPenetrationSimplifiedToi", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpWorld,m_numToisTillAllowedPenetrationSimplifiedToi), HK_NULL },
	{ "numToisTillAllowedPenetrationToi", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpWorld,m_numToisTillAllowedPenetrationToi), HK_NULL },
	{ "numToisTillAllowedPenetrationToiHigher", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpWorld,m_numToisTillAllowedPenetrationToiHigher), HK_NULL },
	{ "numToisTillAllowedPenetrationToiForced", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpWorld,m_numToisTillAllowedPenetrationToiForced), HK_NULL },
	{ "lastEntityUid", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpWorld,m_lastEntityUid), HK_NULL },
	{ "lastIslandUid", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpWorld,m_lastIslandUid), HK_NULL },
	{ "lastConstraintUid", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpWorld,m_lastConstraintUid), HK_NULL },
	{ "phantoms", &hkpPhantomClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, HK_OFFSET_OF(hkpWorld,m_phantoms), HK_NULL },
	{ "actionListeners", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0|hkClassMember::SERIALIZE_IGNORED, HK_OFFSET_OF(hkpWorld,m_actionListeners), HK_NULL },
	{ "entityListeners", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0|hkClassMember::SERIALIZE_IGNORED, HK_OFFSET_OF(hkpWorld,m_entityListeners), HK_NULL },
	{ "phantomListeners", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0|hkClassMember::SERIALIZE_IGNORED, HK_OFFSET_OF(hkpWorld,m_phantomListeners), HK_NULL },
	{ "constraintListeners", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0|hkClassMember::SERIALIZE_IGNORED, HK_OFFSET_OF(hkpWorld,m_constraintListeners), HK_NULL },
	{ "worldDeletionListeners", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0|hkClassMember::SERIALIZE_IGNORED, HK_OFFSET_OF(hkpWorld,m_worldDeletionListeners), HK_NULL },
	{ "islandActivationListeners", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0|hkClassMember::SERIALIZE_IGNORED, HK_OFFSET_OF(hkpWorld,m_islandActivationListeners), HK_NULL },
	{ "worldPostSimulationListeners", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0|hkClassMember::SERIALIZE_IGNORED, HK_OFFSET_OF(hkpWorld,m_worldPostSimulationListeners), HK_NULL },
	{ "worldPostIntegrateListeners", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0|hkClassMember::SERIALIZE_IGNORED, HK_OFFSET_OF(hkpWorld,m_worldPostIntegrateListeners), HK_NULL },
	{ "worldPostCollideListeners", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0|hkClassMember::SERIALIZE_IGNORED, HK_OFFSET_OF(hkpWorld,m_worldPostCollideListeners), HK_NULL },
	{ "islandPostIntegrateListeners", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0|hkClassMember::SERIALIZE_IGNORED, HK_OFFSET_OF(hkpWorld,m_islandPostIntegrateListeners), HK_NULL },
	{ "islandPostCollideListeners", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0|hkClassMember::SERIALIZE_IGNORED, HK_OFFSET_OF(hkpWorld,m_islandPostCollideListeners), HK_NULL },
	{ "contactListeners", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0|hkClassMember::SERIALIZE_IGNORED, HK_OFFSET_OF(hkpWorld,m_contactListeners), HK_NULL },
	{ "contactImpulseLimitBreachedListeners", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0|hkClassMember::SERIALIZE_IGNORED, HK_OFFSET_OF(hkpWorld,m_contactImpulseLimitBreachedListeners), HK_NULL },
	{ "worldExtensions", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0|hkClassMember::SERIALIZE_IGNORED, HK_OFFSET_OF(hkpWorld,m_worldExtensions), HK_NULL },
	{ "violatedConstraintArray", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, HK_OFFSET_OF(hkpWorld,m_violatedConstraintArray), HK_NULL },
	{ "broadPhaseBorder", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, HK_OFFSET_OF(hkpWorld,m_broadPhaseBorder), HK_NULL },
	{ "destructionWorld", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, HK_OFFSET_OF(hkpWorld,m_destructionWorld), HK_NULL },
	{ "npWorld", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, HK_OFFSET_OF(hkpWorld,m_npWorld), HK_NULL },
	{ "broadPhaseExtents", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 2, 0, HK_OFFSET_OF(hkpWorld,m_broadPhaseExtents), HK_NULL },
	{ "broadPhaseNumMarkers", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpWorld,m_broadPhaseNumMarkers), HK_NULL },
	{ "sizeOfToiEventQueue", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpWorld,m_sizeOfToiEventQueue), HK_NULL },
	{ "broadPhaseQuerySize", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpWorld,m_broadPhaseQuerySize), HK_NULL },
	{ "broadPhaseUpdateSize", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpWorld,m_broadPhaseUpdateSize), HK_NULL },
	{ "contactPointGeneration", HK_NULL, HK_NULL, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0|hkClassMember::SERIALIZE_IGNORED, HK_OFFSET_OF(hkpWorld,m_contactPointGeneration), HK_NULL },
	{ "useCompoundSpuElf", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpWorld,m_useCompoundSpuElf), HK_NULL }
};
extern const hkClass hkpWorldClass;
const hkClass hkpWorldClass(
	"hkpWorld",
	&hkReferencedObjectClass, // parent
	sizeof(::hkpWorld),
	HK_NULL,
	0, // interfaces
	reinterpret_cast<const hkClassEnum*>(hkpWorldEnums),
	3, // enums
	reinterpret_cast<const hkClassMember*>(hkpWorldClass_Members),
	HK_COUNT_OF(hkpWorldClass_Members),
	HK_NULL, // defaults
	HK_NULL, // attributes
	hkClass::FLAGS_NOT_SERIALIZABLE,
	hkUint32(0) // version
	);
#ifndef HK_HKCLASS_DEFINITION_ONLY
const hkClass& HK_CALL hkpWorld::staticClass()
{
	return hkpWorldClass;
}
HK_COMPILE_TIME_ASSERT2( \
	sizeof(hkIsVirtual(static_cast<hkpWorld*>(0))) == sizeof(hkBool::CompileTimeTrueType), \
	REFLECTION_PARSER_VTABLE_DETECTION_FAILED );
static void HK_CALL finishLoadedObjecthkpWorld(void* p, int finishing = 1)
{
	hkFinishLoadedObjectFlag f;
	f.m_finishing = finishing;
	new (p) hkpWorld(f);
}
static void HK_CALL cleanupLoadedObjecthkpWorld(void* p)
{
	static_cast<hkpWorld*>(p)->~hkpWorld();
}
static const void* HK_CALL getVtablehkpWorld()
{
	#if HK_LINKONCE_VTABLES==0
	#if HK_HASHCODE_VTABLE_REGISTRY==1
	return ((const void*)(typeid(hkpWorld).hash_code()));
	#else
	return ((const void*)(typeid(hkpWorld).name()));
	#endif
	#else
	union { HK_ALIGN16(void* ptr); char buf[sizeof(hkpWorld)]; } u;
	hkFinishLoadedObjectFlag f;
	new (u.buf) hkpWorld(f);
	return u.ptr;
	#endif
}
extern const hkTypeInfo hkpWorldTypeInfo;
const hkTypeInfo hkpWorldTypeInfo(
	"hkpWorld",
	"!hkpWorld",
	finishLoadedObjecthkpWorld,
	cleanupLoadedObjecthkpWorld,
	getVtablehkpWorld(),
	sizeof(hkpWorld)
	);
#endif

/*
 * Havok SDK - Base file, BUILD(#20130912)
 * 
 * Confidential Information of Havok.  (C) Copyright 1999-2013
 * Telekinesys Research Limited t/a Havok. All Rights Reserved. The Havok
 * Logo, and the Havok buzzsaw logo are trademarks of Havok.  Title, ownership
 * rights, and intellectual property rights in the Havok software remain in
 * Havok and/or its suppliers.
 * 
 * Use of this software for evaluation purposes is subject to and indicates
 * acceptance of the End User licence Agreement for this product. A copy of
 * the license is included with this software and is also available from salesteam@havok.com.
 * 
 */
