/*
 *
 * Confidential Information of Telekinesys Research Limited (t/a Havok). Not for disclosure or distribution without Havok's
 * prior written consent. This software contains code, techniques and know-how which is confidential and proprietary to Havok.
 * Product and Trade Secret source code contains trade secrets of Havok. Havok Software (C) Copyright 1999-2013 Telekinesys Research Limited t/a Havok. All Rights Reserved. Use of this software is subject to the terms of an end user license agreement.
 *
 */

//HK_REFLECTION_PARSER_EXCLUDE_FILE

// Autogenerated by generateReflections.py (reflectedClasses.py)
// Changes will not be lost unless:
// - The workspace is re-generated using build.py
// - The corresponding reflection database (reflection.db) is deleted
// - The --force-output or --force-rebuild option is added to the pre-build generateReflection.py execution

// Generated from 'Common/SceneData/Material/hkxMaterial.h'
#include <Common/SceneData/hkSceneData.h>
#include <Common/Base/Reflection/hkClass.h>
#include <Common/Base/Reflection/hkInternalClassMember.h>
#include <Common/Base/Reflection/hkTypeInfo.h>
#include <Common/Base/Reflection/Attributes/hkAttributes.h>
#include <Common/SceneData/Material/hkxMaterial.h>
#define True true
#define False false


// External pointer and enum types
extern const hkClass hkReferencedObjectClass;
extern const hkClass hkxMaterialPropertyClass;
extern const hkClass hkxMaterialTextureStageClass;
extern const hkClass hkxMaterialClass;
extern const hkClassEnum* hkxMaterialTextureTypeEnum;
extern const hkClassEnum* hkxMaterialTransparencyEnum;
extern const hkClassEnum* hkxMaterialUVMappingAlgorithmEnum;

//
// Enum hkxMaterial::TextureType
//
static const hkInternalClassEnumItem hkxMaterialTextureTypeEnumItems[] =
{
	{0, "TEX_UNKNOWN"},
	{1, "TEX_DIFFUSE"},
	{2, "TEX_REFLECTION"},
	{3, "TEX_BUMP"},
	{4, "TEX_NORMAL"},
	{5, "TEX_DISPLACEMENT"},
	{6, "TEX_SPECULAR"},
	{7, "TEX_SPECULARANDGLOSS"},
	{8, "TEX_OPACITY"},
	{9, "TEX_EMISSIVE"},
	{10, "TEX_REFRACTION"},
	{11, "TEX_GLOSS"},
	{12, "TEX_DOMINANTS"},
	{13, "TEX_NOTEXPORTED"},
};

//
// Enum hkxMaterial::PropertyKey
//
static const hkInternalClassEnumItem hkxMaterialPropertyKeyEnumItems[] =
{
	{1, "PROPERTY_MTL_TYPE_BLEND"},
	{256, "PROPERTY_MTL_UV_ID_STAGE0"},
	{257, "PROPERTY_MTL_UV_ID_STAGE1"},
	{258, "PROPERTY_MTL_UV_ID_STAGE2"},
	{259, "PROPERTY_MTL_UV_ID_STAGE3"},
	{260, "PROPERTY_MTL_UV_ID_STAGE4"},
	{261, "PROPERTY_MTL_UV_ID_STAGE5"},
	{262, "PROPERTY_MTL_UV_ID_STAGE6"},
	{263, "PROPERTY_MTL_UV_ID_STAGE7"},
	{264, "PROPERTY_MTL_UV_ID_STAGE8"},
	{265, "PROPERTY_MTL_UV_ID_STAGE9"},
	{266, "PROPERTY_MTL_UV_ID_STAGE10"},
	{267, "PROPERTY_MTL_UV_ID_STAGE11"},
	{268, "PROPERTY_MTL_UV_ID_STAGE12"},
	{269, "PROPERTY_MTL_UV_ID_STAGE13"},
	{270, "PROPERTY_MTL_UV_ID_STAGE14"},
	{271, "PROPERTY_MTL_UV_ID_STAGE15"},
	{272, "PROPERTY_MTL_UV_ID_STAGE_MAX"},
};

//
// Enum hkxMaterial::UVMappingAlgorithm
//
static const hkInternalClassEnumItem hkxMaterialUVMappingAlgorithmEnumItems[] =
{
	{0, "UVMA_SRT"},
	{1, "UVMA_TRS"},
	{2, "UVMA_3DSMAX_STYLE"},
	{3, "UVMA_MAYA_STYLE"},
};

//
// Enum hkxMaterial::Transparency
//
static const hkInternalClassEnumItem hkxMaterialTransparencyEnumItems[] =
{
	{0, "transp_none"},
	{2, "transp_alpha"},
	{3, "transp_additive"},
	{4, "transp_colorkey"},
	{9, "transp_subtractive"},
};
static const hkInternalClassEnum hkxMaterialEnums[] = {
	{"TextureType", hkxMaterialTextureTypeEnumItems, 14, HK_NULL, 0 },
	{"PropertyKey", hkxMaterialPropertyKeyEnumItems, 18, HK_NULL, 0 },
	{"UVMappingAlgorithm", hkxMaterialUVMappingAlgorithmEnumItems, 4, HK_NULL, 0 },
	{"Transparency", hkxMaterialTransparencyEnumItems, 5, HK_NULL, 0 }
};
const hkClassEnum* hkxMaterialTextureTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkxMaterialEnums[0]);
const hkClassEnum* hkxMaterialPropertyKeyEnum = reinterpret_cast<const hkClassEnum*>(&hkxMaterialEnums[1]);
const hkClassEnum* hkxMaterialUVMappingAlgorithmEnum = reinterpret_cast<const hkClassEnum*>(&hkxMaterialEnums[2]);
const hkClassEnum* hkxMaterialTransparencyEnum = reinterpret_cast<const hkClassEnum*>(&hkxMaterialEnums[3]);

//
// Class hkxMaterial::TextureStage
//
static const hkInternalClassMember hkxMaterial_TextureStageClass_Members[] =
{
	{ "texture", &hkReferencedObjectClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, HK_OFFSET_OF(hkxMaterial::TextureStage,m_texture), HK_NULL },
	{ "usageHint", HK_NULL, hkxMaterialTextureTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT32, 0, 0, HK_OFFSET_OF(hkxMaterial::TextureStage,m_usageHint), HK_NULL },
	{ "tcoordChannel", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkxMaterial::TextureStage,m_tcoordChannel), HK_NULL }
};
namespace
{
	struct hkxMaterialTextureStage_DefaultStruct
	{
		int s_defaultOffsets[3];
		typedef hkInt8 _hkBool;
		typedef hkFloat32 _hkVector4[4];
		typedef hkReal _hkQuaternion[4];
		typedef hkReal _hkMatrix3[12];
		typedef hkReal _hkRotation[12];
		typedef hkReal _hkQsTransform[12];
		typedef hkReal _hkMatrix4[16];
		typedef hkReal _hkTransform[16];
		hkInt32 m_tcoordChannel;
	};
	const hkxMaterialTextureStage_DefaultStruct hkxMaterialTextureStage_Default =
	{
		{-1,-1,HK_OFFSET_OF(hkxMaterialTextureStage_DefaultStruct,m_tcoordChannel)},
		-1
	};
}
const hkClass hkxMaterialTextureStageClass(
	"hkxMaterialTextureStage",
	HK_NULL, // parent
	sizeof(hkxMaterial::TextureStage),
	HK_NULL,
	0, // interfaces
	HK_NULL,
	0, // enums
	reinterpret_cast<const hkClassMember*>(hkxMaterial_TextureStageClass_Members),
	HK_COUNT_OF(hkxMaterial_TextureStageClass_Members),
	&hkxMaterialTextureStage_Default,
	HK_NULL, // attributes
	0, // flags
	hkUint32(1) // version
	);
#ifndef HK_HKCLASS_DEFINITION_ONLY
const hkClass& HK_CALL hkxMaterial::TextureStage::staticClass()
{
	return hkxMaterialTextureStageClass;
}
HK_COMPILE_TIME_ASSERT2( \
	sizeof(hkIsVirtual(static_cast<hkxMaterial::TextureStage*>(0))) == sizeof(hkBool::CompileTimeFalseType), \
	REFLECTION_PARSER_VTABLE_DETECTION_FAILED );
static void HK_CALL finishLoadedObjecthkxMaterialTextureStage(void* p, int finishing = 1)
{
	hkFinishLoadedObjectFlag f;
	f.m_finishing = finishing;
	new (p) hkxMaterial::TextureStage(f);
}
static void HK_CALL cleanupLoadedObjecthkxMaterialTextureStage(void* p)
{
	static_cast<hkxMaterial::TextureStage*>(p)->~TextureStage();
}
extern const hkTypeInfo hkxMaterialTextureStageTypeInfo;
const hkTypeInfo hkxMaterialTextureStageTypeInfo(
	"hkxMaterialTextureStage",
	"!hkxMaterial::TextureStage",
	finishLoadedObjecthkxMaterialTextureStage,
	cleanupLoadedObjecthkxMaterialTextureStage,
	HK_NULL,
	sizeof(hkxMaterial::TextureStage)
	);
#endif

//
// Class hkxMaterial::Property
//
static const hkInternalClassMember hkxMaterial_PropertyClass_Members[] =
{
	{ "key", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkxMaterial::Property,m_key), HK_NULL },
	{ "value", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkxMaterial::Property,m_value), HK_NULL }
};
const hkClass hkxMaterialPropertyClass(
	"hkxMaterialProperty",
	HK_NULL, // parent
	sizeof(hkxMaterial::Property),
	HK_NULL,
	0, // interfaces
	HK_NULL,
	0, // enums
	reinterpret_cast<const hkClassMember*>(hkxMaterial_PropertyClass_Members),
	HK_COUNT_OF(hkxMaterial_PropertyClass_Members),
	HK_NULL, // defaults
	HK_NULL, // attributes
	0, // flags
	hkUint32(0) // version
	);
#ifndef HK_HKCLASS_DEFINITION_ONLY
const hkClass& HK_CALL hkxMaterial::Property::staticClass()
{
	return hkxMaterialPropertyClass;
}
HK_COMPILE_TIME_ASSERT2( \
	sizeof(hkIsVirtual(static_cast<hkxMaterial::Property*>(0))) == sizeof(hkBool::CompileTimeFalseType), \
	REFLECTION_PARSER_VTABLE_DETECTION_FAILED );
static void HK_CALL finishLoadedObjecthkxMaterialProperty(void* p, int finishing = 1)
{
	hkFinishLoadedObjectFlag f;
	f.m_finishing = finishing;
	new (p) hkxMaterial::Property(f);
}
static void HK_CALL cleanupLoadedObjecthkxMaterialProperty(void* p)
{
	static_cast<hkxMaterial::Property*>(p)->~Property();
}
extern const hkTypeInfo hkxMaterialPropertyTypeInfo;
const hkTypeInfo hkxMaterialPropertyTypeInfo(
	"hkxMaterialProperty",
	"!hkxMaterial::Property",
	finishLoadedObjecthkxMaterialProperty,
	cleanupLoadedObjecthkxMaterialProperty,
	HK_NULL,
	sizeof(hkxMaterial::Property)
	);
#endif

//
// Class hkxMaterial
//
extern const hkClass hkxAttributeHolderClass;

const hkInternalClassMember hkxMaterial::Members[] =
{
	{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkxMaterial,m_name), HK_NULL },
	{ "stages", &hkxMaterialTextureStageClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, HK_OFFSET_OF(hkxMaterial,m_stages), HK_NULL },
	{ "diffuseColor", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkxMaterial,m_diffuseColor), HK_NULL },
	{ "ambientColor", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkxMaterial,m_ambientColor), HK_NULL },
	{ "specularColor", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkxMaterial,m_specularColor), HK_NULL },
	{ "emissiveColor", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkxMaterial,m_emissiveColor), HK_NULL },
	{ "subMaterials", &hkxMaterialClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, HK_OFFSET_OF(hkxMaterial,m_subMaterials), HK_NULL },
	{ "extraData", &hkReferencedObjectClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, HK_OFFSET_OF(hkxMaterial,m_extraData), HK_NULL },
	{ "uvMapScale", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 2, 0, HK_OFFSET_OF(hkxMaterial,m_uvMapScale), HK_NULL },
	{ "uvMapOffset", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 2, 0, HK_OFFSET_OF(hkxMaterial,m_uvMapOffset), HK_NULL },
	{ "uvMapRotation", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkxMaterial,m_uvMapRotation), HK_NULL },
	{ "uvMapAlgorithm", HK_NULL, hkxMaterialUVMappingAlgorithmEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT32, 0, 0, HK_OFFSET_OF(hkxMaterial,m_uvMapAlgorithm), HK_NULL },
	{ "specularMultiplier", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkxMaterial,m_specularMultiplier), HK_NULL },
	{ "specularExponent", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkxMaterial,m_specularExponent), HK_NULL },
	{ "transparency", HK_NULL, hkxMaterialTransparencyEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, HK_OFFSET_OF(hkxMaterial,m_transparency), HK_NULL },
	{ "userData", HK_NULL, HK_NULL, hkClassMember::TYPE_ULONG, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkxMaterial,m_userData), HK_NULL },
	{ "properties", &hkxMaterialPropertyClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, HK_OFFSET_OF(hkxMaterial,m_properties), HK_NULL }
};
namespace
{
	struct hkxMaterial_DefaultStruct
	{
		int s_defaultOffsets[17];
		typedef hkInt8 _hkBool;
		typedef hkFloat32 _hkVector4[4];
		typedef hkReal _hkQuaternion[4];
		typedef hkReal _hkMatrix3[12];
		typedef hkReal _hkRotation[12];
		typedef hkReal _hkQsTransform[12];
		typedef hkReal _hkMatrix4[16];
		typedef hkReal _hkTransform[16];
		float m_uvMapScale[2];
		float m_uvMapOffset[2];
		float m_uvMapRotation;
		hkUint32 /* hkEnum< enum hkxMaterial::UVMappingAlgorithm, hkUint32 > */ m_uvMapAlgorithm;
	};
	const hkxMaterial_DefaultStruct hkxMaterial_Default =
	{
		{-1,-1,-1,-1,-1,-1,-1,-1,HK_OFFSET_OF(hkxMaterial_DefaultStruct,m_uvMapScale),HK_OFFSET_OF(hkxMaterial_DefaultStruct,m_uvMapOffset),HK_OFFSET_OF(hkxMaterial_DefaultStruct,m_uvMapRotation),HK_OFFSET_OF(hkxMaterial_DefaultStruct,m_uvMapAlgorithm),-1,-1,-1,hkClassMember::HK_CLASS_ZERO_DEFAULT,-1},
{1.f,1.f},{0.f,0.f},0.f,2
	};
}
const hkClass hkxMaterialClass(
	"hkxMaterial",
	&hkxAttributeHolderClass, // parent
	sizeof(::hkxMaterial),
	HK_NULL,
	0, // interfaces
	reinterpret_cast<const hkClassEnum*>(hkxMaterialEnums),
	4, // enums
	reinterpret_cast<const hkClassMember*>(hkxMaterial::Members),
	HK_COUNT_OF(hkxMaterial::Members),
	&hkxMaterial_Default,
	HK_NULL, // attributes
	0, // flags
	hkUint32(5) // version
	);
#ifndef HK_HKCLASS_DEFINITION_ONLY
const hkClass& HK_CALL hkxMaterial::staticClass()
{
	return hkxMaterialClass;
}
HK_COMPILE_TIME_ASSERT2( \
	sizeof(hkIsVirtual(static_cast<hkxMaterial*>(0))) == sizeof(hkBool::CompileTimeTrueType), \
	REFLECTION_PARSER_VTABLE_DETECTION_FAILED );
static void HK_CALL finishLoadedObjecthkxMaterial(void* p, int finishing = 1)
{
	hkFinishLoadedObjectFlag f;
	f.m_finishing = finishing;
	new (p) hkxMaterial(f);
}
static void HK_CALL cleanupLoadedObjecthkxMaterial(void* p)
{
	static_cast<hkxMaterial*>(p)->~hkxMaterial();
}
static const void* HK_CALL getVtablehkxMaterial()
{
	#if HK_LINKONCE_VTABLES==0
	#if HK_HASHCODE_VTABLE_REGISTRY==1
	return ((const void*)(typeid(hkxMaterial).hash_code()));
	#else
	return ((const void*)(typeid(hkxMaterial).name()));
	#endif
	#else
	union { HK_ALIGN16(void* ptr); char buf[sizeof(hkxMaterial)]; } u;
	hkFinishLoadedObjectFlag f;
	new (u.buf) hkxMaterial(f);
	return u.ptr;
	#endif
}
extern const hkTypeInfo hkxMaterialTypeInfo;
const hkTypeInfo hkxMaterialTypeInfo(
	"hkxMaterial",
	"!hkxMaterial",
	finishLoadedObjecthkxMaterial,
	cleanupLoadedObjecthkxMaterial,
	getVtablehkxMaterial(),
	sizeof(hkxMaterial)
	);
#endif

/*
 * Havok SDK - Base file, BUILD(#20130912)
 * 
 * Confidential Information of Havok.  (C) Copyright 1999-2013
 * Telekinesys Research Limited t/a Havok. All Rights Reserved. The Havok
 * Logo, and the Havok buzzsaw logo are trademarks of Havok.  Title, ownership
 * rights, and intellectual property rights in the Havok software remain in
 * Havok and/or its suppliers.
 * 
 * Use of this software for evaluation purposes is subject to and indicates
 * acceptance of the End User licence Agreement for this product. A copy of
 * the license is included with this software and is also available from salesteam@havok.com.
 * 
 */
