/*
 *
 * Confidential Information of Telekinesys Research Limited (t/a Havok). Not for disclosure or distribution without Havok's
 * prior written consent. This software contains code, techniques and know-how which is confidential and proprietary to Havok.
 * Product and Trade Secret source code contains trade secrets of Havok. Havok Software (C) Copyright 1999-2013 Telekinesys Research Limited t/a Havok. All Rights Reserved. Use of this software is subject to the terms of an end user license agreement.
 *
 */

//HK_REFLECTION_PARSER_EXCLUDE_FILE

// Autogenerated by generateReflections.py (reflectedClasses.py)
// Changes will not be lost unless:
// - The workspace is re-generated using build.py
// - The corresponding reflection database (reflection.db) is deleted
// - The --force-output or --force-rebuild option is added to the pre-build generateReflection.py execution

// Generated from 'Common/Base/Monitor/MonitorStreamAnalyzer/hkMonitorStreamAnalyzer.h'
#include <Common/Base/hkBase.h>
#include <Common/Base/Reflection/hkClass.h>
#include <Common/Base/Reflection/hkInternalClassMember.h>
#include <Common/Base/Reflection/hkTypeInfo.h>
#include <Common/Base/Reflection/Attributes/hkAttributes.h>
#include <Common/Base/Monitor/MonitorStreamAnalyzer/hkMonitorStreamAnalyzer.h>
#define True true
#define False false


// External pointer and enum types
extern const hkClass hkMonitorStreamAnalyzerNodeClass;
extern const hkClass hkMonitorStreamColorTableColorPairClass;
extern const hkClass hkMonitorStreamColorTableClass;
extern const hkClass hkMonitorStreamFrameInfoClass;
extern const hkClass hkMonitorStreamStringMapStringMapClass;
extern const hkClassEnum* hkMonitorStreamAnalyzerNodeNodeTypeEnum;
extern const hkClassEnum* hkMonitorStreamFrameInfoAbsoluteTimeCounterEnum;

//
// Class hkMonitorStreamStringMap::StringMap
//
static const hkInternalClassMember hkMonitorStreamStringMap_StringMapClass_Members[] =
{
	{ "id", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT64, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::ALIGN_8, HK_OFFSET_OF(hkMonitorStreamStringMap::StringMap,m_id), HK_NULL },
	{ "string", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkMonitorStreamStringMap::StringMap,m_string), HK_NULL }
};
const hkClass hkMonitorStreamStringMapStringMapClass(
	"hkMonitorStreamStringMapStringMap",
	HK_NULL, // parent
	sizeof(hkMonitorStreamStringMap::StringMap),
	HK_NULL,
	0, // interfaces
	HK_NULL,
	0, // enums
	reinterpret_cast<const hkClassMember*>(hkMonitorStreamStringMap_StringMapClass_Members),
	HK_COUNT_OF(hkMonitorStreamStringMap_StringMapClass_Members),
	HK_NULL, // defaults
	HK_NULL, // attributes
	0, // flags
	hkUint32(0) // version
	);
#ifndef HK_HKCLASS_DEFINITION_ONLY
const hkClass& HK_CALL hkMonitorStreamStringMap::StringMap::staticClass()
{
	return hkMonitorStreamStringMapStringMapClass;
}
HK_COMPILE_TIME_ASSERT2( \
	sizeof(hkIsVirtual(static_cast<hkMonitorStreamStringMap::StringMap*>(0))) == sizeof(hkBool::CompileTimeFalseType), \
	REFLECTION_PARSER_VTABLE_DETECTION_FAILED );
static void HK_CALL finishLoadedObjecthkMonitorStreamStringMapStringMap(void* p, int finishing = 1)
{
	hkFinishLoadedObjectFlag f;
	f.m_finishing = finishing;
	new (p) hkMonitorStreamStringMap::StringMap(f);
}
static void HK_CALL cleanupLoadedObjecthkMonitorStreamStringMapStringMap(void* p)
{
	static_cast<hkMonitorStreamStringMap::StringMap*>(p)->~StringMap();
}
extern const hkTypeInfo hkMonitorStreamStringMapStringMapTypeInfo;
const hkTypeInfo hkMonitorStreamStringMapStringMapTypeInfo(
	"hkMonitorStreamStringMapStringMap",
	"!hkMonitorStreamStringMap::StringMap",
	finishLoadedObjecthkMonitorStreamStringMapStringMap,
	cleanupLoadedObjecthkMonitorStreamStringMapStringMap,
	HK_NULL,
	sizeof(hkMonitorStreamStringMap::StringMap)
	);
#endif

//
// Class hkMonitorStreamStringMap
//
// hkMonitorStreamStringMap attributes
static const hkInternalClassMember hkMonitorStreamStringMapClass_Members[] =
{
	{ "map", &hkMonitorStreamStringMapStringMapClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, HK_OFFSET_OF(hkMonitorStreamStringMap,m_map), HK_NULL }
};
extern const hkClass hkMonitorStreamStringMapClass;
const hkClass hkMonitorStreamStringMapClass(
	"hkMonitorStreamStringMap",
	HK_NULL, // parent
	sizeof(::hkMonitorStreamStringMap),
	HK_NULL,
	0, // interfaces
	HK_NULL,
	0, // enums
	reinterpret_cast<const hkClassMember*>(hkMonitorStreamStringMapClass_Members),
	HK_COUNT_OF(hkMonitorStreamStringMapClass_Members),
	HK_NULL, // defaults
	HK_NULL, // attributes
	0, // flags
	hkUint32(0) // version
	);
#ifndef HK_HKCLASS_DEFINITION_ONLY
const hkClass& HK_CALL hkMonitorStreamStringMap::staticClass()
{
	return hkMonitorStreamStringMapClass;
}
HK_COMPILE_TIME_ASSERT2( \
	sizeof(hkIsVirtual(static_cast<hkMonitorStreamStringMap*>(0))) == sizeof(hkBool::CompileTimeFalseType), \
	REFLECTION_PARSER_VTABLE_DETECTION_FAILED );
static void HK_CALL finishLoadedObjecthkMonitorStreamStringMap(void* p, int finishing = 1)
{
	hkFinishLoadedObjectFlag f;
	f.m_finishing = finishing;
	new (p) hkMonitorStreamStringMap(f);
}
static void HK_CALL cleanupLoadedObjecthkMonitorStreamStringMap(void* p)
{
	static_cast<hkMonitorStreamStringMap*>(p)->~hkMonitorStreamStringMap();
}
extern const hkTypeInfo hkMonitorStreamStringMapTypeInfo;
const hkTypeInfo hkMonitorStreamStringMapTypeInfo(
	"hkMonitorStreamStringMap",
	"!hkMonitorStreamStringMap",
	finishLoadedObjecthkMonitorStreamStringMap,
	cleanupLoadedObjecthkMonitorStreamStringMap,
	HK_NULL,
	sizeof(hkMonitorStreamStringMap)
	);
#endif

//
// Enum hkMonitorStreamFrameInfo::AbsoluteTimeCounter
//
static const hkInternalClassEnumItem hkMonitorStreamFrameInfoAbsoluteTimeCounterEnumItems[] =
{
	{0, "ABSOLUTE_TIME_TIMER_0"},
	{1, "ABSOLUTE_TIME_TIMER_1"},
	{-1, "ABSOLUTE_TIME_NOT_TIMED"},
};
static const hkInternalClassEnum hkMonitorStreamFrameInfoEnums[] = {
	{"AbsoluteTimeCounter", hkMonitorStreamFrameInfoAbsoluteTimeCounterEnumItems, 3, HK_NULL, 0 }
};
const hkClassEnum* hkMonitorStreamFrameInfoAbsoluteTimeCounterEnum = reinterpret_cast<const hkClassEnum*>(&hkMonitorStreamFrameInfoEnums[0]);

//
// Class hkMonitorStreamFrameInfo
//
// hkMonitorStreamFrameInfo attributes
static const hkInternalClassMember hkMonitorStreamFrameInfoClass_Members[] =
{
	{ "heading", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkMonitorStreamFrameInfo,m_heading), HK_NULL },
	{ "indexOfTimer0", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkMonitorStreamFrameInfo,m_indexOfTimer0), HK_NULL },
	{ "indexOfTimer1", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkMonitorStreamFrameInfo,m_indexOfTimer1), HK_NULL },
	{ "absoluteTimeCounter", HK_NULL, hkMonitorStreamFrameInfoAbsoluteTimeCounterEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT32, 0, 0, HK_OFFSET_OF(hkMonitorStreamFrameInfo,m_absoluteTimeCounter), HK_NULL },
	{ "timerFactor0", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkMonitorStreamFrameInfo,m_timerFactor0), HK_NULL },
	{ "timerFactor1", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkMonitorStreamFrameInfo,m_timerFactor1), HK_NULL },
	{ "threadId", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkMonitorStreamFrameInfo,m_threadId), HK_NULL },
	{ "frameStreamStart", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkMonitorStreamFrameInfo,m_frameStreamStart), HK_NULL },
	{ "frameStreamEnd", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkMonitorStreamFrameInfo,m_frameStreamEnd), HK_NULL }
};
const hkClass hkMonitorStreamFrameInfoClass(
	"hkMonitorStreamFrameInfo",
	HK_NULL, // parent
	sizeof(::hkMonitorStreamFrameInfo),
	HK_NULL,
	0, // interfaces
	reinterpret_cast<const hkClassEnum*>(hkMonitorStreamFrameInfoEnums),
	1, // enums
	reinterpret_cast<const hkClassMember*>(hkMonitorStreamFrameInfoClass_Members),
	HK_COUNT_OF(hkMonitorStreamFrameInfoClass_Members),
	HK_NULL, // defaults
	HK_NULL, // attributes
	0, // flags
	hkUint32(0) // version
	);
#ifndef HK_HKCLASS_DEFINITION_ONLY
const hkClass& HK_CALL hkMonitorStreamFrameInfo::staticClass()
{
	return hkMonitorStreamFrameInfoClass;
}
HK_COMPILE_TIME_ASSERT2( \
	sizeof(hkIsVirtual(static_cast<hkMonitorStreamFrameInfo*>(0))) == sizeof(hkBool::CompileTimeFalseType), \
	REFLECTION_PARSER_VTABLE_DETECTION_FAILED );
static void HK_CALL finishLoadedObjecthkMonitorStreamFrameInfo(void* p, int finishing = 1)
{
	hkFinishLoadedObjectFlag f;
	f.m_finishing = finishing;
	new (p) hkMonitorStreamFrameInfo(f);
}
static void HK_CALL cleanupLoadedObjecthkMonitorStreamFrameInfo(void* p)
{
	static_cast<hkMonitorStreamFrameInfo*>(p)->~hkMonitorStreamFrameInfo();
}
extern const hkTypeInfo hkMonitorStreamFrameInfoTypeInfo;
const hkTypeInfo hkMonitorStreamFrameInfoTypeInfo(
	"hkMonitorStreamFrameInfo",
	"!hkMonitorStreamFrameInfo",
	finishLoadedObjecthkMonitorStreamFrameInfo,
	cleanupLoadedObjecthkMonitorStreamFrameInfo,
	HK_NULL,
	sizeof(hkMonitorStreamFrameInfo)
	);
#endif

//
// Class hkMonitorStreamColorTable::ColorPair
//
static const hkInternalClassMember hkMonitorStreamColorTable_ColorPairClass_Members[] =
{
	{ "colorName", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkMonitorStreamColorTable::ColorPair,m_colorName), HK_NULL },
	{ "color", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkMonitorStreamColorTable::ColorPair,m_color), HK_NULL }
};
const hkClass hkMonitorStreamColorTableColorPairClass(
	"hkMonitorStreamColorTableColorPair",
	HK_NULL, // parent
	sizeof(hkMonitorStreamColorTable::ColorPair),
	HK_NULL,
	0, // interfaces
	HK_NULL,
	0, // enums
	reinterpret_cast<const hkClassMember*>(hkMonitorStreamColorTable_ColorPairClass_Members),
	HK_COUNT_OF(hkMonitorStreamColorTable_ColorPairClass_Members),
	HK_NULL, // defaults
	HK_NULL, // attributes
	0, // flags
	hkUint32(0) // version
	);
#ifndef HK_HKCLASS_DEFINITION_ONLY
const hkClass& HK_CALL hkMonitorStreamColorTable::ColorPair::staticClass()
{
	return hkMonitorStreamColorTableColorPairClass;
}
HK_COMPILE_TIME_ASSERT2( \
	sizeof(hkIsVirtual(static_cast<hkMonitorStreamColorTable::ColorPair*>(0))) == sizeof(hkBool::CompileTimeFalseType), \
	REFLECTION_PARSER_VTABLE_DETECTION_FAILED );
static void HK_CALL finishLoadedObjecthkMonitorStreamColorTableColorPair(void* p, int finishing = 1)
{
	hkFinishLoadedObjectFlag f;
	f.m_finishing = finishing;
	new (p) hkMonitorStreamColorTable::ColorPair(f);
}
static void HK_CALL cleanupLoadedObjecthkMonitorStreamColorTableColorPair(void* p)
{
	static_cast<hkMonitorStreamColorTable::ColorPair*>(p)->~ColorPair();
}
extern const hkTypeInfo hkMonitorStreamColorTableColorPairTypeInfo;
const hkTypeInfo hkMonitorStreamColorTableColorPairTypeInfo(
	"hkMonitorStreamColorTableColorPair",
	"!hkMonitorStreamColorTable::ColorPair",
	finishLoadedObjecthkMonitorStreamColorTableColorPair,
	cleanupLoadedObjecthkMonitorStreamColorTableColorPair,
	HK_NULL,
	sizeof(hkMonitorStreamColorTable::ColorPair)
	);
#endif

//
// Class hkMonitorStreamColorTable
//
extern const hkClass hkReferencedObjectClass;

// hkMonitorStreamColorTable attributes
static const hkInternalClassMember hkMonitorStreamColorTableClass_Members[] =
{
	{ "colorPairs", &hkMonitorStreamColorTableColorPairClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, HK_OFFSET_OF(hkMonitorStreamColorTable,m_colorPairs), HK_NULL },
	{ "defaultColor", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkMonitorStreamColorTable,m_defaultColor), HK_NULL }
};
const hkClass hkMonitorStreamColorTableClass(
	"hkMonitorStreamColorTable",
	&hkReferencedObjectClass, // parent
	sizeof(::hkMonitorStreamColorTable),
	HK_NULL,
	0, // interfaces
	HK_NULL,
	0, // enums
	reinterpret_cast<const hkClassMember*>(hkMonitorStreamColorTableClass_Members),
	HK_COUNT_OF(hkMonitorStreamColorTableClass_Members),
	HK_NULL, // defaults
	HK_NULL, // attributes
	0, // flags
	hkUint32(0) // version
	);
#ifndef HK_HKCLASS_DEFINITION_ONLY
const hkClass& HK_CALL hkMonitorStreamColorTable::staticClass()
{
	return hkMonitorStreamColorTableClass;
}
HK_COMPILE_TIME_ASSERT2( \
	sizeof(hkIsVirtual(static_cast<hkMonitorStreamColorTable*>(0))) == sizeof(hkBool::CompileTimeTrueType), \
	REFLECTION_PARSER_VTABLE_DETECTION_FAILED );
static void HK_CALL finishLoadedObjecthkMonitorStreamColorTable(void* p, int finishing = 1)
{
	hkFinishLoadedObjectFlag f;
	f.m_finishing = finishing;
	new (p) hkMonitorStreamColorTable(f);
}
static void HK_CALL cleanupLoadedObjecthkMonitorStreamColorTable(void* p)
{
	static_cast<hkMonitorStreamColorTable*>(p)->~hkMonitorStreamColorTable();
}
static const void* HK_CALL getVtablehkMonitorStreamColorTable()
{
	#if HK_LINKONCE_VTABLES==0
	#if HK_HASHCODE_VTABLE_REGISTRY==1
	return ((const void*)(typeid(hkMonitorStreamColorTable).hash_code()));
	#else
	return ((const void*)(typeid(hkMonitorStreamColorTable).name()));
	#endif
	#else
	union { HK_ALIGN16(void* ptr); char buf[sizeof(hkMonitorStreamColorTable)]; } u;
	hkFinishLoadedObjectFlag f;
	new (u.buf) hkMonitorStreamColorTable(f);
	return u.ptr;
	#endif
}
extern const hkTypeInfo hkMonitorStreamColorTableTypeInfo;
const hkTypeInfo hkMonitorStreamColorTableTypeInfo(
	"hkMonitorStreamColorTable",
	"!hkMonitorStreamColorTable",
	finishLoadedObjecthkMonitorStreamColorTable,
	cleanupLoadedObjecthkMonitorStreamColorTable,
	getVtablehkMonitorStreamColorTable(),
	sizeof(hkMonitorStreamColorTable)
	);
#endif

/*
 * Havok SDK - Base file, BUILD(#20130912)
 * 
 * Confidential Information of Havok.  (C) Copyright 1999-2013
 * Telekinesys Research Limited t/a Havok. All Rights Reserved. The Havok
 * Logo, and the Havok buzzsaw logo are trademarks of Havok.  Title, ownership
 * rights, and intellectual property rights in the Havok software remain in
 * Havok and/or its suppliers.
 * 
 * Use of this software for evaluation purposes is subject to and indicates
 * acceptance of the End User licence Agreement for this product. A copy of
 * the license is included with this software and is also available from salesteam@havok.com.
 * 
 */
