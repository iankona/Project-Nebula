/*
 *
 * Confidential Information of Telekinesys Research Limited (t/a Havok). Not for disclosure or distribution without Havok's
 * prior written consent. This software contains code, techniques and know-how which is confidential and proprietary to Havok.
 * Product and Trade Secret source code contains trade secrets of Havok. Havok Software (C) Copyright 1999-2013 Telekinesys Research Limited t/a Havok. All Rights Reserved. Use of this software is subject to the terms of an end user license agreement.
 *
 */
#include <Common/Compat/hkCompat.h>
#include <Common/Base/Reflection/hkClass.h>
#include <Common/Base/Reflection/hkInternalClassMember.h>

#include <Common/Compat/Deprecated/Compat/hkHavokAllClasses.h>

#if defined(HK_COMPILER_SNC)
#	pragma diag_suppress=68 //integer sign change
#endif

namespace hkHavok201120r1Classes
{
	namespace
	{
		// Physics
		struct hkpBvTreeShape { enum { BVTREE_USER=4 }; };	
		struct hkpConstraintAtom { enum { METHOD_OLD=1 }; };
		struct hkpFirstPersonGun { enum { KEY_F2=0x71 }; };
		struct hkpSampledHeightFieldShape { enum { HEIGHTFIELD_USER=2 }; };
		struct hkpShapeCollection { enum { COLLECTION_USER=3 }; };
		struct hkpWeldingUtility { enum { WELDING_TYPE_NONE=6 }; };
		struct hkpMoppCode { enum { BUILT_WITHOUT_CHUNK_SUBDIVISION=1 }; };

		// Behavior
		struct hkbAttachmentSetup { enum { ATTACHMENT_TYPE_KEYFRAME_RIGID_BODY=0 }; };
		struct hkbBlendCurveUtils { enum { BLEND_CURVE_SMOOTH=0 }; };
		struct hkbBlendingTransitionEffect { enum { END_MODE_NONE=0, FLAG_NONE=0 }; };
		struct hkbEvaluateHandleModifier { enum { HANDLE_CHANGE_MODE_ABRUPT=0 }; };
		struct hkbHandIkControlData { enum { HANDLE_CHANGE_MODE_ABRUPT=0 }; };
		struct hkbEvent { enum { EVENT_ID_NULL=-1 }; };
		struct hkbEventBase { enum { EVENT_ID_NULL=-1 }; };
		struct hkbEventRangeData { enum { EVENT_MODE_SEND_ON_ENTER_RANGE=0 }; };
		struct hkbJigglerModifier { enum { JIGGLE_IN_WORLD_COORDINATES=0 }; };
		struct hkbExpressionData { enum { EVENT_MODE_SEND_ONCE=0 }; };
		struct hkbFootIkModifier { enum { ALIGN_MODE_FORWARD_RIGHT=0 }; };
		struct hkbGeneratorOutput { enum { NUM_STANDARD_TRACKS=23 }; };
		struct hkbPoseMatchingGenerator { enum { MODE_MATCH=0 }; };
		struct hkbSenseHandleModifier { enum { SENSE_IN_NEARBY_RIGID_BODIES=0 }; };
		struct hkbTwistModifier { enum { ROTATION_AXIS_IN_MODEL_COORDINATES=0 }; };
		struct hkbStateMachine { enum { SELF_TRANSITION_MODE_NO_TRANSITION=0 }; };
		struct hkbTransitionEffect { enum { EVENT_MODE_DEFAULT=0, SELF_TRANSITION_MODE_CONTINUE_IF_CYCLIC_BLEND_IF_ACYCLIC=0 }; };
		struct hkbWorldFromModelModeData { enum { WORLD_FROM_MODEL_MODE_NONE=3 }; };
		struct hkbCharacterControllerModifier { enum { MOTION_MODE_FOLLOW_ANIMATION=0 }; };
		struct hkbParticleSystemEventPayload { enum { DUST=1 }; };
		struct hkbDockingGenerator { enum { FLAG_NONE=0 }; };

		// Destruction
		struct hkdConvexDecompositionAction { enum { SURFACE=0, REDUCE_GLOBAL=0, REFINE_NONE=0, HOLLOW_KEEP=0 }; };
		struct hkdCutOutFracture { enum { USE_PHYSICS_WITH_SPLIT_GEOMETRY=0 }; };
		struct hkdBreakableBodyMemento { enum { INVALID_BODY_ID=0xffff }; };
		struct hkdAction { enum { INHERIT_SELF_AND_CHILDREN=7, EXECUTE_ON_ADD=1 }; };
		struct hkdController { enum { CONSTRAIN_TO_FIXED_UNBREAKABLE=1 }; };
		struct hkdDebrisFracture { enum { INSERT_RND_TRANSFORM=2, SRC_INTERSECTION=1 }; };
		struct hkdDeformationController { enum { DISTANCE_TO_SURFACE=2 }; };
		struct hkdFracture { enum { REFIT_CONVEX_HULL=1 }; };
		struct hkdShape { enum { CONNECTIVITY_INHERITED=0, QUALITY_INHERITED=0, FLEXJOINT_SELF=0 }; };
		struct hkdSliceFracture { enum { SNAP_TO_PIVOT=0 }; };
		struct hkdExplosionForceAction { enum { SHAPE_SPACE=0 }; };
		struct hkdSplitInHalfFracture { enum { CHILDREN_32=4 }; };
		struct hkdWoodFracture { struct SplittingData { enum { AUTO_ROTATE=0 }; }; };
		struct hkdDecorateFractureFaceAction { enum { DECORATE_NEIGHBOR=0, AABB_CENTER=1, X_WITH_FACE_NORMAL=0, FAST=0, FLOAT_32=0 }; }; 
		struct hkdBody { enum { TYPE_BODY=0 }; };
		struct hkdBuildingController { enum { EXTENDED_MESH_SHAPE=0 }; };	
		struct hkdShockWaveAction { enum { INTERSECTING_COMS=0 }; };	

		// AI
		struct hkaiNavMeshGenerationSettings { enum { ORDER_BY_DISTANCE=2, MATERIAL_WALKABLE_AND_CUTTING=3, BLOCK_EDGES=1 }; };
		struct hkaiNavMeshPathSearchParameters { enum { USER_EDGE_TRAVERSAL_TEST_DISABLED=0, OUTPUT_PATH_SMOOTHED_AND_PROJECTED=2 }; };
		struct hkaiNavVolumeGenerationSettings { enum { MATERIAL_DEFAULT=1 }; struct ChunkSettings { enum { DEFAULT_MAX_CHUNK_SIZE=256 }; }; };
		struct hkaiNavMeshCutter { enum { CLEARANCE_RESET_ALL=0 }; };	
		struct hkaiCharacter { enum { AVOID_ALL=7 }; };	
	}

	const char VersionString[] = "hk_2011.2.0-r1";
	const int ClassVersion = 6;

	extern hkClass hclActionClass;
	extern hkClass hclAntiPinchConstraintSetClass;
	extern hkClass hclAntiPinchConstraintSetPerParticleClass;
	extern hkClass hclBendLinkConstraintSetClass;
	extern hkClass hclBendLinkConstraintSetLinkClass;
	extern hkClass hclBendLinkConstraintSetMxBatchClass;
	extern hkClass hclBendLinkConstraintSetMxClass;
	extern hkClass hclBendLinkConstraintSetMxSingleClass;
	extern hkClass hclBendLinkSetupObjectClass;
	extern hkClass hclBendStiffnessConstraintSetClass;
	extern hkClass hclBendStiffnessConstraintSetLinkClass;
	extern hkClass hclBendStiffnessConstraintSetMxBatchClass;
	extern hkClass hclBendStiffnessConstraintSetMxClass;
	extern hkClass hclBendStiffnessConstraintSetMxSingleClass;
	extern hkClass hclBendStiffnessSetupObjectClass;
	extern hkClass hclBlendSetupObjectClass;
	extern hkClass hclBlendSomeVerticesOperatorBlendEntryClass;
	extern hkClass hclBlendSomeVerticesOperatorClass;
	extern hkClass hclBonePlanesConstraintSetBonePlaneClass;
	extern hkClass hclBonePlanesConstraintSetClass;
	extern hkClass hclBonePlanesSetupObjectClass;
	extern hkClass hclBonePlanesSetupObjectGlobalPlaneClass;
	extern hkClass hclBonePlanesSetupObjectPerParticleAngleClass;
	extern hkClass hclBonePlanesSetupObjectPerParticlePlaneClass;
	extern hkClass hclBoneSpaceDeformerClass;
	extern hkClass hclBoneSpaceDeformerFourBlendEntryBlockClass;
	extern hkClass hclBoneSpaceDeformerLocalBlockPClass;
	extern hkClass hclBoneSpaceDeformerLocalBlockPNClass;
	extern hkClass hclBoneSpaceDeformerLocalBlockPNTBClass;
	extern hkClass hclBoneSpaceDeformerLocalBlockPNTClass;
	extern hkClass hclBoneSpaceDeformerOneBlendEntryBlockClass;
	extern hkClass hclBoneSpaceDeformerThreeBlendEntryBlockClass;
	extern hkClass hclBoneSpaceDeformerTwoBlendEntryBlockClass;
	extern hkClass hclBoneSpaceMeshMeshDeformOperatorClass;
	extern hkClass hclBoneSpaceMeshMeshDeformPNOperatorClass;
	extern hkClass hclBoneSpaceMeshMeshDeformPNTBOperatorClass;
	extern hkClass hclBoneSpaceMeshMeshDeformPNTOperatorClass;
	extern hkClass hclBoneSpaceMeshMeshDeformPOperatorClass;
	extern hkClass hclBoneSpaceSkinOperatorClass;
	extern hkClass hclBoneSpaceSkinPNOperatorClass;
	extern hkClass hclBoneSpaceSkinPNTBOperatorClass;
	extern hkClass hclBoneSpaceSkinPNTOperatorClass;
	extern hkClass hclBoneSpaceSkinPOperatorClass;
	extern hkClass hclBufferDefinitionClass;
	extern hkClass hclBufferLayoutBufferElementClass;
	extern hkClass hclBufferLayoutClass;
	extern hkClass hclBufferLayoutSlotClass;
	extern hkClass hclBufferSetupObjectClass;
	extern hkClass hclBufferUsageClass;
	extern hkClass hclCapsuleShapeClass;
	extern hkClass hclClothContainerClass;
	extern hkClass hclClothDataClass;
	extern hkClass hclClothSetupContainerClass;
	extern hkClass hclClothSetupObjectClass;
	extern hkClass hclClothStateBufferAccessClass;
	extern hkClass hclClothStateClass;
	extern hkClass hclClothStateSetupObjectClass;
	extern hkClass hclClothStateTransformSetAccessClass;
	extern hkClass hclCollidableClass;
	extern hkClass hclCompressibleLinkConstraintSetClass;
	extern hkClass hclCompressibleLinkConstraintSetLinkClass;
	extern hkClass hclCompressibleLinkConstraintSetMxBatchClass;
	extern hkClass hclCompressibleLinkConstraintSetMxClass;
	extern hkClass hclCompressibleLinkConstraintSetMxSingleClass;
	extern hkClass hclConstraintSetClass;
	extern hkClass hclConstraintSetSetupObjectClass;
	extern hkClass hclConvexGeometryShapeClass;
	extern hkClass hclConvexHeightFieldShapeClass;
	extern hkClass hclCopyVerticesOperatorClass;
	extern hkClass hclDisplayBufferSetupObjectClass;
	extern hkClass hclEdgeSelectionInputClass;
	extern hkClass hclGatherAllVerticesOperatorClass;
	extern hkClass hclGatherSomeVerticesOperatorClass;
	extern hkClass hclGatherSomeVerticesOperatorVertexPairClass;
	extern hkClass hclHingeConstraintSetClass;
	extern hkClass hclHingeConstraintSetHingeClass;
	extern hkClass hclHingeSetupObjectClass;
	extern hkClass hclInputConvertOperatorClass;
	extern hkClass hclLocalRangeConstraintSetClass;
	extern hkClass hclLocalRangeConstraintSetLocalConstraintClass;
	extern hkClass hclLocalRangeSetupObjectClass;
	extern hkClass hclMeshBoneDeformOperatorClass;
	extern hkClass hclMeshBoneDeformOperatorTriangleBonePairClass;
	extern hkClass hclMeshBoneDeformSetupObjectClass;
	extern hkClass hclMeshMeshDeformOperatorClass;
	extern hkClass hclMeshMeshDeformOperatorTriangleVertexPairClass;
	extern hkClass hclMeshMeshDeformSetupObjectClass;
	extern hkClass hclMoveFixedParticlesSetupObjectClass;
	extern hkClass hclMoveParticlesOperatorClass;
	extern hkClass hclMoveParticlesOperatorVertexParticlePairClass;
	extern hkClass hclNamedSetupMeshClass;
	extern hkClass hclNamedTransformSetSetupObjectClass;
	extern hkClass hclObjectSpaceDeformerClass;
	extern hkClass hclObjectSpaceDeformerFourBlendEntryBlockClass;
	extern hkClass hclObjectSpaceDeformerLocalBlockPClass;
	extern hkClass hclObjectSpaceDeformerLocalBlockPNClass;
	extern hkClass hclObjectSpaceDeformerLocalBlockPNTBClass;
	extern hkClass hclObjectSpaceDeformerLocalBlockPNTClass;
	extern hkClass hclObjectSpaceDeformerOneBlendEntryBlockClass;
	extern hkClass hclObjectSpaceDeformerThreeBlendEntryBlockClass;
	extern hkClass hclObjectSpaceDeformerTwoBlendEntryBlockClass;
	extern hkClass hclObjectSpaceMeshMeshDeformOperatorClass;
	extern hkClass hclObjectSpaceMeshMeshDeformPNOperatorClass;
	extern hkClass hclObjectSpaceMeshMeshDeformPNTBOperatorClass;
	extern hkClass hclObjectSpaceMeshMeshDeformPNTOperatorClass;
	extern hkClass hclObjectSpaceMeshMeshDeformPOperatorClass;
	extern hkClass hclObjectSpaceSkinOperatorClass;
	extern hkClass hclObjectSpaceSkinPNOperatorClass;
	extern hkClass hclObjectSpaceSkinPNTBOperatorClass;
	extern hkClass hclObjectSpaceSkinPNTOperatorClass;
	extern hkClass hclObjectSpaceSkinPOperatorClass;
	extern hkClass hclOperatorClass;
	extern hkClass hclOperatorSetupObjectClass;
	extern hkClass hclOutputConvertOperatorClass;
	extern hkClass hclPlaneShapeClass;
	extern hkClass hclRecalculateAllNormalsOperatorClass;
	extern hkClass hclRecalculateNormalsSetupObjectClass;
	extern hkClass hclRecalculateSomeNormalsOperatorClass;
	extern hkClass hclRuntimeConversionInfoClass;
	extern hkClass hclRuntimeConversionInfoElementConversionClass;
	extern hkClass hclRuntimeConversionInfoSlotConversionClass;
	extern hkClass hclSceneDataSetupMeshClass;
	extern hkClass hclSceneDataSetupMeshSectionClass;
	extern hkClass hclScratchBufferDefinitionClass;
	extern hkClass hclScratchBufferSetupObjectClass;
	extern hkClass hclSetupMeshClass;
	extern hkClass hclSetupMeshSectionClass;
	extern hkClass hclSetupMeshSectionTriangleClass;
	extern hkClass hclShadowBufferDefinitionClass;
	extern hkClass hclShapeClass;
	extern hkClass hclSimClothBufferSetupObjectClass;
	extern hkClass hclSimClothDataClass;
	extern hkClass hclSimClothDataCollidablePinchingDataClass;
	extern hkClass hclSimClothDataCollidableTransformMapClass;
	extern hkClass hclSimClothDataLandscapeCollisionDataClass;
	extern hkClass hclSimClothDataParticleDataClass;
	extern hkClass hclSimClothDataSimulationInfoClass;
	extern hkClass hclSimClothPoseClass;
	extern hkClass hclSimClothSetupObjectClass;
	extern hkClass hclSimClothSetupObjectPerInstanceCollidableClass;
	extern hkClass hclSimpleMeshBoneDeformOperatorClass;
	extern hkClass hclSimpleMeshBoneDeformOperatorTriangleBonePairClass;
	extern hkClass hclSimpleWindActionClass;
	extern hkClass hclSimulateOperatorClass;
	extern hkClass hclSimulateSetupObjectClass;
	extern hkClass hclSimulationSetupMeshClass;
	extern hkClass hclSimulationSetupMeshMapOptionsClass;
	extern hkClass hclSkeletonTransformSetSetupObjectClass;
	extern hkClass hclSkinOperatorBoneInfluenceClass;
	extern hkClass hclSkinOperatorClass;
	extern hkClass hclSkinSetupObjectClass;
	extern hkClass hclSphereShapeClass;
	extern hkClass hclStandardLinkConstraintSetClass;
	extern hkClass hclStandardLinkConstraintSetLinkClass;
	extern hkClass hclStandardLinkConstraintSetMxBatchClass;
	extern hkClass hclStandardLinkConstraintSetMxClass;
	extern hkClass hclStandardLinkConstraintSetMxSingleClass;
	extern hkClass hclStandardLinkSetupObjectClass;
	extern hkClass hclStaticDisplayBufferSetupObjectClass;
	extern hkClass hclStaticShadowBufferDefinitionClass;
	extern hkClass hclStorageSetupMeshBoneClass;
	extern hkClass hclStorageSetupMeshClass;
	extern hkClass hclStorageSetupMeshEdgeChannelClass;
	extern hkClass hclStorageSetupMeshSectionBoneInfluencesClass;
	extern hkClass hclStorageSetupMeshSectionClass;
	extern hkClass hclStorageSetupMeshSectionSectionEdgeSelectionChannelClass;
	extern hkClass hclStorageSetupMeshSectionSectionTriangleSelectionChannelClass;
	extern hkClass hclStorageSetupMeshSectionSectionVertexChannelClass;
	extern hkClass hclStorageSetupMeshSectionSectionVertexFloatChannelClass;
	extern hkClass hclStorageSetupMeshSectionSectionVertexSelectionChannelClass;
	extern hkClass hclStorageSetupMeshTriangleChannelClass;
	extern hkClass hclStorageSetupMeshVertexChannelClass;
	extern hkClass hclStretchLinkConstraintSetClass;
	extern hkClass hclStretchLinkConstraintSetLinkClass;
	extern hkClass hclStretchLinkConstraintSetMxBatchClass;
	extern hkClass hclStretchLinkConstraintSetMxClass;
	extern hkClass hclStretchLinkConstraintSetMxSingleClass;
	extern hkClass hclStretchLinkSetupObjectClass;
	extern hkClass hclTaperedCapsuleShapeClass;
	extern hkClass hclToolNamedObjectReferenceClass;
	extern hkClass hclTransformSetDefinitionClass;
	extern hkClass hclTransformSetSetupObjectClass;
	extern hkClass hclTransformSetUsageClass;
	extern hkClass hclTransitionConstraintSetClass;
	extern hkClass hclTransitionConstraintSetPerParticleClass;
	extern hkClass hclTransitionSetupObjectClass;
	extern hkClass hclTriangleSelectionInputClass;
	extern hkClass hclUpdateAllVertexFramesOperatorClass;
	extern hkClass hclUpdateSomeVertexFramesOperatorClass;
	extern hkClass hclUpdateSomeVertexFramesOperatorTriangleClass;
	extern hkClass hclUpdateVertexFramesSetupObjectClass;
	extern hkClass hclVertexCopySetupObjectClass;
	extern hkClass hclVertexFloatInputClass;
	extern hkClass hclVertexGatherSetupObjectClass;
	extern hkClass hclVertexSelectionInputClass;
	extern hkClass hclVolumeConstraintApplyDataClass;
	extern hkClass hclVolumeConstraintClass;
	extern hkClass hclVolumeConstraintFrameDataClass;
	extern hkClass hclVolumeConstraintMxApplyBatchDataClass;
	extern hkClass hclVolumeConstraintMxApplySingleDataClass;
	extern hkClass hclVolumeConstraintMxClass;
	extern hkClass hclVolumeConstraintMxFrameBatchDataClass;
	extern hkClass hclVolumeConstraintMxFrameSingleDataClass;
	extern hkClass hclVolumeConstraintSetupObjectClass;
	extern hkClass hkAabbClass;
	extern hkClass hkAabbHalfClass;
	extern hkClass hkAabbUint32Class;
	extern hkClass hkAlignSceneToNodeOptionsClass;
	extern hkClass hkArrayTypeAttributeClass;
	extern hkClass hkBaseObjectClass;
	extern hkClass hkBitFieldClass;
	extern hkClass hkClassClass;
	extern hkClass hkClassEnumClass;
	extern hkClass hkClassEnumItemClass;
	extern hkClass hkClassMemberClass;
	extern hkClass hkColorClass;
	extern hkClass hkContactPointClass;
	extern hkClass hkContactPointMaterialClass;
	extern hkClass hkCustomAttributesAttributeClass;
	extern hkClass hkCustomAttributesClass;
	extern hkClass hkDataObjectTypeAttributeClass;
	extern hkClass hkDescriptionAttributeClass;
	extern hkClass hkDocumentationAttributeClass;
	extern hkClass hkFloat16Class;
	extern hkClass hkFloat16TransformClass;
	extern hkClass hkFourTransposedPointsClass;
	extern hkClass hkGeometryClass;
	extern hkClass hkGeometryTriangleClass;
	extern hkClass hkGizmoAttributeClass;
	extern hkClass hkIndexedTransformSetClass;
	extern hkClass hkLinkAttributeClass;
	extern hkClass hkLocalFrameClass;
	extern hkClass hkLocalFrameGroupClass;
	extern hkClass hkMemoryMeshBodyClass;
	extern hkClass hkMemoryMeshMaterialClass;
	extern hkClass hkMemoryMeshShapeClass;
	extern hkClass hkMemoryMeshTextureClass;
	extern hkClass hkMemoryMeshVertexBufferClass;
	extern hkClass hkMemoryResourceContainerClass;
	extern hkClass hkMemoryResourceHandleClass;
	extern hkClass hkMemoryResourceHandleExternalLinkClass;
	extern hkClass hkMeshBodyClass;
	extern hkClass hkMeshBoneIndexMappingClass;
	extern hkClass hkMeshMaterialClass;
	extern hkClass hkMeshSectionCinfoClass;
	extern hkClass hkMeshSectionClass;
	extern hkClass hkMeshShapeClass;
	extern hkClass hkMeshTextureClass;
	extern hkClass hkMeshVertexBufferClass;
	extern hkClass hkModelerNodeTypeAttributeClass;
	extern hkClass hkMonitorStreamColorTableClass;
	extern hkClass hkMonitorStreamColorTableColorPairClass;
	extern hkClass hkMonitorStreamFrameInfoClass;
	extern hkClass hkMonitorStreamStringMapClass;
	extern hkClass hkMonitorStreamStringMapStringMapClass;
	extern hkClass hkMoppBvTreeShapeBaseClass;
	extern hkClass hkMotionStateClass;
	extern hkClass hkMultiThreadCheckClass;
	extern hkClass hkMultipleVertexBufferClass;
	extern hkClass hkMultipleVertexBufferElementInfoClass;
	extern hkClass hkMultipleVertexBufferLockedElementClass;
	extern hkClass hkMultipleVertexBufferVertexBufferInfoClass;
	extern hkClass hkPackedVector3Class;
	extern hkClass hkPackfileHeaderClass;
	extern hkClass hkPackfileSectionHeaderClass;
	extern hkClass hkPostFinishAttributeClass;
	extern hkClass hkQTransformClass;
	extern hkClass hkRangeInt32AttributeClass;
	extern hkClass hkRangeRealAttributeClass;
	extern hkClass hkRefCountedPropertiesClass;
	extern hkClass hkRefCountedPropertiesEntryClass;
	extern hkClass hkReferencedObjectClass;
	extern hkClass hkResourceBaseClass;
	extern hkClass hkResourceContainerClass;
	extern hkClass hkResourceHandleClass;
	extern hkClass hkRootLevelContainerClass;
	extern hkClass hkRootLevelContainerNamedVariantClass;
	extern hkClass hkSemanticsAttributeClass;
	extern hkClass hkSimpleLocalFrameClass;
	extern hkClass hkSphereClass;
	extern hkClass hkSweptTransformClass;
	extern hkClass hkUiAttributeClass;
	extern hkClass hkVariableTweakingHelperBoolVariableInfoClass;
	extern hkClass hkVariableTweakingHelperClass;
	extern hkClass hkVariableTweakingHelperIntVariableInfoClass;
	extern hkClass hkVariableTweakingHelperRealVariableInfoClass;
	extern hkClass hkVariableTweakingHelperVector4VariableInfoClass;
	extern hkClass hkVertexFormatClass;
	extern hkClass hkVertexFormatElementClass;
	extern hkClass hkWorldMemoryAvailableWatchDogClass;
	extern hkClass hkaAnimatedReferenceFrameClass;
	extern hkClass hkaAnimationBindingClass;
	extern hkClass hkaAnimationClass;
	extern hkClass hkaAnimationContainerClass;
	extern hkClass hkaAnimationPreviewColorContainerClass;
	extern hkClass hkaAnnotationTrackAnnotationClass;
	extern hkClass hkaAnnotationTrackClass;
	extern hkClass hkaBoneAttachmentClass;
	extern hkClass hkaBoneClass;
	extern hkClass hkaDefaultAnimatedReferenceFrameClass;
	extern hkClass hkaFootstepAnalysisInfoClass;
	extern hkClass hkaFootstepAnalysisInfoContainerClass;
	extern hkClass hkaInterleavedUncompressedAnimationClass;
	extern hkClass hkaKeyFrameHierarchyUtilityClass;
	extern hkClass hkaKeyFrameHierarchyUtilityControlDataClass;
	extern hkClass hkaMeshBindingClass;
	extern hkClass hkaMeshBindingMappingClass;
	extern hkClass hkaPredictiveCompressedAnimationClass;
	extern hkClass hkaPredictiveCompressedAnimationTrackCompressionParamsClass;
	extern hkClass hkaQuantizedAnimationClass;
	extern hkClass hkaQuantizedAnimationTrackCompressionParamsClass;
	extern hkClass hkaRagdollInstanceClass;
	extern hkClass hkaSkeletonClass;
	extern hkClass hkaSkeletonLocalFrameOnBoneClass;
	extern hkClass hkaSkeletonMapperClass;
	extern hkClass hkaSkeletonMapperDataChainMappingClass;
	extern hkClass hkaSkeletonMapperDataClass;
	extern hkClass hkaSkeletonMapperDataSimpleMappingClass;
	extern hkClass hkaSplineCompressedAnimationAnimationCompressionParamsClass;
	extern hkClass hkaSplineCompressedAnimationClass;
	extern hkClass hkaSplineCompressedAnimationTrackCompressionParamsClass;
	extern hkClass hkaiAgentTraversalInfoClass;
	extern hkClass hkaiAstarOutputParametersClass;
	extern hkClass hkaiAvoidancePairPropertiesClass;
	extern hkClass hkaiAvoidancePairPropertiesPairDataClass;
	extern hkClass hkaiAvoidanceSolverAvoidancePropertiesClass;
	extern hkClass hkaiAvoidanceSolverMovementPropertiesClass;
	extern hkClass hkaiCharacterClass;
	extern hkClass hkaiDefaultNavMeshCostModifierClass;
	extern hkClass hkaiDefaultNavVolumeCostModifierClass;
	extern hkClass hkaiDirectedGraphExplicitCostClass;
	extern hkClass hkaiDirectedGraphExplicitCostEdgeClass;
	extern hkClass hkaiDirectedGraphExplicitCostExternalEdgeInfoClass;
	extern hkClass hkaiDirectedGraphExplicitCostNodeClass;
	extern hkClass hkaiDynamicNavMeshQueryMediatorClass;
	extern hkClass hkaiEdgeGeometryClass;
	extern hkClass hkaiEdgeGeometryEdgeClass;
	extern hkClass hkaiEdgeGeometryFaceClass;
	extern hkClass hkaiGraphPathSearchParametersClass;
	extern hkClass hkaiInvertedAabbVolumeClass;
	extern hkClass hkaiLocalSteeringInputClass;
	extern hkClass hkaiMaterialPainterClass;
	extern hkClass hkaiNavMeshClass;
	extern hkClass hkaiNavMeshCostModifierClass;
	extern hkClass hkaiNavMeshCutterClass;
	extern hkClass hkaiNavMeshCutterMeshInfoClass;
	extern hkClass hkaiNavMeshCutterSavedConnectivityClass;
	extern hkClass hkaiNavMeshEdgeClass;
	extern hkClass hkaiNavMeshFaceClass;
	extern hkClass hkaiNavMeshGenerationSettingsClass;
	extern hkClass hkaiNavMeshGenerationSettingsEdgeMatchingParametersClass;
	extern hkClass hkaiNavMeshGenerationSettingsMaterialConstructionPairClass;
	extern hkClass hkaiNavMeshGenerationSettingsOverrideSettingsClass;
	extern hkClass hkaiNavMeshGenerationSettingsRegionPruningSettingsClass;
	extern hkClass hkaiNavMeshGenerationSnapshotClass;
	extern hkClass hkaiNavMeshInstanceClass;
	extern hkClass hkaiNavMeshPathRequestInfoClass;
	extern hkClass hkaiNavMeshPathSearchParametersClass;
	extern hkClass hkaiNavMeshQueryMediatorClass;
	extern hkClass hkaiNavMeshSimplificationUtilsSettingsClass;
	extern hkClass hkaiNavVolumeCellClass;
	extern hkClass hkaiNavVolumeClass;
	extern hkClass hkaiNavVolumeCostModifierClass;
	extern hkClass hkaiNavVolumeEdgeClass;
	extern hkClass hkaiNavVolumeExternalEdgeInfoClass;
	extern hkClass hkaiNavVolumeGenerationSettingsChunkSettingsClass;
	extern hkClass hkaiNavVolumeGenerationSettingsClass;
	extern hkClass hkaiNavVolumeGenerationSettingsMaterialConstructionInfoClass;
	extern hkClass hkaiNavVolumeGenerationSettingsMergingSettingsClass;
	extern hkClass hkaiNavVolumeGenerationSnapshotClass;
	extern hkClass hkaiNavVolumePathRequestInfoClass;
	extern hkClass hkaiNavVolumePathSearchParametersClass;
	extern hkClass hkaiPathClass;
	extern hkClass hkaiPathFollowingPropertiesClass;
	extern hkClass hkaiPathPathPointClass;
	extern hkClass hkaiPathfindingUtilClass;
	extern hkClass hkaiPathfindingUtilFindGraphPathInputClass;
	extern hkClass hkaiPathfindingUtilFindPathInputClass;
	extern hkClass hkaiPathfindingUtilFindPathOutputClass;
	extern hkClass hkaiPhysicsShapeVolumeClass;
	extern hkClass hkaiPlaneVolumeClass;
	extern hkClass hkaiReferenceFrameClass;
	extern hkClass hkaiStaticTreeClass;
	extern hkClass hkaiStreamingCollectionClass;
	extern hkClass hkaiStreamingCollectionInstanceInfoClass;
	extern hkClass hkaiStreamingManagerClass;
	extern hkClass hkaiStreamingManagerSectionInfoClass;
	extern hkClass hkaiUserEdgePairArrayClass;
	extern hkClass hkaiUserEdgeSetupArrayClass;
	extern hkClass hkaiUserEdgeUtilsClass;
	extern hkClass hkaiUserEdgeUtilsObbClass;
	extern hkClass hkaiUserEdgeUtilsUserEdgePairClass;
	extern hkClass hkaiUserEdgeUtilsUserEdgeSetupClass;
	extern hkClass hkaiVolumeClass;
	extern hkClass hkaiVolumePathfindingUtilClass;
	extern hkClass hkaiVolumePathfindingUtilFindPathInputClass;
	extern hkClass hkaiVolumePathfindingUtilFindPathOutputClass;
	extern hkClass hkaiWorldCharacterStepCallbackContextClass;
	extern hkClass hkaiWorldClass;
	extern hkClass hkbAlignBoneModifierClass;
	extern hkClass hkbAnimatedSkeletonGeneratorClass;
	extern hkClass hkbAttachmentModifierClass;
	extern hkClass hkbAttachmentSetupClass;
	extern hkClass hkbAttributeModifierAssignmentClass;
	extern hkClass hkbAttributeModifierClass;
	extern hkClass hkbAuxiliaryNodeInfoClass;
	extern hkClass hkbBalanceModifierClass;
	extern hkClass hkbBalanceModifierStepInfoClass;
	extern hkClass hkbBalanceRadialSelectorGeneratorClass;
	extern hkClass hkbBehaviorEventsInfoClass;
	extern hkClass hkbBehaviorGraphClass;
	extern hkClass hkbBehaviorGraphDataClass;
	extern hkClass hkbBehaviorGraphInternalStateClass;
	extern hkClass hkbBehaviorGraphInternalStateInfoClass;
	extern hkClass hkbBehaviorGraphStringDataClass;
	extern hkClass hkbBehaviorInfoClass;
	extern hkClass hkbBehaviorInfoIdToNamePairClass;
	extern hkClass hkbBehaviorReferenceGeneratorClass;
	extern hkClass hkbBindableClass;
	extern hkClass hkbBlendCurveUtilsClass;
	extern hkClass hkbBlenderGeneratorChildClass;
	extern hkClass hkbBlenderGeneratorChildInternalStateClass;
	extern hkClass hkbBlenderGeneratorClass;
	extern hkClass hkbBlendingTransitionEffectClass;
	extern hkClass hkbBoneIndexArrayClass;
	extern hkClass hkbBoneWeightArrayClass;
	extern hkClass hkbBoolVariableSequencedDataClass;
	extern hkClass hkbBoolVariableSequencedDataSampleClass;
	extern hkClass hkbCameraShakeEventPayloadClass;
	extern hkClass hkbCatchFallModifierClass;
	extern hkClass hkbCatchFallModifierHandClass;
	extern hkClass hkbCharacterAddedInfoClass;
	extern hkClass hkbCharacterClass;
	extern hkClass hkbCharacterControlCommandClass;
	extern hkClass hkbCharacterControllerModifierClass;
	extern hkClass hkbCharacterControllerModifierControlDataClass;
	extern hkClass hkbCharacterDataCharacterControllerInfoClass;
	extern hkClass hkbCharacterDataClass;
	extern hkClass hkbCharacterInfoClass;
	extern hkClass hkbCharacterSelectedInfoClass;
	extern hkClass hkbCharacterSetupClass;
	extern hkClass hkbCharacterSkinInfoClass;
	extern hkClass hkbCharacterSteppedInfoClass;
	extern hkClass hkbCharacterStringDataClass;
	extern hkClass hkbCharacterStringDataFileNameMeshNamePairClass;
	extern hkClass hkbCheckBalanceModifierClass;
	extern hkClass hkbCheckRagdollSpeedModifierClass;
	extern hkClass hkbClientCharacterStateClass;
	extern hkClass hkbClipGeneratorClass;
	extern hkClass hkbClipGeneratorEchoClass;
	extern hkClass hkbClipTriggerArrayClass;
	extern hkClass hkbClipTriggerClass;
	extern hkClass hkbCombineTransformsModifierClass;
	extern hkClass hkbCompiledExpressionSetClass;
	extern hkClass hkbCompiledExpressionSetTokenClass;
	extern hkClass hkbComputeDirectionModifierClass;
	extern hkClass hkbComputeRotationFromAxisAngleModifierClass;
	extern hkClass hkbComputeRotationToTargetModifierClass;
	extern hkClass hkbComputeWorldFromModelModifierClass;
	extern hkClass hkbConditionClass;
	extern hkClass hkbConstrainRigidBodyModifierClass;
	extern hkClass hkbContextClass;
	extern hkClass hkbControlledReachModifierClass;
	extern hkClass hkbCustomTestGeneratorClass;
	extern hkClass hkbCustomTestGeneratorStruckClass;
	extern hkClass hkbDampingModifierClass;
	extern hkClass hkbDefaultMessageLogClass;
	extern hkClass hkbDelayedModifierClass;
	extern hkClass hkbDemoConfigCharacterInfoClass;
	extern hkClass hkbDemoConfigClass;
	extern hkClass hkbDemoConfigStickVariableInfoClass;
	extern hkClass hkbDemoConfigTerrainInfoClass;
	extern hkClass hkbDetectCloseToGroundModifierClass;
	extern hkClass hkbDockingGeneratorClass;
	extern hkClass hkbEvaluateExpressionModifierClass;
	extern hkClass hkbEvaluateExpressionModifierInternalExpressionDataClass;
	extern hkClass hkbEvaluateHandleModifierClass;
	extern hkClass hkbEventBaseClass;
	extern hkClass hkbEventClass;
	extern hkClass hkbEventDrivenModifierClass;
	extern hkClass hkbEventInfoClass;
	extern hkClass hkbEventPayloadClass;
	extern hkClass hkbEventPayloadListClass;
	extern hkClass hkbEventPropertyClass;
	extern hkClass hkbEventRaisedInfoClass;
	extern hkClass hkbEventRangeDataArrayClass;
	extern hkClass hkbEventRangeDataClass;
	extern hkClass hkbEventSequencedDataClass;
	extern hkClass hkbEventSequencedDataSequencedEventClass;
	extern hkClass hkbEventsFromRangeModifierClass;
	extern hkClass hkbExpressionConditionClass;
	extern hkClass hkbExpressionDataArrayClass;
	extern hkClass hkbExpressionDataClass;
	extern hkClass hkbExtractRagdollPoseModifierClass;
	extern hkClass hkbExtrapolatingTransitionEffectClass;
	extern hkClass hkbFaceTargetModifierClass;
	extern hkClass hkbFootIkControlDataClass;
	extern hkClass hkbFootIkControlsModifierClass;
	extern hkClass hkbFootIkControlsModifierLegClass;
	extern hkClass hkbFootIkDriverInfoClass;
	extern hkClass hkbFootIkDriverInfoLegClass;
	extern hkClass hkbFootIkGainsClass;
	extern hkClass hkbFootIkModifierClass;
	extern hkClass hkbFootIkModifierInternalLegDataClass;
	extern hkClass hkbFootIkModifierLegClass;
	extern hkClass hkbGeneratorClass;
	extern hkClass hkbGeneratorOutputListenerClass;
	extern hkClass hkbGeneratorSyncInfoClass;
	extern hkClass hkbGeneratorSyncInfoSyncPointClass;
	extern hkClass hkbGeneratorTransitionEffectClass;
	extern hkClass hkbGetHandleOnBoneModifierClass;
	extern hkClass hkbGetUpModifierClass;
	extern hkClass hkbGetWorldFromModelModifierClass;
	extern hkClass hkbGravityModifierClass;
	extern hkClass hkbHandIkControlDataClass;
	extern hkClass hkbHandIkControlsModifierClass;
	extern hkClass hkbHandIkControlsModifierHandClass;
	extern hkClass hkbHandIkDriverInfoClass;
	extern hkClass hkbHandIkDriverInfoHandClass;
	extern hkClass hkbHandIkModifierClass;
	extern hkClass hkbHandIkModifierHandClass;
	extern hkClass hkbHandleClass;
	extern hkClass hkbHoldFromBlendingTransitionEffectClass;
	extern hkClass hkbIntEventPayloadClass;
	extern hkClass hkbIntVariableSequencedDataClass;
	extern hkClass hkbIntVariableSequencedDataSampleClass;
	extern hkClass hkbJigglerGroupClass;
	extern hkClass hkbJigglerModifierClass;
	extern hkClass hkbKeyframeBonesModifierClass;
	extern hkClass hkbKeyframeBonesModifierKeyframeInfoClass;
	extern hkClass hkbLinkedSymbolInfoClass;
	extern hkClass hkbLookAtModifierClass;
	extern hkClass hkbManualSelectorGeneratorClass;
	extern hkClass hkbMessageLogClass;
	extern hkClass hkbMirrorModifierClass;
	extern hkClass hkbMirroredSkeletonInfoClass;
	extern hkClass hkbModifierClass;
	extern hkClass hkbModifierGeneratorClass;
	extern hkClass hkbModifierListClass;
	extern hkClass hkbModifierWrapperClass;
	extern hkClass hkbMoveBoneAttachmentModifierClass;
	extern hkClass hkbMoveBoneTowardTargetModifierClass;
	extern hkClass hkbMoveCharacterModifierClass;
	extern hkClass hkbNamedEventPayloadClass;
	extern hkClass hkbNamedIntEventPayloadClass;
	extern hkClass hkbNamedRealEventPayloadClass;
	extern hkClass hkbNamedStringEventPayloadClass;
	extern hkClass hkbNodeClass;
	extern hkClass hkbNodeInternalStateInfoClass;
	extern hkClass hkbParticleSystemEventPayloadClass;
	extern hkClass hkbPoseMatchingGeneratorClass;
	extern hkClass hkbPoseStoringGeneratorOutputListenerClass;
	extern hkClass hkbPoseStoringGeneratorOutputListenerStoredPoseClass;
	extern hkClass hkbPoweredRagdollControlDataClass;
	extern hkClass hkbPoweredRagdollControlsModifierClass;
	extern hkClass hkbProjectDataClass;
	extern hkClass hkbProjectStringDataClass;
	extern hkClass hkbRadialSelectorGeneratorClass;
	extern hkClass hkbRadialSelectorGeneratorGeneratorInfoClass;
	extern hkClass hkbRadialSelectorGeneratorGeneratorPairClass;
	extern hkClass hkbRaiseEventCommandClass;
	extern hkClass hkbReachModifierClass;
	extern hkClass hkbReachModifierHandClass;
	extern hkClass hkbReachTowardTargetModifierClass;
	extern hkClass hkbReachTowardTargetModifierHandClass;
	extern hkClass hkbRealEventPayloadClass;
	extern hkClass hkbRealVariableSequencedDataClass;
	extern hkClass hkbRealVariableSequencedDataSampleClass;
	extern hkClass hkbRebuildScriptsCommandClass;
	extern hkClass hkbReferencePoseGeneratorClass;
	extern hkClass hkbReferencedGeneratorSyncInfoClass;
	extern hkClass hkbRigidBodyRagdollControlDataClass;
	extern hkClass hkbRigidBodyRagdollControlsModifierClass;
	extern hkClass hkbRoleAttributeClass;
	extern hkClass hkbRotateCharacterModifierClass;
	extern hkClass hkbScriptGeneratorClass;
	extern hkClass hkbSenseHandleModifierClass;
	extern hkClass hkbSenseHandleModifierRangeClass;
	extern hkClass hkbSequenceClass;
	extern hkClass hkbSequenceStringDataClass;
	extern hkClass hkbSequencedDataClass;
	extern hkClass hkbSetBehaviorCommandClass;
	extern hkClass hkbSetLocalTimeOfClipGeneratorCommandClass;
	extern hkClass hkbSetNodePropertyCommandClass;
	extern hkClass hkbSetSelectedCharacterCommandClass;
	extern hkClass hkbSetWordVariableCommandClass;
	extern hkClass hkbSetWorldFromModelModifierClass;
	extern hkClass hkbSimulationControlCommandClass;
	extern hkClass hkbSimulationStateInfoClass;
	extern hkClass hkbStateChooserClass;
	extern hkClass hkbStateDependentModifierClass;
	extern hkClass hkbStateListenerClass;
	extern hkClass hkbStateMachineActiveTransitionInfoClass;
	extern hkClass hkbStateMachineClass;
	extern hkClass hkbStateMachineDelayedTransitionInfoClass;
	extern hkClass hkbStateMachineEventPropertyArrayClass;
	extern hkClass hkbStateMachineNestedStateMachineDataClass;
	extern hkClass hkbStateMachineProspectiveTransitionInfoClass;
	extern hkClass hkbStateMachineStateInfoClass;
	extern hkClass hkbStateMachineTimeIntervalClass;
	extern hkClass hkbStateMachineTransitionInfoArrayClass;
	extern hkClass hkbStateMachineTransitionInfoClass;
	extern hkClass hkbStateMachineTransitionInfoReferenceClass;
	extern hkClass hkbStringConditionClass;
	extern hkClass hkbStringEventPayloadClass;
	extern hkClass hkbTargetClass;
	extern hkClass hkbTargetRigidBodyModifierClass;
	extern hkClass hkbTestStateChooserClass;
	extern hkClass hkbTimerModifierClass;
	extern hkClass hkbToolNodeTypeClass;
	extern hkClass hkbTransformVectorModifierClass;
	extern hkClass hkbTransitionEffectClass;
	extern hkClass hkbTwistModifierClass;
	extern hkClass hkbVariableBindingSetBindingClass;
	extern hkClass hkbVariableBindingSetClass;
	extern hkClass hkbVariableBoundsClass;
	extern hkClass hkbVariableInfoClass;
	extern hkClass hkbVariableValueClass;
	extern hkClass hkbVariableValueSetClass;
	extern hkClass hkbWorldEnumsClass;
	extern hkClass hkbWorldFromModelModeDataClass;
	extern hkClass hkcdDynamicTreeAnisotropicMetricClass;
	extern hkClass hkcdDynamicTreeBalanceMetricClass;
	extern hkClass hkcdDynamicTreeCentroidMetricClass;
	extern hkClass hkcdDynamicTreeCodec18Class;
	extern hkClass hkcdDynamicTreeCodec32Class;
	extern hkClass hkcdDynamicTreeCodecRawUintClass;
	extern hkClass hkcdDynamicTreeCodecRawUlongClass;
	extern hkClass hkcdDynamicTreeCodecRawunsignedintClass;
	extern hkClass hkcdDynamicTreeCodecRawunsignedlongClass;
	extern hkClass hkcdDynamicTreeDefaultDynamicStoragehkcdDynamicTreeCodec32Class;
	extern hkClass hkcdDynamicTreeDefaultDynamicStoragehkcdDynamicTreeCodecRawUintClass;
	extern hkClass hkcdDynamicTreeDefaultDynamicStoragehkcdDynamicTreeCodecRawUlongClass;
	extern hkClass hkcdDynamicTreeDefaultTree32StorageClass;
	extern hkClass hkcdDynamicTreeDefaultTree48StorageClass;
	extern hkClass hkcdDynamicTreeDefaultTreePtrStorageClass;
	extern hkClass hkcdDynamicTreeDynamicStorage0hkcdDynamicTreeAnisotropicMetrichkcdDynamicTreeCodec32Class;
	extern hkClass hkcdDynamicTreeDynamicStorage0hkcdDynamicTreeAnisotropicMetrichkcdDynamicTreeCodecRawUintClass;
	extern hkClass hkcdDynamicTreeDynamicStorage0hkcdDynamicTreeAnisotropicMetrichkcdDynamicTreeCodecRawUlongClass;
	extern hkClass hkcdDynamicTreeDynamicStorage16Class;
	extern hkClass hkcdDynamicTreeDynamicStorage32Class;
	extern hkClass hkcdDynamicTreeDynamicStoragePtrClass;
	extern hkClass hkcdDynamicTreeTreehkcdDynamicTreeDynamicStorage16Class;
	extern hkClass hkcdDynamicTreeTreehkcdDynamicTreeDynamicStorage32Class;
	extern hkClass hkcdDynamicTreeTreehkcdDynamicTreeDynamicStoragePtrClass;
	extern hkClass hkcdStaticMeshTreeBaseClass;
	extern hkClass hkcdStaticMeshTreeBasePrimitiveClass;
	extern hkClass hkcdStaticMeshTreeBasePrimitiveDataRunBaseunsignedintClass;
	extern hkClass hkcdStaticMeshTreeBasePrimitiveDataRunBaseunsignedshortClass;
	extern hkClass hkcdStaticMeshTreeBaseSectionClass;
	extern hkClass hkcdStaticMeshTreeBaseSectionDataRunsClass;
	extern hkClass hkcdStaticMeshTreeBaseSectionPrimitivesClass;
	extern hkClass hkcdStaticMeshTreeBaseSectionSharedVerticesClass;
	extern hkClass hkcdStaticMeshTreeDefaultDataRunClass;
	extern hkClass hkcdStaticMeshTreehkcdStaticMeshTreeCommonConfigunsignedintunsignedlonglong1121hkpBvCompressedMeshShapeTreeDataRunClass;
	extern hkClass hkcdStaticTreeCodec3Axis4Class;
	extern hkClass hkcdStaticTreeCodec3Axis5Class;
	extern hkClass hkcdStaticTreeCodec3Axis6Class;
	extern hkClass hkcdStaticTreeCodec3AxisClass;
	extern hkClass hkcdStaticTreeCodecRawClass;
	extern hkClass hkcdStaticTreeDefaultTreeStorage32Class;
	extern hkClass hkcdStaticTreeDefaultTreeStorage4Class;
	extern hkClass hkcdStaticTreeDefaultTreeStorage5Class;
	extern hkClass hkcdStaticTreeDefaultTreeStorage6Class;
	extern hkClass hkcdStaticTreeDynamicStorage32Class;
	extern hkClass hkcdStaticTreeDynamicStorage4Class;
	extern hkClass hkcdStaticTreeDynamicStorage5Class;
	extern hkClass hkcdStaticTreeDynamicStorage6Class;
	extern hkClass hkcdStaticTreeDynamicStoragehkcdStaticTreeCodec3Axis4Class;
	extern hkClass hkcdStaticTreeDynamicStoragehkcdStaticTreeCodec3Axis5Class;
	extern hkClass hkcdStaticTreeDynamicStoragehkcdStaticTreeCodec3Axis6Class;
	extern hkClass hkcdStaticTreeDynamicStoragehkcdStaticTreeCodecRawClass;
	extern hkClass hkcdStaticTreeTreehkcdStaticTreeDynamicStorage32Class;
	extern hkClass hkcdStaticTreeTreehkcdStaticTreeDynamicStorage4Class;
	extern hkClass hkcdStaticTreeTreehkcdStaticTreeDynamicStorage5Class;
	extern hkClass hkcdStaticTreeTreehkcdStaticTreeDynamicStorage6Class;
	extern hkClass hkdActionClass;
	extern hkClass hkdBodyClass;
	extern hkClass hkdBreakableBodyClass;
	extern hkClass hkdBreakableBodyMementoClass;
	extern hkClass hkdBreakableBodySmallArraySerializeOverrideTypeClass;
	extern hkClass hkdBreakableShapeActionListClass;
	extern hkClass hkdBreakableShapeClass;
	extern hkClass hkdBreakableShapeConnectionClass;
	extern hkClass hkdBreakableShapeConnectionListClass;
	extern hkClass hkdBreakableShapeContactAreaClass;
	extern hkClass hkdBuildingControllerClass;
	extern hkClass hkdCompoundBreakableBodyMementoClass;
	extern hkClass hkdCompoundBreakableShapeClass;
	extern hkClass hkdContactRegionControllerClass;
	extern hkClass hkdControllerClass;
	extern hkClass hkdControllerSmallArraySerializeOverrideTypeClass;
	extern hkClass hkdConvexDecompositionActionClass;
	extern hkClass hkdCutOutFractureClass;
	extern hkClass hkdDebrisFractureClass;
	extern hkClass hkdDebrisFractureInfoClass;
	extern hkClass hkdDebrisFractureInfoTemplateInfoClass;
	extern hkClass hkdDebugLinesClass;
	extern hkClass hkdDebugLinesDebugLineClass;
	extern hkClass hkdDebugLinesDebugTextClass;
	extern hkClass hkdDecalMapActionClass;
	extern hkClass hkdDecalMapActionDecalMapClass;
	extern hkClass hkdDecalMapActionDecalMapDataClass;
	extern hkClass hkdDecalMapActionDecorMapInfoClass;
	extern hkClass hkdDecomposeFractureClass;
	extern hkClass hkdDecorateCornerInfoClass;
	extern hkClass hkdDecorateCornerInfoContainerClass;
	extern hkClass hkdDecorateFractureFaceActionClass;
	extern hkClass hkdDecorateFractureFaceActionCompressedDecorationPlacementClass;
	extern hkClass hkdDecorateFractureFaceActionConnectionDecorationInfoClass;
	extern hkClass hkdDecorateFractureFaceActionCornerDecorationInfoClass;
	extern hkClass hkdDecorateFractureFaceActionForwarderClass;
	extern hkClass hkdDecorateFractureFaceActionFractureFaceInfo2Class;
	extern hkClass hkdDecorateFractureFaceActionFractureFaceInfoClass;
	extern hkClass hkdDecorateFractureFaceActionGlobalDecorationDataClass;
	extern hkClass hkdDecorateFractureFaceActionShapeDecorationInfoClass;
	extern hkClass hkdDecorateFractureFaceInfoClass;
	extern hkClass hkdDeformableBreakableBodyMementoClass;
	extern hkClass hkdDeformableBreakableShapeBoneDeformationDataClass;
	extern hkClass hkdDeformableBreakableShapeBoneInfoClass;
	extern hkClass hkdDeformableBreakableShapeClass;
	extern hkClass hkdDeformableBreakableShapeDeformationPropertyClass;
	extern hkClass hkdDeformableBreakableShapePhysicsSkinInstanceClass;
	extern hkClass hkdDeformableBreakableShapePhysicsSkinShapeClass;
	extern hkClass hkdDeformableBreakableShapeSkinShapeSectionClass;
	extern hkClass hkdDeformationControllerClass;
	extern hkClass hkdDestructionDemoConfigClass;
	extern hkClass hkdExplosionForceActionClass;
	extern hkClass hkdFlexibleJointControllerClass;
	extern hkClass hkdFlexibleJointControllerJointDefClass;
	extern hkClass hkdFlexibleJointControllerWatchConstraintActionClass;
	extern hkClass hkdFractureClass;
	extern hkClass hkdGeometryClass;
	extern hkClass hkdGeometryFaceClass;
	extern hkClass hkdGeometryFaceIdentifierClass;
	extern hkClass hkdGeometryObjectIdentifierClass;
	extern hkClass hkdGeometryTriangleClass;
	extern hkClass hkdGlueFixedPiecesActionClass;
	extern hkClass hkdGraphicsBodyClass;
	extern hkClass hkdGraphicsShapeClass;
	extern hkClass hkdGrenadeGunClass;
	extern hkClass hkdInfoClass;
	extern hkClass hkdIntegrityAnalyzerActionClass;
	extern hkClass hkdMeshSimplifierActionClass;
	extern hkClass hkdMissileGunClass;
	extern hkClass hkdObjectPropertiesClass;
	extern hkClass hkdObjectPropertiesPropertyClass;
	extern hkClass hkdPieFractureClass;
	extern hkClass hkdPropertiesClass;
	extern hkClass hkdPropertyFlagSetClass;
	extern hkClass hkdRandomSplitFractureClass;
	extern hkClass hkdRaycastGunClass;
	extern hkClass hkdRemoveDebrisActionClass;
	extern hkClass hkdRemoveWeakConnectionsActionClass;
	extern hkClass hkdSetRigidBodyPropertiesActionClass;
	extern hkClass hkdShapeClass;
	extern hkClass hkdShapeInstanceInfoClass;
	extern hkClass hkdShapeInstanceInfoRuntimeInfoClass;
	extern hkClass hkdShareVerticesActionClass;
	extern hkClass hkdShockWaveActionClass;
	extern hkClass hkdSimpleBreakableBodyMementoClass;
	extern hkClass hkdSimpleShockWaveActionClass;
	extern hkClass hkdSliceFractureClass;
	extern hkClass hkdSphereGunClass;
	extern hkClass hkdSplitInHalfControllerClass;
	extern hkClass hkdSplitInHalfFractureClass;
	extern hkClass hkdSplitShapeClass;
	extern hkClass hkdStickyGunClass;
	extern hkClass hkdStringObjectClass;
	extern hkClass hkdTransformObjectClass;
	extern hkClass hkdVoronoiFractureClass;
	extern hkClass hkdWoodControllerClass;
	extern hkClass hkdWoodFractureClass;
	extern hkClass hkdWoodFractureSplittingDataClass;
	extern hkClass hkp2dAngConstraintAtomClass;
	extern hkClass hkpAabbPhantomClass;
	extern hkClass hkpActionClass;
	extern hkClass hkpAgent1nSectorClass;
	extern hkClass hkpAngConstraintAtomClass;
	extern hkClass hkpAngFrictionConstraintAtomClass;
	extern hkClass hkpAngLimitConstraintAtomClass;
	extern hkClass hkpAngMotorConstraintAtomClass;
	extern hkClass hkpAngularDashpotActionClass;
	extern hkClass hkpArrayActionClass;
	extern hkClass hkpBallAndSocketConstraintDataAtomsClass;
	extern hkClass hkpBallAndSocketConstraintDataClass;
	extern hkClass hkpBallGunClass;
	extern hkClass hkpBallSocketChainDataClass;
	extern hkClass hkpBallSocketChainDataConstraintInfoClass;
	extern hkClass hkpBallSocketConstraintAtomClass;
	extern hkClass hkpBinaryActionClass;
	extern hkClass hkpBoxMotionClass;
	extern hkClass hkpBoxShapeClass;
	extern hkClass hkpBreakableBodyClass;
	extern hkClass hkpBreakableBodyControllerClass;
	extern hkClass hkpBreakableConstraintDataClass;
	extern hkClass hkpBreakableMaterialClass;
	extern hkClass hkpBreakableMultiMaterialClass;
	extern hkClass hkpBreakableMultiMaterialInverseMappingClass;
	extern hkClass hkpBreakableMultiMaterialInverseMappingDescriptorClass;
	extern hkClass hkpBreakableShapeClass;
	extern hkClass hkpBridgeAtomsClass;
	extern hkClass hkpBridgeConstraintAtomClass;
	extern hkClass hkpBroadPhaseHandleClass;
	extern hkClass hkpBvCompressedMeshShapeClass;
	extern hkClass hkpBvCompressedMeshShapeTreeClass;
	extern hkClass hkpBvCompressedMeshShapeTreeDataRunClass;
	extern hkClass hkpBvShapeClass;
	extern hkClass hkpBvTreeShapeClass;
	extern hkClass hkpCachingShapePhantomClass;
	extern hkClass hkpCallbackConstraintMotorClass;
	extern hkClass hkpCapsuleShapeClass;
	extern hkClass hkpCdBodyClass;
	extern hkClass hkpCenterOfMassChangerModifierConstraintAtomClass;
	extern hkClass hkpCharacterControllerCinfoClass;
	extern hkClass hkpCharacterMotionClass;
	extern hkClass hkpCharacterProxyCinfoClass;
	extern hkClass hkpCharacterRigidBodyCinfoClass;
	extern hkClass hkpCogWheelConstraintAtomClass;
	extern hkClass hkpCogWheelConstraintDataAtomsClass;
	extern hkClass hkpCogWheelConstraintDataClass;
	extern hkClass hkpCollidableBoundingVolumeDataClass;
	extern hkClass hkpCollidableClass;
	extern hkClass hkpCollidableCollidableFilterClass;
	extern hkClass hkpCollisionFilterClass;
	extern hkClass hkpCollisionFilterListClass;
	extern hkClass hkpCompressedMeshShapeBigTriangleClass;
	extern hkClass hkpCompressedMeshShapeChunkClass;
	extern hkClass hkpCompressedMeshShapeClass;
	extern hkClass hkpCompressedMeshShapeConvexPieceClass;
	extern hkClass hkpCompressedSampledHeightFieldShapeClass;
	extern hkClass hkpConeLimitConstraintAtomClass;
	extern hkClass hkpConstrainedSystemFilterClass;
	extern hkClass hkpConstraintAtomClass;
	extern hkClass hkpConstraintChainDataClass;
	extern hkClass hkpConstraintChainInstanceActionClass;
	extern hkClass hkpConstraintChainInstanceClass;
	extern hkClass hkpConstraintCollisionFilterClass;
	extern hkClass hkpConstraintDataClass;
	extern hkClass hkpConstraintInstanceClass;
	extern hkClass hkpConstraintInstanceSmallArraySerializeOverrideTypeClass;
	extern hkClass hkpConstraintMotorClass;
	extern hkClass hkpConvexListFilterClass;
	extern hkClass hkpConvexListShapeClass;
	extern hkClass hkpConvexPieceMeshShapeClass;
	extern hkClass hkpConvexPieceStreamDataClass;
	extern hkClass hkpConvexShapeClass;
	extern hkClass hkpConvexTransformShapeBaseClass;
	extern hkClass hkpConvexTransformShapeClass;
	extern hkClass hkpConvexTranslateShapeClass;
	extern hkClass hkpConvexVerticesConnectivityClass;
	extern hkClass hkpConvexVerticesShapeClass;
	extern hkClass hkpCylinderShapeClass;
	extern hkClass hkpDashpotActionClass;
	extern hkClass hkpDefaultConvexListFilterClass;
	extern hkClass hkpDefaultWorldMemoryWatchDogClass;
	extern hkClass hkpDisableEntityCollisionFilterClass;
	extern hkClass hkpDisplayBindingDataClass;
	extern hkClass hkpDisplayBindingDataPhysicsSystemClass;
	extern hkClass hkpDisplayBindingDataRigidBodyClass;
	extern hkClass hkpEntityClass;
	extern hkClass hkpEntityExtendedListenersClass;
	extern hkClass hkpEntitySmallArraySerializeOverrideTypeClass;
	extern hkClass hkpEntitySpuCollisionCallbackClass;
	extern hkClass hkpExtendedMeshShapeBreakableMaterialClass;
	extern hkClass hkpExtendedMeshShapeClass;
	extern hkClass hkpExtendedMeshShapeShapesSubpartClass;
	extern hkClass hkpExtendedMeshShapeSubpartClass;
	extern hkClass hkpExtendedMeshShapeTrianglesSubpartClass;
	extern hkClass hkpFastMeshShapeClass;
	extern hkClass hkpFirstPersonGunClass;
	extern hkClass hkpFixedRigidMotionClass;
	extern hkClass hkpGenericConstraintDataClass;
	extern hkClass hkpGenericConstraintDataSchemeClass;
	extern hkClass hkpGenericConstraintDataSchemeConstraintInfoClass;
	extern hkClass hkpGravityGunClass;
	extern hkClass hkpGroupCollisionFilterClass;
	extern hkClass hkpGroupFilterClass;
	extern hkClass hkpHeightFieldShapeClass;
	extern hkClass hkpHingeConstraintDataAtomsClass;
	extern hkClass hkpHingeConstraintDataClass;
	extern hkClass hkpHingeLimitsDataAtomsClass;
	extern hkClass hkpHingeLimitsDataClass;
	extern hkClass hkpIgnoreModifierConstraintAtomClass;
	extern hkClass hkpKeyframedRigidMotionClass;
	extern hkClass hkpLimitedForceConstraintMotorClass;
	extern hkClass hkpLimitedHingeConstraintDataAtomsClass;
	extern hkClass hkpLimitedHingeConstraintDataClass;
	extern hkClass hkpLinConstraintAtomClass;
	extern hkClass hkpLinFrictionConstraintAtomClass;
	extern hkClass hkpLinLimitConstraintAtomClass;
	extern hkClass hkpLinMotorConstraintAtomClass;
	extern hkClass hkpLinSoftConstraintAtomClass;
	extern hkClass hkpLinearParametricCurveClass;
	extern hkClass hkpLinkedCollidableClass;
	extern hkClass hkpListShapeBreakableMaterialClass;
	extern hkClass hkpListShapeChildInfoClass;
	extern hkClass hkpListShapeClass;
	extern hkClass hkpMalleableConstraintDataClass;
	extern hkClass hkpMassChangerModifierConstraintAtomClass;
	extern hkClass hkpMassPropertiesClass;
	extern hkClass hkpMaterialClass;
	extern hkClass hkpMaxSizeMotionClass;
	extern hkClass hkpMeshMaterialClass;
	extern hkClass hkpMeshShapeClass;
	extern hkClass hkpMeshShapeSubpartClass;
	extern hkClass hkpModifierConstraintAtomClass;
	extern hkClass hkpMoppBvTreeShapeClass;
	extern hkClass hkpMoppCodeClass;
	extern hkClass hkpMoppCodeCodeInfoClass;
	extern hkClass hkpMoppCodeReindexedTerminalClass;
	extern hkClass hkpMotionClass;
	extern hkClass hkpMotorActionClass;
	extern hkClass hkpMountedBallGunClass;
	extern hkClass hkpMouseSpringActionClass;
	extern hkClass hkpMovingSurfaceModifierConstraintAtomClass;
	extern hkClass hkpMultiRayShapeClass;
	extern hkClass hkpMultiRayShapeRayClass;
	extern hkClass hkpMultiSphereShapeClass;
	extern hkClass hkpMultithreadedVehicleManagerClass;
	extern hkClass hkpNamedMeshMaterialClass;
	extern hkClass hkpNullCollisionFilterClass;
	extern hkClass hkpOverwritePivotConstraintAtomClass;
	extern hkClass hkpPairCollisionFilterClass;
	extern hkClass hkpPairCollisionFilterMapPairFilterKeyOverrideTypeClass;
	extern hkClass hkpParametricCurveClass;
	extern hkClass hkpPhantomCallbackShapeClass;
	extern hkClass hkpPhantomClass;
	extern hkClass hkpPhysicsDataClass;
	extern hkClass hkpPhysicsSystemClass;
	extern hkClass hkpPhysicsSystemWithContactsClass;
	extern hkClass hkpPlaneShapeClass;
	extern hkClass hkpPointToPathConstraintDataClass;
	extern hkClass hkpPointToPlaneConstraintDataAtomsClass;
	extern hkClass hkpPointToPlaneConstraintDataClass;
	extern hkClass hkpPositionConstraintMotorClass;
	extern hkClass hkpPoweredChainDataClass;
	extern hkClass hkpPoweredChainDataConstraintInfoClass;
	extern hkClass hkpPoweredChainMapperClass;
	extern hkClass hkpPoweredChainMapperLinkInfoClass;
	extern hkClass hkpPoweredChainMapperTargetClass;
	extern hkClass hkpPrismaticConstraintDataAtomsClass;
	extern hkClass hkpPrismaticConstraintDataClass;
	extern hkClass hkpProjectileGunClass;
	extern hkClass hkpPropertyClass;
	extern hkClass hkpPropertyValueClass;
	extern hkClass hkpPulleyConstraintAtomClass;
	extern hkClass hkpPulleyConstraintDataAtomsClass;
	extern hkClass hkpPulleyConstraintDataClass;
	extern hkClass hkpRackAndPinionConstraintAtomClass;
	extern hkClass hkpRackAndPinionConstraintDataAtomsClass;
	extern hkClass hkpRackAndPinionConstraintDataClass;
	extern hkClass hkpRagdollConstraintDataAtomsClass;
	extern hkClass hkpRagdollConstraintDataClass;
	extern hkClass hkpRagdollLimitsDataAtomsClass;
	extern hkClass hkpRagdollLimitsDataClass;
	extern hkClass hkpRagdollMotorConstraintAtomClass;
	extern hkClass hkpRayCollidableFilterClass;
	extern hkClass hkpRayShapeCollectionFilterClass;
	extern hkClass hkpRejectChassisListenerClass;
	extern hkClass hkpRemoveTerminalsMoppModifierClass;
	extern hkClass hkpReorientActionClass;
	extern hkClass hkpRigidBodyClass;
	extern hkClass hkpRotationalConstraintDataAtomsClass;
	extern hkClass hkpRotationalConstraintDataClass;
	extern hkClass hkpSampledHeightFieldShapeClass;
	extern hkClass hkpSampledHeightFieldShapeCoarseMinMaxLevelClass;
	extern hkClass hkpSerializedAgentNnEntryClass;
	extern hkClass hkpSerializedDisplayMarkerClass;
	extern hkClass hkpSerializedDisplayMarkerListClass;
	extern hkClass hkpSerializedDisplayRbTransformsClass;
	extern hkClass hkpSerializedDisplayRbTransformsDisplayTransformPairClass;
	extern hkClass hkpSerializedSubTrack1nInfoClass;
	extern hkClass hkpSerializedTrack1nInfoClass;
	extern hkClass hkpSetLocalRotationsConstraintAtomClass;
	extern hkClass hkpSetLocalTransformsConstraintAtomClass;
	extern hkClass hkpSetLocalTranslationsConstraintAtomClass;
	extern hkClass hkpSetupStabilizationAtomClass;
	extern hkClass hkpShapeClass;
	extern hkClass hkpShapeCollectionClass;
	extern hkClass hkpShapeCollectionFilterClass;
	extern hkClass hkpShapeContainerClass;
	extern hkClass hkpShapeInfoClass;
	extern hkClass hkpShapeKeyTableBlockClass;
	extern hkClass hkpShapeKeyTableClass;
	extern hkClass hkpShapePhantomClass;
	extern hkClass hkpSimpleBreakableMaterialClass;
	extern hkClass hkpSimpleContactConstraintAtomClass;
	extern hkClass hkpSimpleContactConstraintDataInfoClass;
	extern hkClass hkpSimpleMeshShapeClass;
	extern hkClass hkpSimpleMeshShapeTriangleClass;
	extern hkClass hkpSimpleShapePhantomClass;
	extern hkClass hkpSingleShapeContainerClass;
	extern hkClass hkpSoftContactModifierConstraintAtomClass;
	extern hkClass hkpSphereMotionClass;
	extern hkClass hkpSphereRepShapeClass;
	extern hkClass hkpSphereShapeClass;
	extern hkClass hkpSpringActionClass;
	extern hkClass hkpSpringDamperConstraintMotorClass;
	extern hkClass hkpStaticCompoundShapeBreakableMaterialClass;
	extern hkClass hkpStaticCompoundShapeClass;
	extern hkClass hkpStaticCompoundShapeInstanceClass;
	extern hkClass hkpStiffSpringChainDataClass;
	extern hkClass hkpStiffSpringChainDataConstraintInfoClass;
	extern hkClass hkpStiffSpringConstraintAtomClass;
	extern hkClass hkpStiffSpringConstraintDataAtomsClass;
	extern hkClass hkpStiffSpringConstraintDataClass;
	extern hkClass hkpStorageExtendedMeshShapeClass;
	extern hkClass hkpStorageExtendedMeshShapeMaterialClass;
	extern hkClass hkpStorageExtendedMeshShapeMeshSubpartStorageClass;
	extern hkClass hkpStorageExtendedMeshShapeShapeSubpartStorageClass;
	extern hkClass hkpStorageMeshShapeClass;
	extern hkClass hkpStorageMeshShapeSubpartStorageClass;
	extern hkClass hkpStorageSampledHeightFieldShapeClass;
	extern hkClass hkpThinBoxMotionClass;
	extern hkClass hkpTransformShapeClass;
	extern hkClass hkpTriSampledHeightFieldBvTreeShapeClass;
	extern hkClass hkpTriSampledHeightFieldCollectionClass;
	extern hkClass hkpTriangleShapeClass;
	extern hkClass hkpTriggerVolumeClass;
	extern hkClass hkpTriggerVolumeEventInfoClass;
	extern hkClass hkpTwistLimitConstraintAtomClass;
	extern hkClass hkpTypedBroadPhaseHandleClass;
	extern hkClass hkpTyremarkPointClass;
	extern hkClass hkpTyremarksInfoClass;
	extern hkClass hkpTyremarksWheelClass;
	extern hkClass hkpUnaryActionClass;
	extern hkClass hkpVehicleAerodynamicsClass;
	extern hkClass hkpVehicleBrakeClass;
	extern hkClass hkpVehicleCastBatchingManagerClass;
	extern hkClass hkpVehicleDataClass;
	extern hkClass hkpVehicleDataWheelComponentParamsClass;
	extern hkClass hkpVehicleDefaultAerodynamicsClass;
	extern hkClass hkpVehicleDefaultAnalogDriverInputClass;
	extern hkClass hkpVehicleDefaultBrakeClass;
	extern hkClass hkpVehicleDefaultBrakeWheelBrakingPropertiesClass;
	extern hkClass hkpVehicleDefaultEngineClass;
	extern hkClass hkpVehicleDefaultSteeringClass;
	extern hkClass hkpVehicleDefaultSuspensionClass;
	extern hkClass hkpVehicleDefaultSuspensionWheelSpringSuspensionParametersClass;
	extern hkClass hkpVehicleDefaultTransmissionClass;
	extern hkClass hkpVehicleDefaultVelocityDamperClass;
	extern hkClass hkpVehicleDriverInputAnalogStatusClass;
	extern hkClass hkpVehicleDriverInputClass;
	extern hkClass hkpVehicleDriverInputStatusClass;
	extern hkClass hkpVehicleEngineClass;
	extern hkClass hkpVehicleFrictionDescriptionAxisDescriptionClass;
	extern hkClass hkpVehicleFrictionDescriptionClass;
	extern hkClass hkpVehicleFrictionStatusAxisStatusClass;
	extern hkClass hkpVehicleFrictionStatusClass;
	extern hkClass hkpVehicleInstanceClass;
	extern hkClass hkpVehicleInstanceWheelInfoClass;
	extern hkClass hkpVehicleLinearCastBatchingManagerClass;
	extern hkClass hkpVehicleLinearCastWheelCollideClass;
	extern hkClass hkpVehicleLinearCastWheelCollideWheelStateClass;
	extern hkClass hkpVehicleManagerClass;
	extern hkClass hkpVehicleRayCastBatchingManagerClass;
	extern hkClass hkpVehicleRayCastWheelCollideClass;
	extern hkClass hkpVehicleSteeringClass;
	extern hkClass hkpVehicleSuspensionClass;
	extern hkClass hkpVehicleSuspensionSuspensionWheelParametersClass;
	extern hkClass hkpVehicleTransmissionClass;
	extern hkClass hkpVehicleVelocityDamperClass;
	extern hkClass hkpVehicleWheelCollideClass;
	extern hkClass hkpVelocityConstraintMotorClass;
	extern hkClass hkpViscousSurfaceModifierConstraintAtomClass;
	extern hkClass hkpWeldingUtilityClass;
	extern hkClass hkpWheelConstraintDataAtomsClass;
	extern hkClass hkpWheelConstraintDataClass;
	extern hkClass hkpWorldCinfoClass;
	extern hkClass hkpWorldObjectClass;
	extern hkClass hkxAnimatedFloatClass;
	extern hkClass hkxAnimatedMatrixClass;
	extern hkClass hkxAnimatedQuaternionClass;
	extern hkClass hkxAnimatedVectorClass;
	extern hkClass hkxAttributeClass;
	extern hkClass hkxAttributeGroupClass;
	extern hkClass hkxAttributeHolderClass;
	extern hkClass hkxCameraClass;
	extern hkClass hkxEdgeSelectionChannelClass;
	extern hkClass hkxEnumClass;
	extern hkClass hkxEnumItemClass;
	extern hkClass hkxEnvironmentClass;
	extern hkClass hkxEnvironmentVariableClass;
	extern hkClass hkxIndexBufferClass;
	extern hkClass hkxLightClass;
	extern hkClass hkxMaterialClass;
	extern hkClass hkxMaterialEffectClass;
	extern hkClass hkxMaterialPropertyClass;
	extern hkClass hkxMaterialShaderClass;
	extern hkClass hkxMaterialShaderSetClass;
	extern hkClass hkxMaterialTextureStageClass;
	extern hkClass hkxMeshClass;
	extern hkClass hkxMeshSectionClass;
	extern hkClass hkxMeshUserChannelInfoClass;
	extern hkClass hkxNodeAnnotationDataClass;
	extern hkClass hkxNodeClass;
	extern hkClass hkxNodeSelectionSetClass;
	extern hkClass hkxSceneClass;
	extern hkClass hkxSkinBindingClass;
	extern hkClass hkxSparselyAnimatedBoolClass;
	extern hkClass hkxSparselyAnimatedEnumClass;
	extern hkClass hkxSparselyAnimatedIntClass;
	extern hkClass hkxSparselyAnimatedStringClass;
	extern hkClass hkxTextureFileClass;
	extern hkClass hkxTextureInplaceClass;
	extern hkClass hkxTriangleSelectionChannelClass;
	extern hkClass hkxVertexBufferClass;
	extern hkClass hkxVertexBufferVertexDataClass;
	extern hkClass hkxVertexDescriptionClass;
	extern hkClass hkxVertexDescriptionElementDeclClass;
	extern hkClass hkxVertexFloatDataChannelClass;
	extern hkClass hkxVertexIntDataChannelClass;
	extern hkClass hkxVertexSelectionChannelClass;
	extern hkClass hkxVertexVectorDataChannelClass;

	static const hkInternalClassEnumItem ManifesthkaiIndicesEnumItems[] =
	{
		{10, "HKAI_NUM_BITS_FOR_SECTION"},
		{22, "HKAI_NUM_BITS_FOR_INDEX"},
		{1024, "HKAI_MAX_NUM_SECTIONS"},
		{4194304, "HKAI_MAX_NUM_EDGES"},
		{4194304, "HKAI_MAX_NUM_FACES"},
		{-1, "HKAI_INVALID_RUNTIME_INDEX"},
		{1022, "HKAI_START_NODE_SECTION_ID"},
		{1021, "HKAI_GOAL_NODE_SECTION_ID"},
	};
	static const hkInternalClassEnumItem ManifesthkaDmaGroupsEnumEnumItems[] =
	{
		{0, "HK_SPU_DMA_GROUP_ANIMATION_DATA"},
		{2, "HK_SPU_DMA_GROUP_ANIMATED_SKELETON_DATA"},
		{3, "HK_SPU_DMA_GROUP_OUTPUT_POSE"},
		{4, "HK_SPU_DMA_GROUP_ANIMATION_SAMPLE_DATA"},
		{7, "HK_SPU_DMA_GROUP_HEADER"},
		{10, "HK_SPU_DMA_GROUP_FRAME"},
		{13, "HK_SPU_DMA_GROUP_SEMAPHORE"},
	};
	static const hkInternalClassEnumItem ManifestBLEND_MODEEnumItems[] =
	{
		{0, "NORMAL"},
		{1, "ADDITIVE"},
		{-1, "SUBTRACTIVE"},
	};
	static const hkInternalClassEnumItem ManifestROTATION_MODEEnumItems[] =
	{
		{0, "LERP"},
		{1, "SLERP"},
	};
	static const hkInternalClassEnumItem ManifesthkbNodeTypeEnumItems[] =
	{
		{0, "HKB_NODE_TYPE_INVALID"},
		{1, "HKB_NODE_TYPE_FIRST_GENERATOR"},
		{1, "HKB_NODE_TYPE_BEHAVIOR_GRAPH"},
		{2, "HKB_NODE_TYPE_BEHAVIOR_REFERENCE_GENERATOR"},
		{3, "HKB_NODE_TYPE_BLENDER_GENERATOR"},
		{4, "HKB_NODE_TYPE_CLIP_GENERATOR"},
		{5, "HKB_NODE_TYPE_MANUAL_SELECTOR_GENERATOR"},
		{6, "HKB_NODE_TYPE_MODIFIER_GENERATOR"},
		{7, "HKB_NODE_TYPE_REFERENCE_POSE_GENERATOR"},
		{8, "HKB_NODE_TYPE_STATE_MACHINE"},
		{9, "HKB_NODE_TYPE_SCRIPT_GENERATOR"},
		{10, "HKB_NODE_TYPE_END_OF_SPU_GENERATORS"},
		{10, "HKB_NODE_TYPE_DOCKING_GENERATOR"},
		{11, "HKB_NODE_TYPE_OTHER_GENERATOR"},
		{48, "HKB_NODE_TYPE_FIRST_TRANSITION_EFFECT"},
		{48, "HKB_NODE_TYPE_BLENDING_TRANSITION_EFFECT"},
		{49, "HKB_NODE_TYPE_GENERATOR_TRANSITION_EFFECT"},
		{50, "HKB_NODE_TYPE_END_OF_SPU_TRANSITION_EFFECTS"},
		{64, "HKB_NODE_TYPE_FIRST_MODIFIER"},
		{64, "HKB_NODE_TYPE_ATTACHMENT_MODIFIER"},
		{65, "HKB_NODE_TYPE_ATTRIBUTE_MODIFIER"},
		{66, "HKB_NODE_TYPE_CHARACTER_CONTROLLER_MODIFIER"},
		{67, "HKB_NODE_TYPE_COMBINE_TRANSFORMS_MODIFIER"},
		{68, "HKB_NODE_TYPE_COMPUTE_DIRECTION_MODIFIER"},
		{69, "HKB_NODE_TYPE_COMPUTE_ROTATION_FROM_AXIS_ANGLE_MODIFIER"},
		{70, "HKB_NODE_TYPE_COMPUTE_ROTATION_TO_TARGET_MODIFIER"},
		{71, "HKB_NODE_TYPE_DAMPING_MODIFIER"},
		{72, "HKB_NODE_TYPE_DELAYED_MODIFIER"},
		{73, "HKB_NODE_TYPE_EVALUATE_EXPRESSION_MODIFIER"},
		{74, "HKB_NODE_TYPE_EVENTS_FROM_RANGE_MODIFIER"},
		{75, "HKB_NODE_TYPE_EVENT_DRIVEN_MODIFIER"},
		{76, "HKB_NODE_TYPE_FOOT_IK_CONTROLS_MODIFIER"},
		{77, "HKB_NODE_TYPE_GET_WORLD_FROM_MODEL_MODIFIER"},
		{78, "HKB_NODE_TYPE_HAND_IK_CONTROLS_MODIFIER"},
		{79, "HKB_NODE_TYPE_KEYFRAME_BONES_MODIFIER"},
		{80, "HKB_NODE_TYPE_LOOK_AT_MODIFIER"},
		{81, "HKB_NODE_TYPE_MIRROR_MODIFIER"},
		{82, "HKB_NODE_TYPE_MODIFIER_LIST"},
		{83, "HKB_NODE_TYPE_MOVE_BONE_ATTACHMENT_MODIFIER"},
		{84, "HKB_NODE_TYPE_MOVE_CHARACTER_MODIFIER"},
		{85, "HKB_NODE_TYPE_POWERED_RAGDOLL_CONTROLS_MODIFIER"},
		{86, "HKB_NODE_TYPE_RIGID_BODY_RAGDOLL_CONTROLS_MODIFIER"},
		{87, "HKB_NODE_TYPE_ROTATE_CHARACTER_MODIFIER"},
		{88, "HKB_NODE_TYPE_SET_WORLD_FROM_MODEL_MODIFIER"},
		{89, "HKB_NODE_TYPE_TIMER_MODIFIER"},
		{90, "HKB_NODE_TYPE_TRANSFORM_VECTOR_MODIFIER"},
		{91, "HKB_NODE_TYPE_TWIST_MODIFIER"},
		{92, "HKB_NODE_TYPE_END_OF_SPU_MODIFIERS"},
		{92, "HKB_NODE_TYPE_DETECT_CLOSE_TO_GROUND_MODIFIER"},
		{93, "HKB_NODE_TYPE_EVALUATE_HANDLE_MODIFIER"},
		{94, "HKB_NODE_TYPE_GET_HANDLE_ON_BONE_MODIFIER"},
		{95, "HKB_NODE_TYPE_GET_UP_MODIFIER"},
		{96, "HKB_NODE_TYPE_JIGGLER_MODIFIER"},
		{97, "HKB_NODE_TYPE_SENSE_HANDLE_MODIFIER"},
		{98, "HKB_NODE_TYPE_SEQUENCE"},
		{99, "HKB_NODE_TYPE_OTHER_MODIFIER"},
	};
	static const hkInternalClassEnumItem ManifesthclTransformSetTypeEnumItems[] =
	{
		{0, "HCL_TRANSFORMSET_TYPE_INVALID"},
		{1, "HCL_TRANSFORMSET_TYPE_ANIMATION"},
		{100, "HCL_TRANSFORMSET_TYPE_USER_0"},
		{101, "HCL_TRANSFORMSET_TYPE_USER_1"},
	};
	static const hkInternalClassEnumItem ManifesthclShapeTypeEnumItems[] =
	{
		{0, "HCL_SHAPE_TYPE_SPHERE"},
		{1, "HCL_SHAPE_TYPE_PLANE"},
		{2, "HCL_SHAPE_TYPE_CAPSULE"},
		{3, "HCL_SHAPE_TYPE_TAPERED_CAPSULE"},
		{4, "HCL_SHAPE_TYPE_CYLINDER"},
		{5, "HCL_SHAPE_TYPE_CONVEX_HEIGHTFIELD"},
		{6, "HCL_SHAPE_TYPE_CONNECTED_MESH"},
		{7, "HCL_SHAPE_TYPE_PLANAR_HEIGHTFIELD"},
		{8, "HCL_SHAPE_TYPE_DEFORMING_MESH"},
		{9, "HCL_SHAPE_TYPE_CONVEX_GEOMETRY"},
		{10, "HCL_SHAPE_TYPE_POINT_CONTACT_PLANES"},
	};
	static const hkInternalClassEnumItem ManifesthclActionSpuDispatchIdEnumItems[] =
	{
		{0, "HCL_SPU_ACTION_NOT_IMPLEMENTED"},
		{1, "HCL_SPU_ACTION_SIMPLE_WIND"},
		{100, "HCL_SPU_ACTION_USER_START"},
	};
	static const hkInternalClassEnumItem ManifesthclConstraintSetTypeEnumItems[] =
	{
		{0, "HCL_CONSTRAINTSET_INVALID"},
		{1, "HCL_CONSTRAINTSET_STANDARD_LINK"},
		{2, "HCL_CONSTRAINTSET_STRETCH_LINK"},
		{3, "HCL_CONSTRAINTSET_BEND_LINK"},
		{4, "HCL_CONSTRAINTSET_BEND_STIFFNESS"},
		{5, "HCL_CONSTRAINTSET_LOCAL_RANGE"},
		{6, "HCL_CONSTRAINTSET_VOLUME"},
		{7, "HCL_CONSTRAINTSET_HINGE"},
		{8, "HCL_CONSTRAINTSET_TRANSITION"},
		{9, "HCL_CONSTRAINTSET_DRIVE"},
		{10, "HCL_CONSTRAINTSET_BONE_PLANES"},
		{11, "HCL_CONSTRAINTSET_UNILATERAL_STANDARD_LINK"},
		{12, "HCL_CONSTRAINTSET_HIERARCHICAL_STANDARD_LINK_NV"},
		{13, "HCL_CONSTRAINTSET_STANDARD_LINK_MX"},
		{14, "HCL_CONSTRAINTSET_BEND_LINK_MX"},
		{15, "HCL_CONSTRAINTSET_STRETCH_LINK_MX"},
		{16, "HCL_CONSTRAINTSET_BEND_STIFFNESS_MX"},
		{17, "HCL_CONSTRAINTSET_VOLUME_MX"},
		{18, "HCL_CONSTRAINTSET_COLLISION"},
		{19, "HCL_CONSTRAINTSET_ANTI_PINCH"},
		{20, "HCL_CONSTRAINTSET_COMPRESSIBLE_LINK"},
		{21, "HCL_CONSTRAINTSET_COMPRESSIBLE_LINK_MX"},
		{21, "HCL_CONSTRAINTSET_MAX_ID"},
	};
	static const hkInternalClassEnumItem ManifesthclOperatorTypeEnumItems[] =
	{
		{0, "HCL_OPERATOR_INVALID"},
		{1, "HCL_OPERATOR_SIMULATE"},
		{2, "HCL_OPERATOR_GATHER_ALL_VERTICES"},
		{3, "HCL_OPERATOR_GATHER_SOME_VERTICES"},
		{4, "HCL_OPERATOR_COPY_VERTICES"},
		{5, "HCL_OPERATOR_MESH_MESH_DEFORM"},
		{6, "HCL_OPERATOR_RECALCULATE_ALL_NORMALS"},
		{7, "HCL_OPERATOR_RECALCULATE_SOME_NORMALS"},
		{8, "HCL_OPERATOR_SKIN"},
		{9, "HCL_OPERATOR_UPDATE_SUBDIVISION_SURFACE"},
		{10, "HCL_OPERATOR_BLEND_SOME_VERTICES"},
		{11, "HCL_OPERATOR_MOVE_SOME_PARTICLES"},
		{12, "HCL_OPERATOR_UPDATE_ALL_VERTEX_FRAMES"},
		{13, "HCL_OPERATOR_UPDATE_SOME_VERTEX_FRAMES"},
		{14, "HCL_OPERATOR_CONVERT_INPUT"},
		{15, "HCL_OPERATOR_CONVERT_OUTPUT"},
		{16, "HCL_OPERATOR_MESH_BONE_DEFORM"},
		{17, "HCL_OPERATOR_SIMPLE_MESH_BONE_DEFORM"},
		{18, "HCL_OPERATOR_BONESPACE_SKIN_P"},
		{19, "HCL_OPERATOR_BONESPACE_SKIN_PN"},
		{20, "HCL_OPERATOR_BONESPACE_SKIN_PNT"},
		{21, "HCL_OPERATOR_BONESPACE_SKIN_PNTB"},
		{22, "HCL_OPERATOR_OBJECTSPACE_SKIN_P"},
		{23, "HCL_OPERATOR_OBJECTSPACE_SKIN_PN"},
		{24, "HCL_OPERATOR_OBJECTSPACE_SKIN_PNT"},
		{25, "HCL_OPERATOR_OBJECTSPACE_SKIN_PNTB"},
		{26, "HCL_OPERATOR_BONESPACE_MESH_MESH_DEFORM_P"},
		{27, "HCL_OPERATOR_BONESPACE_MESH_MESH_DEFORM_PN"},
		{28, "HCL_OPERATOR_BONESPACE_MESH_MESH_DEFORM_PNT"},
		{29, "HCL_OPERATOR_BONESPACE_MESH_MESH_DEFORM_PNTB"},
		{30, "HCL_OPERATOR_OBJECTSPACE_MESH_MESH_DEFORM_P"},
		{31, "HCL_OPERATOR_OBJECTSPACE_MESH_MESH_DEFORM_PN"},
		{32, "HCL_OPERATOR_OBJECTSPACE_MESH_MESH_DEFORM_PNT"},
		{33, "HCL_OPERATOR_OBJECTSPACE_MESH_MESH_DEFORM_PNTB"},
		{34, "HCL_OPERATOR_MAX_ID"},
		{100, "HCL_OPERATOR_USER_0"},
		{101, "HCL_OPERATOR_USER_1"},
		{102, "HCL_OPERATOR_USER_2"},
		{103, "HCL_OPERATOR_USER_3"},
	};
	static const hkInternalClassEnumItem ManifesthclBufferTypeEnumItems[] =
	{
		{0, "HCL_BUFFER_TYPE_INVALID"},
		{1, "HCL_BUFFER_TYPE_CLOTH_CURRENT_POSITIONS"},
		{2, "HCL_BUFFER_TYPE_CLOTH_PREVIOUS_POSITIONS"},
		{3, "HCL_BUFFER_TYPE_CLOTHDATA_POSE"},
		{4, "HCL_BUFFER_TYPE_DISPLAY"},
		{5, "HCL_BUFFER_TYPE_STATIC_DISPLAY"},
		{6, "HCL_BUFFER_TYPE_SCRATCH_BUFFER"},
		{7, "HCL_BUFFER_TYPE_SHADOW"},
		{8, "HCL_BUFFER_TYPE_STATIC_SHADOW"},
		{100, "HCL_BUFFER_TYPE_USER_0"},
		{101, "HCL_BUFFER_TYPE_USER_1"},
	};
	static const hkInternalClassEnumItem ManifestResult_EnumItems[] =
	{
		{0, "COMP_ERROR"},
		{1, "COMP_NEEDINPUT"},
		{2, "COMP_NEEDOUTPUT"},
	};
	static const hkInternalClassEnumItem ManifesthkResultEnumItems[] =
	{
		{0, "HK_SUCCESS"},
		{1, "HK_FAILURE"},
	};
	static const hkInternalClassEnumItem ManifesthkBool32FalseTypeEnumItems[] =
	{
		{0, "hkFalse32"},
	};
	static const hkInternalClassEnumItem ManifesthkJobTypeEnumItems[] =
	{
		{0, "HK_JOB_TYPE_DYNAMICS"},
		{1, "HK_JOB_TYPE_COLLIDE"},
		{2, "HK_JOB_TYPE_COLLISION_QUERY"},
		{3, "HK_JOB_TYPE_RAYCAST_QUERY"},
		{4, "HK_JOB_TYPE_KD_TREE_BUILDING"},
		{5, "HK_JOB_TYPE_ANIMATION_SAMPLE_AND_COMBINE"},
		{6, "HK_JOB_TYPE_ANIMATION_SAMPLE_AND_BLEND"},
		{7, "HK_JOB_TYPE_ANIMATION_MAPPING"},
		{8, "HK_JOB_TYPE_BEHAVIOR"},
		{9, "HK_JOB_TYPE_CLOTH"},
		{10, "HK_JOB_TYPE_AI_PATHFINDING"},
		{11, "HK_JOB_TYPE_AI_DYNAMIC"},
		{12, "HK_JOB_TYPE_AI_LOCAL_STEERING"},
		{13, "HK_JOB_TYPE_AI_GENERATION"},
		{14, "HK_JOB_TYPE_DESTRUCTION"},
		{15, "HK_JOB_TYPE_UNIT_TEST"},
		{16, "HK_JOB_TYPE_CHARACTER_PROXY"},
		{17, "HK_JOB_TYPE_VEHICLE"},
		{18, "HK_JOB_TYPE_COLLIDE_STATIC_COMPOUND"},
		{19, "HK_JOB_TYPE_NP_SOLVER"},
		{20, "HK_JOB_TYPE_NP_COLLIDE"},
		{21, "HK_JOB_TYPE_HAVOK_MAX"},
		{21, "HK_JOB_TYPE_USER_0"},
		{22, "HK_JOB_TYPE_MAX"},
	};
	static const hkInternalClassEnumItem ManifesthkJobSpuTypeEnumItems[] =
	{
		{0, "HK_JOB_SPU_TYPE_INVALID"},
		{1, "HK_JOB_SPU_TYPE_ENABLED"},
		{2, "HK_JOB_SPU_TYPE_DISABLED"},
	};
	static const hkInternalClassEnumItem ManifesthkVectorConstantEnumItems[] =
	{
		{0, "HK_QUADREAL_MINUS1"},
		{1, "HK_QUADREAL_0"},
		{2, "HK_QUADREAL_1"},
		{3, "HK_QUADREAL_2"},
		{4, "HK_QUADREAL_3"},
		{5, "HK_QUADREAL_4"},
		{6, "HK_QUADREAL_5"},
		{7, "HK_QUADREAL_6"},
		{8, "HK_QUADREAL_7"},
		{9, "HK_QUADREAL_15"},
		{10, "HK_QUADREAL_16"},
		{11, "HK_QUADREAL_255"},
		{12, "HK_QUADREAL_256"},
		{13, "HK_QUADREAL_2_POW_23"},
		{14, "HK_QUADREAL_INV_0"},
		{15, "HK_QUADREAL_INV_1"},
		{16, "HK_QUADREAL_INV_2"},
		{17, "HK_QUADREAL_INV_3"},
		{18, "HK_QUADREAL_INV_4"},
		{19, "HK_QUADREAL_INV_5"},
		{20, "HK_QUADREAL_INV_6"},
		{21, "HK_QUADREAL_INV_7"},
		{22, "HK_QUADREAL_INV_15"},
		{23, "HK_QUADREAL_INV_255"},
		{24, "HK_QUADREAL_1000"},
		{25, "HK_QUADREAL_0100"},
		{26, "HK_QUADREAL_0010"},
		{27, "HK_QUADREAL_0001"},
		{28, "HK_QUADREAL_MAX"},
		{29, "HK_QUADREAL_EPS"},
		{30, "HK_QUADREAL_EPS_SQRD"},
		{31, "HK_QUADREAL_m11m11"},
		{32, "HK_QUADREAL_1010"},
		{33, "HK_QUADREAL_1248"},
		{34, "HK_QUADREAL_8421"},
		{35, "HK_QUADREAL_PACK_HALF"},
		{36, "HK_QUADREAL_PACK16_UNIT_VEC"},
		{37, "HK_QUADREAL_UNPACK16_UNIT_VEC"},
		{38, "HK_QUADREAL_PI"},
		{39, "HK_QUADREAL_PI_HALF"},
		{40, "HK_QUADREAL_PI_QUARTER"},
		{41, "HK_QUADREAL_END"},
	};
	static const hkInternalClassEnumItem ManifesthkIntVectorConstantEnumItems[] =
	{
		{0, "HK_QUADINT_0"},
		{1, "HK_QUADINT_1"},
		{2, "HK_QUADINT_2"},
		{3, "HK_QUADINT_4"},
		{4, "HK_QUADINT_0123"},
		{5, "HK_QUADINT_0123_INT24W"},
		{6, "HK_QUADINT_PERM_XXXX"},
		{7, "HK_QUADINT_PERM_YYYY"},
		{8, "HK_QUADINT_PERM_ZZZZ"},
		{9, "HK_QUADINT_PERM_WWWW"},
		{10, "HK_QUADINT_END"},
	};
	static const hkInternalClassEnumItem ManifesthkMathAccuracyModeEnumItems[] =
	{
		{0, "HK_ACC_FULL"},
		{1, "HK_ACC_23_BIT"},
		{2, "HK_ACC_12_BIT"},
	};
	static const hkInternalClassEnumItem ManifesthkMathDivByZeroModeEnumItems[] =
	{
		{0, "HK_DIV_IGNORE"},
		{1, "HK_DIV_SET_ZERO"},
		{2, "HK_DIV_SET_ZERO_AND_ONE"},
		{3, "HK_DIV_SET_MAX"},
		{4, "HK_DIV_SET_HIGH"},
	};
	static const hkInternalClassEnumItem ManifesthkMathNegSqrtModeEnumItems[] =
	{
		{0, "HK_SQRT_IGNORE"},
		{1, "HK_SQRT_SET_ZERO"},
	};
	static const hkInternalClassEnumItem ManifesthkMathIoModeEnumItems[] =
	{
		{0, "HK_IO_BYTE_ALIGNED"},
		{1, "HK_IO_NATIVE_ALIGNED"},
		{2, "HK_IO_SIMD_ALIGNED"},
		{3, "HK_IO_NOT_CACHED"},
	};
	static const hkInternalClassEnumItem ManifesthkMathRoundingModeEnumItems[] =
	{
		{0, "HK_ROUND_TRUNCATE"},
		{1, "HK_ROUND_NEAREST"},
	};
	static const hkInternalClassEnumItem ManifesthkGeomConvexHullModeEnumItems[] =
	{
		{0, "HK_GEOM_CONVEXHULL_MODE_INVALID"},
		{1, "HK_GEOM_CONVEXHULL_MODE_FAST"},
		{2, "HK_GEOM_CONVEXHULL_MODE_ACCURATE_BUT_SLOW"},
		{3, "HK_GEOM_CONVEXHULL_MODE_MAX_ID"},
	};
	static const hkInternalClassEnumItem ManifesthkGeomObbModeEnumItems[] =
	{
		{0, "HK_GEOM_OBB_MODE_INVALID"},
		{1, "HK_GEOM_OBB_MODE_DEFAULT"},
		{2, "HK_GEOM_OBB_MODE_BETTER_FIT_BUT_SLOWER"},
		{3, "HK_GEOM_OBB_MODE_MAX_ID"},
	};
	static const hkInternalClassEnumItem ManifesthkSplitPrimitivesStatusEnumItems[] =
	{
		{0, "SPLIT_PRIMITIVES_OK"},
		{1, "SPLIT_PRIMITIVES_INDISTINGUISHABLE"},
	};
	static const hkInternalClassEnumItem ManifestSplittingEnumItems[] =
	{
		{0, "SURFACE_AREA_HEURISTIC"},
		{1, "MEDIAN"},
	};
	static const hkInternalClassEnumItem ManifestneighbourDirectionEnumItems[] =
	{
		{-1, "CLOCKWISE"},
		{1, "COUNTERCLOCKWISE"},
		{2, "NEIGHBOURDIRECTION_MAX"},
	};
	static const hkInternalClassEnumItem ManifestFlagsEnumItems[] =
	{
		{0, "NONE"},
		{1, "VERBOSE"},
		{2, "IGNORE_REMOVED"},
	};
	static const hkInternalClassEnumItem ManifestSaveOptionBitsEnumItems[] =
	{
		{0, "SAVE_DEFAULT"},
		{1, "SAVE_TEXT_FORMAT"},
		{2, "SAVE_SERIALIZE_IGNORED_MEMBERS"},
		{4, "SAVE_WRITE_ATTRIBUTES"},
		{8, "SAVE_CONCISE"},
		{16, "SAVE_TEXT_NUMBERS"},
	};
	static const hkInternalClassEnumItem ManifestLoadOptionBitsEnumItems[] =
	{
		{0, "LOAD_DEFAULT"},
		{1, "LOAD_FAIL_IF_VERSIONING"},
	};
	static const hkInternalClassEnumItem ManifestFormatTypeEnumItems[] =
	{
		{0, "FORMAT_ERROR"},
		{1, "FORMAT_UNKNOWN"},
		{2, "FORMAT_PACKFILE_BINARY"},
		{3, "FORMAT_PACKFILE_XML"},
		{4, "FORMAT_TAGFILE_BINARY"},
		{5, "FORMAT_TAGFILE_XML"},
	};
	static const hkInternalClassEnumItem ManifestTagTypeEnumItems[] =
	{
		{0, "TAG_NONE"},
		{1, "TAG_FILE_INFO"},
		{2, "TAG_METADATA"},
		{3, "TAG_OBJECT"},
		{4, "TAG_OBJECT_REMEMBER"},
		{5, "TAG_OBJECT_BACKREF"},
		{6, "TAG_OBJECT_NULL"},
		{7, "TAG_FILE_END"},
	};
	static const hkInternalClassEnumItem ManifestVersionEnumItems[] =
	{
		{4096, "CURRENT_VERSION"},
	};
	static const hkInternalClassEnumItem ManifestCommandsEnumItems[] =
	{
		{1, "SEND_FRAMEBUFFER"},
		{2, "SEND_GAMEPAD"},
		{3, "SEND_KEY"},
		{4, "SEND_MOUSE"},
		{5, "SEND_OPTIONS"},
		{6, "SEND_INFO"},
		{7, "SEND_STRING"},
	};
	static const hkInternalClassEnumItem ManifestFramebufferCommandsEnumItems[] =
	{
		{1, "FRAMEBUFFER_RECT_RAW"},
		{2, "FRAMEBUFFER_RECT_DIFF"},
		{3, "FRAMEBUFFER_RECT_RLE"},
	};
	static const hkInternalClassEnumItem ManifestFramebufferFormatEnumItems[] =
	{
		{1, "PIXEL_RGB888"},
		{2, "PIXEL_RGB565"},
		{3, "PIXEL_PALLETE8"},
	};
	static const hkInternalClassEnumItem ManifesthkDisplayGeometryTypeEnumItems[] =
	{
		{0, "HK_DISPLAY_RECTANGLE"},
		{1, "HK_DISPLAY_SPHERE"},
		{2, "HK_DISPLAY_BOX"},
		{3, "HK_DISPLAY_AABB"},
		{4, "HK_DISPLAY_CONE"},
		{5, "HK_DISPLAY_SEMICIRCLE"},
		{6, "HK_DISPLAY_CONVEX"},
		{7, "HK_DISPLAY_PLANE"},
		{8, "HK_DISPLAY_CAPSULE"},
		{9, "HK_DISPLAY_CYLINDER"},
		{10, "HK_DISPLAY_TAPERED_CAPSULE"},
		{11, "HK_DISPLAY_MESH"},
	};
	static const hkInternalClassEnumItem ManifestServerToClientCommandsEnumItems[] =
	{
		{0, "HK_STEP"},
		{1, "HK_ADD_GEOMETRY"},
		{2, "HK_UPDATE_GEOMETRY"},
		{3, "HK_SET_COLOR_GEOMETRY"},
		{4, "HK_REMOVE_GEOMETRY"},
		{5, "HK_DISPLAY_GEOMETRY_WITH_TRANSFORM"},
		{6, "HK_DISPLAY_GEOMETRY"},
		{7, "HK_DISPLAY_POINT"},
		{8, "HK_DISPLAY_LINE"},
		{9, "HK_DISPLAY_TEXT"},
		{10, "HK_SEND_STATISTICS_DUMP"},
		{11, "HK_HOLD_IMMEDIATE"},
		{12, "HK_ADD_CAMERA"},
		{13, "HK_UPDATE_CAMERA"},
		{14, "HK_REMOVE_CAMERA"},
		{15, "HK_SEND_MEMSTATS_DUMP"},
		{16, "HK_ADD_GEOMETRY_INSTANCE"},
		{17, "HK_DISPLAY_TEXT_3D"},
		{18, "HK_UNUSED_0"},
		{19, "HK_UNUSED_1"},
		{20, "HK_DISPLAY_ANNOTATION"},
		{21, "HK_ADD_MESH_OBSOLETE"},
		{22, "HK_REMOVE_MESH_OBSOLETE"},
		{23, "HK_UPDATE_GEOMETRY_WITH_SCALE"},
		{24, "HK_SKIN_GEOMETRY"},
		{25, "HK_ADD_GEOMETRY_PART"},
		{26, "HK_ADD_GEOMETRY_FINAL"},
		{27, "HK_ADD_GEOMETRY_HASH"},
		{28, "HK_GEOMETRY_FOR_HASH_PART"},
		{29, "HK_GEOMETRY_FOR_HASH_FINAL"},
		{30, "HK_DISPLAY_BONE"},
		{31, "HK_SET_TRANSPARENCY_GEOMETRY"},
		{32, "HK_SETUP"},
		{144, "HK_VERSION_INFORMATION"},
		{145, "HK_SERVER_LAYOUT"},
		{192, "HK_REGISTER_PROCESS"},
		{193, "HK_SELECT_PROCESS"},
		{196, "HK_PAUSE_WORLD_STEP"},
		{197, "HK_UNPAUSE_WORLD_STEP"},
		{208, "HK_SNAPSHOT"},
		{209, "MEMORY_SNAPSHOT"},
	};
	static const hkInternalClassEnumItem ManifestBidirectionalCommandsEnumItems[] =
	{
		{33, "HK_ADD_TOPLEVEL"},
		{34, "HK_REMOVE_TOPLEVEL"},
		{35, "HK_REQUEST_OBJECT"},
		{36, "HK_ADD_OBJECT"},
		{37, "HK_UPDATE_MEMBER"},
		{64, "HK_LIVE_OBJECT"},
	};
	static const hkInternalClassEnumItem ManifestClientToServerCommandsEnumItems[] =
	{
		{0, "COMMAND_STEP"},
		{48, "COMMAND_REQUEST_GEOMETRY_WITH_HASH"},
		{49, "COMMAND_DO_NOT_REQUEST_GEOMETRY_WITH_HASH"},
		{50, "COMMAND_CLIENT_DISPLAY_HANDLER_SETTINGS"},
		{176, "HK_PICK_OBJECT"},
		{177, "HK_DRAG_OBJECT"},
		{178, "HK_RELEASE_OBJECT"},
		{194, "HK_CREATE_PROCESS"},
		{195, "HK_DELETE_PROCESS"},
		{240, "COMMAND_ACK"},
	};
	static const hkInternalClassEnumItem ManifesthkKeyboardCommandEnumItems[] =
	{
		{160, "HK_VIRTUAL_KEYBOARD_DUMP"},
	};
	static const hkInternalClassEnumItem ManifesthkpCollidableQualityTypeEnumItems[] =
	{
		{-1, "HK_COLLIDABLE_QUALITY_INVALID"},
		{0, "HK_COLLIDABLE_QUALITY_FIXED"},
		{1, "HK_COLLIDABLE_QUALITY_KEYFRAMED"},
		{2, "HK_COLLIDABLE_QUALITY_DEBRIS"},
		{3, "HK_COLLIDABLE_QUALITY_DEBRIS_SIMPLE_TOI"},
		{4, "HK_COLLIDABLE_QUALITY_MOVING"},
		{5, "HK_COLLIDABLE_QUALITY_CRITICAL"},
		{6, "HK_COLLIDABLE_QUALITY_BULLET"},
		{7, "HK_COLLIDABLE_QUALITY_USER"},
		{8, "HK_COLLIDABLE_QUALITY_CHARACTER"},
		{9, "HK_COLLIDABLE_QUALITY_KEYFRAMED_REPORTING"},
		{10, "HK_COLLIDABLE_QUALITY_MAX"},
	};
	static const hkInternalClassEnumItem ManifesthkpShapeTypeEnumItems[] =
	{
		{0, "HK_SHAPE_INVALID"},
		{1, "HK_SHAPE_SPHERE"},
		{1, "HK_FIRST_SHAPE_TYPE"},
		{2, "HK_SHAPE_CYLINDER"},
		{3, "HK_SHAPE_TRIANGLE"},
		{4, "HK_SHAPE_BOX"},
		{5, "HK_SHAPE_CAPSULE"},
		{6, "HK_SHAPE_CONVEX_VERTICES"},
		{7, "HK_SHAPE_COLLECTION"},
		{8, "HK_SHAPE_BV_TREE"},
		{9, "HK_SHAPE_LIST"},
		{10, "HK_SHAPE_MOPP"},
		{11, "HK_SHAPE_CONVEX_TRANSLATE"},
		{12, "HK_SHAPE_CONVEX_TRANSFORM"},
		{13, "HK_SHAPE_SAMPLED_HEIGHT_FIELD"},
		{14, "HK_SHAPE_EXTENDED_MESH"},
		{15, "HK_SHAPE_TRANSFORM"},
		{16, "HK_SHAPE_COMPRESSED_MESH"},
		{17, "HK_SHAPE_STATIC_COMPOUND"},
		{18, "HK_SHAPE_BV_COMPRESSED_MESH"},
		{19, "HK_SHAPE_MAX_ID_SPU"},
		{20, "HK_SHAPE_CONVEX"},
		{21, "HK_SHAPE_CONVEX_PIECE"},
		{22, "HK_SHAPE_MULTI_SPHERE"},
		{23, "HK_SHAPE_CONVEX_LIST"},
		{24, "HK_SHAPE_TRIANGLE_COLLECTION"},
		{25, "HK_SHAPE_HEIGHT_FIELD"},
		{26, "HK_SHAPE_SPHERE_REP"},
		{27, "HK_SHAPE_BV"},
		{28, "HK_SHAPE_PLANE"},
		{29, "HK_SHAPE_PHANTOM_CALLBACK"},
		{30, "HK_SHAPE_MULTI_RAY"},
		{31, "HK_SHAPE_USER0"},
		{32, "HK_SHAPE_USER1"},
		{33, "HK_SHAPE_USER2"},
		{34, "HK_SHAPE_MAX_ID"},
		{-1, "HK_SHAPE_ALL"},
	};
	static const hkInternalClassEnumItem ManifesthkpCollisionDispatcherAgentTypeEnumItems[] =
	{
		{0, "HK_AGENT_TYPE_NULL"},
		{1, "HK_AGENT_TYPE_BRIDGE"},
	};
	static const hkInternalClassEnumItem ManifestStreamCommandEnumItems[] =
	{
		{0, "STREAM_NULL"},
		{1, "STREAM_END"},
		{2, "STREAM_CALL"},
		{3, "STREAM_CALL_FLIPPED"},
		{4, "STREAM_CALL_WITH_TIM"},
		{5, "STREAM_CALL_WITH_TIM_FLIPPED"},
		{6, "STREAM_CALL_AGENT"},
		{8, "TRANSFORM_FLAG"},
		{10, "STREAM_CALL_WITH_TRANSFORM"},
		{11, "STREAM_CALL_FLIPPED_WITH_TRANSFORM"},
		{12, "STREAM_CALL_WITH_TIM_WITH_TRANSFORM"},
		{13, "STREAM_CALL_WITH_TIM_FLIPPED_WITH_TRANSFORM"},
		{14, "STREAM_CALL_AGENT_WITH_TRANSFORM"},
	};
	static const hkInternalClassEnumItem ManifestSymmetricEnumItems[] =
	{
		{0, "IS_SYMMETRIC"},
		{1, "IS_NOT_SYMMETRIC"},
		{2, "IS_NOT_SYMMETRIC_AND_FLIPPED"},
	};
	static const hkInternalClassEnumItem ManifesthkpAgentNnTrackTypeEnumItems[] =
	{
		{0, "HK_AGENT3_INVALID_TRACK"},
		{1, "HK_AGENT3_MIDPHASE_TRACK"},
		{2, "HK_AGENT3_NARROWPHASE_TRACK"},
	};
	static const hkInternalClassEnumItem ManifesthkpBufferSizeEnumItems[] =
	{
		{512, "HK_SHAPE_BUFFER_SIZE"},
	};
	static const hkInternalClassEnumItem ManifestResultEnumItems[] =
	{
		{0, "POSTPONED"},
		{1, "DONE"},
	};
	static const hkInternalClassEnumItem ManifesthkpPhantomTypeEnumItems[] =
	{
		{0, "HK_PHANTOM_AABB"},
		{1, "HK_PHANTOM_SIMPLE_SHAPE"},
		{2, "HK_PHANTOM_CACHING_SHAPE"},
		{3, "HK_PHANTOM_USER0"},
		{4, "HK_PHANTOM_USER1"},
		{5, "HK_PHANTOM_USER2"},
		{6, "HK_PHANTOM_USER3"},
		{7, "HK_PHANTOM_USER4"},
		{8, "HK_PHANTOM_USER5"},
		{9, "HK_PHANTOM_USER6"},
		{10, "HK_PHANTOM_USER7"},
		{11, "HK_PHANTOM_USER8"},
		{12, "HK_PHANTOM_USER9"},
		{13, "HK_PHANTOM_MAX_ID"},
	};
	static const hkInternalClassEnumItem ManifesthkpContactPointAcceptEnumItems[] =
	{
		{0, "HK_CONTACT_POINT_ACCEPT"},
		{1, "HK_CONTACT_POINT_REJECT"},
	};
	static const hkInternalClassEnumItem ManifesthkpCollidableAcceptEnumItems[] =
	{
		{0, "HK_COLLIDABLE_ACCEPT"},
		{1, "HK_COLLIDABLE_REJECT"},
	};
	static const hkInternalClassEnumItem ManifesthkpUpdateCollisionFilterOnWorldModeEnumItems[] =
	{
		{0, "HK_UPDATE_FILTER_ON_WORLD_FULL_CHECK"},
		{1, "HK_UPDATE_FILTER_ON_WORLD_DISABLE_ENTITY_ENTITY_COLLISIONS_ONLY"},
	};
	static const hkInternalClassEnumItem ManifesthkpUpdateCollisionFilterOnEntityModeEnumItems[] =
	{
		{0, "HK_UPDATE_FILTER_ON_ENTITY_FULL_CHECK"},
		{1, "HK_UPDATE_FILTER_ON_ENTITY_DISABLE_ENTITY_ENTITY_COLLISIONS_ONLY"},
	};
	static const hkInternalClassEnumItem ManifesthkpEntityActivationEnumItems[] =
	{
		{0, "HK_ENTITY_ACTIVATION_DO_NOT_ACTIVATE"},
		{1, "HK_ENTITY_ACTIVATION_DO_ACTIVATE"},
	};
	static const hkInternalClassEnumItem ManifesthkpUpdateCollectionFilterModeEnumItems[] =
	{
		{0, "HK_UPDATE_COLLECTION_FILTER_IGNORE_SHAPE_COLLECTIONS"},
		{1, "HK_UPDATE_COLLECTION_FILTER_PROCESS_SHAPE_COLLECTIONS"},
	};
	static const hkInternalClassEnumItem ManifesthkpStepResultEnumItems[] =
	{
		{0, "HK_STEP_RESULT_SUCCESS"},
		{1, "HK_STEP_RESULT_MEMORY_FAILURE_BEFORE_INTEGRATION"},
		{2, "HK_STEP_RESULT_MEMORY_FAILURE_DURING_COLLIDE"},
		{3, "HK_STEP_RESULT_MEMORY_FAILURE_DURING_TOI_SOLVE"},
	};
	static const hkInternalClassEnumItem ManifesthkpKnownWorldExtensionIdsEnumItems[] =
	{
		{-1, "HK_WORLD_EXTENSION_ANONYMOUS"},
		{1000, "HK_WORLD_EXTENSION_BREAK_OFF_PARTS"},
		{1001, "HK_WORLD_EXTENSION_COLLISION_CALLBACK"},
	};
	static const hkInternalClassEnumItem ManifestTypeEnumItems[] =
	{
		{0, "OPERATION_ID_ANY"},
		{0, "OPERATION_ID_INVALID"},
		{1, "ENTITY_ADD"},
		{2, "ENTITY_REMOVE"},
		{3, "ENTITY_UPDATE_BROAD_PHASE"},
		{4, "RIGIDBODY_SET_MOTION_TYPE"},
		{5, "WORLD_OBJECT_SET_SHAPE"},
		{6, "WORLD_OBJECT_UPDATE_SHAPE"},
		{7, "ENTITY_BATCH_ADD"},
		{8, "ENTITY_BATCH_REMOVE"},
		{9, "CONSTRAINT_ADD"},
		{10, "CONSTRAINT_REMOVE"},
		{11, "ACTION_ADD"},
		{12, "ACTION_REMOVE"},
		{13, "ISLAND_MERGE"},
		{14, "PHANTOM_ADD"},
		{15, "PHANTOM_REMOVE"},
		{16, "PHANTOM_BATCH_ADD"},
		{17, "PHANTOM_BATCH_REMOVE"},
		{18, "PHANTOM_UPDATE_BROAD_PHASE"},
		{19, "UPDATE_FILTER_ENTITY"},
		{20, "UPDATE_FILTER_ENTITY_PAIR"},
		{21, "UPDATE_FILTER_PHANTOM"},
		{22, "UPDATE_FILTER_WORLD"},
		{23, "UPDATE_MOVED_BODY_INFO"},
		{24, "ENTITY_BATCH_REINTEGRATE_AND_RECOLLIDE"},
		{25, "RIGIDBODY_SET_POSITION_AND_ROTATION"},
		{26, "RIGIDBODY_SET_LINEAR_VELOCITY"},
		{27, "RIGIDBODY_SET_ANGULAR_VELOCITY"},
		{28, "RIGIDBODY_APPLY_LINEAR_IMPULSE"},
		{29, "RIGIDBODY_APPLY_POINT_IMPULSE"},
		{30, "RIGIDBODY_APPLY_ANGULAR_IMPULSE"},
		{31, "WORLD_OBJECT_ADD_REFERENCE"},
		{32, "WORLD_OBJECT_REMOVE_REFERENCE"},
		{33, "ACTIVATE_REGION"},
		{34, "ACTIVATE_ENTITY"},
		{35, "REQUEST_DEACTIVATE_ENTITY"},
		{36, "DEACTIVATE_ENTITY"},
		{37, "CONSTRAINT_FILTER_BROKEN_EVENT"},
		{38, "USER_CALLBACK"},
	};
	static const hkInternalClassEnumItem ManifesthkpGskStatusEnumItems[] =
	{
		{0, "HK_GSK_OK"},
		{1, "HK_GSK_PD_HEURISTIC_SAMPLING"},
		{2, "HK_GSK_PD_OUT_OF_MEMORY"},
		{3, "HK_GSK_PD_UNSOLVABLE"},
		{4, "HK_GSK_PENETRATING"},
	};
	static const hkInternalClassEnumItem ManifestHK_MOPP_SPLIT_DIRECTIONSEnumItems[] =
	{
		{0, "HK_MOPP_SD_X"},
		{1, "HK_MOPP_SD_Y"},
		{2, "HK_MOPP_SD_Z"},
		{3, "HK_MOPP_SD_YZ"},
		{4, "HK_MOPP_SD_YMZ"},
		{5, "HK_MOPP_SD_XZ"},
		{6, "HK_MOPP_SD_XMZ"},
		{7, "HK_MOPP_SD_XY"},
		{8, "HK_MOPP_SD_XMY"},
		{9, "HK_MOPP_SD_XYZ"},
		{10, "HK_MOPP_SD_XYMZ"},
		{11, "HK_MOPP_SD_XMYZ"},
		{12, "HK_MOPP_SD_XMYMZ"},
		{13, "HK_MOPP_SD_MAX"},
	};
	static const hkInternalClassEnumItem ManifesthkpMoppCommandsEnumItems[] =
	{
		{0, "HK_MOPP_RETURN"},
		{1, "HK_MOPP_SCALE1"},
		{2, "HK_MOPP_SCALE2"},
		{3, "HK_MOPP_SCALE3"},
		{4, "HK_MOPP_SCALE4"},
		{5, "HK_MOPP_JUMP8"},
		{6, "HK_MOPP_JUMP16"},
		{7, "HK_MOPP_JUMP24"},
		{8, "HK_MOPP_JUMP32"},
		{9, "HK_MOPP_TERM_REOFFSET8"},
		{10, "HK_MOPP_TERM_REOFFSET16"},
		{11, "HK_MOPP_TERM_REOFFSET32"},
		{12, "HK_MOPP_JUMP_CHUNK"},
		{13, "HK_MOPP_DATA_OFFSET"},
		{16, "HK_MOPP_SPLIT_X"},
		{17, "HK_MOPP_SPLIT_Y"},
		{18, "HK_MOPP_SPLIT_Z"},
		{19, "HK_MOPP_SPLIT_YZ"},
		{20, "HK_MOPP_SPLIT_YMZ"},
		{21, "HK_MOPP_SPLIT_XZ"},
		{22, "HK_MOPP_SPLIT_XMZ"},
		{23, "HK_MOPP_SPLIT_XY"},
		{24, "HK_MOPP_SPLIT_XMY"},
		{25, "HK_MOPP_SPLIT_XYZ"},
		{26, "HK_MOPP_SPLIT_XYMZ"},
		{27, "HK_MOPP_SPLIT_XMYZ"},
		{28, "HK_MOPP_SPLIT_XMYMZ"},
		{32, "HK_MOPP_SINGLE_SPLIT_X"},
		{33, "HK_MOPP_SINGLE_SPLIT_Y"},
		{34, "HK_MOPP_SINGLE_SPLIT_Z"},
		{35, "HK_MOPP_SPLIT_JUMP_X"},
		{36, "HK_MOPP_SPLIT_JUMP_Y"},
		{37, "HK_MOPP_SPLIT_JUMP_Z"},
		{38, "HK_MOPP_DOUBLE_CUT_X"},
		{39, "HK_MOPP_DOUBLE_CUT_Y"},
		{40, "HK_MOPP_DOUBLE_CUT_Z"},
		{41, "HK_MOPP_DOUBLE_CUT24_X"},
		{42, "HK_MOPP_DOUBLE_CUT24_Y"},
		{43, "HK_MOPP_DOUBLE_CUT24_Z"},
		{48, "HK_MOPP_TERM4_0"},
		{49, "HK_MOPP_TERM4_1"},
		{50, "HK_MOPP_TERM4_2"},
		{51, "HK_MOPP_TERM4_3"},
		{52, "HK_MOPP_TERM4_4"},
		{53, "HK_MOPP_TERM4_5"},
		{54, "HK_MOPP_TERM4_6"},
		{55, "HK_MOPP_TERM4_7"},
		{56, "HK_MOPP_TERM4_8"},
		{57, "HK_MOPP_TERM4_9"},
		{58, "HK_MOPP_TERM4_A"},
		{59, "HK_MOPP_TERM4_B"},
		{60, "HK_MOPP_TERM4_C"},
		{61, "HK_MOPP_TERM4_D"},
		{62, "HK_MOPP_TERM4_E"},
		{63, "HK_MOPP_TERM4_F"},
		{64, "HK_MOPP_TERM4_10"},
		{65, "HK_MOPP_TERM4_11"},
		{66, "HK_MOPP_TERM4_12"},
		{67, "HK_MOPP_TERM4_13"},
		{68, "HK_MOPP_TERM4_14"},
		{69, "HK_MOPP_TERM4_15"},
		{70, "HK_MOPP_TERM4_16"},
		{71, "HK_MOPP_TERM4_17"},
		{72, "HK_MOPP_TERM4_18"},
		{73, "HK_MOPP_TERM4_19"},
		{74, "HK_MOPP_TERM4_1A"},
		{75, "HK_MOPP_TERM4_1B"},
		{76, "HK_MOPP_TERM4_1C"},
		{77, "HK_MOPP_TERM4_1D"},
		{78, "HK_MOPP_TERM4_1E"},
		{79, "HK_MOPP_TERM4_1F"},
		{80, "HK_MOPP_TERM8"},
		{81, "HK_MOPP_TERM16"},
		{82, "HK_MOPP_TERM24"},
		{83, "HK_MOPP_TERM32"},
		{84, "HK_MOPP_NTERM8"},
		{85, "HK_MOPP_NTERM16"},
		{86, "HK_MOPP_NTERM24"},
		{87, "HK_MOPP_NTERM32"},
		{96, "HK_MOPP_PROPERTY8_0"},
		{97, "HK_MOPP_PROPERTY8_1"},
		{98, "HK_MOPP_PROPERTY8_2"},
		{99, "HK_MOPP_PROPERTY8_3"},
		{100, "HK_MOPP_PROPERTY16_0"},
		{101, "HK_MOPP_PROPERTY16_1"},
		{102, "HK_MOPP_PROPERTY16_2"},
		{103, "HK_MOPP_PROPERTY16_3"},
		{104, "HK_MOPP_PROPERTY32_0"},
		{105, "HK_MOPP_PROPERTY32_1"},
		{106, "HK_MOPP_PROPERTY32_2"},
		{107, "HK_MOPP_PROPERTY32_3"},
		{112, "HK_MOPP_JUMP_CHUNK32"},
	};
	static const hkInternalClassEnumItem ManifesthkpGskManifoldAddStatusEnumItems[] =
	{
		{0, "HK_GSK_MANIFOLD_POINT_REPLACED0"},
		{1, "HK_GSK_MANIFOLD_POINT_REPLACED1"},
		{2, "HK_GSK_MANIFOLD_POINT_REPLACED2"},
		{3, "HK_GSK_MANIFOLD_POINT_REPLACED3"},
		{4, "HK_GSK_MANIFOLD_POINT_ADDED"},
		{5, "HK_GSK_MANIFOLD_POINT_REJECTED"},
		{6, "HK_GSK_MANIFOLD_TWO_POINT2_REJECTED"},
	};
	static const hkInternalClassEnumItem ManifesthkpGskManifoldUtilMgrHandlingEnumItems[] =
	{
		{0, "HK_GSK_MANIFOLD_CREATE_ID_ALWAYS"},
		{1, "HK_GSK_MANIFOLD_NO_ID_FOR_POTENTIALS"},
	};
	static const hkInternalClassEnumItem ManifesthkpGskManifoldPointExistsFlagsEnumItems[] =
	{
		{0, "HK_GSK_MANIFOLD_POINT_NOT_IN_MANIFOLD"},
		{1, "HK_GSK_MANIFOLD_POINT_IN_MANIFOLD"},
		{2, "HK_GSK_MANIFOLD_FEATURE_WITHIN_KEEP_DISTANCE_REMOVED"},
	};
	static const hkInternalClassEnumItem ManifesthkpMoppMeshTypeEnumItems[] =
	{
		{0, "HK_MOPP_MT_LANDSCAPE"},
		{1, "HK_MOPP_MT_INDOOR"},
	};
	static const hkInternalClassEnumItem ManifesthkpToiResourceMgrResponseEnumItems[] =
	{
		{0, "HK_TOI_RESOURCE_MGR_RESPONSE_CONTINUE"},
		{1, "HK_TOI_RESOURCE_MGR_RESPONSE_DO_NOT_EXPAND_AND_CONTINUE"},
		{2, "HK_TOI_RESOURCE_MGR_RESPONSE_BACKSTEP"},
	};
	static const hkInternalClassEnumItem ManifesthkpCharacterStateTypeEnumItems[] =
	{
		{0, "HK_CHARACTER_ON_GROUND"},
		{1, "HK_CHARACTER_JUMPING"},
		{2, "HK_CHARACTER_IN_AIR"},
		{3, "HK_CHARACTER_CLIMBING"},
		{4, "HK_CHARACTER_FLYING"},
		{5, "HK_CHARACTER_USER_STATE_0"},
		{6, "HK_CHARACTER_USER_STATE_1"},
		{7, "HK_CHARACTER_USER_STATE_2"},
		{8, "HK_CHARACTER_USER_STATE_3"},
		{9, "HK_CHARACTER_USER_STATE_4"},
		{10, "HK_CHARACTER_USER_STATE_5"},
		{11, "HK_CHARACTER_MAX_STATE_ID"},
	};
	static const hkInternalClassEnum ManifestEnums[] = {
		{"hkaiIndices", ManifesthkaiIndicesEnumItems, 8, HK_NULL, 0 },
		{"hkaDmaGroupsEnum", ManifesthkaDmaGroupsEnumEnumItems, 7, HK_NULL, 0 },
		{"BLEND_MODE", ManifestBLEND_MODEEnumItems, 3, HK_NULL, 0 },
		{"ROTATION_MODE", ManifestROTATION_MODEEnumItems, 2, HK_NULL, 0 },
		{"hkbNodeType", ManifesthkbNodeTypeEnumItems, 56, HK_NULL, 0 },
		{"hclTransformSetType", ManifesthclTransformSetTypeEnumItems, 4, HK_NULL, 0 },
		{"hclShapeType", ManifesthclShapeTypeEnumItems, 11, HK_NULL, 0 },
		{"hclActionSpuDispatchId", ManifesthclActionSpuDispatchIdEnumItems, 3, HK_NULL, 0 },
		{"hclConstraintSetType", ManifesthclConstraintSetTypeEnumItems, 23, HK_NULL, 0 },
		{"hclOperatorType", ManifesthclOperatorTypeEnumItems, 39, HK_NULL, 0 },
		{"hclBufferType", ManifesthclBufferTypeEnumItems, 11, HK_NULL, 0 },
		{"Result_", ManifestResult_EnumItems, 3, HK_NULL, 0 },
		{"hkResult", ManifesthkResultEnumItems, 2, HK_NULL, 0 },
		{"hkBool32FalseType", ManifesthkBool32FalseTypeEnumItems, 1, HK_NULL, 0 },
		{"hkJobType", ManifesthkJobTypeEnumItems, 24, HK_NULL, 0 },
		{"hkJobSpuType", ManifesthkJobSpuTypeEnumItems, 3, HK_NULL, 0 },
		{"hkVectorConstant", ManifesthkVectorConstantEnumItems, 42, HK_NULL, 0 },
		{"hkIntVectorConstant", ManifesthkIntVectorConstantEnumItems, 11, HK_NULL, 0 },
		{"hkMathAccuracyMode", ManifesthkMathAccuracyModeEnumItems, 3, HK_NULL, 0 },
		{"hkMathDivByZeroMode", ManifesthkMathDivByZeroModeEnumItems, 5, HK_NULL, 0 },
		{"hkMathNegSqrtMode", ManifesthkMathNegSqrtModeEnumItems, 2, HK_NULL, 0 },
		{"hkMathIoMode", ManifesthkMathIoModeEnumItems, 4, HK_NULL, 0 },
		{"hkMathRoundingMode", ManifesthkMathRoundingModeEnumItems, 2, HK_NULL, 0 },
		{"hkGeomConvexHullMode", ManifesthkGeomConvexHullModeEnumItems, 4, HK_NULL, 0 },
		{"hkGeomObbMode", ManifesthkGeomObbModeEnumItems, 4, HK_NULL, 0 },
		{"hkSplitPrimitivesStatus", ManifesthkSplitPrimitivesStatusEnumItems, 2, HK_NULL, 0 },
		{"Splitting", ManifestSplittingEnumItems, 2, HK_NULL, 0 },
		{"neighbourDirection", ManifestneighbourDirectionEnumItems, 3, HK_NULL, 0 },
		{"Flags", ManifestFlagsEnumItems, 3, HK_NULL, 0 },
		{"SaveOptionBits", ManifestSaveOptionBitsEnumItems, 6, HK_NULL, 0 },
		{"LoadOptionBits", ManifestLoadOptionBitsEnumItems, 2, HK_NULL, 0 },
		{"FormatType", ManifestFormatTypeEnumItems, 6, HK_NULL, 0 },
		{"TagType", ManifestTagTypeEnumItems, 8, HK_NULL, 0 },
		{"Version", ManifestVersionEnumItems, 1, HK_NULL, 0 },
		{"Commands", ManifestCommandsEnumItems, 7, HK_NULL, 0 },
		{"FramebufferCommands", ManifestFramebufferCommandsEnumItems, 3, HK_NULL, 0 },
		{"FramebufferFormat", ManifestFramebufferFormatEnumItems, 3, HK_NULL, 0 },
		{"hkDisplayGeometryType", ManifesthkDisplayGeometryTypeEnumItems, 12, HK_NULL, 0 },
		{"ServerToClientCommands", ManifestServerToClientCommandsEnumItems, 41, HK_NULL, 0 },
		{"BidirectionalCommands", ManifestBidirectionalCommandsEnumItems, 6, HK_NULL, 0 },
		{"ClientToServerCommands", ManifestClientToServerCommandsEnumItems, 10, HK_NULL, 0 },
		{"hkKeyboardCommand", ManifesthkKeyboardCommandEnumItems, 1, HK_NULL, 0 },
		{"hkpCollidableQualityType", ManifesthkpCollidableQualityTypeEnumItems, 12, HK_NULL, 0 },
		{"hkpShapeType", ManifesthkpShapeTypeEnumItems, 37, HK_NULL, 0 },
		{"hkpCollisionDispatcherAgentType", ManifesthkpCollisionDispatcherAgentTypeEnumItems, 2, HK_NULL, 0 },
		{"StreamCommand", ManifestStreamCommandEnumItems, 13, HK_NULL, 0 },
		{"Symmetric", ManifestSymmetricEnumItems, 3, HK_NULL, 0 },
		{"hkpAgentNnTrackType", ManifesthkpAgentNnTrackTypeEnumItems, 3, HK_NULL, 0 },
		{"hkpBufferSize", ManifesthkpBufferSizeEnumItems, 1, HK_NULL, 0 },
		{"Result", ManifestResultEnumItems, 2, HK_NULL, 0 },
		{"hkpPhantomType", ManifesthkpPhantomTypeEnumItems, 14, HK_NULL, 0 },
		{"hkpContactPointAccept", ManifesthkpContactPointAcceptEnumItems, 2, HK_NULL, 0 },
		{"hkpCollidableAccept", ManifesthkpCollidableAcceptEnumItems, 2, HK_NULL, 0 },
		{"hkpUpdateCollisionFilterOnWorldMode", ManifesthkpUpdateCollisionFilterOnWorldModeEnumItems, 2, HK_NULL, 0 },
		{"hkpUpdateCollisionFilterOnEntityMode", ManifesthkpUpdateCollisionFilterOnEntityModeEnumItems, 2, HK_NULL, 0 },
		{"hkpEntityActivation", ManifesthkpEntityActivationEnumItems, 2, HK_NULL, 0 },
		{"hkpUpdateCollectionFilterMode", ManifesthkpUpdateCollectionFilterModeEnumItems, 2, HK_NULL, 0 },
		{"hkpStepResult", ManifesthkpStepResultEnumItems, 4, HK_NULL, 0 },
		{"hkpKnownWorldExtensionIds", ManifesthkpKnownWorldExtensionIdsEnumItems, 3, HK_NULL, 0 },
		{"Type", ManifestTypeEnumItems, 40, HK_NULL, 0 },
		{"hkpGskStatus", ManifesthkpGskStatusEnumItems, 5, HK_NULL, 0 },
		{"HK_MOPP_SPLIT_DIRECTIONS", ManifestHK_MOPP_SPLIT_DIRECTIONSEnumItems, 14, HK_NULL, 0 },
		{"hkpMoppCommands", ManifesthkpMoppCommandsEnumItems, 92, HK_NULL, 0 },
		{"hkpGskManifoldAddStatus", ManifesthkpGskManifoldAddStatusEnumItems, 7, HK_NULL, 0 },
		{"hkpGskManifoldUtilMgrHandling", ManifesthkpGskManifoldUtilMgrHandlingEnumItems, 2, HK_NULL, 0 },
		{"hkpGskManifoldPointExistsFlags", ManifesthkpGskManifoldPointExistsFlagsEnumItems, 3, HK_NULL, 0 },
		{"hkpMoppMeshType", ManifesthkpMoppMeshTypeEnumItems, 2, HK_NULL, 0 },
		{"hkpToiResourceMgrResponse", ManifesthkpToiResourceMgrResponseEnumItems, 3, HK_NULL, 0 },
		{"hkpCharacterStateType", ManifesthkpCharacterStateTypeEnumItems, 12, HK_NULL, 0 }
	};
	const hkClassEnum* hkaiIndicesEnum = reinterpret_cast<const hkClassEnum*>(&ManifestEnums[0]);
	const hkClassEnum* hkaDmaGroupsEnumEnum = reinterpret_cast<const hkClassEnum*>(&ManifestEnums[1]);
	const hkClassEnum* BLEND_MODEEnum = reinterpret_cast<const hkClassEnum*>(&ManifestEnums[2]);
	const hkClassEnum* ROTATION_MODEEnum = reinterpret_cast<const hkClassEnum*>(&ManifestEnums[3]);
	const hkClassEnum* hkbNodeTypeEnum = reinterpret_cast<const hkClassEnum*>(&ManifestEnums[4]);
	const hkClassEnum* hclTransformSetTypeEnum = reinterpret_cast<const hkClassEnum*>(&ManifestEnums[5]);
	const hkClassEnum* hclShapeTypeEnum = reinterpret_cast<const hkClassEnum*>(&ManifestEnums[6]);
	const hkClassEnum* hclActionSpuDispatchIdEnum = reinterpret_cast<const hkClassEnum*>(&ManifestEnums[7]);
	const hkClassEnum* hclConstraintSetTypeEnum = reinterpret_cast<const hkClassEnum*>(&ManifestEnums[8]);
	const hkClassEnum* hclOperatorTypeEnum = reinterpret_cast<const hkClassEnum*>(&ManifestEnums[9]);
	const hkClassEnum* hclBufferTypeEnum = reinterpret_cast<const hkClassEnum*>(&ManifestEnums[10]);
	const hkClassEnum* Result_Enum = reinterpret_cast<const hkClassEnum*>(&ManifestEnums[11]);
	const hkClassEnum* hkResultEnum = reinterpret_cast<const hkClassEnum*>(&ManifestEnums[12]);
	const hkClassEnum* hkBool32FalseTypeEnum = reinterpret_cast<const hkClassEnum*>(&ManifestEnums[13]);
	const hkClassEnum* hkJobTypeEnum = reinterpret_cast<const hkClassEnum*>(&ManifestEnums[14]);
	const hkClassEnum* hkJobSpuTypeEnum = reinterpret_cast<const hkClassEnum*>(&ManifestEnums[15]);
	const hkClassEnum* hkVectorConstantEnum = reinterpret_cast<const hkClassEnum*>(&ManifestEnums[16]);
	const hkClassEnum* hkIntVectorConstantEnum = reinterpret_cast<const hkClassEnum*>(&ManifestEnums[17]);
	const hkClassEnum* hkMathAccuracyModeEnum = reinterpret_cast<const hkClassEnum*>(&ManifestEnums[18]);
	const hkClassEnum* hkMathDivByZeroModeEnum = reinterpret_cast<const hkClassEnum*>(&ManifestEnums[19]);
	const hkClassEnum* hkMathNegSqrtModeEnum = reinterpret_cast<const hkClassEnum*>(&ManifestEnums[20]);
	const hkClassEnum* hkMathIoModeEnum = reinterpret_cast<const hkClassEnum*>(&ManifestEnums[21]);
	const hkClassEnum* hkMathRoundingModeEnum = reinterpret_cast<const hkClassEnum*>(&ManifestEnums[22]);
	const hkClassEnum* hkGeomConvexHullModeEnum = reinterpret_cast<const hkClassEnum*>(&ManifestEnums[23]);
	const hkClassEnum* hkGeomObbModeEnum = reinterpret_cast<const hkClassEnum*>(&ManifestEnums[24]);
	const hkClassEnum* hkSplitPrimitivesStatusEnum = reinterpret_cast<const hkClassEnum*>(&ManifestEnums[25]);
	const hkClassEnum* SplittingEnum = reinterpret_cast<const hkClassEnum*>(&ManifestEnums[26]);
	const hkClassEnum* neighbourDirectionEnum = reinterpret_cast<const hkClassEnum*>(&ManifestEnums[27]);
	const hkClassEnum* FlagsEnum = reinterpret_cast<const hkClassEnum*>(&ManifestEnums[28]);
	const hkClassEnum* SaveOptionBitsEnum = reinterpret_cast<const hkClassEnum*>(&ManifestEnums[29]);
	const hkClassEnum* LoadOptionBitsEnum = reinterpret_cast<const hkClassEnum*>(&ManifestEnums[30]);
	const hkClassEnum* FormatTypeEnum = reinterpret_cast<const hkClassEnum*>(&ManifestEnums[31]);
	const hkClassEnum* TagTypeEnum = reinterpret_cast<const hkClassEnum*>(&ManifestEnums[32]);
	const hkClassEnum* VersionEnum = reinterpret_cast<const hkClassEnum*>(&ManifestEnums[33]);
	const hkClassEnum* CommandsEnum = reinterpret_cast<const hkClassEnum*>(&ManifestEnums[34]);
	const hkClassEnum* FramebufferCommandsEnum = reinterpret_cast<const hkClassEnum*>(&ManifestEnums[35]);
	const hkClassEnum* FramebufferFormatEnum = reinterpret_cast<const hkClassEnum*>(&ManifestEnums[36]);
	const hkClassEnum* hkDisplayGeometryTypeEnum = reinterpret_cast<const hkClassEnum*>(&ManifestEnums[37]);
	const hkClassEnum* ServerToClientCommandsEnum = reinterpret_cast<const hkClassEnum*>(&ManifestEnums[38]);
	const hkClassEnum* BidirectionalCommandsEnum = reinterpret_cast<const hkClassEnum*>(&ManifestEnums[39]);
	const hkClassEnum* ClientToServerCommandsEnum = reinterpret_cast<const hkClassEnum*>(&ManifestEnums[40]);
	const hkClassEnum* hkKeyboardCommandEnum = reinterpret_cast<const hkClassEnum*>(&ManifestEnums[41]);
	const hkClassEnum* hkpCollidableQualityTypeEnum = reinterpret_cast<const hkClassEnum*>(&ManifestEnums[42]);
	const hkClassEnum* hkpShapeTypeEnum = reinterpret_cast<const hkClassEnum*>(&ManifestEnums[43]);
	const hkClassEnum* hkpCollisionDispatcherAgentTypeEnum = reinterpret_cast<const hkClassEnum*>(&ManifestEnums[44]);
	const hkClassEnum* StreamCommandEnum = reinterpret_cast<const hkClassEnum*>(&ManifestEnums[45]);
	const hkClassEnum* SymmetricEnum = reinterpret_cast<const hkClassEnum*>(&ManifestEnums[46]);
	const hkClassEnum* hkpAgentNnTrackTypeEnum = reinterpret_cast<const hkClassEnum*>(&ManifestEnums[47]);
	const hkClassEnum* hkpBufferSizeEnum = reinterpret_cast<const hkClassEnum*>(&ManifestEnums[48]);
	const hkClassEnum* ResultEnum = reinterpret_cast<const hkClassEnum*>(&ManifestEnums[49]);
	const hkClassEnum* hkpPhantomTypeEnum = reinterpret_cast<const hkClassEnum*>(&ManifestEnums[50]);
	const hkClassEnum* hkpContactPointAcceptEnum = reinterpret_cast<const hkClassEnum*>(&ManifestEnums[51]);
	const hkClassEnum* hkpCollidableAcceptEnum = reinterpret_cast<const hkClassEnum*>(&ManifestEnums[52]);
	const hkClassEnum* hkpUpdateCollisionFilterOnWorldModeEnum = reinterpret_cast<const hkClassEnum*>(&ManifestEnums[53]);
	const hkClassEnum* hkpUpdateCollisionFilterOnEntityModeEnum = reinterpret_cast<const hkClassEnum*>(&ManifestEnums[54]);
	const hkClassEnum* hkpEntityActivationEnum = reinterpret_cast<const hkClassEnum*>(&ManifestEnums[55]);
	const hkClassEnum* hkpUpdateCollectionFilterModeEnum = reinterpret_cast<const hkClassEnum*>(&ManifestEnums[56]);
	const hkClassEnum* hkpStepResultEnum = reinterpret_cast<const hkClassEnum*>(&ManifestEnums[57]);
	const hkClassEnum* hkpKnownWorldExtensionIdsEnum = reinterpret_cast<const hkClassEnum*>(&ManifestEnums[58]);
	const hkClassEnum* TypeEnum = reinterpret_cast<const hkClassEnum*>(&ManifestEnums[59]);
	const hkClassEnum* hkpGskStatusEnum = reinterpret_cast<const hkClassEnum*>(&ManifestEnums[60]);
	const hkClassEnum* HK_MOPP_SPLIT_DIRECTIONSEnum = reinterpret_cast<const hkClassEnum*>(&ManifestEnums[61]);
	const hkClassEnum* hkpMoppCommandsEnum = reinterpret_cast<const hkClassEnum*>(&ManifestEnums[62]);
	const hkClassEnum* hkpGskManifoldAddStatusEnum = reinterpret_cast<const hkClassEnum*>(&ManifestEnums[63]);
	const hkClassEnum* hkpGskManifoldUtilMgrHandlingEnum = reinterpret_cast<const hkClassEnum*>(&ManifestEnums[64]);
	const hkClassEnum* hkpGskManifoldPointExistsFlagsEnum = reinterpret_cast<const hkClassEnum*>(&ManifestEnums[65]);
	const hkClassEnum* hkpMoppMeshTypeEnum = reinterpret_cast<const hkClassEnum*>(&ManifestEnums[66]);
	const hkClassEnum* hkpToiResourceMgrResponseEnum = reinterpret_cast<const hkClassEnum*>(&ManifestEnums[67]);
	const hkClassEnum* hkpCharacterStateTypeEnum = reinterpret_cast<const hkClassEnum*>(&ManifestEnums[68]);
	extern const hkClassEnum* hclBoneSpaceMeshMeshDeformOperatorScaleNormalBehaviourEnum;
	extern const hkClassEnum* hclBufferLayoutSlotFlagsEnum;
	extern const hkClassEnum* hclBufferLayoutTriangleFormatEnum;
	extern const hkClassEnum* hclClothDataPlatformEnum;
	extern const hkClassEnum* hclEdgeSelectionInputEdgeSelectionTypeEnum;
	extern const hkClassEnum* hclMeshMeshDeformOperatorScaleNormalBehaviourEnum;
	extern const hkClassEnum* hclObjectSpaceMeshMeshDeformOperatorScaleNormalBehaviourEnum;
	extern const hkClassEnum* hclRuntimeConversionInfoVectorConversionEnum;
	extern const hkClassEnum* hclSetupMeshEdgeChannelTypeEnum;
	extern const hkClassEnum* hclSetupMeshTriangleChannelTypeEnum;
	extern const hkClassEnum* hclSetupMeshVertexChannelTypeEnum;
	extern const hkClassEnum* hclSimClothBufferSetupObjectTypeEnum;
	extern const hkClassEnum* hclTriangleSelectionInputTriangleSelectionTypeEnum;
	extern const hkClassEnum* hclVertexFloatInputVertexFloatTypeEnum;
	extern const hkClassEnum* hclVertexGatherSetupObjectDirectionEnum;
	extern const hkClassEnum* hclVertexSelectionInputVertexSelectionTypeEnum;
	extern const hkClassEnum* hkArrayTypeAttributeArrayTypeEnum;
	extern const hkClassEnum* hkCheckingMemorySystemAllocatorBitsEnum;
	extern const hkClassEnum* hkCheckingMemorySystemCheckBitsEnum;
	extern const hkClassEnum* hkClassEnumFlagValuesEnum;
	extern const hkClassEnum* hkClassFlagValuesEnum;
	extern const hkClassEnum* hkClassMemberFlagValuesEnum;
	extern const hkClassEnum* hkClassMemberTypeEnum;
	extern const hkClassEnum* hkColorExtendedColorsEnum;
	extern const hkClassEnum* hkCommandPrimaryTypeEnum;
	extern const hkClassEnum* hkGizmoAttributeGizmoTypeEnum;
	extern const hkClassEnum* hkKdTreeCinfoEmptyNodeAllocationEnum;
	extern const hkClassEnum* hkLinkAttributeLinkEnum;
	extern const hkClassEnum* hkMeshSectionMeshSectionIndexTypeEnum;
	extern const hkClassEnum* hkMeshSectionPrimitiveTypeEnum;
	extern const hkClassEnum* hkMeshTextureFilterModeEnum;
	extern const hkClassEnum* hkMeshTextureFormatEnum;
	extern const hkClassEnum* hkMeshTextureTextureUsageTypeEnum;
	extern const hkClassEnum* hkModelerNodeTypeAttributeModelerTypeEnum;
	extern const hkClassEnum* hkMonitorStreamAnalyzerNodeNodeTypeEnum;
	extern const hkClassEnum* hkMonitorStreamFrameInfoAbsoluteTimeCounterEnum;
	extern const hkClassEnum* hkObjectCopierObjectCopierFlagBitsEnum;
	extern const hkClassEnum* hkOptimizerMemorySystemDetectBitsEnum;
	extern const hkClassEnum* hkQemMeshSimplifierSimplificationStatusEnum;
	extern const hkClassEnum* hkQemVertexPairPairTypeEnum;
	extern const hkClassEnum* hkSemanticsAttributeSemanticsEnum;
	extern const hkClassEnum* hkSerializeUtilErrorDetailsErrorIDEnum;
	extern const hkClassEnum* hkSerializeUtilFormatTypeEnum;
	extern const hkClassEnum* hkUiAttributeHideInModelerEnum;
	extern const hkClassEnum* hkVertexFormatComponentTypeEnum;
	extern const hkClassEnum* hkVertexFormatComponentUsageEnum;
	extern const hkClassEnum* hkVertexFormatHintFlagsEnum;
	extern const hkClassEnum* hkVirtualGamepadButtonEnum;
	extern const hkClassEnum* hkVirtualMouseButtonEnum;
	extern const hkClassEnum* hkWorldOperationTypeEnum;
	extern const hkClassEnum* hkaAnimationAnimationTypeEnum;
	extern const hkClassEnum* hkaAnimationBindingBlendHintEnum;
	extern const hkClassEnum* hkaSampleBlendJobSingleAnimationSampleFlagsEnum;
	extern const hkClassEnum* hkaSkeletonMapperDataMappingTypeEnum;
	extern const hkClassEnum* hkaSkeletonMapperUtilsExtractedMotionParamsExtractedMotionModeEnum;
	extern const hkClassEnum* hkaSplineCompressedAnimationTrackCompressionParamsRotationQuantizationEnum;
	extern const hkClassEnum* hkaSplineCompressedAnimationTrackCompressionParamsScalarQuantizationEnum;
	extern const hkClassEnum* hkaiAstarOutputParametersSearchStatusEnum;
	extern const hkClassEnum* hkaiCharacterAvoidanceEnabledMaskBitsEnum;
	extern const hkClassEnum* hkaiCharacterMovementStateEnum;
	extern const hkClassEnum* hkaiCharacterStateEnum;
	extern const hkClassEnum* hkaiDeprecatedSearchStateNodeFlagValuesEnum;
	extern const hkClassEnum* hkaiDirectedGraphExplicitCostEdgeBitsEnum;
	extern const hkClassEnum* hkaiNavMeshCostModifierCostModifierTypeEnum;
	extern const hkClassEnum* hkaiNavMeshCostModifierQueryTypeEnum;
	extern const hkClassEnum* hkaiNavMeshCutterClearanceResetMethodEnum;
	extern const hkClassEnum* hkaiNavMeshEdgeFlagBitsEnum;
	extern const hkClassEnum* hkaiNavMeshGenerationSettingsCharacterWidthUsageEnum;
	extern const hkClassEnum* hkaiNavMeshGenerationSettingsConstructionFlagsBitsEnum;
	extern const hkClassEnum* hkaiNavMeshGenerationSettingsEdgeMatchingMetricEnum;
	extern const hkClassEnum* hkaiNavMeshPathSearchParametersOutputPathTypeEnum;
	extern const hkClassEnum* hkaiNavMeshPathSearchParametersUserEdgeTraversalTestTypeEnum;
	extern const hkClassEnum* hkaiNavVolumeCellEdgeFlagBitsEnum;
	extern const hkClassEnum* hkaiNavVolumeCostModifierCostModifierTypeEnum;
	extern const hkClassEnum* hkaiNavVolumeCostModifierQueryTypeEnum;
	extern const hkClassEnum* hkaiNavVolumeGenerationSettingsMaterialFlagsBitsEnum;
	extern const hkClassEnum* hkaiPathPathPointBitsEnum;
	extern const hkClassEnum* hkaiPathReferenceFrameEnum;
	extern const hkClassEnum* hkaiRigidBodySilhouetteGeneratorDetailLevelEnum;
	extern const hkClassEnum* hkaiSearchStateNodeFlagValuesEnum;
	extern const hkClassEnum* hkaiSilhouetteGeneratorGeneratorTypeEnum;
	extern const hkClassEnum* hkaiSilhouetteMergerMergeTypeEnum;
	extern const hkClassEnum* hkaiSplitGenerationUtilsSplitAndGenerateOptionsEnum;
	extern const hkClassEnum* hkaiStringPullingSideEnum;
	extern const hkClassEnum* hkaiStringPullingTypeEnum;
	extern const hkClassEnum* hkaiUserEdgeUtilsUserEdgeDirectionEnum;
	extern const hkClassEnum* hkaiVisibilityUtilInitialIntersectionBehaviorEnum;
	extern const hkClassEnum* hkaiWorldCharacterStepCallbackContextCharacterCallbackTypeEnum;
	extern const hkClassEnum* hkbAlignBoneModifierAlignModeABAMEnum;
	extern const hkClassEnum* hkbAlignBoneModifierAlignTargetModeEnum;
	extern const hkClassEnum* hkbAttachmentSetupAttachmentTypeEnum;
	extern const hkClassEnum* hkbBehaviorGraphVariableModeEnum;
	extern const hkClassEnum* hkbBlendCurveUtilsBlendCurveEnum;
	extern const hkClassEnum* hkbBlendingTransitionEffectEndModeEnum;
	extern const hkClassEnum* hkbBlendingTransitionEffectFlagBitsEnum;
	extern const hkClassEnum* hkbCatchFallModifierFadeStateEnum;
	extern const hkClassEnum* hkbCharacterControlCommandCharacterControlCommandEnum;
	extern const hkClassEnum* hkbCharacterControllerModifierInitialVelocityCoordinatesEnum;
	extern const hkClassEnum* hkbCharacterControllerModifierMotionModeEnum;
	extern const hkClassEnum* hkbCharacterInfoEventEnum;
	extern const hkClassEnum* hkbClipGeneratorPlaybackModeEnum;
	extern const hkClassEnum* hkbCompiledExpressionSetTokenOperatorEnum;
	extern const hkClassEnum* hkbCompiledExpressionSetTokenTokenTypeEnum;
	extern const hkClassEnum* hkbConstrainRigidBodyModifierBoneToConstrainPlacementEnum;
	extern const hkClassEnum* hkbConstrainRigidBodyModifierPivotPlacementEnum;
	extern const hkClassEnum* hkbCustomTestGeneratorModesEnum;
	extern const hkClassEnum* hkbCustomTestGeneratorStrangeFlagsEnum;
	extern const hkClassEnum* hkbDemoConfigStickVariableInfoStickEnum;
	extern const hkClassEnum* hkbDockingGeneratorBlendTypeEnum;
	extern const hkClassEnum* hkbDockingGeneratorDockingFlagBitsEnum;
	extern const hkClassEnum* hkbEvaluateHandleModifierHandleChangeModeEnum;
	extern const hkClassEnum* hkbEventInfoFlagsEnum;
	extern const hkClassEnum* hkbEventRangeDataEventRangeModeEnum;
	extern const hkClassEnum* hkbExpressionDataExpressionEventModeEnum;
	extern const hkClassEnum* hkbFootIkModifierAlignModeEnum;
	extern const hkClassEnum* hkbGeneratorOutputTrackFlagsEnum;
	extern const hkClassEnum* hkbGeneratorOutputTrackTypesEnum;
	extern const hkClassEnum* hkbGeneratorTransitionEffectChildStateEnum;
	extern const hkClassEnum* hkbGeneratorTransitionEffectStageEnum;
	extern const hkClassEnum* hkbGeneratorTransitionEffectToGeneratorStateEnum;
	extern const hkClassEnum* hkbHandIkControlDataHandleChangeModeEnum;
	extern const hkClassEnum* hkbJigglerModifierJiggleCoordinatesEnum;
	extern const hkClassEnum* hkbMoveBoneTowardTargetModifierTargetModeMBTTEnum;
	extern const hkClassEnum* hkbNodeCloneStateEnum;
	extern const hkClassEnum* hkbNodeInfoFlagsEnum;
	extern const hkClassEnum* hkbParticleSystemEventPayloadSystemTypeEnum;
	extern const hkClassEnum* hkbPoseMatchingGeneratorModeEnum;
	extern const hkClassEnum* hkbReachModifierReachModeEnum;
	extern const hkClassEnum* hkbReachTowardTargetModifierFadeStateEnum;
	extern const hkClassEnum* hkbRoleAttributeRoleEnum;
	extern const hkClassEnum* hkbRoleAttributeRoleFlagsEnum;
	extern const hkClassEnum* hkbSenseHandleModifierSensingModeEnum;
	extern const hkClassEnum* hkbSimulationControlCommandSimulationControlCommandEnum;
	extern const hkClassEnum* hkbStateMachineStartStateModeEnum;
	extern const hkClassEnum* hkbStateMachineStateMachineSelfTransitionModeEnum;
	extern const hkClassEnum* hkbStateMachineTransitionInfoTransitionFlagsEnum;
	extern const hkClassEnum* hkbTargetRigidBodyModifierComputeTargetAngleModeEnum;
	extern const hkClassEnum* hkbTargetRigidBodyModifierComputeTargetDistanceModeEnum;
	extern const hkClassEnum* hkbTargetRigidBodyModifierEventModeTRBAMEnum;
	extern const hkClassEnum* hkbTargetRigidBodyModifierTargetModeEnum;
	extern const hkClassEnum* hkbToolNodeTypeNodeTypeEnum;
	extern const hkClassEnum* hkbTransitionEffectEventModeEnum;
	extern const hkClassEnum* hkbTransitionEffectSelfTransitionModeEnum;
	extern const hkClassEnum* hkbTwistModifierRotationAxisCoordinatesEnum;
	extern const hkClassEnum* hkbTwistModifierSetAngleMethodEnum;
	extern const hkClassEnum* hkbVariableBindingSetBindingBindingTypeEnum;
	extern const hkClassEnum* hkbVariableBindingSetBindingInternalBindingFlagsEnum;
	extern const hkClassEnum* hkbVariableInfoVariableTypeEnum;
	extern const hkClassEnum* hkbWorldEnumsAccumulateMotionStateEnum;
	extern const hkClassEnum* hkbWorldEnumsSimulationStateEnum;
	extern const hkClassEnum* hkbWorldFromModelModeDataWorldFromModelModeEnum;
	extern const hkClassEnum* hkbWorldMultithreadingStageEnum;
	extern const hkClassEnum* hkdActionExecutionTypeEnum;
	extern const hkClassEnum* hkdActionInheritanceTypeEnum;
	extern const hkClassEnum* hkdActionReplaceTypeEnum;
	extern const hkClassEnum* hkdBodyBodyTypeEnum;
	extern const hkClassEnum* hkdBuildingControllerShapeTypeEnum;
	extern const hkClassEnum* hkdControllerConstrainToTypeEnum;
	extern const hkClassEnum* hkdControllerControllerTypeEnum;
	extern const hkClassEnum* hkdConvexDecompositionActionDecompositionMethodEnum;
	extern const hkClassEnum* hkdConvexDecompositionActionHollowMethodEnum;
	extern const hkClassEnum* hkdConvexDecompositionActionReduceMethodEnum;
	extern const hkClassEnum* hkdConvexDecompositionActionRefineLevelEnum;
	extern const hkClassEnum* hkdCutOutFractureSplitTypeEnum;
	extern const hkClassEnum* hkdDebrisFractureInsertTypeEnum;
	extern const hkClassEnum* hkdDebrisFracturePositionSourceEnum;
	extern const hkClassEnum* hkdDecalMapActionDecalMapTypeEnum;
	extern const hkClassEnum* hkdDecorateFractureFaceActionAlignmentEnum;
	extern const hkClassEnum* hkdDecorateFractureFaceActionDecorateWhatEnum;
	extern const hkClassEnum* hkdDecorateFractureFaceActionDecorationPivotEnum;
	extern const hkClassEnum* hkdDecorateFractureFaceActionPlacementCompressionTypesEnum;
	extern const hkClassEnum* hkdDecorateFractureFaceActionProtrusionTestEnum;
	extern const hkClassEnum* hkdDeformationControllerSkinningTypeEnum;
	extern const hkClassEnum* hkdDestructionTrackerBreakingEventResultEnum;
	extern const hkClassEnum* hkdDestructionTrackerBreakingEventTypeEnum;
	extern const hkClassEnum* hkdDestructionTrackerVerboseLevelEnum;
	extern const hkClassEnum* hkdExplosionForceActionExplosionCenterSpaceEnum;
	extern const hkClassEnum* hkdFractureRefitPhysicsTypeEnum;
	extern const hkClassEnum* hkdFractureTypeEnum;
	extern const hkClassEnum* hkdGraphicsShapeGraphicsShapeTypeEnum;
	extern const hkClassEnum* hkdShapeBodyQualityTypeEnum;
	extern const hkClassEnum* hkdShapeConnectivityEnum;
	extern const hkClassEnum* hkdShapeFlexibleJointTypeEnum;
	extern const hkClassEnum* hkdShockWaveActionTriggerTypeEnum;
	extern const hkClassEnum* hkdSliceFractureSnapTypeEnum;
	extern const hkClassEnum* hkdSplitInHalfFractureNumChildrenEnum;
	extern const hkClassEnum* hkdWoodFractureSplittingDataSplittingPlaneRotationEnum;
	extern const hkClassEnum* hkgpConvexDecompositionConfigeHollowPartsEnum;
	extern const hkClassEnum* hkgpConvexDecompositionConfigePrimaryMethodEnum;
	extern const hkClassEnum* hkgpConvexDecompositionConfigeReduceMethodEnum;
	extern const hkClassEnum* hkpBvCompressedMeshShapeConstructionInfoPerTriangleDataEnum;
	extern const hkClassEnum* hkpBvTreeShapeBvTreeTypeEnum;
	extern const hkClassEnum* hkpCallbackConstraintMotorCallbackTypeEnum;
	extern const hkClassEnum* hkpCollisionFilterhkpFilterTypeEnum;
	extern const hkClassEnum* hkpCompressedMeshShapeMaterialTypeEnum;
	extern const hkClassEnum* hkpConeLimitConstraintAtomMeasurementModeEnum;
	extern const hkClassEnum* hkpConstraintAtomAtomTypeEnum;
	extern const hkClassEnum* hkpConstraintAtomSolvingMethodEnum;
	extern const hkClassEnum* hkpConstraintDataConstraintTypeEnum;
	extern const hkClassEnum* hkpConstraintInstanceConstraintPriorityEnum;
	extern const hkClassEnum* hkpConstraintInstanceOnDestructionRemapInfoEnum;
	extern const hkClassEnum* hkpConstraintMotorMotorTypeEnum;
	extern const hkClassEnum* hkpContactPointAddedEventTypeEnum;
	extern const hkClassEnum* hkpContinuousSimulationCollisionQualityOverrideEnum;
	extern const hkClassEnum* hkpExtendedMeshShapeIndexStridingTypeEnum;
	extern const hkClassEnum* hkpFirstPersonGunKeyboardKeyEnum;
	extern const hkClassEnum* hkpFirstPersonGunTypeEnum;
	extern const hkClassEnum* hkpGunProjectileFlagsEnum;
	extern const hkClassEnum* hkpMaterialResponseTypeEnum;
	extern const hkClassEnum* hkpMeshShapeMeshShapeIndexStridingTypeEnum;
	extern const hkClassEnum* hkpMeshShapeMeshShapeMaterialIndexStridingTypeEnum;
	extern const hkClassEnum* hkpMoppAssemblerDatahkpCutCommandTypeEnum;
	extern const hkClassEnum* hkpMoppAssemblerDatahkpRescaleCommandTypeEnum;
	extern const hkClassEnum* hkpMoppCodeBuildTypeEnum;
	extern const hkClassEnum* hkpMotionMotionTypeEnum;
	extern const hkClassEnum* hkpPhysicsCommandTYPEEnum;
	extern const hkClassEnum* hkpPointToPathConstraintDataOrientationConstraintTypeEnum;
	extern const hkClassEnum* hkpRigidBodyCinfoSolverDeactivationEnum;
	extern const hkClassEnum* hkpSampledHeightFieldShapeHeightFieldTypeEnum;
	extern const hkClassEnum* hkpSerializedAgentNnEntrySerializedAgentTypeEnum;
	extern const hkClassEnum* hkpShapeCollectionCollectionTypeEnum;
	extern const hkClassEnum* hkpTreeWorldManagerObjectRemovedBehaviorEnum;
	extern const hkClassEnum* hkpTriggerVolumeOperationEnum;
	extern const hkClassEnum* hkpVehicleWheelCollideWheelCollideTypeEnum;
	extern const hkClassEnum* hkpVelocityAccumulatorhkpAccumulatorContextEnum;
	extern const hkClassEnum* hkpVelocityAccumulatorhkpAccumulatorTypeEnum;
	extern const hkClassEnum* hkpWeldingUtilityWeldingTypeEnum;
	extern const hkClassEnum* hkpWorldCinfoBroadPhaseBorderBehaviourEnum;
	extern const hkClassEnum* hkpWorldCinfoBroadPhaseTypeEnum;
	extern const hkClassEnum* hkpWorldCinfoContactPointGenerationEnum;
	extern const hkClassEnum* hkpWorldCinfoSimulationTypeEnum;
	extern const hkClassEnum* hkxAttributeHintEnum;
	extern const hkClassEnum* hkxIndexBufferIndexTypeEnum;
	extern const hkClassEnum* hkxLightLightTypeEnum;
	extern const hkClassEnum* hkxMaterialEffectEffectTypeEnum;
	extern const hkClassEnum* hkxMaterialShaderShaderTypeEnum;
	extern const hkClassEnum* hkxMaterialTextureTypeEnum;
	extern const hkClassEnum* hkxVertexDescriptionDataTypeEnum;
	extern const hkClassEnum* hkxVertexDescriptionDataUsageEnum;
	extern const hkClassEnum* hkxVertexFloatDataChannelVertexFloatDimensionsEnum;
	static hkInternalClassMember hkaiPhysicsShapeVolumeClass_Members[] =
	{
		{ "dispatcher", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "shape", &hkpShapeClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "shapeTransform", HK_NULL, HK_NULL, hkClassMember::TYPE_TRANSFORM, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "geometry", &hkGeometryClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkaiPhysicsShapeVolumeClass(
		"hkaiPhysicsShapeVolume",
		&hkaiVolumeClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaiPhysicsShapeVolumeClass_Members),
		HK_COUNT_OF(hkaiPhysicsShapeVolumeClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkaiStaticTreeClass_Members[] =
	{
		{ "shouldDeleteTree", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "treePtr", &hkcdStaticTreeDefaultTreeStorage6Class, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkaiStaticTreeClass(
		"hkaiStaticTree",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaiStaticTreeClass_Members),
		HK_COUNT_OF(hkaiStaticTreeClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkaiNavVolumeGenerationSettingsMaterialFlagsBitsEnumItems[] =
	{
		{0, "MATERIAL_NONE"},
		{1, "MATERIAL_BLOCKING"},
		{1, "MATERIAL_DEFAULT"},
	};
	static const hkInternalClassEnum hkaiNavVolumeGenerationSettingsEnums[] = {
		{"MaterialFlagsBits", hkaiNavVolumeGenerationSettingsMaterialFlagsBitsEnumItems, 3, HK_NULL, 0 }
	};
	const hkClassEnum* hkaiNavVolumeGenerationSettingsMaterialFlagsBitsEnum = reinterpret_cast<const hkClassEnum*>(&hkaiNavVolumeGenerationSettingsEnums[0]);
	static hkInternalClassMember hkaiNavVolumeGenerationSettings_MaterialConstructionInfoClass_Members[] =
	{
		{ "materialIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "flags", HK_NULL, hkaiNavVolumeGenerationSettingsMaterialFlagsBitsEnum, hkClassMember::TYPE_FLAGS, hkClassMember::TYPE_UINT32, 0, 0, 0, HK_NULL },
		{ "resolution", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkaiNavVolumeGenerationSettingsMaterialConstructionInfo_DefaultStruct
		{
			int s_defaultOffsets[3];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkInt32 m_resolution;
		};
		const hkaiNavVolumeGenerationSettingsMaterialConstructionInfo_DefaultStruct hkaiNavVolumeGenerationSettingsMaterialConstructionInfo_Default =
		{
			{-1,-1,HK_OFFSET_OF(hkaiNavVolumeGenerationSettingsMaterialConstructionInfo_DefaultStruct,m_resolution)},
			1
		};
	}
	hkClass hkaiNavVolumeGenerationSettingsMaterialConstructionInfoClass(
		"hkaiNavVolumeGenerationSettingsMaterialConstructionInfo",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaiNavVolumeGenerationSettings_MaterialConstructionInfoClass_Members),
		HK_COUNT_OF(hkaiNavVolumeGenerationSettings_MaterialConstructionInfoClass_Members),
		&hkaiNavVolumeGenerationSettingsMaterialConstructionInfo_Default,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkaiNavVolumeGenerationSettings_ChunkSettingsClass_Members[] =
	{
		{ "maxChunkSizeX", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxChunkSizeY", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxChunkSizeZ", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkaiNavVolumeGenerationSettingsChunkSettings_DefaultStruct
		{
			int s_defaultOffsets[3];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkUint16 m_maxChunkSizeX;
			hkUint16 m_maxChunkSizeY;
			hkUint16 m_maxChunkSizeZ;
		};
		const hkaiNavVolumeGenerationSettingsChunkSettings_DefaultStruct hkaiNavVolumeGenerationSettingsChunkSettings_Default =
		{
			{HK_OFFSET_OF(hkaiNavVolumeGenerationSettingsChunkSettings_DefaultStruct,m_maxChunkSizeX),HK_OFFSET_OF(hkaiNavVolumeGenerationSettingsChunkSettings_DefaultStruct,m_maxChunkSizeY),HK_OFFSET_OF(hkaiNavVolumeGenerationSettingsChunkSettings_DefaultStruct,m_maxChunkSizeZ)},
			hkaiNavVolumeGenerationSettings::ChunkSettings::DEFAULT_MAX_CHUNK_SIZE,hkaiNavVolumeGenerationSettings::ChunkSettings::DEFAULT_MAX_CHUNK_SIZE,hkaiNavVolumeGenerationSettings::ChunkSettings::DEFAULT_MAX_CHUNK_SIZE
		};
	}
	hkClass hkaiNavVolumeGenerationSettingsChunkSettingsClass(
		"hkaiNavVolumeGenerationSettingsChunkSettings",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaiNavVolumeGenerationSettings_ChunkSettingsClass_Members),
		HK_COUNT_OF(hkaiNavVolumeGenerationSettings_ChunkSettingsClass_Members),
		&hkaiNavVolumeGenerationSettingsChunkSettings_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkaiNavVolumeGenerationSettings_MergingSettingsClass_Members[] =
	{
		{ "nodeWeight", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "edgeWeight", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "estimateNewEdges", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "iterationsStabilizationThreshold", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "slopeThreshold", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxMergingIterations", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "randomSeed", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "multiplier", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "useSimpleFirstMergePass", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkaiNavVolumeGenerationSettingsMergingSettings_DefaultStruct
		{
			int s_defaultOffsets[9];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkReal m_nodeWeight;
			hkReal m_edgeWeight;
			_hkBool m_estimateNewEdges;
			hkInt32 m_iterationsStabilizationThreshold;
			hkReal m_slopeThreshold;
			hkInt32 m_maxMergingIterations;
			hkInt32 m_randomSeed;
			hkReal m_multiplier;
			_hkBool m_useSimpleFirstMergePass;
		};
		const hkaiNavVolumeGenerationSettingsMergingSettings_DefaultStruct hkaiNavVolumeGenerationSettingsMergingSettings_Default =
		{
			{HK_OFFSET_OF(hkaiNavVolumeGenerationSettingsMergingSettings_DefaultStruct,m_nodeWeight),HK_OFFSET_OF(hkaiNavVolumeGenerationSettingsMergingSettings_DefaultStruct,m_edgeWeight),HK_OFFSET_OF(hkaiNavVolumeGenerationSettingsMergingSettings_DefaultStruct,m_estimateNewEdges),HK_OFFSET_OF(hkaiNavVolumeGenerationSettingsMergingSettings_DefaultStruct,m_iterationsStabilizationThreshold),HK_OFFSET_OF(hkaiNavVolumeGenerationSettingsMergingSettings_DefaultStruct,m_slopeThreshold),HK_OFFSET_OF(hkaiNavVolumeGenerationSettingsMergingSettings_DefaultStruct,m_maxMergingIterations),HK_OFFSET_OF(hkaiNavVolumeGenerationSettingsMergingSettings_DefaultStruct,m_randomSeed),HK_OFFSET_OF(hkaiNavVolumeGenerationSettingsMergingSettings_DefaultStruct,m_multiplier),HK_OFFSET_OF(hkaiNavVolumeGenerationSettingsMergingSettings_DefaultStruct,m_useSimpleFirstMergePass)},
			10.0f,1.0f,true,10,1.0f,1000000,123,1.0f,true
		};
	}
	hkClass hkaiNavVolumeGenerationSettingsMergingSettingsClass(
		"hkaiNavVolumeGenerationSettingsMergingSettings",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaiNavVolumeGenerationSettings_MergingSettingsClass_Members),
		HK_COUNT_OF(hkaiNavVolumeGenerationSettings_MergingSettingsClass_Members),
		&hkaiNavVolumeGenerationSettingsMergingSettings_Default,
		HK_NULL,
		0,
		hkUint32(3)
		);
	static hkInternalClassMember hkaiNavVolumeGenerationSettingsClass_Members[] =
	{
		{ "volumeAabb", &hkAabbClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxHorizontalRange", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxVerticalRange", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "validateInputGeometry", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "up", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "characterHeight", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "characterDepth", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "characterWidth", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "cellWidth", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "chunkSettings", &hkaiNavVolumeGenerationSettingsChunkSettingsClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "border", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "useBorderCells", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "mergingSettings", &hkaiNavVolumeGenerationSettingsMergingSettingsClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "minRegionVolume", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "minDistanceToSeedPoints", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "regionSeedPoints", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VECTOR4, 0, 0, 0, HK_NULL },
		{ "defaultConstructionProperties", HK_NULL, hkaiNavVolumeGenerationSettingsMaterialFlagsBitsEnum, hkClassMember::TYPE_FLAGS, hkClassMember::TYPE_UINT32, 0, 0, 0, HK_NULL },
		{ "materialMap", &hkaiNavVolumeGenerationSettingsMaterialConstructionInfoClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "carvers", &hkaiVolumeClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "painters", &hkaiMaterialPainterClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "saveInputSnapshot", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "snapshotFilename", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkaiNavVolumeGenerationSettings_DefaultStruct
		{
			int s_defaultOffsets[22];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkReal m_maxHorizontalRange;
			hkReal m_maxVerticalRange;
			_hkVector4 m_up;
			hkReal m_characterHeight;
			hkReal m_characterWidth;
			hkReal m_cellWidth;
			hkReal m_border;
			_hkBool m_useBorderCells;
			hkReal m_minRegionVolume;
			hkReal m_minDistanceToSeedPoints;
			hkUint32 /* hkFlags< enum hkaiNavVolumeGenerationSettings::MaterialFlagsBits, hkUint32 > */ m_defaultConstructionProperties;
		};
		const hkaiNavVolumeGenerationSettings_DefaultStruct hkaiNavVolumeGenerationSettings_Default =
		{
			{-1,HK_OFFSET_OF(hkaiNavVolumeGenerationSettings_DefaultStruct,m_maxHorizontalRange),HK_OFFSET_OF(hkaiNavVolumeGenerationSettings_DefaultStruct,m_maxVerticalRange),hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkaiNavVolumeGenerationSettings_DefaultStruct,m_up),HK_OFFSET_OF(hkaiNavVolumeGenerationSettings_DefaultStruct,m_characterHeight),hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkaiNavVolumeGenerationSettings_DefaultStruct,m_characterWidth),HK_OFFSET_OF(hkaiNavVolumeGenerationSettings_DefaultStruct,m_cellWidth),-1,HK_OFFSET_OF(hkaiNavVolumeGenerationSettings_DefaultStruct,m_border),HK_OFFSET_OF(hkaiNavVolumeGenerationSettings_DefaultStruct,m_useBorderCells),-1,HK_OFFSET_OF(hkaiNavVolumeGenerationSettings_DefaultStruct,m_minRegionVolume),HK_OFFSET_OF(hkaiNavVolumeGenerationSettings_DefaultStruct,m_minDistanceToSeedPoints),-1,HK_OFFSET_OF(hkaiNavVolumeGenerationSettings_DefaultStruct,m_defaultConstructionProperties),-1,-1,-1,hkClassMember::HK_CLASS_ZERO_DEFAULT,-1},
		10000.0f,1000.0f,	{0,0,1},1.75,1.75,1.0f,0.01f,true,5.0f,1.0f, hkaiNavVolumeGenerationSettings::MATERIAL_DEFAULT 
		};
	}
	hkClass hkaiNavVolumeGenerationSettingsClass(
		"hkaiNavVolumeGenerationSettings",
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkaiNavVolumeGenerationSettingsEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkaiNavVolumeGenerationSettingsClass_Members),
		HK_COUNT_OF(hkaiNavVolumeGenerationSettingsClass_Members),
		&hkaiNavVolumeGenerationSettings_Default,
		HK_NULL,
		0,
		hkUint32(6)
		);
	static hkInternalClassMember hkaiEdgeGeometry_EdgeClass_Members[] =
	{
		{ "a", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "b", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "face", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "data", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkaiEdgeGeometryEdgeClass(
		"hkaiEdgeGeometryEdge",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaiEdgeGeometry_EdgeClass_Members),
		HK_COUNT_OF(hkaiEdgeGeometry_EdgeClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkaiEdgeGeometry_FaceClass_Members[] =
	{
		{ "data", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "faceIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkaiEdgeGeometryFaceClass(
		"hkaiEdgeGeometryFace",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaiEdgeGeometry_FaceClass_Members),
		HK_COUNT_OF(hkaiEdgeGeometry_FaceClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkaiEdgeGeometryClass_Members[] =
	{
		{ "edges", &hkaiEdgeGeometryEdgeClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "faces", &hkaiEdgeGeometryFaceClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "vertices", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VECTOR4, 0, 0, 0, HK_NULL },
		{ "zeroFace", &hkaiEdgeGeometryFaceClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkaiEdgeGeometryClass(
		"hkaiEdgeGeometry",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaiEdgeGeometryClass_Members),
		HK_COUNT_OF(hkaiEdgeGeometryClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkaiLocalSteeringInputClass_Members[] =
	{
		{ "currentPosition", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "currentForward", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "currentVelocity", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "desiredVelocity", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "desiredFutureDir", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "distToLocalGoal", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "timeToLocalGoal", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "character", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "referenceFrame", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "isLocalGoalLast", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "applyKinematicConstraints", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "applyAvoidanceSteering", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkaiLocalSteeringInputClass(
		"hkaiLocalSteeringInput",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaiLocalSteeringInputClass_Members),
		HK_COUNT_OF(hkaiLocalSteeringInputClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(2)
		);
	static hkInternalClassMember hkaiAvoidancePairProperties_PairDataClass_Members[] =
	{
		{ "key", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "weight", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "cosViewAngle", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkaiAvoidancePairPropertiesPairData_DefaultStruct
		{
			int s_defaultOffsets[3];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkReal m_weight;
			hkReal m_cosViewAngle;
		};
		const hkaiAvoidancePairPropertiesPairData_DefaultStruct hkaiAvoidancePairPropertiesPairData_Default =
		{
			{hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkaiAvoidancePairPropertiesPairData_DefaultStruct,m_weight),HK_OFFSET_OF(hkaiAvoidancePairPropertiesPairData_DefaultStruct,m_cosViewAngle)},
			0.5f,-0.4216f
		};
	}
	hkClass hkaiAvoidancePairPropertiesPairDataClass(
		"hkaiAvoidancePairPropertiesPairData",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaiAvoidancePairProperties_PairDataClass_Members),
		HK_COUNT_OF(hkaiAvoidancePairProperties_PairDataClass_Members),
		&hkaiAvoidancePairPropertiesPairData_Default,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkaiAvoidancePairPropertiesClass_Members[] =
	{
		{ "avoidancePairDataMap", &hkaiAvoidancePairPropertiesPairDataClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkaiAvoidancePairPropertiesClass(
		"hkaiAvoidancePairProperties",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaiAvoidancePairPropertiesClass_Members),
		HK_COUNT_OF(hkaiAvoidancePairPropertiesClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(2)
		);
	static hkInternalClassMember hkaiAvoidanceSolver_MovementPropertiesClass_Members[] =
	{
		{ "minVelocity", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxVelocity", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxAcceleration", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxDeceleration", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxAngularVelocity", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxAngularAcceleration", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxTurnVelocity", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkaiAvoidanceSolverMovementProperties_DefaultStruct
		{
			int s_defaultOffsets[7];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkReal m_minVelocity;
			hkReal m_maxVelocity;
			hkReal m_maxAcceleration;
			hkReal m_maxDeceleration;
			hkReal m_maxAngularVelocity;
			hkReal m_maxAngularAcceleration;
			hkReal m_maxTurnVelocity;
		};
		const hkaiAvoidanceSolverMovementProperties_DefaultStruct hkaiAvoidanceSolverMovementProperties_Default =
		{
			{HK_OFFSET_OF(hkaiAvoidanceSolverMovementProperties_DefaultStruct,m_minVelocity),HK_OFFSET_OF(hkaiAvoidanceSolverMovementProperties_DefaultStruct,m_maxVelocity),HK_OFFSET_OF(hkaiAvoidanceSolverMovementProperties_DefaultStruct,m_maxAcceleration),HK_OFFSET_OF(hkaiAvoidanceSolverMovementProperties_DefaultStruct,m_maxDeceleration),HK_OFFSET_OF(hkaiAvoidanceSolverMovementProperties_DefaultStruct,m_maxAngularVelocity),HK_OFFSET_OF(hkaiAvoidanceSolverMovementProperties_DefaultStruct,m_maxAngularAcceleration),HK_OFFSET_OF(hkaiAvoidanceSolverMovementProperties_DefaultStruct,m_maxTurnVelocity)},
			.02f,5.64f,20.0f,30.0f, 1.25f * HK_REAL_PI , 37.5f * HK_REAL_PI , .5f * 5.64f 
		};
	}
	hkClass hkaiAvoidanceSolverMovementPropertiesClass(
		"hkaiAvoidanceSolverMovementProperties",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaiAvoidanceSolver_MovementPropertiesClass_Members),
		HK_COUNT_OF(hkaiAvoidanceSolver_MovementPropertiesClass_Members),
		&hkaiAvoidanceSolverMovementProperties_Default,
		HK_NULL,
		0,
		hkUint32(2)
		);
	static hkInternalClassMember hkaiAvoidanceSolver_AvoidancePropertiesClass_Members[] =
	{
		{ "movementProperties", &hkaiAvoidanceSolverMovementPropertiesClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "agentLimitTime", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "obstacleLimitTime", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "boundaryLimitTime", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "limitObstacleDistance", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "limitBoundaryDistance", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "limitObstacleVelocity", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkaiAvoidanceSolverAvoidanceProperties_DefaultStruct
		{
			int s_defaultOffsets[7];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkReal m_agentLimitTime;
			hkReal m_obstacleLimitTime;
			hkReal m_boundaryLimitTime;
			hkReal m_limitObstacleDistance;
			hkReal m_limitBoundaryDistance;
			hkReal m_limitObstacleVelocity;
		};
		const hkaiAvoidanceSolverAvoidanceProperties_DefaultStruct hkaiAvoidanceSolverAvoidanceProperties_Default =
		{
			{-1,HK_OFFSET_OF(hkaiAvoidanceSolverAvoidanceProperties_DefaultStruct,m_agentLimitTime),HK_OFFSET_OF(hkaiAvoidanceSolverAvoidanceProperties_DefaultStruct,m_obstacleLimitTime),HK_OFFSET_OF(hkaiAvoidanceSolverAvoidanceProperties_DefaultStruct,m_boundaryLimitTime),HK_OFFSET_OF(hkaiAvoidanceSolverAvoidanceProperties_DefaultStruct,m_limitObstacleDistance),HK_OFFSET_OF(hkaiAvoidanceSolverAvoidanceProperties_DefaultStruct,m_limitBoundaryDistance),HK_OFFSET_OF(hkaiAvoidanceSolverAvoidanceProperties_DefaultStruct,m_limitObstacleVelocity)},
			1.0f,1.0f,0.25f,1.5f,1.5f,1.5f
		};
	}
	hkClass hkaiAvoidanceSolverAvoidancePropertiesClass(
		"hkaiAvoidanceSolverAvoidanceProperties",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaiAvoidanceSolver_AvoidancePropertiesClass_Members),
		HK_COUNT_OF(hkaiAvoidanceSolver_AvoidancePropertiesClass_Members),
		&hkaiAvoidanceSolverAvoidanceProperties_Default,
		HK_NULL,
		0,
		hkUint32(6)
		);
	static hkInternalClassMember hkaiNavMeshSimplificationUtils_SettingsClass_Members[] =
	{
		{ "maxBorderSimplifyArea", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxConcaveBorderSimplifyArea", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "minCorridorWidth", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxCorridorWidth", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "holeReplacementArea", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxLoopShrinkFraction", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxBorderHeightError", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxBorderDistanceError", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxPartitionSize", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "useHeightPartitioning", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxPartitionHeightError", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "useConservativeHeightPartitioning", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "hertelMehlhornHeightError", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "cosPlanarityThreshold", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "nonconvexityThreshold", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "boundaryEdgeFilterThreshold", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxSharedVertexHorizontalError", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxSharedVertexVerticalError", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxBoundaryVertexHorizontalError", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxBoundaryVertexVerticalError", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "mergeLongestEdgesFirst", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkaiNavMeshSimplificationUtilsSettings_DefaultStruct
		{
			int s_defaultOffsets[21];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkReal m_maxBorderSimplifyArea;
			hkReal m_maxConcaveBorderSimplifyArea;
			hkReal m_minCorridorWidth;
			hkReal m_maxCorridorWidth;
			hkReal m_holeReplacementArea;
			hkReal m_maxLoopShrinkFraction;
			hkReal m_maxBorderHeightError;
			hkReal m_maxBorderDistanceError;
			hkInt32 m_maxPartitionSize;
			hkReal m_maxPartitionHeightError;
			hkReal m_hertelMehlhornHeightError;
			hkReal m_cosPlanarityThreshold;
			hkReal m_nonconvexityThreshold;
			hkReal m_boundaryEdgeFilterThreshold;
			hkReal m_maxSharedVertexHorizontalError;
			hkReal m_maxSharedVertexVerticalError;
			hkReal m_maxBoundaryVertexHorizontalError;
			hkReal m_maxBoundaryVertexVerticalError;
			_hkBool m_mergeLongestEdgesFirst;
		};
		const hkaiNavMeshSimplificationUtilsSettings_DefaultStruct hkaiNavMeshSimplificationUtilsSettings_Default =
		{
			{HK_OFFSET_OF(hkaiNavMeshSimplificationUtilsSettings_DefaultStruct,m_maxBorderSimplifyArea),HK_OFFSET_OF(hkaiNavMeshSimplificationUtilsSettings_DefaultStruct,m_maxConcaveBorderSimplifyArea),HK_OFFSET_OF(hkaiNavMeshSimplificationUtilsSettings_DefaultStruct,m_minCorridorWidth),HK_OFFSET_OF(hkaiNavMeshSimplificationUtilsSettings_DefaultStruct,m_maxCorridorWidth),HK_OFFSET_OF(hkaiNavMeshSimplificationUtilsSettings_DefaultStruct,m_holeReplacementArea),HK_OFFSET_OF(hkaiNavMeshSimplificationUtilsSettings_DefaultStruct,m_maxLoopShrinkFraction),HK_OFFSET_OF(hkaiNavMeshSimplificationUtilsSettings_DefaultStruct,m_maxBorderHeightError),HK_OFFSET_OF(hkaiNavMeshSimplificationUtilsSettings_DefaultStruct,m_maxBorderDistanceError),HK_OFFSET_OF(hkaiNavMeshSimplificationUtilsSettings_DefaultStruct,m_maxPartitionSize),hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkaiNavMeshSimplificationUtilsSettings_DefaultStruct,m_maxPartitionHeightError),hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkaiNavMeshSimplificationUtilsSettings_DefaultStruct,m_hertelMehlhornHeightError),HK_OFFSET_OF(hkaiNavMeshSimplificationUtilsSettings_DefaultStruct,m_cosPlanarityThreshold),HK_OFFSET_OF(hkaiNavMeshSimplificationUtilsSettings_DefaultStruct,m_nonconvexityThreshold),HK_OFFSET_OF(hkaiNavMeshSimplificationUtilsSettings_DefaultStruct,m_boundaryEdgeFilterThreshold),HK_OFFSET_OF(hkaiNavMeshSimplificationUtilsSettings_DefaultStruct,m_maxSharedVertexHorizontalError),HK_OFFSET_OF(hkaiNavMeshSimplificationUtilsSettings_DefaultStruct,m_maxSharedVertexVerticalError),HK_OFFSET_OF(hkaiNavMeshSimplificationUtilsSettings_DefaultStruct,m_maxBoundaryVertexHorizontalError),HK_OFFSET_OF(hkaiNavMeshSimplificationUtilsSettings_DefaultStruct,m_maxBoundaryVertexVerticalError),HK_OFFSET_OF(hkaiNavMeshSimplificationUtilsSettings_DefaultStruct,m_mergeLongestEdgesFirst)},
			1.5f,0.15f,0.4f,0.6f,1.0f,0.75f,1.5f,2.f,40000,100.f,0.01f,0.99f,0.1f,0.01f,1.f,1.f,1.f,1.f,true
		};
	}
	hkClass hkaiNavMeshSimplificationUtilsSettingsClass(
		"hkaiNavMeshSimplificationUtilsSettings",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaiNavMeshSimplificationUtils_SettingsClass_Members),
		HK_COUNT_OF(hkaiNavMeshSimplificationUtils_SettingsClass_Members),
		&hkaiNavMeshSimplificationUtilsSettings_Default,
		HK_NULL,
		0,
		hkUint32(10)
		);
	static const hkInternalClassEnumItem hkaiNavMeshGenerationSettingsConstructionFlagsBitsEnumItems[] =
	{
		{1, "MATERIAL_WALKABLE"},
		{2, "MATERIAL_CUTTING"},
		{3, "MATERIAL_WALKABLE_AND_CUTTING"},
	};
	static const hkInternalClassEnumItem hkaiNavMeshGenerationSettingsEdgeMatchingMetricEnumItems[] =
	{
		{1, "ORDER_BY_OVERLAP"},
		{2, "ORDER_BY_DISTANCE"},
	};
	static const hkInternalClassEnumItem hkaiNavMeshGenerationSettingsCharacterWidthUsageEnumItems[] =
	{
		{0, "NONE"},
		{1, "BLOCK_EDGES"},
		{2, "SHRINK_NAV_MESH"},
	};
	static const hkInternalClassEnum hkaiNavMeshGenerationSettingsEnums[] = {
		{"ConstructionFlagsBits", hkaiNavMeshGenerationSettingsConstructionFlagsBitsEnumItems, 3, HK_NULL, 0 },
		{"EdgeMatchingMetric", hkaiNavMeshGenerationSettingsEdgeMatchingMetricEnumItems, 2, HK_NULL, 0 },
		{"CharacterWidthUsage", hkaiNavMeshGenerationSettingsCharacterWidthUsageEnumItems, 3, HK_NULL, 0 }
	};
	const hkClassEnum* hkaiNavMeshGenerationSettingsConstructionFlagsBitsEnum = reinterpret_cast<const hkClassEnum*>(&hkaiNavMeshGenerationSettingsEnums[0]);
	const hkClassEnum* hkaiNavMeshGenerationSettingsEdgeMatchingMetricEnum = reinterpret_cast<const hkClassEnum*>(&hkaiNavMeshGenerationSettingsEnums[1]);
	const hkClassEnum* hkaiNavMeshGenerationSettingsCharacterWidthUsageEnum = reinterpret_cast<const hkClassEnum*>(&hkaiNavMeshGenerationSettingsEnums[2]);
	static hkInternalClassMember hkaiNavMeshGenerationSettings_MaterialConstructionPairClass_Members[] =
	{
		{ "materialIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "flags", HK_NULL, hkaiNavMeshGenerationSettingsConstructionFlagsBitsEnum, hkClassMember::TYPE_FLAGS, hkClassMember::TYPE_UINT32, 0, 0, 0, HK_NULL }
	};
	hkClass hkaiNavMeshGenerationSettingsMaterialConstructionPairClass(
		"hkaiNavMeshGenerationSettingsMaterialConstructionPair",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaiNavMeshGenerationSettings_MaterialConstructionPairClass_Members),
		HK_COUNT_OF(hkaiNavMeshGenerationSettings_MaterialConstructionPairClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkaiNavMeshGenerationSettings_EdgeMatchingParametersClass_Members[] =
	{
		{ "maxStepHeight", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxSeparation", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxOverhang", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "cosPlanarAlignmentAngle", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "cosVerticalAlignmentAngle", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "minEdgeOverlap", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "edgeTraversibilityHorizontalEpsilon", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "edgeTraversibilityVerticalEpsilon", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "cosClimbingFaceNormalAlignmentAngle", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "cosClimbingEdgeAlignmentAngle", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkaiNavMeshGenerationSettingsEdgeMatchingParameters_DefaultStruct
		{
			int s_defaultOffsets[10];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkReal m_maxStepHeight;
			hkReal m_maxSeparation;
			hkReal m_maxOverhang;
			hkReal m_cosPlanarAlignmentAngle;
			hkReal m_cosVerticalAlignmentAngle;
			hkReal m_minEdgeOverlap;
			hkReal m_edgeTraversibilityHorizontalEpsilon;
			hkReal m_edgeTraversibilityVerticalEpsilon;
			hkReal m_cosClimbingFaceNormalAlignmentAngle;
			hkReal m_cosClimbingEdgeAlignmentAngle;
		};
		const hkaiNavMeshGenerationSettingsEdgeMatchingParameters_DefaultStruct hkaiNavMeshGenerationSettingsEdgeMatchingParameters_Default =
		{
			{HK_OFFSET_OF(hkaiNavMeshGenerationSettingsEdgeMatchingParameters_DefaultStruct,m_maxStepHeight),HK_OFFSET_OF(hkaiNavMeshGenerationSettingsEdgeMatchingParameters_DefaultStruct,m_maxSeparation),HK_OFFSET_OF(hkaiNavMeshGenerationSettingsEdgeMatchingParameters_DefaultStruct,m_maxOverhang),HK_OFFSET_OF(hkaiNavMeshGenerationSettingsEdgeMatchingParameters_DefaultStruct,m_cosPlanarAlignmentAngle),HK_OFFSET_OF(hkaiNavMeshGenerationSettingsEdgeMatchingParameters_DefaultStruct,m_cosVerticalAlignmentAngle),HK_OFFSET_OF(hkaiNavMeshGenerationSettingsEdgeMatchingParameters_DefaultStruct,m_minEdgeOverlap),HK_OFFSET_OF(hkaiNavMeshGenerationSettingsEdgeMatchingParameters_DefaultStruct,m_edgeTraversibilityHorizontalEpsilon),HK_OFFSET_OF(hkaiNavMeshGenerationSettingsEdgeMatchingParameters_DefaultStruct,m_edgeTraversibilityVerticalEpsilon),HK_OFFSET_OF(hkaiNavMeshGenerationSettingsEdgeMatchingParameters_DefaultStruct,m_cosClimbingFaceNormalAlignmentAngle),HK_OFFSET_OF(hkaiNavMeshGenerationSettingsEdgeMatchingParameters_DefaultStruct,m_cosClimbingEdgeAlignmentAngle)},
			.5f,.1f,1e-2f,0.99619472f,.5f,.02f,.01f,.01f,-0.5f,0.99619472f
		};
	}
	hkClass hkaiNavMeshGenerationSettingsEdgeMatchingParametersClass(
		"hkaiNavMeshGenerationSettingsEdgeMatchingParameters",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaiNavMeshGenerationSettings_EdgeMatchingParametersClass_Members),
		HK_COUNT_OF(hkaiNavMeshGenerationSettings_EdgeMatchingParametersClass_Members),
		&hkaiNavMeshGenerationSettingsEdgeMatchingParameters_Default,
		HK_NULL,
		0,
		hkUint32(3)
		);
	static hkInternalClassMember hkaiNavMeshGenerationSettings_OverrideSettingsClass_Members[] =
	{
		{ "volume", &hkaiVolumeClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "material", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxWalkableSlope", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "edgeMatchingParams", &hkaiNavMeshGenerationSettingsEdgeMatchingParametersClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "simplificationSettings", &hkaiNavMeshSimplificationUtilsSettingsClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkaiNavMeshGenerationSettingsOverrideSettingsClass(
		"hkaiNavMeshGenerationSettingsOverrideSettings",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaiNavMeshGenerationSettings_OverrideSettingsClass_Members),
		HK_COUNT_OF(hkaiNavMeshGenerationSettings_OverrideSettingsClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(2)
		);
	static hkInternalClassMember hkaiNavMeshGenerationSettings_RegionPruningSettingsClass_Members[] =
	{
		{ "minRegionArea", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "minDistanceToSeedPoints", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "borderPreservationTolerance", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "regionSeedPoints", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VECTOR4, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkaiNavMeshGenerationSettingsRegionPruningSettings_DefaultStruct
		{
			int s_defaultOffsets[4];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkReal m_minRegionArea;
			hkReal m_minDistanceToSeedPoints;
			hkReal m_borderPreservationTolerance;
		};
		const hkaiNavMeshGenerationSettingsRegionPruningSettings_DefaultStruct hkaiNavMeshGenerationSettingsRegionPruningSettings_Default =
		{
			{HK_OFFSET_OF(hkaiNavMeshGenerationSettingsRegionPruningSettings_DefaultStruct,m_minRegionArea),HK_OFFSET_OF(hkaiNavMeshGenerationSettingsRegionPruningSettings_DefaultStruct,m_minDistanceToSeedPoints),HK_OFFSET_OF(hkaiNavMeshGenerationSettingsRegionPruningSettings_DefaultStruct,m_borderPreservationTolerance),-1},
			5.0f,1.0f,.1f
		};
	}
	hkClass hkaiNavMeshGenerationSettingsRegionPruningSettingsClass(
		"hkaiNavMeshGenerationSettingsRegionPruningSettings",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaiNavMeshGenerationSettings_RegionPruningSettingsClass_Members),
		HK_COUNT_OF(hkaiNavMeshGenerationSettings_RegionPruningSettingsClass_Members),
		&hkaiNavMeshGenerationSettingsRegionPruningSettings_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkaiNavMeshGenerationSettingsClass_Members[] =
	{
		{ "maxHorizontalRange", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxVerticalRange", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "validateInputGeometry", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "characterHeight", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "up", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "quantizationGridSize", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxWalkableSlope", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "degenerateAreaThreshold", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "degenerateWidthThreshold", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "convexThreshold", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxNumEdgesPerFace", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "edgeMatchingParams", &hkaiNavMeshGenerationSettingsEdgeMatchingParametersClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "edgeMatchingMetric", HK_NULL, hkaiNavMeshGenerationSettingsEdgeMatchingMetricEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT32, 0, 0, 0, HK_NULL },
		{ "edgeConnectionIterations", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "regionPruningSettings", &hkaiNavMeshGenerationSettingsRegionPruningSettingsClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "boundsAabb", &hkAabbClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "carvers", &hkaiVolumeClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "painters", &hkaiMaterialPainterClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "painterOverlapCallback", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "defaultConstructionProperties", HK_NULL, hkaiNavMeshGenerationSettingsConstructionFlagsBitsEnum, hkClassMember::TYPE_FLAGS, hkClassMember::TYPE_UINT32, 0, 0, 0, HK_NULL },
		{ "materialMap", &hkaiNavMeshGenerationSettingsMaterialConstructionPairClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "weldInputVertices", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "weldThreshold", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "minCharacterWidth", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "characterWidthUsage", HK_NULL, hkaiNavMeshGenerationSettingsCharacterWidthUsageEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "enableSimplification", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "simplificationSettings", &hkaiNavMeshSimplificationUtilsSettingsClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "carvedMaterial", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "carvedCuttingMaterial", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "saveInputSnapshot", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "snapshotFilename", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "overrideSettings", &hkaiNavMeshGenerationSettingsOverrideSettingsClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkaiNavMeshGenerationSettings_DefaultStruct
		{
			int s_defaultOffsets[32];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkReal m_maxHorizontalRange;
			hkReal m_maxVerticalRange;
			hkReal m_characterHeight;
			hkReal m_maxWalkableSlope;
			hkInt32 m_maxNumEdgesPerFace;
			hkUint32 /* hkEnum< enum hkaiNavMeshGenerationSettings::EdgeMatchingMetric, hkUint32 > */ m_edgeMatchingMetric;
			hkInt32 m_edgeConnectionIterations;
			hkUint32 /* hkFlags< enum hkaiNavMeshGenerationSettings::ConstructionFlagsBits, hkUint32 > */ m_defaultConstructionProperties;
			hkUint8 /* hkEnum< enum hkaiNavMeshGenerationSettings::CharacterWidthUsage, hkUint8 > */ m_characterWidthUsage;
		};
		const hkaiNavMeshGenerationSettings_DefaultStruct hkaiNavMeshGenerationSettings_Default =
		{
			{HK_OFFSET_OF(hkaiNavMeshGenerationSettings_DefaultStruct,m_maxHorizontalRange),HK_OFFSET_OF(hkaiNavMeshGenerationSettings_DefaultStruct,m_maxVerticalRange),hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkaiNavMeshGenerationSettings_DefaultStruct,m_characterHeight),-1,-1,HK_OFFSET_OF(hkaiNavMeshGenerationSettings_DefaultStruct,m_maxWalkableSlope),-1,-1,-1,HK_OFFSET_OF(hkaiNavMeshGenerationSettings_DefaultStruct,m_maxNumEdgesPerFace),-1,HK_OFFSET_OF(hkaiNavMeshGenerationSettings_DefaultStruct,m_edgeMatchingMetric),HK_OFFSET_OF(hkaiNavMeshGenerationSettings_DefaultStruct,m_edgeConnectionIterations),-1,-1,-1,-1,-1,HK_OFFSET_OF(hkaiNavMeshGenerationSettings_DefaultStruct,m_defaultConstructionProperties),-1,-1,-1,hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkaiNavMeshGenerationSettings_DefaultStruct,m_characterWidthUsage),-1,-1,-1,-1,-1,-1,-1},
			10000.0f,1000.0f,1.75f, HK_REAL_PI / 3.0f ,255,hkaiNavMeshGenerationSettings::ORDER_BY_DISTANCE,2, hkaiNavMeshGenerationSettings::MATERIAL_WALKABLE_AND_CUTTING ,hkaiNavMeshGenerationSettings::BLOCK_EDGES
		};
	}
	hkClass hkaiNavMeshGenerationSettingsClass(
		"hkaiNavMeshGenerationSettings",
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkaiNavMeshGenerationSettingsEnums),
		3,
		reinterpret_cast<const hkClassMember*>(hkaiNavMeshGenerationSettingsClass_Members),
		HK_COUNT_OF(hkaiNavMeshGenerationSettingsClass_Members),
		&hkaiNavMeshGenerationSettings_Default,
		HK_NULL,
		0,
		hkUint32(20)
		);
	static hkInternalClassMember hkaiDefaultNavVolumeCostModifierClass_Members[] =
	{
		{ "cellMaskLookupTable", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::ALIGN_16, 0, HK_NULL },
		{ "costMultiplierLookupTable", HK_NULL, HK_NULL, hkClassMember::TYPE_HALF, hkClassMember::TYPE_VOID, 32, 0, 0, HK_NULL }
	};
	hkClass hkaiDefaultNavVolumeCostModifierClass(
		"hkaiDefaultNavVolumeCostModifier",
		&hkaiNavVolumeCostModifierClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaiDefaultNavVolumeCostModifierClass_Members),
		HK_COUNT_OF(hkaiDefaultNavVolumeCostModifierClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	hkClass hkaiNavMeshQueryMediatorClass(
		"hkaiNavMeshQueryMediator",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkaiReferenceFrameClass_Members[] =
	{
		{ "transform", HK_NULL, HK_NULL, hkClassMember::TYPE_TRANSFORM, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "linearVelocity", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "angularVelocity", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkaiReferenceFrameClass(
		"hkaiReferenceFrame",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaiReferenceFrameClass_Members),
		HK_COUNT_OF(hkaiReferenceFrameClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkaiGraphPathSearchParametersMemoryDefaultsSingleThreadedEnumItems[] =
	{
		{32768, "OPEN_SET_SIZE_SINGLE_THREADED"},
		{147968, "SEARCH_STATE_SIZE_SINGLE_THREADED"},
	};
	static const hkInternalClassEnumItem hkaiGraphPathSearchParametersMemoryDefaultsMultiThreadedEnumItems[] =
	{
		{2048, "OPEN_SET_SIZE_MULTI_THREADED"},
		{9728, "SEARCH_STATE_SIZE_MULTI_THREADED"},
	};
	static const hkInternalClassEnum hkaiGraphPathSearchParametersEnums[] = {
		{"MemoryDefaultsSingleThreaded", hkaiGraphPathSearchParametersMemoryDefaultsSingleThreadedEnumItems, 2, HK_NULL, 0 },
		{"MemoryDefaultsMultiThreaded", hkaiGraphPathSearchParametersMemoryDefaultsMultiThreadedEnumItems, 2, HK_NULL, 0 }
	};
	const hkClassEnum* hkaiGraphPathSearchParametersMemoryDefaultsSingleThreadedEnum = reinterpret_cast<const hkClassEnum*>(&hkaiGraphPathSearchParametersEnums[0]);
	const hkClassEnum* hkaiGraphPathSearchParametersMemoryDefaultsMultiThreadedEnum = reinterpret_cast<const hkClassEnum*>(&hkaiGraphPathSearchParametersEnums[1]);
	static hkInternalClassMember hkaiGraphPathSearchParametersClass_Members[] =
	{
		{ "maxOpenSetSizeBytes", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxSearchStateSizeBytes", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkaiGraphPathSearchParameters_DefaultStruct
		{
			int s_defaultOffsets[2];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
		};
		const hkaiGraphPathSearchParameters_DefaultStruct hkaiGraphPathSearchParameters_Default =
		{
			{hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT},
		};
	}
	hkClass hkaiGraphPathSearchParametersClass(
		"hkaiGraphPathSearchParameters",
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkaiGraphPathSearchParametersEnums),
		2,
		reinterpret_cast<const hkClassMember*>(hkaiGraphPathSearchParametersClass_Members),
		HK_COUNT_OF(hkaiGraphPathSearchParametersClass_Members),
		&hkaiGraphPathSearchParameters_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkaiNavMeshPathRequestInfoClass_Members[] =
	{
		{ "input", &hkaiPathfindingUtilFindPathInputClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "output", &hkaiPathfindingUtilFindPathOutputClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "priority", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "owner", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "markedForDeletion", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkaiNavMeshPathRequestInfoClass(
		"hkaiNavMeshPathRequestInfo",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaiNavMeshPathRequestInfoClass_Members),
		HK_COUNT_OF(hkaiNavMeshPathRequestInfoClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkaiNavVolumePathRequestInfoClass_Members[] =
	{
		{ "input", &hkaiVolumePathfindingUtilFindPathInputClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "output", &hkaiVolumePathfindingUtilFindPathOutputClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "priority", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "owner", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "markedForDeletion", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkaiNavVolumePathRequestInfoClass(
		"hkaiNavVolumePathRequestInfo",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaiNavVolumePathRequestInfoClass_Members),
		HK_COUNT_OF(hkaiNavVolumePathRequestInfoClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkaiWorldPathTypeEnumItems[] =
	{
		{0, "PATH_TYPE_NAVMESH"},
		{1, "PATH_TYPE_NAVVOLUME"},
	};
	static const hkInternalClassEnum hkaiWorldEnums[] = {
		{"PathType", hkaiWorldPathTypeEnumItems, 2, HK_NULL, 0 }
	};
	const hkClassEnum* hkaiWorldPathTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkaiWorldEnums[0]);
	static const hkInternalClassEnumItem hkaiWorldCharacterStepCallbackContextCharacterCallbackTypeEnumItems[] =
	{
		{0, "CALLBACK_PRECHARACTER_STEP"},
		{1, "CALLBACK_POSTCHARACTER_STEP"},
	};
	static const hkInternalClassEnum hkaiWorldCharacterStepCallbackContextEnums[] = {
		{"CharacterCallbackType", hkaiWorldCharacterStepCallbackContextCharacterCallbackTypeEnumItems, 2, HK_NULL, 0 }
	};
	const hkClassEnum* hkaiWorldCharacterStepCallbackContextCharacterCallbackTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkaiWorldCharacterStepCallbackContextEnums[0]);
	static hkInternalClassMember hkaiWorld_CharacterStepCallbackContextClass_Members[] =
	{
		{ "world", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "callbackType", HK_NULL, hkaiWorldCharacterStepCallbackContextCharacterCallbackTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "characters", &hkaiCharacterClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "localSteeringInputs", &hkaiLocalSteeringInputClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkaiWorldCharacterStepCallbackContextClass(
		"hkaiWorldCharacterStepCallbackContext",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkaiWorldCharacterStepCallbackContextEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkaiWorld_CharacterStepCallbackContextClass_Members),
		HK_COUNT_OF(hkaiWorld_CharacterStepCallbackContextClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkaiWorldClass_Members[] =
	{
		{ "up", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "streamingCollection", &hkaiStreamingCollectionClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "cutter", &hkaiNavMeshCutterClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "performValidationChecks", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "dynamicNavMeshMediator", &hkaiDynamicNavMeshQueryMediatorClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "dynamicNavVolumeMediator", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "overlapManager", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "silhouetteMerger", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "silhouetteExtrusion", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "forceSilhouetteUpdates", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "bounds", &hkAabbClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "listeners", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "silhouetteGenerators", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "obstacleGenerators", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "avoidancePairProps", &hkaiAvoidancePairPropertiesClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "navMeshPathRequests", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "navVolumePathRequests", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "isPathRequestArrayLocked", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "maxRequestsPerStep", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxEstimatedIterationsPerStep", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "priorityThreshold", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "numPathRequestsPerJob", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "numBehaviorUpdatesPerJob", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "numCharactersPerAvoidanceJob", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxPathSearchEdgesOut", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxPathSearchPointsOut", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "defaultPathfindingInput", &hkaiPathfindingUtilFindPathInputClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "defaultVolumePathfindingInput", &hkaiVolumePathfindingUtilFindPathInputClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "erosionRadius", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkaiWorld_DefaultStruct
		{
			int s_defaultOffsets[29];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			_hkBool m_performValidationChecks;
		};
		const hkaiWorld_DefaultStruct hkaiWorld_Default =
		{
			{-1,-1,-1,HK_OFFSET_OF(hkaiWorld_DefaultStruct,m_performValidationChecks),-1,-1,-1,-1,-1,hkClassMember::HK_CLASS_ZERO_DEFAULT,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
			true
		};
	}
	hkClass hkaiWorldClass(
		"hkaiWorld",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkaiWorldEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkaiWorldClass_Members),
		HK_COUNT_OF(hkaiWorldClass_Members),
		&hkaiWorld_Default,
		HK_NULL,
		0,
		hkUint32(25)
		);
	static const hkInternalClassEnumItem hkaiNavVolumeConstantsEnumItems[] =
	{
		{-1, "INVALID_CELL_INDEX"},
		{-1, "INVALID_EDGE_INDEX"},
	};
	static const hkInternalClassEnumItem hkaiNavVolumeCellEdgeFlagBitsEnumItems[] =
	{
		{8, "OPPOSITE_EDGE_UNLOADED"},
	};
	static const hkInternalClassEnum hkaiNavVolumeEnums[] = {
		{"Constants", hkaiNavVolumeConstantsEnumItems, 2, HK_NULL, 0 },
		{"CellEdgeFlagBits", hkaiNavVolumeCellEdgeFlagBitsEnumItems, 1, HK_NULL, 0 }
	};
	const hkClassEnum* hkaiNavVolumeConstantsEnum = reinterpret_cast<const hkClassEnum*>(&hkaiNavVolumeEnums[0]);
	const hkClassEnum* hkaiNavVolumeCellEdgeFlagBitsEnum = reinterpret_cast<const hkClassEnum*>(&hkaiNavVolumeEnums[1]);
	static hkInternalClassMember hkaiNavVolume_CellClass_Members[] =
	{
		{ "min", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 3, 0, 0, HK_NULL },
		{ "numEdges", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "max", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 3, 0, 0, HK_NULL },
		{ "startEdgeIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "data", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkaiNavVolumeCellClass(
		"hkaiNavVolumeCell",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaiNavVolume_CellClass_Members),
		HK_COUNT_OF(hkaiNavVolume_CellClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkaiNavVolume_EdgeClass_Members[] =
	{
		{ "flags", HK_NULL, hkaiNavVolumeCellEdgeFlagBitsEnum, hkClassMember::TYPE_FLAGS, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "oppositeCell", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkaiNavVolumeEdgeClass(
		"hkaiNavVolumeEdge",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaiNavVolume_EdgeClass_Members),
		HK_COUNT_OF(hkaiNavVolume_EdgeClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkaiNavVolume_ExternalEdgeInfoClass_Members[] =
	{
		{ "edgeIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "cellIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "oppositeUid", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkaiNavVolumeExternalEdgeInfoClass(
		"hkaiNavVolumeExternalEdgeInfo",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaiNavVolume_ExternalEdgeInfoClass_Members),
		HK_COUNT_OF(hkaiNavVolume_ExternalEdgeInfoClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkaiNavVolumeClass_Members[] =
	{
		{ "cells", &hkaiNavVolumeCellClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "edges", &hkaiNavVolumeEdgeClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "aabb", &hkAabbClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "quantizationScale", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "quantizationOffset", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "res", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 3, 0, 0, HK_NULL },
		{ "externalEdges", &hkaiNavVolumeExternalEdgeInfoClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "streamingDependencies", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT32, 0, 0, 0, HK_NULL },
		{ "sectionUid", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "runtimeId", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	namespace
	{
		struct hkaiNavVolume_DefaultStruct
		{
			int s_defaultOffsets[10];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
		};
		const hkaiNavVolume_DefaultStruct hkaiNavVolume_Default =
		{
			{-1,-1,-1,-1,-1,-1,-1,-1,hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT},
		};
	}
	hkClass hkaiNavVolumeClass(
		"hkaiNavVolume",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkaiNavVolumeEnums),
		2,
		reinterpret_cast<const hkClassMember*>(hkaiNavVolumeClass_Members),
		HK_COUNT_OF(hkaiNavVolumeClass_Members),
		&hkaiNavVolume_Default,
		HK_NULL,
		0,
		hkUint32(7)
		);
	static const hkInternalClassEnumItem hkaiUserEdgeUtilsUserEdgeDirectionEnumItems[] =
	{
		{0, "USER_EDGE_BLOCKED"},
		{1, "USER_EDGE_A_TO_B"},
		{2, "USER_EDGE_B_TO_A"},
		{3, "USER_EDGE_BIDIRECTIONAL"},
	};
	static const hkInternalClassEnumItem hkaiUserEdgeUtilsClearanceResetModeEnumItems[] =
	{
		{0, "RESET_CLEARANCE_CACHE"},
		{1, "DONT_RESET_CLEARANCE_CACHE"},
	};
	static const hkInternalClassEnum hkaiUserEdgeUtilsEnums[] = {
		{"UserEdgeDirection", hkaiUserEdgeUtilsUserEdgeDirectionEnumItems, 4, HK_NULL, 0 },
		{"ClearanceResetMode", hkaiUserEdgeUtilsClearanceResetModeEnumItems, 2, HK_NULL, 0 }
	};
	const hkClassEnum* hkaiUserEdgeUtilsUserEdgeDirectionEnum = reinterpret_cast<const hkClassEnum*>(&hkaiUserEdgeUtilsEnums[0]);
	const hkClassEnum* hkaiUserEdgeUtilsClearanceResetModeEnum = reinterpret_cast<const hkClassEnum*>(&hkaiUserEdgeUtilsEnums[1]);
	static hkInternalClassMember hkaiUserEdgeUtils_ObbClass_Members[] =
	{
		{ "transform", HK_NULL, HK_NULL, hkClassMember::TYPE_TRANSFORM, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "halfExtents", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkaiUserEdgeUtilsObbClass(
		"hkaiUserEdgeUtilsObb",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaiUserEdgeUtils_ObbClass_Members),
		HK_COUNT_OF(hkaiUserEdgeUtils_ObbClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkaiUserEdgeUtils_UserEdgeSetupClass_Members[] =
	{
		{ "obbA", &hkaiUserEdgeUtilsObbClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "obbB", &hkaiUserEdgeUtilsObbClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "userDataA", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "userDataB", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "costAtoB", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "costBtoA", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "direction", HK_NULL, hkaiUserEdgeUtilsUserEdgeDirectionEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "forceAlign", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkaiUserEdgeUtilsUserEdgeSetup_DefaultStruct
		{
			int s_defaultOffsets[8];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			_hkBool m_forceAlign;
		};
		const hkaiUserEdgeUtilsUserEdgeSetup_DefaultStruct hkaiUserEdgeUtilsUserEdgeSetup_Default =
		{
			{-1,-1,-1,-1,-1,-1,-1,HK_OFFSET_OF(hkaiUserEdgeUtilsUserEdgeSetup_DefaultStruct,m_forceAlign)},
			true
		};
	}
	hkClass hkaiUserEdgeUtilsUserEdgeSetupClass(
		"hkaiUserEdgeUtilsUserEdgeSetup",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaiUserEdgeUtils_UserEdgeSetupClass_Members),
		HK_COUNT_OF(hkaiUserEdgeUtils_UserEdgeSetupClass_Members),
		&hkaiUserEdgeUtilsUserEdgeSetup_Default,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkaiUserEdgeUtils_UserEdgePairClass_Members[] =
	{
		{ "x", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "y", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "z", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "meshUidA", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "meshUidB", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "faceA", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "faceB", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "userDataA", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "userDataB", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "costAtoB", HK_NULL, HK_NULL, hkClassMember::TYPE_HALF, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "costBtoA", HK_NULL, HK_NULL, hkClassMember::TYPE_HALF, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "direction", HK_NULL, hkaiUserEdgeUtilsUserEdgeDirectionEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL }
	};
	hkClass hkaiUserEdgeUtilsUserEdgePairClass(
		"hkaiUserEdgeUtilsUserEdgePair",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaiUserEdgeUtils_UserEdgePairClass_Members),
		HK_COUNT_OF(hkaiUserEdgeUtils_UserEdgePairClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hkaiUserEdgeUtilsClass(
		"hkaiUserEdgeUtils",
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkaiUserEdgeUtilsEnums),
		2,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkaiUserEdgeSetupArrayClass_Members[] =
	{
		{ "edgeSetups", &hkaiUserEdgeUtilsUserEdgeSetupClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkaiUserEdgeSetupArrayClass(
		"hkaiUserEdgeSetupArray",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaiUserEdgeSetupArrayClass_Members),
		HK_COUNT_OF(hkaiUserEdgeSetupArrayClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkaiUserEdgePairArrayClass_Members[] =
	{
		{ "edgePairs", &hkaiUserEdgeUtilsUserEdgePairClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkaiUserEdgePairArrayClass(
		"hkaiUserEdgePairArray",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaiUserEdgePairArrayClass_Members),
		HK_COUNT_OF(hkaiUserEdgePairArrayClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkaiInvertedAabbVolumeClass_Members[] =
	{
		{ "aabb", &hkAabbClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "geometry", &hkGeometryClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkaiInvertedAabbVolumeClass(
		"hkaiInvertedAabbVolume",
		&hkaiVolumeClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaiInvertedAabbVolumeClass_Members),
		HK_COUNT_OF(hkaiInvertedAabbVolumeClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkaiNavMeshPathSearchParametersOutputPathTypeEnumItems[] =
	{
		{0, "OUTPUT_PATH_NONE"},
		{1, "OUTPUT_PATH_SMOOTHED_ONLY"},
		{2, "OUTPUT_PATH_SMOOTHED_AND_PROJECTED"},
	};
	static const hkInternalClassEnumItem hkaiNavMeshPathSearchParametersUserEdgeTraversalTestTypeEnumItems[] =
	{
		{0, "USER_EDGE_TRAVERSAL_TEST_DISABLED"},
		{1, "USER_EDGE_TRAVERSAL_TEST_ENABLED"},
	};
	static const hkInternalClassEnumItem hkaiNavMeshPathSearchParametersMemoryDefaultsSingleThreadedEnumItems[] =
	{
		{131072, "OPEN_SET_SIZE_SINGLE_THREADED"},
		{590336, "SEARCH_STATE_SIZE_SINGLE_THREADED"},
		{32768, "HIERARCHY_OPEN_SET_SIZE_SINGLE_THREADED"},
		{147968, "HIERARCHY_SEARCH_STATE_SIZE_SINGLE_THREADED"},
	};
	static const hkInternalClassEnumItem hkaiNavMeshPathSearchParametersMemoryDefaultsMultiThreadedEnumItems[] =
	{
		{8192, "OPEN_SET_SIZE_MULTI_THREADED"},
		{37376, "SEARCH_STATE_SIZE_MULTI_THREADED"},
		{2048, "HIERARCHY_OPEN_SET_SIZE_MULTI_THREADED"},
		{9728, "HIERARCHY_SEARCH_STATE_SIZE_MULTI_THREADED"},
	};
	static const hkInternalClassEnum hkaiNavMeshPathSearchParametersEnums[] = {
		{"OutputPathType", hkaiNavMeshPathSearchParametersOutputPathTypeEnumItems, 3, HK_NULL, 0 },
		{"UserEdgeTraversalTestType", hkaiNavMeshPathSearchParametersUserEdgeTraversalTestTypeEnumItems, 2, HK_NULL, 0 },
		{"MemoryDefaultsSingleThreaded", hkaiNavMeshPathSearchParametersMemoryDefaultsSingleThreadedEnumItems, 4, HK_NULL, 0 },
		{"MemoryDefaultsMultiThreaded", hkaiNavMeshPathSearchParametersMemoryDefaultsMultiThreadedEnumItems, 4, HK_NULL, 0 }
	};
	const hkClassEnum* hkaiNavMeshPathSearchParametersOutputPathTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkaiNavMeshPathSearchParametersEnums[0]);
	const hkClassEnum* hkaiNavMeshPathSearchParametersUserEdgeTraversalTestTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkaiNavMeshPathSearchParametersEnums[1]);
	const hkClassEnum* hkaiNavMeshPathSearchParametersMemoryDefaultsSingleThreadedEnum = reinterpret_cast<const hkClassEnum*>(&hkaiNavMeshPathSearchParametersEnums[2]);
	const hkClassEnum* hkaiNavMeshPathSearchParametersMemoryDefaultsMultiThreadedEnum = reinterpret_cast<const hkClassEnum*>(&hkaiNavMeshPathSearchParametersEnums[3]);
	static hkInternalClassMember hkaiNavMeshPathSearchParametersClass_Members[] =
	{
		{ "up", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "costModifier", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "validateInputs", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "outputPathType", HK_NULL, hkaiNavMeshPathSearchParametersOutputPathTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "checkForLineOfSight", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "useHierarchicalHeuristic", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "userEdgeTraversalTestType", HK_NULL, hkaiNavMeshPathSearchParametersUserEdgeTraversalTestTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "heuristicWeight", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "simpleRadiusThreshold", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxOpenSetSizeBytes", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxSearchStateSizeBytes", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxHierarchyOpenSetSizeBytes", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxHierarchySearchStateSizeBytes", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkaiNavMeshPathSearchParameters_DefaultStruct
		{
			int s_defaultOffsets[13];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			_hkBool m_validateInputs;
			hkUint8 /* hkEnum< enum hkaiNavMeshPathSearchParameters::OutputPathType, hkUint8 > */ m_outputPathType;
			_hkBool m_checkForLineOfSight;
			hkUint8 /* hkEnum< enum hkaiNavMeshPathSearchParameters::UserEdgeTraversalTestType, hkUint8 > */ m_userEdgeTraversalTestType;
			hkReal m_heuristicWeight;
			hkReal m_simpleRadiusThreshold;
		};
		const hkaiNavMeshPathSearchParameters_DefaultStruct hkaiNavMeshPathSearchParameters_Default =
		{
			{-1,-1,HK_OFFSET_OF(hkaiNavMeshPathSearchParameters_DefaultStruct,m_validateInputs),HK_OFFSET_OF(hkaiNavMeshPathSearchParameters_DefaultStruct,m_outputPathType),HK_OFFSET_OF(hkaiNavMeshPathSearchParameters_DefaultStruct,m_checkForLineOfSight),hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkaiNavMeshPathSearchParameters_DefaultStruct,m_userEdgeTraversalTestType),HK_OFFSET_OF(hkaiNavMeshPathSearchParameters_DefaultStruct,m_heuristicWeight),HK_OFFSET_OF(hkaiNavMeshPathSearchParameters_DefaultStruct,m_simpleRadiusThreshold),hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT},
			true,hkaiNavMeshPathSearchParameters::OUTPUT_PATH_SMOOTHED_AND_PROJECTED,true,hkaiNavMeshPathSearchParameters::USER_EDGE_TRAVERSAL_TEST_DISABLED,1.0f,0.01f
		};
	}
	hkClass hkaiNavMeshPathSearchParametersClass(
		"hkaiNavMeshPathSearchParameters",
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkaiNavMeshPathSearchParametersEnums),
		4,
		reinterpret_cast<const hkClassMember*>(hkaiNavMeshPathSearchParametersClass_Members),
		HK_COUNT_OF(hkaiNavMeshPathSearchParametersClass_Members),
		&hkaiNavMeshPathSearchParameters_Default,
		HK_NULL,
		0,
		hkUint32(3)
		);
	static hkInternalClassMember hkaiAgentTraversalInfoClass_Members[] =
	{
		{ "diameter", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "filterInfo", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkaiAgentTraversalInfoClass(
		"hkaiAgentTraversalInfo",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaiAgentTraversalInfoClass_Members),
		HK_COUNT_OF(hkaiAgentTraversalInfoClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static const hkInternalClassEnumItem hkaiNavMeshCutterClearanceResetMethodEnumItems[] =
	{
		{0, "CLEARANCE_RESET_ALL"},
		{1, "CLEARANCE_RESET_MEDIATOR"},
		{2, "CLEARANCE_RESET_FLOODFILL"},
	};
	static const hkInternalClassEnum hkaiNavMeshCutterEnums[] = {
		{"ClearanceResetMethod", hkaiNavMeshCutterClearanceResetMethodEnumItems, 3, HK_NULL, 0 }
	};
	const hkClassEnum* hkaiNavMeshCutterClearanceResetMethodEnum = reinterpret_cast<const hkClassEnum*>(&hkaiNavMeshCutterEnums[0]);
	static hkInternalClassMember hkaiNavMeshCutter_SavedConnectivityClass_Members[] =
	{
		{ "storage", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hkaiNavMeshCutterSavedConnectivityClass(
		"hkaiNavMeshCutterSavedConnectivity",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaiNavMeshCutter_SavedConnectivityClass_Members),
		HK_COUNT_OF(hkaiNavMeshCutter_SavedConnectivityClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkaiNavMeshCutter_MeshInfoClass_Members[] =
	{
		{ "originalNumFaces", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "originalNumEdges", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "originalNumVertices", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "magic", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_INT32, 0, 0, 0, HK_NULL }
	};
	hkClass hkaiNavMeshCutterMeshInfoClass(
		"hkaiNavMeshCutterMeshInfo",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaiNavMeshCutter_MeshInfoClass_Members),
		HK_COUNT_OF(hkaiNavMeshCutter_MeshInfoClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkaiNavMeshCutterClass_Members[] =
	{
		{ "meshInfos", &hkaiNavMeshCutterMeshInfoClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "connectivityInfo", &hkaiNavMeshCutterSavedConnectivityClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "streamingCollection", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "forceRecutFaceKeys", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "up", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "edgeMatchParams", &hkaiNavMeshGenerationSettingsEdgeMatchingParametersClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "cutEdgeTolerance", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "minEdgeMatchingLength", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "performValidationChecks", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "clearanceResetMethod", HK_NULL, hkaiNavMeshCutterClearanceResetMethodEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkaiNavMeshCutter_DefaultStruct
		{
			int s_defaultOffsets[10];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkReal m_cutEdgeTolerance;
			hkReal m_minEdgeMatchingLength;
			_hkBool m_performValidationChecks;
			hkUint8 /* hkEnum< enum hkaiNavMeshCutter::ClearanceResetMethod, hkUint8 > */ m_clearanceResetMethod;
		};
		const hkaiNavMeshCutter_DefaultStruct hkaiNavMeshCutter_Default =
		{
			{-1,-1,-1,-1,-1,-1,HK_OFFSET_OF(hkaiNavMeshCutter_DefaultStruct,m_cutEdgeTolerance),HK_OFFSET_OF(hkaiNavMeshCutter_DefaultStruct,m_minEdgeMatchingLength),HK_OFFSET_OF(hkaiNavMeshCutter_DefaultStruct,m_performValidationChecks),HK_OFFSET_OF(hkaiNavMeshCutter_DefaultStruct,m_clearanceResetMethod)},
			1e-4f,.01f,true,hkaiNavMeshCutter::CLEARANCE_RESET_ALL
		};
	}
	hkClass hkaiNavMeshCutterClass(
		"hkaiNavMeshCutter",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkaiNavMeshCutterEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkaiNavMeshCutterClass_Members),
		HK_COUNT_OF(hkaiNavMeshCutterClass_Members),
		&hkaiNavMeshCutter_Default,
		HK_NULL,
		0,
		hkUint32(10)
		);
	static const hkInternalClassEnumItem hkaiCharacterStateEnumItems[] =
	{
		{0, "STATE_NEEDS_NEW_PATH"},
		{1, "STATE_FOLLOWING_PATH"},
		{2, "STATE_SLOWING_TO_GOAL"},
		{3, "STATE_GOAL_REACHED"},
		{4, "STATE_PATH_FAILED"},
		{5, "STATE_WANDERED_OFF_PATH"},
	};
	static const hkInternalClassEnumItem hkaiCharacterMovementStateEnumItems[] =
	{
		{0, "MOVEMENT_STATE_NAVMESH"},
		{1, "MOVEMENT_STATE_NAVVOLUME"},
	};
	static const hkInternalClassEnumItem hkaiCharacterAvoidanceEnabledMaskBitsEnumItems[] =
	{
		{1, "AVOID_BOUNDARIES"},
		{2, "AVOID_CHARACTERS"},
		{4, "AVOID_OBSTACLES"},
		{0, "AVOID_NONE"},
		{7, "AVOID_ALL"},
	};
	static const hkInternalClassEnumItem hkaiCharacterAvoidanceStateEnumItems[] =
	{
		{0, "AVOIDANCE_SUCCESS"},
		{1, "AVOIDANCE_FAILURE"},
	};
	static const hkInternalClassEnum hkaiCharacterEnums[] = {
		{"State", hkaiCharacterStateEnumItems, 6, HK_NULL, 0 },
		{"MovementState", hkaiCharacterMovementStateEnumItems, 2, HK_NULL, 0 },
		{"AvoidanceEnabledMaskBits", hkaiCharacterAvoidanceEnabledMaskBitsEnumItems, 5, HK_NULL, 0 },
		{"AvoidanceState", hkaiCharacterAvoidanceStateEnumItems, 2, HK_NULL, 0 }
	};
	const hkClassEnum* hkaiCharacterStateEnum = reinterpret_cast<const hkClassEnum*>(&hkaiCharacterEnums[0]);
	const hkClassEnum* hkaiCharacterMovementStateEnum = reinterpret_cast<const hkClassEnum*>(&hkaiCharacterEnums[1]);
	const hkClassEnum* hkaiCharacterAvoidanceEnabledMaskBitsEnum = reinterpret_cast<const hkClassEnum*>(&hkaiCharacterEnums[2]);
	const hkClassEnum* hkaiCharacterAvoidanceStateEnum = reinterpret_cast<const hkClassEnum*>(&hkaiCharacterEnums[3]);
	static hkInternalClassMember hkaiCharacterClass_Members[] =
	{
		{ "userData", HK_NULL, HK_NULL, hkClassMember::TYPE_ULONG, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "position", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "forward", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "velocity", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "currentNavMeshFace", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "radius", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "desiredSpeed", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "localSensorAabb", &hkAabbClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "costModifier", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "volumeCostModifier", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "hitFilter", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "agentFilterInfo", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "avoidanceProperties", &hkaiAvoidanceSolverAvoidancePropertiesClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "avoidanceState", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "agentPriority", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "avoidanceType", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "avoidanceEnabledMask", HK_NULL, hkaiCharacterAvoidanceEnabledMaskBitsEnum, hkClassMember::TYPE_FLAGS, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "state", HK_NULL, hkaiCharacterStateEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT32, 0, 0, 0, HK_NULL },
		{ "movementState", HK_NULL, hkaiCharacterMovementStateEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT32, 0, 0, 0, HK_NULL },
		{ "characterBehaviorListener", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	namespace
	{
		struct hkaiCharacter_DefaultStruct
		{
			int s_defaultOffsets[20];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkUint32 m_agentPriority;
			hkUint16 m_avoidanceType;
			hkUint8 /* hkFlags< enum hkaiCharacter::AvoidanceEnabledMaskBits, hkUint8 > */ m_avoidanceEnabledMask;
		};
		const hkaiCharacter_DefaultStruct hkaiCharacter_Default =
		{
			{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,hkClassMember::HK_CLASS_ZERO_DEFAULT,-1,-1,HK_OFFSET_OF(hkaiCharacter_DefaultStruct,m_agentPriority),HK_OFFSET_OF(hkaiCharacter_DefaultStruct,m_avoidanceType),HK_OFFSET_OF(hkaiCharacter_DefaultStruct,m_avoidanceEnabledMask),-1,-1,-1},
			1,1, hkaiCharacter::AVOID_ALL 
		};
	}
	hkClass hkaiCharacterClass(
		"hkaiCharacter",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkaiCharacterEnums),
		4,
		reinterpret_cast<const hkClassMember*>(hkaiCharacterClass_Members),
		HK_COUNT_OF(hkaiCharacterClass_Members),
		&hkaiCharacter_Default,
		HK_NULL,
		0,
		hkUint32(21)
		);
	static hkInternalClassMember hkaiNavMeshGenerationSnapshotClass_Members[] =
	{
		{ "geometry", &hkGeometryClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "settings", &hkaiNavMeshGenerationSettingsClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkaiNavMeshGenerationSnapshotClass(
		"hkaiNavMeshGenerationSnapshot",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaiNavMeshGenerationSnapshotClass_Members),
		HK_COUNT_OF(hkaiNavMeshGenerationSnapshotClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkaiDefaultNavMeshCostModifierClass_Members[] =
	{
		{ "edgeMaskLookupTable", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 32, 0|hkClassMember::ALIGN_16, 0, HK_NULL },
		{ "maxCostPenalty", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkaiDefaultNavMeshCostModifier_DefaultStruct
		{
			int s_defaultOffsets[2];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkReal m_maxCostPenalty;
		};
		const hkaiDefaultNavMeshCostModifier_DefaultStruct hkaiDefaultNavMeshCostModifier_Default =
		{
			{-1,HK_OFFSET_OF(hkaiDefaultNavMeshCostModifier_DefaultStruct,m_maxCostPenalty)},
			1.0f
		};
	}
	hkClass hkaiDefaultNavMeshCostModifierClass(
		"hkaiDefaultNavMeshCostModifier",
		&hkaiNavMeshCostModifierClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaiDefaultNavMeshCostModifierClass_Members),
		HK_COUNT_OF(hkaiDefaultNavMeshCostModifierClass_Members),
		&hkaiDefaultNavMeshCostModifier_Default,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkaiPlaneVolumeClass_Members[] =
	{
		{ "planes", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VECTOR4, 0, 0, 0, HK_NULL },
		{ "geometry", &hkGeometryClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkaiPlaneVolumeClass(
		"hkaiPlaneVolume",
		&hkaiVolumeClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaiPlaneVolumeClass_Members),
		HK_COUNT_OF(hkaiPlaneVolumeClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkaiNavMeshCostModifierCostModifierTypeEnumItems[] =
	{
		{0, "COST_MODIFIER_DEFAULT"},
		{1, "COST_MODIFIER_USER"},
	};
	static const hkInternalClassEnumItem hkaiNavMeshCostModifierQueryTypeEnumItems[] =
	{
		{1, "QUERY_TYPE_ASTAR"},
		{2, "QUERY_TYPE_LINE_OF_SIGHT"},
		{4, "QUERY_TYPE_LOCAL_STEERING"},
		{8, "QUERY_TYPE_USER"},
		{16, "QUERY_START_POINT"},
		{32, "QUERY_INTERMEDIATE_POINT"},
		{64, "QUERY_END_POINT"},
	};
	static const hkInternalClassEnum hkaiNavMeshCostModifierEnums[] = {
		{"CostModifierType", hkaiNavMeshCostModifierCostModifierTypeEnumItems, 2, HK_NULL, 0 },
		{"QueryType", hkaiNavMeshCostModifierQueryTypeEnumItems, 7, HK_NULL, 0 }
	};
	const hkClassEnum* hkaiNavMeshCostModifierCostModifierTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkaiNavMeshCostModifierEnums[0]);
	const hkClassEnum* hkaiNavMeshCostModifierQueryTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkaiNavMeshCostModifierEnums[1]);
	static hkInternalClassMember hkaiNavMeshCostModifierClass_Members[] =
	{
		{ "type", HK_NULL, hkaiNavMeshCostModifierCostModifierTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL }
	};
	hkClass hkaiNavMeshCostModifierClass(
		"hkaiNavMeshCostModifier",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkaiNavMeshCostModifierEnums),
		2,
		reinterpret_cast<const hkClassMember*>(hkaiNavMeshCostModifierClass_Members),
		HK_COUNT_OF(hkaiNavMeshCostModifierClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(2)
		);
	static const hkInternalClassEnumItem hkaiAstarOutputParametersSearchStatusEnumItems[] =
	{
		{0, "SEARCH_IN_PROGRESS"},
		{1, "SEARCH_SUCCEEDED"},
		{2, "SEARCH_UNREACHABLE"},
		{3, "SEARCH_TERMINATED"},
		{4, "SEARCH_SUCCEEDED_BUT_RESULTS_TRUNCATED"},
		{5, "SEARCH_INVALID"},
	};
	static const hkInternalClassEnum hkaiAstarOutputParametersEnums[] = {
		{"SearchStatus", hkaiAstarOutputParametersSearchStatusEnumItems, 6, HK_NULL, 0 }
	};
	const hkClassEnum* hkaiAstarOutputParametersSearchStatusEnum = reinterpret_cast<const hkClassEnum*>(&hkaiAstarOutputParametersEnums[0]);
	static hkInternalClassMember hkaiAstarOutputParametersClass_Members[] =
	{
		{ "numIterations", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::ALIGN_16, 0, HK_NULL },
		{ "goalIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "status", HK_NULL, hkaiAstarOutputParametersSearchStatusEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL }
	};
	hkClass hkaiAstarOutputParametersClass(
		"hkaiAstarOutputParameters",
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkaiAstarOutputParametersEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkaiAstarOutputParametersClass_Members),
		HK_COUNT_OF(hkaiAstarOutputParametersClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkaiDynamicNavMeshQueryMediatorClass_Members[] =
	{
		{ "collection", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "aabbTree", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "cutter", &hkaiNavMeshCutterClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "cutAabbTolerance", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkaiDynamicNavMeshQueryMediator_DefaultStruct
		{
			int s_defaultOffsets[4];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkReal m_cutAabbTolerance;
		};
		const hkaiDynamicNavMeshQueryMediator_DefaultStruct hkaiDynamicNavMeshQueryMediator_Default =
		{
			{-1,-1,-1,HK_OFFSET_OF(hkaiDynamicNavMeshQueryMediator_DefaultStruct,m_cutAabbTolerance)},
			.05f
		};
	}
	hkClass hkaiDynamicNavMeshQueryMediatorClass(
		"hkaiDynamicNavMeshQueryMediator",
		&hkaiNavMeshQueryMediatorClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaiDynamicNavMeshQueryMediatorClass_Members),
		HK_COUNT_OF(hkaiDynamicNavMeshQueryMediatorClass_Members),
		&hkaiDynamicNavMeshQueryMediator_Default,
		HK_NULL,
		0,
		hkUint32(3)
		);
	static const hkInternalClassEnumItem hkaiNavVolumeCostModifierCostModifierTypeEnumItems[] =
	{
		{0, "COST_MODIFIER_DEFAULT"},
		{1, "COST_MODIFIER_USER"},
	};
	static const hkInternalClassEnumItem hkaiNavVolumeCostModifierQueryTypeEnumItems[] =
	{
		{1, "QUERY_TYPE_ASTAR"},
		{2, "QUERY_TYPE_LINE_OF_SIGHT"},
		{8, "QUERY_TYPE_USER"},
		{16, "QUERY_START_POINT"},
		{32, "QUERY_INTERMEDIATE_POINT"},
		{64, "QUERY_END_POINT"},
	};
	static const hkInternalClassEnum hkaiNavVolumeCostModifierEnums[] = {
		{"CostModifierType", hkaiNavVolumeCostModifierCostModifierTypeEnumItems, 2, HK_NULL, 0 },
		{"QueryType", hkaiNavVolumeCostModifierQueryTypeEnumItems, 6, HK_NULL, 0 }
	};
	const hkClassEnum* hkaiNavVolumeCostModifierCostModifierTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkaiNavVolumeCostModifierEnums[0]);
	const hkClassEnum* hkaiNavVolumeCostModifierQueryTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkaiNavVolumeCostModifierEnums[1]);
	static hkInternalClassMember hkaiNavVolumeCostModifierClass_Members[] =
	{
		{ "type", HK_NULL, hkaiNavVolumeCostModifierCostModifierTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL }
	};
	hkClass hkaiNavVolumeCostModifierClass(
		"hkaiNavVolumeCostModifier",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkaiNavVolumeCostModifierEnums),
		2,
		reinterpret_cast<const hkClassMember*>(hkaiNavVolumeCostModifierClass_Members),
		HK_COUNT_OF(hkaiNavVolumeCostModifierClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkaiStreamingCollection_InstanceInfoClass_Members[] =
	{
		{ "instancePtr", &hkaiNavMeshInstanceClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "volumePtr", &hkaiNavVolumeClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "clusterGraph", &hkaiDirectedGraphExplicitCostClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "mediator", &hkaiNavMeshQueryMediatorClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "volumeMediator", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "treeNode", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hkaiStreamingCollectionInstanceInfoClass(
		"hkaiStreamingCollectionInstanceInfo",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaiStreamingCollection_InstanceInfoClass_Members),
		HK_COUNT_OF(hkaiStreamingCollection_InstanceInfoClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkaiStreamingCollectionClass_Members[] =
	{
		{ "isTemporary", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "tree", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "instances", &hkaiStreamingCollectionInstanceInfoClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkaiStreamingCollectionClass(
		"hkaiStreamingCollection",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaiStreamingCollectionClass_Members),
		HK_COUNT_OF(hkaiStreamingCollectionClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static const hkInternalClassEnumItem hkaiPathfindingUtilNearestFeatureTypeEnumItems[] =
	{
		{0, "CALLBACK_EDGE"},
		{1, "CALLBACK_FACE"},
	};
	static const hkInternalClassEnum hkaiPathfindingUtilEnums[] = {
		{"NearestFeatureType", hkaiPathfindingUtilNearestFeatureTypeEnumItems, 2, HK_NULL, 0 }
	};
	const hkClassEnum* hkaiPathfindingUtilNearestFeatureTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkaiPathfindingUtilEnums[0]);
	static hkInternalClassMember hkaiPathfindingUtil_FindPathInputClass_Members[] =
	{
		{ "startPoint", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "goalPoints", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VECTOR4, 0, 0, 0, HK_NULL },
		{ "startFaceKey", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "goalFaceKeys", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT32, 0, 0, 0, HK_NULL },
		{ "maxNumberOfIterations", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "agentInfo", &hkaiAgentTraversalInfoClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "searchSphereRadius", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "searchCapsuleRadius", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "searchParameters", &hkaiNavMeshPathSearchParametersClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "openSetBuffer", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "searchStateBuffer", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "hierarchyOpenSetBuffer", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "hierarchySearchStateBuffer", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	namespace
	{
		struct hkaiPathfindingUtilFindPathInput_DefaultStruct
		{
			int s_defaultOffsets[13];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkInt32 m_maxNumberOfIterations;
			hkReal m_searchSphereRadius;
			hkReal m_searchCapsuleRadius;
		};
		const hkaiPathfindingUtilFindPathInput_DefaultStruct hkaiPathfindingUtilFindPathInput_Default =
		{
			{-1,-1,-1,-1,HK_OFFSET_OF(hkaiPathfindingUtilFindPathInput_DefaultStruct,m_maxNumberOfIterations),-1,HK_OFFSET_OF(hkaiPathfindingUtilFindPathInput_DefaultStruct,m_searchSphereRadius),HK_OFFSET_OF(hkaiPathfindingUtilFindPathInput_DefaultStruct,m_searchCapsuleRadius),-1,-1,-1,-1,-1},
			100000,-1.0f,-1.0f
		};
	}
	hkClass hkaiPathfindingUtilFindPathInputClass(
		"hkaiPathfindingUtilFindPathInput",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaiPathfindingUtil_FindPathInputClass_Members),
		HK_COUNT_OF(hkaiPathfindingUtil_FindPathInputClass_Members),
		&hkaiPathfindingUtilFindPathInput_Default,
		HK_NULL,
		0,
		hkUint32(9)
		);
	static hkInternalClassMember hkaiPathfindingUtil_FindPathOutputClass_Members[] =
	{
		{ "visitedEdges", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT32, 0, 0, 0, HK_NULL },
		{ "pathOut", &hkaiPathPathPointClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "outputParameters", &hkaiAstarOutputParametersClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkaiPathfindingUtilFindPathOutputClass(
		"hkaiPathfindingUtilFindPathOutput",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaiPathfindingUtil_FindPathOutputClass_Members),
		HK_COUNT_OF(hkaiPathfindingUtil_FindPathOutputClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkaiPathfindingUtil_FindGraphPathInputClass_Members[] =
	{
		{ "startNodeKey", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "goalNodeKey", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxNumberOfIterations", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "searchParameters", &hkaiGraphPathSearchParametersClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "openSetBuffer", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "searchStateBuffer", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	namespace
	{
		struct hkaiPathfindingUtilFindGraphPathInput_DefaultStruct
		{
			int s_defaultOffsets[6];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkInt32 m_maxNumberOfIterations;
		};
		const hkaiPathfindingUtilFindGraphPathInput_DefaultStruct hkaiPathfindingUtilFindGraphPathInput_Default =
		{
			{-1,-1,HK_OFFSET_OF(hkaiPathfindingUtilFindGraphPathInput_DefaultStruct,m_maxNumberOfIterations),-1,-1,-1},
			100000
		};
	}
	hkClass hkaiPathfindingUtilFindGraphPathInputClass(
		"hkaiPathfindingUtilFindGraphPathInput",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaiPathfindingUtil_FindGraphPathInputClass_Members),
		HK_COUNT_OF(hkaiPathfindingUtil_FindGraphPathInputClass_Members),
		&hkaiPathfindingUtilFindGraphPathInput_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hkaiPathfindingUtilClass(
		"hkaiPathfindingUtil",
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkaiPathfindingUtilEnums),
		1,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkaiVolumePathfindingUtil_FindPathInputClass_Members[] =
	{
		{ "startPoint", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "goalPoints", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VECTOR4, 0, 0, 0, HK_NULL },
		{ "startCellKey", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "goalCellKeys", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT32, 0, 0, 0, HK_NULL },
		{ "maxNumberOfIterations", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "agentInfo", &hkaiAgentTraversalInfoClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "searchParameters", &hkaiNavVolumePathSearchParametersClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "openSetBuffer", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "searchStateBuffer", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hkaiVolumePathfindingUtilFindPathInputClass(
		"hkaiVolumePathfindingUtilFindPathInput",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaiVolumePathfindingUtil_FindPathInputClass_Members),
		HK_COUNT_OF(hkaiVolumePathfindingUtil_FindPathInputClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(6)
		);
	static hkInternalClassMember hkaiVolumePathfindingUtil_FindPathOutputClass_Members[] =
	{
		{ "visitedCells", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT32, 0, 0, 0, HK_NULL },
		{ "pathOut", &hkaiPathPathPointClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "outputParameters", &hkaiAstarOutputParametersClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkaiVolumePathfindingUtilFindPathOutputClass(
		"hkaiVolumePathfindingUtilFindPathOutput",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaiVolumePathfindingUtil_FindPathOutputClass_Members),
		HK_COUNT_OF(hkaiVolumePathfindingUtil_FindPathOutputClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hkaiVolumePathfindingUtilClass(
		"hkaiVolumePathfindingUtil",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkaiPathPathPointBitsEnumItems[] =
	{
		{1, "EDGE_TYPE_USER_START"},
		{2, "EDGE_TYPE_USER_END"},
		{4, "EDGE_TYPE_SEGMENT_START"},
		{8, "EDGE_TYPE_SEGMENT_END"},
	};
	static const hkInternalClassEnumItem hkaiPathReferenceFrameEnumItems[] =
	{
		{0, "REFERENCE_FRAME_WORLD"},
		{1, "REFERENCE_FRAME_SECTION_LOCAL"},
		{2, "REFERENCE_FRAME_SECTION_FIXED"},
	};
	static const hkInternalClassEnum hkaiPathEnums[] = {
		{"PathPointBits", hkaiPathPathPointBitsEnumItems, 4, HK_NULL, 0 },
		{"ReferenceFrame", hkaiPathReferenceFrameEnumItems, 3, HK_NULL, 0 }
	};
	const hkClassEnum* hkaiPathPathPointBitsEnum = reinterpret_cast<const hkClassEnum*>(&hkaiPathEnums[0]);
	const hkClassEnum* hkaiPathReferenceFrameEnum = reinterpret_cast<const hkClassEnum*>(&hkaiPathEnums[1]);
	static hkInternalClassMember hkaiPath_PathPointClass_Members[] =
	{
		{ "position", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "userEdgeData", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "sectionId", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "flags", HK_NULL, hkaiPathPathPointBitsEnum, hkClassMember::TYPE_FLAGS, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL }
	};
	hkClass hkaiPathPathPointClass(
		"hkaiPathPathPoint",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaiPath_PathPointClass_Members),
		HK_COUNT_OF(hkaiPath_PathPointClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(2)
		);
	static hkInternalClassMember hkaiPathClass_Members[] =
	{
		{ "points", &hkaiPathPathPointClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "referenceFrame", HK_NULL, hkaiPathReferenceFrameEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkaiPath_DefaultStruct
		{
			int s_defaultOffsets[2];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
		};
		const hkaiPath_DefaultStruct hkaiPath_Default =
		{
			{-1,hkClassMember::HK_CLASS_ZERO_DEFAULT},
		};
	}
	hkClass hkaiPathClass(
		"hkaiPath",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkaiPathEnums),
		2,
		reinterpret_cast<const hkClassMember*>(hkaiPathClass_Members),
		HK_COUNT_OF(hkaiPathClass_Members),
		&hkaiPath_Default,
		HK_NULL,
		0,
		hkUint32(10)
		);
	static hkInternalClassMember hkaiPathFollowingPropertiesClass_Members[] =
	{
		{ "repathDistance", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "searchPathLimit", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "desiredSpeedAtEnd", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "goalDistTolerance", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkaiPathFollowingProperties_DefaultStruct
		{
			int s_defaultOffsets[4];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkReal m_repathDistance;
			hkReal m_searchPathLimit;
			hkReal m_goalDistTolerance;
		};
		const hkaiPathFollowingProperties_DefaultStruct hkaiPathFollowingProperties_Default =
		{
			{HK_OFFSET_OF(hkaiPathFollowingProperties_DefaultStruct,m_repathDistance),HK_OFFSET_OF(hkaiPathFollowingProperties_DefaultStruct,m_searchPathLimit),hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkaiPathFollowingProperties_DefaultStruct,m_goalDistTolerance)},
			2.0f,5.0f,0.25f
		};
	}
	hkClass hkaiPathFollowingPropertiesClass(
		"hkaiPathFollowingProperties",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaiPathFollowingPropertiesClass_Members),
		HK_COUNT_OF(hkaiPathFollowingPropertiesClass_Members),
		&hkaiPathFollowingProperties_Default,
		HK_NULL,
		0,
		hkUint32(4)
		);
	static hkInternalClassMember hkaiNavVolumeGenerationSnapshotClass_Members[] =
	{
		{ "geometry", &hkGeometryClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "settings", &hkaiNavVolumeGenerationSettingsClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkaiNavVolumeGenerationSnapshotClass(
		"hkaiNavVolumeGenerationSnapshot",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaiNavVolumeGenerationSnapshotClass_Members),
		HK_COUNT_OF(hkaiNavVolumeGenerationSnapshotClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	hkClass hkaiVolumeClass(
		"hkaiVolume",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkaiStreamingManager_SectionInfoClass_Members[] =
	{
		{ "uid", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "referenceCount", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "meshPtr", &hkaiNavMeshClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "meshGraphPtr", &hkaiDirectedGraphExplicitCostClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "volumePtr", &hkaiNavVolumeClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkaiStreamingManagerSectionInfoClass(
		"hkaiStreamingManagerSectionInfo",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaiStreamingManager_SectionInfoClass_Members),
		HK_COUNT_OF(hkaiStreamingManager_SectionInfoClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(5)
		);
	static hkInternalClassMember hkaiStreamingManagerClass_Members[] =
	{
		{ "sections", &hkaiStreamingManagerSectionInfoClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkaiStreamingManagerClass(
		"hkaiStreamingManager",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaiStreamingManagerClass_Members),
		HK_COUNT_OF(hkaiStreamingManagerClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(6)
		);
	static const hkInternalClassEnumItem hkaiNavVolumePathSearchParametersMemoryDefaultsSingleThreadedEnumItems[] =
	{
		{131072, "OPEN_SET_SIZE_SINGLE_THREADED"},
		{590336, "SEARCH_STATE_SIZE_SINGLE_THREADED"},
	};
	static const hkInternalClassEnumItem hkaiNavVolumePathSearchParametersMemoryDefaultsMultiThreadedEnumItems[] =
	{
		{8192, "OPEN_SET_SIZE_MULTI_THREADED"},
		{37376, "SEARCH_STATE_SIZE_MULTI_THREADED"},
	};
	static const hkInternalClassEnum hkaiNavVolumePathSearchParametersEnums[] = {
		{"MemoryDefaultsSingleThreaded", hkaiNavVolumePathSearchParametersMemoryDefaultsSingleThreadedEnumItems, 2, HK_NULL, 0 },
		{"MemoryDefaultsMultiThreaded", hkaiNavVolumePathSearchParametersMemoryDefaultsMultiThreadedEnumItems, 2, HK_NULL, 0 }
	};
	const hkClassEnum* hkaiNavVolumePathSearchParametersMemoryDefaultsSingleThreadedEnum = reinterpret_cast<const hkClassEnum*>(&hkaiNavVolumePathSearchParametersEnums[0]);
	const hkClassEnum* hkaiNavVolumePathSearchParametersMemoryDefaultsMultiThreadedEnum = reinterpret_cast<const hkClassEnum*>(&hkaiNavVolumePathSearchParametersEnums[1]);
	static hkInternalClassMember hkaiNavVolumePathSearchParametersClass_Members[] =
	{
		{ "up", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "costModifier", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "checkForLineOfSight", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "heuristicWeight", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxOpenSetSizeBytes", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxSearchStateSizeBytes", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkaiNavVolumePathSearchParameters_DefaultStruct
		{
			int s_defaultOffsets[6];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			_hkBool m_checkForLineOfSight;
			hkReal m_heuristicWeight;
		};
		const hkaiNavVolumePathSearchParameters_DefaultStruct hkaiNavVolumePathSearchParameters_Default =
		{
			{-1,-1,HK_OFFSET_OF(hkaiNavVolumePathSearchParameters_DefaultStruct,m_checkForLineOfSight),HK_OFFSET_OF(hkaiNavVolumePathSearchParameters_DefaultStruct,m_heuristicWeight),hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT},
			true,1.0f
		};
	}
	hkClass hkaiNavVolumePathSearchParametersClass(
		"hkaiNavVolumePathSearchParameters",
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkaiNavVolumePathSearchParametersEnums),
		2,
		reinterpret_cast<const hkClassMember*>(hkaiNavVolumePathSearchParametersClass_Members),
		HK_COUNT_OF(hkaiNavVolumePathSearchParametersClass_Members),
		&hkaiNavVolumePathSearchParameters_Default,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static const hkInternalClassEnumItem hkaiDirectedGraphExplicitCostEdgeBitsEnumItems[] =
	{
		{1, "EDGE_OPPOSITE_IS_UNLOADED"},
		{2, "EDGE_IS_USER"},
	};
	static const hkInternalClassEnum hkaiDirectedGraphExplicitCostEnums[] = {
		{"EdgeBits", hkaiDirectedGraphExplicitCostEdgeBitsEnumItems, 2, HK_NULL, 0 }
	};
	const hkClassEnum* hkaiDirectedGraphExplicitCostEdgeBitsEnum = reinterpret_cast<const hkClassEnum*>(&hkaiDirectedGraphExplicitCostEnums[0]);
	static hkInternalClassMember hkaiDirectedGraphExplicitCost_NodeClass_Members[] =
	{
		{ "edgeStartIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "numEdges", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkaiDirectedGraphExplicitCostNodeClass(
		"hkaiDirectedGraphExplicitCostNode",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaiDirectedGraphExplicitCost_NodeClass_Members),
		HK_COUNT_OF(hkaiDirectedGraphExplicitCost_NodeClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkaiDirectedGraphExplicitCost_EdgeClass_Members[] =
	{
		{ "cost", HK_NULL, HK_NULL, hkClassMember::TYPE_HALF, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "flags", HK_NULL, hkaiDirectedGraphExplicitCostEdgeBitsEnum, hkClassMember::TYPE_FLAGS, hkClassMember::TYPE_UINT16, 0, 0, 0, HK_NULL },
		{ "target", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkaiDirectedGraphExplicitCostEdgeClass(
		"hkaiDirectedGraphExplicitCostEdge",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaiDirectedGraphExplicitCost_EdgeClass_Members),
		HK_COUNT_OF(hkaiDirectedGraphExplicitCost_EdgeClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkaiDirectedGraphExplicitCost_ExternalEdgeInfoClass_Members[] =
	{
		{ "nodeIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "edgeKey", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "targetUid", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkaiDirectedGraphExplicitCostExternalEdgeInfoClass(
		"hkaiDirectedGraphExplicitCostExternalEdgeInfo",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaiDirectedGraphExplicitCost_ExternalEdgeInfoClass_Members),
		HK_COUNT_OF(hkaiDirectedGraphExplicitCost_ExternalEdgeInfoClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkaiDirectedGraphExplicitCostClass_Members[] =
	{
		{ "positions", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VECTOR4, 0, 0, 0, HK_NULL },
		{ "nodes", &hkaiDirectedGraphExplicitCostNodeClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "edges", &hkaiDirectedGraphExplicitCostEdgeClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "externalEdges", &hkaiDirectedGraphExplicitCostExternalEdgeInfoClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "sectionDependencies", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT32, 0, 0, 0, HK_NULL },
		{ "sectionUid", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "runtimeId", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	namespace
	{
		struct hkaiDirectedGraphExplicitCost_DefaultStruct
		{
			int s_defaultOffsets[7];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
		};
		const hkaiDirectedGraphExplicitCost_DefaultStruct hkaiDirectedGraphExplicitCost_Default =
		{
			{-1,-1,-1,-1,-1,hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT},
		};
	}
	hkClass hkaiDirectedGraphExplicitCostClass(
		"hkaiDirectedGraphExplicitCost",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkaiDirectedGraphExplicitCostEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkaiDirectedGraphExplicitCostClass_Members),
		HK_COUNT_OF(hkaiDirectedGraphExplicitCostClass_Members),
		&hkaiDirectedGraphExplicitCost_Default,
		HK_NULL,
		0,
		hkUint32(4)
		);
	static const hkInternalClassEnumItem hkaiNavMeshInstanceDebugValuesEnumItems[] =
	{
		{3735943886u, "DEAD_FACE"},
		{3735940462u, "DEAD_EDGE"},
	};
	static const hkInternalClassEnumItem hkaiNavMeshInstanceCutInfoValuesEnumItems[] =
	{
		{65535, "NOT_CUT_EDGE"},
	};
	static const hkInternalClassEnum hkaiNavMeshInstanceEnums[] = {
		{"DebugValues", hkaiNavMeshInstanceDebugValuesEnumItems, 2, HK_NULL, 0 },
		{"CutInfoValues", hkaiNavMeshInstanceCutInfoValuesEnumItems, 1, HK_NULL, 0 }
	};
	const hkClassEnum* hkaiNavMeshInstanceDebugValuesEnum = reinterpret_cast<const hkClassEnum*>(&hkaiNavMeshInstanceEnums[0]);
	const hkClassEnum* hkaiNavMeshInstanceCutInfoValuesEnum = reinterpret_cast<const hkClassEnum*>(&hkaiNavMeshInstanceEnums[1]);
	static hkInternalClassMember hkaiNavMeshInstanceClass_Members[] =
	{
		{ "originalFaces", HK_NULL, HK_NULL, hkClassMember::TYPE_SIMPLEARRAY, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "originalEdges", HK_NULL, HK_NULL, hkClassMember::TYPE_SIMPLEARRAY, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "originalVertices", HK_NULL, HK_NULL, hkClassMember::TYPE_SIMPLEARRAY, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "originalMesh", &hkaiNavMeshClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "referenceFrame", &hkaiReferenceFrameClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "edgeMap", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_INT32, 0, 0, 0, HK_NULL },
		{ "faceMap", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_INT32, 0, 0, 0, HK_NULL },
		{ "instancedFaces", &hkaiNavMeshFaceClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "instancedEdges", &hkaiNavMeshEdgeClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "ownedFaces", &hkaiNavMeshFaceClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "ownedEdges", &hkaiNavMeshEdgeClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "ownedVertices", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VECTOR4, 0, 0, 0, HK_NULL },
		{ "faceFlags", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "cuttingInfo", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT16, 0, 0, 0, HK_NULL },
		{ "clearanceCache", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_HALF, 0, 0, 0, HK_NULL },
		{ "globalClearanceCache", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_HALF, 0, 0, 0, HK_NULL },
		{ "faceClearanceIndices", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_INT32, 0, 0, 0, HK_NULL },
		{ "maxGlobalClearance", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkaiNavMeshInstanceClass(
		"hkaiNavMeshInstance",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkaiNavMeshInstanceEnums),
		2,
		reinterpret_cast<const hkClassMember*>(hkaiNavMeshInstanceClass_Members),
		HK_COUNT_OF(hkaiNavMeshInstanceClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(2)
		);
	static hkInternalClassMember hkaiMaterialPainterClass_Members[] =
	{
		{ "material", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "volume", &hkaiVolumeClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkaiMaterialPainterClass(
		"hkaiMaterialPainter",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaiMaterialPainterClass_Members),
		HK_COUNT_OF(hkaiMaterialPainterClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkaiNavMeshFaceFlagBitsEnumItems[] =
	{
		{1, "FACE_HIDDEN"},
		{2, "FACE_CUT"},
	};
	static const hkInternalClassEnumItem hkaiNavMeshConstantsEnumItems[] =
	{
		{-1, "INVALID_REGION_INDEX"},
		{-1, "INVALID_FACE_INDEX"},
		{-1, "INVALID_EDGE_INDEX"},
		{-1, "INVALID_VERTEX_INDEX"},
	};
	static const hkInternalClassEnumItem hkaiNavMeshEdgeFlagBitsEnumItems[] =
	{
		{1, "EDGE_SILHOUETTE"},
		{2, "EDGE_INTERNAL"},
		{4, "EDGE_EXTERNAL"},
		{8, "OPPOSITE_EDGE_UNLOADED"},
		{16, "EDGE_USER"},
		{32, "EDGE_BLOCKED"},
	};
	static const hkInternalClassEnum hkaiNavMeshEnums[] = {
		{"FaceFlagBits", hkaiNavMeshFaceFlagBitsEnumItems, 2, HK_NULL, 0 },
		{"Constants", hkaiNavMeshConstantsEnumItems, 4, HK_NULL, 0 },
		{"EdgeFlagBits", hkaiNavMeshEdgeFlagBitsEnumItems, 6, HK_NULL, 0 }
	};
	const hkClassEnum* hkaiNavMeshFaceFlagBitsEnum = reinterpret_cast<const hkClassEnum*>(&hkaiNavMeshEnums[0]);
	const hkClassEnum* hkaiNavMeshConstantsEnum = reinterpret_cast<const hkClassEnum*>(&hkaiNavMeshEnums[1]);
	const hkClassEnum* hkaiNavMeshEdgeFlagBitsEnum = reinterpret_cast<const hkClassEnum*>(&hkaiNavMeshEnums[2]);
	static hkInternalClassMember hkaiNavMesh_FaceClass_Members[] =
	{
		{ "startEdgeIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "startUserEdgeIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "numEdges", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "numUserEdges", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "clusterIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "padding", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "data", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkaiNavMeshFaceClass(
		"hkaiNavMeshFace",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaiNavMesh_FaceClass_Members),
		HK_COUNT_OF(hkaiNavMesh_FaceClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(5)
		);
	static hkInternalClassMember hkaiNavMesh_EdgeClass_Members[] =
	{
		{ "a", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "b", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "oppositeEdge", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "oppositeFace", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "oppositeSectionUid", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "flags", HK_NULL, hkaiNavMeshEdgeFlagBitsEnum, hkClassMember::TYPE_FLAGS, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "paddingByte", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "userEdgeCost", HK_NULL, HK_NULL, hkClassMember::TYPE_HALF, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "data", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "padding", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkaiNavMeshEdgeClass(
		"hkaiNavMeshEdge",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaiNavMesh_EdgeClass_Members),
		HK_COUNT_OF(hkaiNavMesh_EdgeClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(6)
		);
	static hkInternalClassMember hkaiNavMeshClass_Members[] =
	{
		{ "faces", &hkaiNavMeshFaceClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "edges", &hkaiNavMeshEdgeClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "vertices", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VECTOR4, 0, 0, 0, HK_NULL },
		{ "sectionDependencies", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT32, 0, 0, 0, HK_NULL },
		{ "sectionUid", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "runtimeId", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "aabb", &hkAabbClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "erosionRadius", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "userData", HK_NULL, HK_NULL, hkClassMember::TYPE_ULONG, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkaiNavMesh_DefaultStruct
		{
			int s_defaultOffsets[9];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
		};
		const hkaiNavMesh_DefaultStruct hkaiNavMesh_Default =
		{
			{-1,-1,-1,-1,hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,-1,-1,hkClassMember::HK_CLASS_ZERO_DEFAULT},
		};
	}
	hkClass hkaiNavMeshClass(
		"hkaiNavMesh",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkaiNavMeshEnums),
		3,
		reinterpret_cast<const hkClassMember*>(hkaiNavMeshClass_Members),
		HK_COUNT_OF(hkaiNavMeshClass_Members),
		&hkaiNavMesh_Default,
		HK_NULL,
		0,
		hkUint32(10)
		);
	hkClass hkaAnimatedReferenceFrameClass(
		"hkaAnimatedReferenceFrame",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkaPredictiveCompressedAnimationStorageClassEnumItems[] =
	{
		{0, "STORAGE_STATIC"},
		{1, "STORAGE_REFERENCE"},
		{2, "STORAGE_DYNAMIC_RANGE"},
		{3, "STORAGE_DYNAMIC_FIXED"},
	};
	static const hkInternalClassEnumItem hkaPredictiveCompressedAnimationIntArrayIDEnumItems[] =
	{
		{0, "BLOCK_OFFSETS"},
		{1, "FIRST_FLOAT_BLOCK_OFFSETS"},
		{2, "IS_ANIMATED_BITMAP"},
		{3, "IS_FIXED_RANGE_BITMAP"},
		{4, "DYNAMIC_BONE_TRACK_INDEX"},
		{5, "DYNAMIC_FLOAT_TRACK_INDEX"},
		{6, "STATIC_BONE_TRACK_INDEX"},
		{7, "STATIC_FLOAT_TRACK_INDEX"},
		{8, "RENORM_QUATERNION_INDEX"},
		{9, "NUM_INT_ARRAYS"},
	};
	static const hkInternalClassEnumItem hkaPredictiveCompressedAnimationFloatArrayIDEnumItems[] =
	{
		{0, "STATIC_VALUES"},
		{1, "DYNAMIC_SCALES"},
		{2, "DYNAMIC_OFFSETS"},
		{3, "NUM_FLOAT_ARRAYS"},
	};
	static const hkInternalClassEnum hkaPredictiveCompressedAnimationEnums[] = {
		{"StorageClass", hkaPredictiveCompressedAnimationStorageClassEnumItems, 4, HK_NULL, 0 },
		{"IntArrayID", hkaPredictiveCompressedAnimationIntArrayIDEnumItems, 10, HK_NULL, 0 },
		{"FloatArrayID", hkaPredictiveCompressedAnimationFloatArrayIDEnumItems, 4, HK_NULL, 0 }
	};
	const hkClassEnum* hkaPredictiveCompressedAnimationStorageClassEnum = reinterpret_cast<const hkClassEnum*>(&hkaPredictiveCompressedAnimationEnums[0]);
	const hkClassEnum* hkaPredictiveCompressedAnimationIntArrayIDEnum = reinterpret_cast<const hkClassEnum*>(&hkaPredictiveCompressedAnimationEnums[1]);
	const hkClassEnum* hkaPredictiveCompressedAnimationFloatArrayIDEnum = reinterpret_cast<const hkClassEnum*>(&hkaPredictiveCompressedAnimationEnums[2]);
	static hkInternalClassMember hkaPredictiveCompressedAnimation_TrackCompressionParamsClass_Members[] =
	{
		{ "staticTranslationTolerance", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "staticRotationTolerance", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "staticScaleTolerance", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "staticFloatTolerance", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "dynamicTranslationTolerance", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "dynamicRotationTolerance", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "dynamicScaleTolerance", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "dynamicFloatTolerance", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkaPredictiveCompressedAnimationTrackCompressionParamsClass(
		"hkaPredictiveCompressedAnimationTrackCompressionParams",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaPredictiveCompressedAnimation_TrackCompressionParamsClass_Members),
		HK_COUNT_OF(hkaPredictiveCompressedAnimation_TrackCompressionParamsClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkaPredictiveCompressedAnimationClass_Members[] =
	{
		{ "compressedData", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "intData", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT16, 0, 0, 0, HK_NULL },
		{ "intArrayOffsets", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 9, 0, 0, HK_NULL },
		{ "floatData", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_REAL, 0, 0, 0, HK_NULL },
		{ "floatArrayOffsets", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 3, 0, 0, HK_NULL },
		{ "numBones", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "numFloatSlots", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "numFrames", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "firstFloatBlockScaleAndOffsetIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "skeleton", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "maxCompressedBytesPerFrame", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hkaPredictiveCompressedAnimationClass(
		"hkaPredictiveCompressedAnimation",
		&hkaAnimationClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkaPredictiveCompressedAnimationEnums),
		3,
		reinterpret_cast<const hkClassMember*>(hkaPredictiveCompressedAnimationClass_Members),
		HK_COUNT_OF(hkaPredictiveCompressedAnimationClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkaDefaultAnimatedReferenceFrameClass_Members[] =
	{
		{ "up", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "forward", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "duration", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "referenceFrameSamples", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VECTOR4, 0, 0, 0, HK_NULL }
	};
	hkClass hkaDefaultAnimatedReferenceFrameClass(
		"hkaDefaultAnimatedReferenceFrame",
		&hkaAnimatedReferenceFrameClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaDefaultAnimatedReferenceFrameClass_Members),
		HK_COUNT_OF(hkaDefaultAnimatedReferenceFrameClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkaAnimationBindingBlendHintEnumItems[] =
	{
		{0, "NORMAL"},
		{1, "ADDITIVE"},
	};
	static const hkInternalClassEnum hkaAnimationBindingEnums[] = {
		{"BlendHint", hkaAnimationBindingBlendHintEnumItems, 2, HK_NULL, 0 }
	};
	const hkClassEnum* hkaAnimationBindingBlendHintEnum = reinterpret_cast<const hkClassEnum*>(&hkaAnimationBindingEnums[0]);
	static hkInternalClassMember hkaAnimationBindingClass_Members[] =
	{
		{ "originalSkeletonName", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "animation", &hkaAnimationClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "transformTrackToBoneIndices", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_INT16, 0, 0, 0, HK_NULL },
		{ "floatTrackToFloatSlotIndices", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_INT16, 0, 0, 0, HK_NULL },
		{ "blendHint", HK_NULL, hkaAnimationBindingBlendHintEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkaAnimationBinding_DefaultStruct
		{
			int s_defaultOffsets[5];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkInt8 /* hkEnum< enum hkaAnimationBinding::BlendHint, hkInt8 > */ m_blendHint;
		};
		const hkaAnimationBinding_DefaultStruct hkaAnimationBinding_Default =
		{
			{-1,-1,-1,-1,HK_OFFSET_OF(hkaAnimationBinding_DefaultStruct,m_blendHint)},
			0/*hkaAnimationBinding::NORMAL*/
		};
	}
	hkClass hkaAnimationBindingClass(
		"hkaAnimationBinding",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkaAnimationBindingEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkaAnimationBindingClass_Members),
		HK_COUNT_OF(hkaAnimationBindingClass_Members),
		&hkaAnimationBinding_Default,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkaInterleavedUncompressedAnimationClass_Members[] =
	{
		{ "transforms", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_QSTRANSFORM, 0, 0, 0, HK_NULL },
		{ "floats", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_REAL, 0, 0, 0, HK_NULL }
	};
	hkClass hkaInterleavedUncompressedAnimationClass(
		"hkaInterleavedUncompressedAnimation",
		&hkaAnimationClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaInterleavedUncompressedAnimationClass_Members),
		HK_COUNT_OF(hkaInterleavedUncompressedAnimationClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkaSplineCompressedAnimationTrackCompressionParamsRotationQuantizationEnumItems[] =
	{
		{0, "POLAR32"},
		{1, "THREECOMP40"},
		{2, "THREECOMP48"},
		{3, "THREECOMP24"},
		{4, "STRAIGHT16"},
		{5, "UNCOMPRESSED"},
	};
	static const hkInternalClassEnumItem hkaSplineCompressedAnimationTrackCompressionParamsScalarQuantizationEnumItems[] =
	{
		{0, "BITS8"},
		{1, "BITS16"},
	};
	static const hkInternalClassEnum hkaSplineCompressedAnimationTrackCompressionParamsEnums[] = {
		{"RotationQuantization", hkaSplineCompressedAnimationTrackCompressionParamsRotationQuantizationEnumItems, 6, HK_NULL, 0 },
		{"ScalarQuantization", hkaSplineCompressedAnimationTrackCompressionParamsScalarQuantizationEnumItems, 2, HK_NULL, 0 }
	};
	const hkClassEnum* hkaSplineCompressedAnimationTrackCompressionParamsRotationQuantizationEnum = reinterpret_cast<const hkClassEnum*>(&hkaSplineCompressedAnimationTrackCompressionParamsEnums[0]);
	const hkClassEnum* hkaSplineCompressedAnimationTrackCompressionParamsScalarQuantizationEnum = reinterpret_cast<const hkClassEnum*>(&hkaSplineCompressedAnimationTrackCompressionParamsEnums[1]);
	static hkInternalClassMember hkaSplineCompressedAnimation_TrackCompressionParamsClass_Members[] =
	{
		{ "rotationTolerance", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "translationTolerance", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "scaleTolerance", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "floatingTolerance", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "rotationDegree", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "translationDegree", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "scaleDegree", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "floatingDegree", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "rotationQuantizationType", HK_NULL, hkaSplineCompressedAnimationTrackCompressionParamsRotationQuantizationEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "translationQuantizationType", HK_NULL, hkaSplineCompressedAnimationTrackCompressionParamsScalarQuantizationEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "scaleQuantizationType", HK_NULL, hkaSplineCompressedAnimationTrackCompressionParamsScalarQuantizationEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "floatQuantizationType", HK_NULL, hkaSplineCompressedAnimationTrackCompressionParamsScalarQuantizationEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL }
	};
	hkClass hkaSplineCompressedAnimationTrackCompressionParamsClass(
		"hkaSplineCompressedAnimationTrackCompressionParams",
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkaSplineCompressedAnimationTrackCompressionParamsEnums),
		2,
		reinterpret_cast<const hkClassMember*>(hkaSplineCompressedAnimation_TrackCompressionParamsClass_Members),
		HK_COUNT_OF(hkaSplineCompressedAnimation_TrackCompressionParamsClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkaSplineCompressedAnimation_AnimationCompressionParamsClass_Members[] =
	{
		{ "maxFramesPerBlock", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "enableSampleSingleTracks", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkaSplineCompressedAnimationAnimationCompressionParamsClass(
		"hkaSplineCompressedAnimationAnimationCompressionParams",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaSplineCompressedAnimation_AnimationCompressionParamsClass_Members),
		HK_COUNT_OF(hkaSplineCompressedAnimation_AnimationCompressionParamsClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkaSplineCompressedAnimationClass_Members[] =
	{
		{ "numFrames", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "numBlocks", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxFramesPerBlock", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maskAndQuantizationSize", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "blockDuration", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "blockInverseDuration", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "frameDuration", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "blockOffsets", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT32, 0, 0, 0, HK_NULL },
		{ "floatBlockOffsets", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT32, 0, 0, 0, HK_NULL },
		{ "transformOffsets", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT32, 0, 0, 0, HK_NULL },
		{ "floatOffsets", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT32, 0, 0, 0, HK_NULL },
		{ "data", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "endian", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkaSplineCompressedAnimationClass(
		"hkaSplineCompressedAnimation",
		&hkaAnimationClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaSplineCompressedAnimationClass_Members),
		HK_COUNT_OF(hkaSplineCompressedAnimationClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkaMeshBinding_MappingClass_Members[] =
	{
		{ "mapping", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_INT16, 0, 0, 0, HK_NULL }
	};
	hkClass hkaMeshBindingMappingClass(
		"hkaMeshBindingMapping",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaMeshBinding_MappingClass_Members),
		HK_COUNT_OF(hkaMeshBinding_MappingClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkaMeshBindingClass_Members[] =
	{
		{ "mesh", &hkxMeshClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "originalSkeletonName", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "skeleton", &hkaSkeletonClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "mappings", &hkaMeshBindingMappingClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "boneFromSkinMeshTransforms", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_TRANSFORM, 0, 0, 0, HK_NULL }
	};
	hkClass hkaMeshBindingClass(
		"hkaMeshBinding",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaMeshBindingClass_Members),
		HK_COUNT_OF(hkaMeshBindingClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(3)
		);
	static const hkInternalClassEnumItem hkaSkeletonMapperConstraintSourceEnumItems[] =
	{
		{0, "NO_CONSTRAINTS"},
		{1, "REFERENCE_POSE"},
		{2, "CURRENT_POSE"},
	};
	static const hkInternalClassEnum hkaSkeletonMapperEnums[] = {
		{"ConstraintSource", hkaSkeletonMapperConstraintSourceEnumItems, 3, HK_NULL, 0 }
	};
	const hkClassEnum* hkaSkeletonMapperConstraintSourceEnum = reinterpret_cast<const hkClassEnum*>(&hkaSkeletonMapperEnums[0]);
	static hkInternalClassMember hkaSkeletonMapperClass_Members[] =
	{
		{ "mapping", &hkaSkeletonMapperDataClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkaSkeletonMapperClass(
		"hkaSkeletonMapper",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkaSkeletonMapperEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkaSkeletonMapperClass_Members),
		HK_COUNT_OF(hkaSkeletonMapperClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkaAnimationContainerClass_Members[] =
	{
		{ "skeletons", &hkaSkeletonClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "animations", &hkaAnimationClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "bindings", &hkaAnimationBindingClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "attachments", &hkaBoneAttachmentClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "skins", &hkaMeshBindingClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL }
	};
	hkClass hkaAnimationContainerClass(
		"hkaAnimationContainer",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaAnimationContainerClass_Members),
		HK_COUNT_OF(hkaAnimationContainerClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static const hkInternalClassEnumItem hkaSkeletonMapperDataMappingTypeEnumItems[] =
	{
		{0, "HK_RAGDOLL_MAPPING"},
		{1, "HK_RETARGETING_MAPPING"},
	};
	static const hkInternalClassEnum hkaSkeletonMapperDataEnums[] = {
		{"MappingType", hkaSkeletonMapperDataMappingTypeEnumItems, 2, HK_NULL, 0 }
	};
	const hkClassEnum* hkaSkeletonMapperDataMappingTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkaSkeletonMapperDataEnums[0]);
	static hkInternalClassMember hkaSkeletonMapperData_SimpleMappingClass_Members[] =
	{
		{ "boneA", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "boneB", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "aFromBTransform", HK_NULL, HK_NULL, hkClassMember::TYPE_QSTRANSFORM, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkaSkeletonMapperDataSimpleMappingClass(
		"hkaSkeletonMapperDataSimpleMapping",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaSkeletonMapperData_SimpleMappingClass_Members),
		HK_COUNT_OF(hkaSkeletonMapperData_SimpleMappingClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkaSkeletonMapperData_ChainMappingClass_Members[] =
	{
		{ "startBoneA", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "endBoneA", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "startBoneB", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "endBoneB", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "startAFromBTransform", HK_NULL, HK_NULL, hkClassMember::TYPE_QSTRANSFORM, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "endAFromBTransform", HK_NULL, HK_NULL, hkClassMember::TYPE_QSTRANSFORM, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkaSkeletonMapperDataChainMappingClass(
		"hkaSkeletonMapperDataChainMapping",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaSkeletonMapperData_ChainMappingClass_Members),
		HK_COUNT_OF(hkaSkeletonMapperData_ChainMappingClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkaSkeletonMapperDataClass_Members[] =
	{
		{ "skeletonA", &hkaSkeletonClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "skeletonB", &hkaSkeletonClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "simpleMappings", &hkaSkeletonMapperDataSimpleMappingClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "chainMappings", &hkaSkeletonMapperDataChainMappingClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "unmappedBones", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_INT16, 0, 0, 0, HK_NULL },
		{ "extractedMotionMapping", HK_NULL, HK_NULL, hkClassMember::TYPE_QSTRANSFORM, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "keepUnmappedLocal", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "mappingType", HK_NULL, hkaSkeletonMapperDataMappingTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT32, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkaSkeletonMapperData_DefaultStruct
		{
			int s_defaultOffsets[8];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
		};
		const hkaSkeletonMapperData_DefaultStruct hkaSkeletonMapperData_Default =
		{
			{-1,-1,-1,-1,-1,-1,-1,hkClassMember::HK_CLASS_ZERO_DEFAULT},
		};
	}
	hkClass hkaSkeletonMapperDataClass(
		"hkaSkeletonMapperData",
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkaSkeletonMapperDataEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkaSkeletonMapperDataClass_Members),
		HK_COUNT_OF(hkaSkeletonMapperDataClass_Members),
		&hkaSkeletonMapperData_Default,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkaQuantizedAnimation_TrackCompressionParamsClass_Members[] =
	{
		{ "rotationTolerance", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "translationTolerance", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "scaleTolerance", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "floatingTolerance", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkaQuantizedAnimationTrackCompressionParamsClass(
		"hkaQuantizedAnimationTrackCompressionParams",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaQuantizedAnimation_TrackCompressionParamsClass_Members),
		HK_COUNT_OF(hkaQuantizedAnimation_TrackCompressionParamsClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkaQuantizedAnimationClass_Members[] =
	{
		{ "data", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "endian", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "skeleton", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hkaQuantizedAnimationClass(
		"hkaQuantizedAnimation",
		&hkaAnimationClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaQuantizedAnimationClass_Members),
		HK_COUNT_OF(hkaQuantizedAnimationClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkaAnimationPreviewColorContainerClass_Members[] =
	{
		{ "previewColor", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT32, 0, 0, 0, HK_NULL }
	};
	hkClass hkaAnimationPreviewColorContainerClass(
		"hkaAnimationPreviewColorContainer",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaAnimationPreviewColorContainerClass_Members),
		HK_COUNT_OF(hkaAnimationPreviewColorContainerClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkaBoneAttachmentClass_Members[] =
	{
		{ "originalSkeletonName", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "boneFromAttachment", HK_NULL, HK_NULL, hkClassMember::TYPE_MATRIX4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "attachment", &hkReferencedObjectClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "boneIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkaBoneAttachmentClass(
		"hkaBoneAttachment",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaBoneAttachmentClass_Members),
		HK_COUNT_OF(hkaBoneAttachmentClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(2)
		);
	static const hkInternalClassEnumItem hkaAnimationAnimationTypeEnumItems[] =
	{
		{0, "HK_UNKNOWN_ANIMATION"},
		{1, "HK_INTERLEAVED_ANIMATION"},
		{2, "HK_MIRRORED_ANIMATION"},
		{3, "HK_SPLINE_COMPRESSED_ANIMATION"},
		{4, "HK_QUANTIZED_COMPRESSED_ANIMATION"},
		{5, "HK_PREDICTIVE_COMPRESSED_ANIMATION"},
	};
	static const hkInternalClassEnum hkaAnimationEnums[] = {
		{"AnimationType", hkaAnimationAnimationTypeEnumItems, 6, HK_NULL, 0 }
	};
	const hkClassEnum* hkaAnimationAnimationTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkaAnimationEnums[0]);
	static hkInternalClassMember hkaAnimationClass_Members[] =
	{
		{ "type", HK_NULL, hkaAnimationAnimationTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT32, 0, 0, 0, HK_NULL },
		{ "duration", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "numberOfTransformTracks", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "numberOfFloatTracks", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "extractedMotion", &hkaAnimatedReferenceFrameClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "annotationTracks", &hkaAnnotationTrackClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkaAnimationClass(
		"hkaAnimation",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkaAnimationEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkaAnimationClass_Members),
		HK_COUNT_OF(hkaAnimationClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(3)
		);
	static hkInternalClassMember hkaSkeleton_LocalFrameOnBoneClass_Members[] =
	{
		{ "localFrame", &hkLocalFrameClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "boneIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkaSkeletonLocalFrameOnBoneClass(
		"hkaSkeletonLocalFrameOnBone",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaSkeleton_LocalFrameOnBoneClass_Members),
		HK_COUNT_OF(hkaSkeleton_LocalFrameOnBoneClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkaSkeletonClass_Members[] =
	{
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "parentIndices", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_INT16, 0, 0, 0, HK_NULL },
		{ "bones", &hkaBoneClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "referencePose", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_QSTRANSFORM, 0, 0, 0, HK_NULL },
		{ "referenceFloats", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_REAL, 0, 0, 0, HK_NULL },
		{ "floatSlots", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRINGPTR, 0, 0, 0, HK_NULL },
		{ "localFrames", &hkaSkeletonLocalFrameOnBoneClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkaSkeletonClass(
		"hkaSkeleton",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaSkeletonClass_Members),
		HK_COUNT_OF(hkaSkeletonClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(3)
		);
	static hkInternalClassMember hkaFootstepAnalysisInfoClass_Members[] =
	{
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_CHAR, 0, 0, 0, HK_NULL },
		{ "nameStrike", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_CHAR, 0, 0, 0, HK_NULL },
		{ "nameLift", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_CHAR, 0, 0, 0, HK_NULL },
		{ "nameLock", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_CHAR, 0, 0, 0, HK_NULL },
		{ "nameUnlock", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_CHAR, 0, 0, 0, HK_NULL },
		{ "minPos", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_REAL, 0, 0, 0, HK_NULL },
		{ "maxPos", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_REAL, 0, 0, 0, HK_NULL },
		{ "minVel", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_REAL, 0, 0, 0, HK_NULL },
		{ "maxVel", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_REAL, 0, 0, 0, HK_NULL },
		{ "allBonesDown", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_REAL, 0, 0, 0, HK_NULL },
		{ "anyBonesDown", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_REAL, 0, 0, 0, HK_NULL },
		{ "posTol", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "velTol", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "duration", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkaFootstepAnalysisInfoClass(
		"hkaFootstepAnalysisInfo",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaFootstepAnalysisInfoClass_Members),
		HK_COUNT_OF(hkaFootstepAnalysisInfoClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkaFootstepAnalysisInfoContainerClass_Members[] =
	{
		{ "previewInfo", &hkaFootstepAnalysisInfoClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL }
	};
	hkClass hkaFootstepAnalysisInfoContainerClass(
		"hkaFootstepAnalysisInfoContainer",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaFootstepAnalysisInfoContainerClass_Members),
		HK_COUNT_OF(hkaFootstepAnalysisInfoContainerClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkaBoneClass_Members[] =
	{
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "lockTranslation", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkaBoneClass(
		"hkaBone",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaBoneClass_Members),
		HK_COUNT_OF(hkaBoneClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkaAnnotationTrack_AnnotationClass_Members[] =
	{
		{ "time", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "text", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkaAnnotationTrackAnnotationClass(
		"hkaAnnotationTrackAnnotation",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaAnnotationTrack_AnnotationClass_Members),
		HK_COUNT_OF(hkaAnnotationTrack_AnnotationClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkaAnnotationTrackClass_Members[] =
	{
		{ "trackName", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "annotations", &hkaAnnotationTrackAnnotationClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkaAnnotationTrackClass(
		"hkaAnnotationTrack",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaAnnotationTrackClass_Members),
		HK_COUNT_OF(hkaAnnotationTrackClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkaKeyFrameHierarchyUtility_ControlDataClass_Members[] =
	{
		{ "hierarchyGain", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "velocityDamping", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "accelerationGain", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "velocityGain", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "positionGain", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "positionMaxLinearVelocity", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "positionMaxAngularVelocity", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "snapGain", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "snapMaxLinearVelocity", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "snapMaxAngularVelocity", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "snapMaxLinearDistance", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "snapMaxAngularDistance", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkaKeyFrameHierarchyUtilityControlData_DefaultStruct
		{
			int s_defaultOffsets[12];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkReal m_hierarchyGain;
			hkReal m_accelerationGain;
			hkReal m_velocityGain;
			hkReal m_positionGain;
			hkReal m_positionMaxLinearVelocity;
			hkReal m_positionMaxAngularVelocity;
			hkReal m_snapGain;
			hkReal m_snapMaxLinearVelocity;
			hkReal m_snapMaxAngularVelocity;
			hkReal m_snapMaxLinearDistance;
			hkReal m_snapMaxAngularDistance;
		};
		const hkaKeyFrameHierarchyUtilityControlData_DefaultStruct hkaKeyFrameHierarchyUtilityControlData_Default =
		{
			{HK_OFFSET_OF(hkaKeyFrameHierarchyUtilityControlData_DefaultStruct,m_hierarchyGain),hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkaKeyFrameHierarchyUtilityControlData_DefaultStruct,m_accelerationGain),HK_OFFSET_OF(hkaKeyFrameHierarchyUtilityControlData_DefaultStruct,m_velocityGain),HK_OFFSET_OF(hkaKeyFrameHierarchyUtilityControlData_DefaultStruct,m_positionGain),HK_OFFSET_OF(hkaKeyFrameHierarchyUtilityControlData_DefaultStruct,m_positionMaxLinearVelocity),HK_OFFSET_OF(hkaKeyFrameHierarchyUtilityControlData_DefaultStruct,m_positionMaxAngularVelocity),HK_OFFSET_OF(hkaKeyFrameHierarchyUtilityControlData_DefaultStruct,m_snapGain),HK_OFFSET_OF(hkaKeyFrameHierarchyUtilityControlData_DefaultStruct,m_snapMaxLinearVelocity),HK_OFFSET_OF(hkaKeyFrameHierarchyUtilityControlData_DefaultStruct,m_snapMaxAngularVelocity),HK_OFFSET_OF(hkaKeyFrameHierarchyUtilityControlData_DefaultStruct,m_snapMaxLinearDistance),HK_OFFSET_OF(hkaKeyFrameHierarchyUtilityControlData_DefaultStruct,m_snapMaxAngularDistance)},
			0.17f,1.0f,0.6f,0.05f,1.4f,1.8f,0.1f,0.3f,0.3f,0.03f,0.1f
		};
	}
	hkClass hkaKeyFrameHierarchyUtilityControlDataClass(
		"hkaKeyFrameHierarchyUtilityControlData",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaKeyFrameHierarchyUtility_ControlDataClass_Members),
		HK_COUNT_OF(hkaKeyFrameHierarchyUtility_ControlDataClass_Members),
		&hkaKeyFrameHierarchyUtilityControlData_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hkaKeyFrameHierarchyUtilityClass(
		"hkaKeyFrameHierarchyUtility",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkaRagdollInstanceClass_Members[] =
	{
		{ "rigidBodies", &hkpRigidBodyClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "constraints", &hkpConstraintInstanceClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "boneToRigidBodyMap", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_INT32, 0, 0, 0, HK_NULL },
		{ "skeleton", &hkaSkeletonClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkaRagdollInstanceClass(
		"hkaRagdollInstance",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkaRagdollInstanceClass_Members),
		HK_COUNT_OF(hkaRagdollInstanceClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkbCompiledExpressionSetTokenTokenTypeEnumItems[] =
	{
		{0, "TOKEN_TYPE_NONE"},
		{1, "TOKEN_TYPE_OPERATOR"},
		{2, "TOKEN_TYPE_NUMBER"},
		{3, "TOKEN_TYPE_VARIABLE_INDEX"},
		{4, "TOKEN_TYPE_OPENING_PAREN"},
		{5, "TOKEN_TYPE_CLOSING_PAREN"},
		{6, "TOKEN_TYPE_COMMA"},
		{7, "TOKEN_TYPE_CHARACTER_PROPERTY_INDEX"},
	};
	static const hkInternalClassEnumItem hkbCompiledExpressionSetTokenOperatorEnumItems[] =
	{
		{0, "OP_NOP"},
		{1, "OP_RAND01"},
		{2, "OP_LOGICAL_NOT"},
		{3, "OP_UNARY_MINUS"},
		{4, "OP_UNARY_PLUS"},
		{5, "OP_SIN"},
		{6, "OP_COS"},
		{7, "OP_ASIN"},
		{8, "OP_ACOS"},
		{9, "OP_SQRT"},
		{10, "OP_FABS"},
		{11, "OP_CEIL"},
		{12, "OP_FLOOR"},
		{13, "OP_SQRTINV"},
		{14, "OP_MUL"},
		{15, "OP_DIV"},
		{16, "OP_ADD"},
		{17, "OP_SUB"},
		{18, "OP_LOGICAL_OR"},
		{19, "OP_LOGICAL_AND"},
		{20, "OP_EQ"},
		{21, "OP_NEQ"},
		{22, "OP_LT"},
		{23, "OP_GT"},
		{24, "OP_LEQ"},
		{25, "OP_GEQ"},
		{26, "OP_POW"},
		{27, "OP_MAX2"},
		{28, "OP_MIN2"},
		{29, "OP_RANDRANGE"},
		{30, "OP_ATAN2APPROX"},
		{31, "OP_CLAMP"},
		{32, "OP_MOD"},
		{33, "OP_DEG2RAD"},
		{34, "OP_RAD2DEG"},
		{35, "OP_COSD"},
		{36, "OP_SIND"},
		{37, "OP_ACOSD"},
		{38, "OP_ASIND"},
		{39, "OP_ATAN2APPROXD"},
		{40, "OP_SIGN"},
		{41, "OP_LERP"},
		{42, "OP_CLERP"},
		{43, "OP_COND"},
	};
	static const hkInternalClassEnum hkbCompiledExpressionSetTokenEnums[] = {
		{"TokenType", hkbCompiledExpressionSetTokenTokenTypeEnumItems, 8, HK_NULL, 0 },
		{"Operator", hkbCompiledExpressionSetTokenOperatorEnumItems, 44, HK_NULL, 0 }
	};
	const hkClassEnum* hkbCompiledExpressionSetTokenTokenTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkbCompiledExpressionSetTokenEnums[0]);
	const hkClassEnum* hkbCompiledExpressionSetTokenOperatorEnum = reinterpret_cast<const hkClassEnum*>(&hkbCompiledExpressionSetTokenEnums[1]);
	static hkInternalClassMember hkbCompiledExpressionSet_TokenClass_Members[] =
	{
		{ "data", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "type", HK_NULL, hkbCompiledExpressionSetTokenTokenTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL },
		{ "operator", HK_NULL, hkbCompiledExpressionSetTokenOperatorEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL }
	};
	hkClass hkbCompiledExpressionSetTokenClass(
		"hkbCompiledExpressionSetToken",
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkbCompiledExpressionSetTokenEnums),
		2,
		reinterpret_cast<const hkClassMember*>(hkbCompiledExpressionSet_TokenClass_Members),
		HK_COUNT_OF(hkbCompiledExpressionSet_TokenClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbCompiledExpressionSetClass_Members[] =
	{
		{ "rpn", &hkbCompiledExpressionSetTokenClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "expressionToRpnIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_INT32, 0, 0, 0, HK_NULL },
		{ "numExpressions", HK_NULL, HK_NULL, hkClassMember::TYPE_INT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkbCompiledExpressionSetClass(
		"hkbCompiledExpressionSet",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbCompiledExpressionSetClass_Members),
		HK_COUNT_OF(hkbCompiledExpressionSetClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static const hkInternalClassEnumItem hkbEvaluateHandleModifierHandleChangeModeEnumItems[] =
	{
		{0, "HANDLE_CHANGE_MODE_ABRUPT"},
		{1, "HANDLE_CHANGE_MODE_CONSTANT_VELOCITY"},
	};
	static const hkInternalClassEnum hkbEvaluateHandleModifierEnums[] = {
		{"HandleChangeMode", hkbEvaluateHandleModifierHandleChangeModeEnumItems, 2, HK_NULL, 0 }
	};
	const hkClassEnum* hkbEvaluateHandleModifierHandleChangeModeEnum = reinterpret_cast<const hkClassEnum*>(&hkbEvaluateHandleModifierEnums[0]);
	static hkInternalClassMember hkbEvaluateHandleModifierClass_Members[] =
	{
		{ "handle", &hkbHandleClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "handlePositionOut", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "handleRotationOut", HK_NULL, HK_NULL, hkClassMember::TYPE_QUATERNION, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "isValidOut", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "extrapolationTimeStep", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "handleChangeSpeed", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "handleChangeMode", HK_NULL, hkbEvaluateHandleModifierHandleChangeModeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL },
		{ "oldHandle", &hkbHandleClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "oldHandlePosition", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "oldHandleRotation", HK_NULL, HK_NULL, hkClassMember::TYPE_QUATERNION, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "timeSinceLastModify", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "smoothlyChangingHandles", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	namespace
	{
		struct hkbEvaluateHandleModifier_DefaultStruct
		{
			int s_defaultOffsets[12];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			_hkVector4 m_handlePositionOut;
			_hkQuaternion m_handleRotationOut;
			hkReal m_handleChangeSpeed;
			hkInt8 /* hkEnum< enum hkbEvaluateHandleModifier::HandleChangeMode, hkInt8 > */ m_handleChangeMode;
		};
		const hkbEvaluateHandleModifier_DefaultStruct hkbEvaluateHandleModifier_Default =
		{
			{-1,HK_OFFSET_OF(hkbEvaluateHandleModifier_DefaultStruct,m_handlePositionOut),HK_OFFSET_OF(hkbEvaluateHandleModifier_DefaultStruct,m_handleRotationOut),hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkbEvaluateHandleModifier_DefaultStruct,m_handleChangeSpeed),HK_OFFSET_OF(hkbEvaluateHandleModifier_DefaultStruct,m_handleChangeMode),-1,-1,-1,-1,-1},
		{0,0,0},	{0,0,0,1},1.0f,hkbEvaluateHandleModifier::HANDLE_CHANGE_MODE_ABRUPT
		};
	}
	hkClass hkbEvaluateHandleModifierClass(
		"hkbEvaluateHandleModifier",
		&hkbModifierClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkbEvaluateHandleModifierEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkbEvaluateHandleModifierClass_Members),
		HK_COUNT_OF(hkbEvaluateHandleModifierClass_Members),
		&hkbEvaluateHandleModifier_Default,
		HK_NULL,
		0,
		hkUint32(2)
		);
	static hkInternalClassMember hkbMoveCharacterModifierClass_Members[] =
	{
		{ "offsetPerSecondMS", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "timeSinceLastModify", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	namespace
	{
		struct hkbMoveCharacterModifier_DefaultStruct
		{
			int s_defaultOffsets[2];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			_hkVector4 m_offsetPerSecondMS;
		};
		const hkbMoveCharacterModifier_DefaultStruct hkbMoveCharacterModifier_Default =
		{
			{HK_OFFSET_OF(hkbMoveCharacterModifier_DefaultStruct,m_offsetPerSecondMS),-1},
			{0,0,0}
		};
	}
	hkClass hkbMoveCharacterModifierClass(
		"hkbMoveCharacterModifier",
		&hkbModifierClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbMoveCharacterModifierClass_Members),
		HK_COUNT_OF(hkbMoveCharacterModifierClass_Members),
		&hkbMoveCharacterModifier_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbClipTriggerClass_Members[] =
	{
		{ "localTime", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "event", &hkbEventPropertyClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "relativeToEndOfClip", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "acyclic", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "isAnnotation", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkbClipTrigger_DefaultStruct
		{
			int s_defaultOffsets[5];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
		};
		const hkbClipTrigger_DefaultStruct hkbClipTrigger_Default =
		{
			{-1,-1,-1,hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT},
		};
	}
	hkClass hkbClipTriggerClass(
		"hkbClipTrigger",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbClipTriggerClass_Members),
		HK_COUNT_OF(hkbClipTriggerClass_Members),
		&hkbClipTrigger_Default,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkbClipTriggerArrayClass_Members[] =
	{
		{ "triggers", &hkbClipTriggerClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkbClipTriggerArrayClass(
		"hkbClipTriggerArray",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbClipTriggerArrayClass_Members),
		HK_COUNT_OF(hkbClipTriggerArrayClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkbClipGeneratorPlaybackModeEnumItems[] =
	{
		{0, "MODE_SINGLE_PLAY"},
		{1, "MODE_LOOPING"},
		{2, "MODE_USER_CONTROLLED"},
		{3, "MODE_PING_PONG"},
		{4, "MODE_COUNT"},
	};
	static const hkInternalClassEnumItem hkbClipGeneratorClipFlagsEnumItems[] =
	{
		{1, "FLAG_CONTINUE_MOTION_AT_END"},
		{2, "FLAG_SYNC_HALF_CYCLE_IN_PING_PONG_MODE"},
		{4, "FLAG_MIRROR"},
		{8, "FLAG_FORCE_DENSE_POSE"},
		{16, "FLAG_DONT_CONVERT_ANNOTATIONS_TO_TRIGGERS"},
		{32, "FLAG_IGNORE_MOTION"},
	};
	static const hkInternalClassEnum hkbClipGeneratorEnums[] = {
		{"PlaybackMode", hkbClipGeneratorPlaybackModeEnumItems, 5, HK_NULL, 0 },
		{"ClipFlags", hkbClipGeneratorClipFlagsEnumItems, 6, HK_NULL, 0 }
	};
	const hkClassEnum* hkbClipGeneratorPlaybackModeEnum = reinterpret_cast<const hkClassEnum*>(&hkbClipGeneratorEnums[0]);
	const hkClassEnum* hkbClipGeneratorClipFlagsEnum = reinterpret_cast<const hkClassEnum*>(&hkbClipGeneratorEnums[1]);
	static hkInternalClassMember hkbClipGenerator_EchoClass_Members[] =
	{
		{ "offsetLocalTime", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::ALIGN_16, 0, HK_NULL },
		{ "weight", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "dwdt", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkbClipGeneratorEchoClass(
		"hkbClipGeneratorEcho",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbClipGenerator_EchoClass_Members),
		HK_COUNT_OF(hkbClipGenerator_EchoClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbClipGeneratorClass_Members[] =
	{
		{ "animationName", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "triggers", &hkbClipTriggerArrayClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "cropStartAmountLocalTime", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "cropEndAmountLocalTime", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "startTime", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "playbackSpeed", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "enforcedDuration", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "userControlledTimeFraction", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "animationBindingIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "mode", HK_NULL, hkbClipGeneratorPlaybackModeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL },
		{ "flags", HK_NULL, HK_NULL, hkClassMember::TYPE_INT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "animDatas", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "animationControl", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "originalTriggers", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "mapperData", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "binding", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "extractedMotion", HK_NULL, HK_NULL, hkClassMember::TYPE_QSTRANSFORM, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "echos", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "localTime", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "time", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "previousUserControlledTimeFraction", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "bufferSize", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "atEnd", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "ignoreStartTime", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "pingPongBackward", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	namespace
	{
		struct hkbClipGenerator_DefaultStruct
		{
			int s_defaultOffsets[25];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkInt16 m_animationBindingIndex;
		};
		const hkbClipGenerator_DefaultStruct hkbClipGenerator_Default =
		{
			{-1,-1,-1,-1,-1,-1,hkClassMember::HK_CLASS_ZERO_DEFAULT,-1,HK_OFFSET_OF(hkbClipGenerator_DefaultStruct,m_animationBindingIndex),-1,hkClassMember::HK_CLASS_ZERO_DEFAULT,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
			-1
		};
	}
	hkClass hkbClipGeneratorClass(
		"hkbClipGenerator",
		&hkbGeneratorClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkbClipGeneratorEnums),
		2,
		reinterpret_cast<const hkClassMember*>(hkbClipGeneratorClass_Members),
		HK_COUNT_OF(hkbClipGeneratorClass_Members),
		&hkbClipGenerator_Default,
		HK_NULL,
		0,
		hkUint32(2)
		);
	static const hkInternalClassEnumItem hkbDockingGeneratorBlendTypeEnumItems[] =
	{
		{0, "BLEND_TYPE_BLEND_IN"},
		{1, "BLEND_TYPE_FULL_ON"},
	};
	static const hkInternalClassEnumItem hkbDockingGeneratorDockingFlagBitsEnumItems[] =
	{
		{0, "FLAG_NONE"},
		{1, "FLAG_DOCK_TO_FUTURE_POSITION"},
		{2, "FLAG_OVERRIDE_MOTION"},
	};
	static const hkInternalClassEnum hkbDockingGeneratorEnums[] = {
		{"BlendType", hkbDockingGeneratorBlendTypeEnumItems, 2, HK_NULL, 0 },
		{"DockingFlagBits", hkbDockingGeneratorDockingFlagBitsEnumItems, 3, HK_NULL, 0 }
	};
	const hkClassEnum* hkbDockingGeneratorBlendTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkbDockingGeneratorEnums[0]);
	const hkClassEnum* hkbDockingGeneratorDockingFlagBitsEnum = reinterpret_cast<const hkClassEnum*>(&hkbDockingGeneratorEnums[1]);
	static hkInternalClassMember hkbDockingGeneratorClass_Members[] =
	{
		{ "dockingBone", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "translationOffset", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "rotationOffset", HK_NULL, HK_NULL, hkClassMember::TYPE_QUATERNION, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "blendType", HK_NULL, hkbDockingGeneratorBlendTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL },
		{ "flags", HK_NULL, hkbDockingGeneratorDockingFlagBitsEnum, hkClassMember::TYPE_FLAGS, hkClassMember::TYPE_UINT16, 0, 0, 0, HK_NULL },
		{ "child", &hkbGeneratorClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "intervalStart", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "intervalEnd", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "localTime", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "previousLocalTime", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "intervalStartLocalTime", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "intervalEndLocalTime", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkbDockingGenerator_DefaultStruct
		{
			int s_defaultOffsets[12];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkInt16 m_dockingBone;
			hkUint16 /* hkFlags< enum hkbDockingGenerator::DockingFlagBits, hkUint16 > */ m_flags;
			hkInt32 m_intervalStart;
			hkInt32 m_intervalEnd;
		};
		const hkbDockingGenerator_DefaultStruct hkbDockingGenerator_Default =
		{
			{HK_OFFSET_OF(hkbDockingGenerator_DefaultStruct,m_dockingBone),-1,-1,-1,HK_OFFSET_OF(hkbDockingGenerator_DefaultStruct,m_flags),-1,HK_OFFSET_OF(hkbDockingGenerator_DefaultStruct,m_intervalStart),HK_OFFSET_OF(hkbDockingGenerator_DefaultStruct,m_intervalEnd),-1,-1,-1,-1},
			-1,hkbDockingGenerator::FLAG_NONE,hkbEvent::EVENT_ID_NULL,hkbEvent::EVENT_ID_NULL
		};
	}
	hkClass hkbDockingGeneratorClass(
		"hkbDockingGenerator",
		&hkbGeneratorClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkbDockingGeneratorEnums),
		2,
		reinterpret_cast<const hkClassMember*>(hkbDockingGeneratorClass_Members),
		HK_COUNT_OF(hkbDockingGeneratorClass_Members),
		&hkbDockingGenerator_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkbWorldFromModelModeDataWorldFromModelModeEnumItems[] =
	{
		{0, "WORLD_FROM_MODEL_MODE_USE_OLD"},
		{1, "WORLD_FROM_MODEL_MODE_USE_INPUT"},
		{2, "WORLD_FROM_MODEL_MODE_COMPUTE"},
		{3, "WORLD_FROM_MODEL_MODE_NONE"},
	};
	static const hkInternalClassEnum hkbWorldFromModelModeDataEnums[] = {
		{"WorldFromModelMode", hkbWorldFromModelModeDataWorldFromModelModeEnumItems, 4, HK_NULL, 0 }
	};
	const hkClassEnum* hkbWorldFromModelModeDataWorldFromModelModeEnum = reinterpret_cast<const hkClassEnum*>(&hkbWorldFromModelModeDataEnums[0]);
	static hkInternalClassMember hkbWorldFromModelModeDataClass_Members[] =
	{
		{ "poseMatchingBone0", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "poseMatchingBone1", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "poseMatchingBone2", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "mode", HK_NULL, hkbWorldFromModelModeDataWorldFromModelModeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkbWorldFromModelModeData_DefaultStruct
		{
			int s_defaultOffsets[4];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkInt16 m_poseMatchingBone0;
			hkInt16 m_poseMatchingBone1;
			hkInt16 m_poseMatchingBone2;
			hkInt8 /* hkEnum< enum hkbWorldFromModelModeData::WorldFromModelMode, hkInt8 > */ m_mode;
		};
		const hkbWorldFromModelModeData_DefaultStruct hkbWorldFromModelModeData_Default =
		{
			{HK_OFFSET_OF(hkbWorldFromModelModeData_DefaultStruct,m_poseMatchingBone0),HK_OFFSET_OF(hkbWorldFromModelModeData_DefaultStruct,m_poseMatchingBone1),HK_OFFSET_OF(hkbWorldFromModelModeData_DefaultStruct,m_poseMatchingBone2),HK_OFFSET_OF(hkbWorldFromModelModeData_DefaultStruct,m_mode)},
			-1,-1,-1,hkbWorldFromModelModeData::WORLD_FROM_MODEL_MODE_NONE
		};
	}
	hkClass hkbWorldFromModelModeDataClass(
		"hkbWorldFromModelModeData",
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkbWorldFromModelModeDataEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkbWorldFromModelModeDataClass_Members),
		HK_COUNT_OF(hkbWorldFromModelModeDataClass_Members),
		&hkbWorldFromModelModeData_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbBehaviorReferenceGeneratorClass_Members[] =
	{
		{ "behaviorName", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "behavior", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hkbBehaviorReferenceGeneratorClass(
		"hkbBehaviorReferenceGenerator",
		&hkbGeneratorClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbBehaviorReferenceGeneratorClass_Members),
		HK_COUNT_OF(hkbBehaviorReferenceGeneratorClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hkbStateListenerClass(
		"hkbStateListener",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkbBlendCurveUtilsBlendCurveEnumItems[] =
	{
		{0, "BLEND_CURVE_SMOOTH"},
		{1, "BLEND_CURVE_LINEAR"},
		{2, "BLEND_CURVE_LINEAR_TO_SMOOTH"},
		{3, "BLEND_CURVE_SMOOTH_TO_LINEAR"},
	};
	static const hkInternalClassEnum hkbBlendCurveUtilsEnums[] = {
		{"BlendCurve", hkbBlendCurveUtilsBlendCurveEnumItems, 4, HK_NULL, 0 }
	};
	const hkClassEnum* hkbBlendCurveUtilsBlendCurveEnum = reinterpret_cast<const hkClassEnum*>(&hkbBlendCurveUtilsEnums[0]);
	hkClass hkbBlendCurveUtilsClass(
		"hkbBlendCurveUtils",
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkbBlendCurveUtilsEnums),
		1,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkbJigglerModifierJiggleCoordinatesEnumItems[] =
	{
		{0, "JIGGLE_IN_WORLD_COORDINATES"},
		{1, "JIGGLE_IN_MODEL_COORDINATES"},
	};
	static const hkInternalClassEnum hkbJigglerModifierEnums[] = {
		{"JiggleCoordinates", hkbJigglerModifierJiggleCoordinatesEnumItems, 2, HK_NULL, 0 }
	};
	const hkClassEnum* hkbJigglerModifierJiggleCoordinatesEnum = reinterpret_cast<const hkClassEnum*>(&hkbJigglerModifierEnums[0]);
	static hkInternalClassMember hkbJigglerModifierClass_Members[] =
	{
		{ "jigglerGroups", &hkbJigglerGroupClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "jiggleCoordinates", HK_NULL, hkbJigglerModifierJiggleCoordinatesEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL },
		{ "currentVelocitiesWS", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "currentPositions", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "timeStep", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "initNextModify", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	namespace
	{
		struct hkbJigglerModifier_DefaultStruct
		{
			int s_defaultOffsets[6];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkInt8 /* hkEnum< enum hkbJigglerModifier::JiggleCoordinates, hkInt8 > */ m_jiggleCoordinates;
		};
		const hkbJigglerModifier_DefaultStruct hkbJigglerModifier_Default =
		{
			{-1,HK_OFFSET_OF(hkbJigglerModifier_DefaultStruct,m_jiggleCoordinates),-1,-1,-1,-1},
			hkbJigglerModifier::JIGGLE_IN_WORLD_COORDINATES
		};
	}
	hkClass hkbJigglerModifierClass(
		"hkbJigglerModifier",
		&hkbModifierClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkbJigglerModifierEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkbJigglerModifierClass_Members),
		HK_COUNT_OF(hkbJigglerModifierClass_Members),
		&hkbJigglerModifier_Default,
		HK_NULL,
		0,
		hkUint32(1)
		);
	hkClass hkbDefaultMessageLogClass(
		"hkbDefaultMessageLog",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbBehaviorGraphStringDataClass_Members[] =
	{
		{ "eventNames", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRINGPTR, 0, 0, 0, HK_NULL },
		{ "attributeNames", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRINGPTR, 0, 0, 0, HK_NULL },
		{ "variableNames", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRINGPTR, 0, 0, 0, HK_NULL },
		{ "characterPropertyNames", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRINGPTR, 0, 0, 0, HK_NULL }
	};
	hkClass hkbBehaviorGraphStringDataClass(
		"hkbBehaviorGraphStringData",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbBehaviorGraphStringDataClass_Members),
		HK_COUNT_OF(hkbBehaviorGraphStringDataClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkbComputeDirectionModifierClass_Members[] =
	{
		{ "pointIn", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "pointOut", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "groundAngleOut", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "upAngleOut", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "verticalOffset", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "reverseGroundAngle", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "reverseUpAngle", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "projectPoint", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "normalizePoint", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "computeOnlyOnce", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "computedOutput", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkbComputeDirectionModifierClass(
		"hkbComputeDirectionModifier",
		&hkbModifierClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbComputeDirectionModifierClass_Members),
		HK_COUNT_OF(hkbComputeDirectionModifierClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbGetWorldFromModelModifierClass_Members[] =
	{
		{ "translationOut", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "rotationOut", HK_NULL, HK_NULL, hkClassMember::TYPE_QUATERNION, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkbGetWorldFromModelModifier_DefaultStruct
		{
			int s_defaultOffsets[2];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			_hkVector4 m_translationOut;
			_hkQuaternion m_rotationOut;
		};
		const hkbGetWorldFromModelModifier_DefaultStruct hkbGetWorldFromModelModifier_Default =
		{
			{HK_OFFSET_OF(hkbGetWorldFromModelModifier_DefaultStruct,m_translationOut),HK_OFFSET_OF(hkbGetWorldFromModelModifier_DefaultStruct,m_rotationOut)},
		{0,0,0,0},	{0,0,0,1}
		};
	}
	hkClass hkbGetWorldFromModelModifierClass(
		"hkbGetWorldFromModelModifier",
		&hkbModifierClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbGetWorldFromModelModifierClass_Members),
		HK_COUNT_OF(hkbGetWorldFromModelModifierClass_Members),
		&hkbGetWorldFromModelModifier_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbCharacterStringData_FileNameMeshNamePairClass_Members[] =
	{
		{ "fileName", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "meshName", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkbCharacterStringDataFileNameMeshNamePairClass(
		"hkbCharacterStringDataFileNameMeshNamePair",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbCharacterStringData_FileNameMeshNamePairClass_Members),
		HK_COUNT_OF(hkbCharacterStringData_FileNameMeshNamePairClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbCharacterStringDataClass_Members[] =
	{
		{ "skinNames", &hkbCharacterStringDataFileNameMeshNamePairClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "boneAttachmentNames", &hkbCharacterStringDataFileNameMeshNamePairClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "animationNames", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRINGPTR, 0, 0, 0, HK_NULL },
		{ "animationFilenames", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRINGPTR, 0, 0, 0, HK_NULL },
		{ "characterPropertyNames", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRINGPTR, 0, 0, 0, HK_NULL },
		{ "retargetingSkeletonMapperFilenames", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRINGPTR, 0, 0, 0, HK_NULL },
		{ "lodNames", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRINGPTR, 0, 0, 0, HK_NULL },
		{ "mirroredSyncPointSubstringsA", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRINGPTR, 0, 0, 0, HK_NULL },
		{ "mirroredSyncPointSubstringsB", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRINGPTR, 0, 0, 0, HK_NULL },
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "rigName", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "ragdollName", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "behaviorFilename", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "luaScriptOnCharacterActivated", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "luaScriptOnCharacterDeactivated", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "luaFiles", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRINGPTR, 0, 0, 0, HK_NULL }
	};
	hkClass hkbCharacterStringDataClass(
		"hkbCharacterStringData",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbCharacterStringDataClass_Members),
		HK_COUNT_OF(hkbCharacterStringDataClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(8)
		);
	static hkInternalClassMember hkbModifierWrapperClass_Members[] =
	{
		{ "modifier", &hkbModifierClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkbModifierWrapperClass(
		"hkbModifierWrapper",
		&hkbModifierClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbModifierWrapperClass_Members),
		HK_COUNT_OF(hkbModifierWrapperClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbRigidBodyRagdollControlDataClass_Members[] =
	{
		{ "keyFrameHierarchyControlData", &hkaKeyFrameHierarchyUtilityControlDataClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::ALIGN_16, 0, HK_NULL },
		{ "durationToBlend", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkbRigidBodyRagdollControlData_DefaultStruct
		{
			int s_defaultOffsets[2];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
		};
		const hkbRigidBodyRagdollControlData_DefaultStruct hkbRigidBodyRagdollControlData_Default =
		{
			{-1,hkClassMember::HK_CLASS_ZERO_DEFAULT},
		};
	}
	hkClass hkbRigidBodyRagdollControlDataClass(
		"hkbRigidBodyRagdollControlData",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbRigidBodyRagdollControlDataClass_Members),
		HK_COUNT_OF(hkbRigidBodyRagdollControlDataClass_Members),
		&hkbRigidBodyRagdollControlData_Default,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkbHandleClass_Members[] =
	{
		{ "frame", &hkLocalFrameClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "rigidBody", &hkpRigidBodyClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "character", &hkbCharacterClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "animationBoneIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkbHandle_DefaultStruct
		{
			int s_defaultOffsets[4];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkInt16 m_animationBoneIndex;
		};
		const hkbHandle_DefaultStruct hkbHandle_Default =
		{
			{hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkbHandle_DefaultStruct,m_animationBoneIndex)},
			-1
		};
	}
	hkClass hkbHandleClass(
		"hkbHandle",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbHandleClass_Members),
		HK_COUNT_OF(hkbHandleClass_Members),
		&hkbHandle_Default,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkbBoneWeightArrayClass_Members[] =
	{
		{ "boneWeights", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_REAL, 0, 0, 0, HK_NULL }
	};
	hkClass hkbBoneWeightArrayClass(
		"hkbBoneWeightArray",
		&hkbBindableClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbBoneWeightArrayClass_Members),
		HK_COUNT_OF(hkbBoneWeightArrayClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbGeneratorSyncInfo_SyncPointClass_Members[] =
	{
		{ "id", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "time", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkbGeneratorSyncInfoSyncPointClass(
		"hkbGeneratorSyncInfoSyncPoint",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbGeneratorSyncInfo_SyncPointClass_Members),
		HK_COUNT_OF(hkbGeneratorSyncInfo_SyncPointClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbGeneratorSyncInfoClass_Members[] =
	{
		{ "syncPoints", &hkbGeneratorSyncInfoSyncPointClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 8, 0, 0, HK_NULL },
		{ "baseFrequency", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "localTime", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "playbackSpeed", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "numSyncPoints", HK_NULL, HK_NULL, hkClassMember::TYPE_INT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "isCyclic", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "isMirrored", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "isAdditive", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkbGeneratorSyncInfoClass(
		"hkbGeneratorSyncInfo",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbGeneratorSyncInfoClass_Members),
		HK_COUNT_OF(hkbGeneratorSyncInfoClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbReferencedGeneratorSyncInfoClass_Members[] =
	{
		{ "syncInfo", &hkbGeneratorSyncInfoClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkbReferencedGeneratorSyncInfoClass(
		"hkbReferencedGeneratorSyncInfo",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbReferencedGeneratorSyncInfoClass_Members),
		HK_COUNT_OF(hkbReferencedGeneratorSyncInfoClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbFootIkGainsClass_Members[] =
	{
		{ "onOffGain", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "groundAscendingGain", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "groundDescendingGain", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "footPlantedGain", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "footRaisedGain", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "footUnlockGain", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "worldFromModelFeedbackGain", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "errorUpDownBias", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "alignWorldFromModelGain", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "hipOrientationGain", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkbFootIkGains_DefaultStruct
		{
			int s_defaultOffsets[10];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkReal m_onOffGain;
			hkReal m_groundAscendingGain;
			hkReal m_groundDescendingGain;
			hkReal m_footPlantedGain;
			hkReal m_footRaisedGain;
			hkReal m_footUnlockGain;
			hkReal m_errorUpDownBias;
		};
		const hkbFootIkGains_DefaultStruct hkbFootIkGains_Default =
		{
			{HK_OFFSET_OF(hkbFootIkGains_DefaultStruct,m_onOffGain),HK_OFFSET_OF(hkbFootIkGains_DefaultStruct,m_groundAscendingGain),HK_OFFSET_OF(hkbFootIkGains_DefaultStruct,m_groundDescendingGain),HK_OFFSET_OF(hkbFootIkGains_DefaultStruct,m_footPlantedGain),HK_OFFSET_OF(hkbFootIkGains_DefaultStruct,m_footRaisedGain),HK_OFFSET_OF(hkbFootIkGains_DefaultStruct,m_footUnlockGain),hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkbFootIkGains_DefaultStruct,m_errorUpDownBias),hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT},
			0.2f,1.0f,1.0f,1.0f,1.0f,1.0f,1.0f
		};
	}
	hkClass hkbFootIkGainsClass(
		"hkbFootIkGains",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbFootIkGainsClass_Members),
		HK_COUNT_OF(hkbFootIkGainsClass_Members),
		&hkbFootIkGains_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbComputeRotationToTargetModifierClass_Members[] =
	{
		{ "rotationOut", HK_NULL, HK_NULL, hkClassMember::TYPE_QUATERNION, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "targetPosition", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "currentPosition", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "currentRotation", HK_NULL, HK_NULL, hkClassMember::TYPE_QUATERNION, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "localAxisOfRotation", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "localFacingDirection", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "resultIsDelta", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkbComputeRotationToTargetModifier_DefaultStruct
		{
			int s_defaultOffsets[7];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			_hkQuaternion m_rotationOut;
			_hkVector4 m_targetPosition;
			_hkVector4 m_currentPosition;
			_hkQuaternion m_currentRotation;
			_hkVector4 m_localAxisOfRotation;
			_hkVector4 m_localFacingDirection;
		};
		const hkbComputeRotationToTargetModifier_DefaultStruct hkbComputeRotationToTargetModifier_Default =
		{
			{HK_OFFSET_OF(hkbComputeRotationToTargetModifier_DefaultStruct,m_rotationOut),HK_OFFSET_OF(hkbComputeRotationToTargetModifier_DefaultStruct,m_targetPosition),HK_OFFSET_OF(hkbComputeRotationToTargetModifier_DefaultStruct,m_currentPosition),HK_OFFSET_OF(hkbComputeRotationToTargetModifier_DefaultStruct,m_currentRotation),HK_OFFSET_OF(hkbComputeRotationToTargetModifier_DefaultStruct,m_localAxisOfRotation),HK_OFFSET_OF(hkbComputeRotationToTargetModifier_DefaultStruct,m_localFacingDirection),hkClassMember::HK_CLASS_ZERO_DEFAULT},
		{0,0,0,1},	{0,0,0,0},	{0,0,0,0},	{0,0,0,0},	{0,0,1,0},	{1,0,0,0}
		};
	}
	hkClass hkbComputeRotationToTargetModifierClass(
		"hkbComputeRotationToTargetModifier",
		&hkbModifierClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbComputeRotationToTargetModifierClass_Members),
		HK_COUNT_OF(hkbComputeRotationToTargetModifierClass_Members),
		&hkbComputeRotationToTargetModifier_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbProjectStringDataClass_Members[] =
	{
		{ "animationFilenames", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRINGPTR, 0, 0, 0, HK_NULL },
		{ "behaviorFilenames", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRINGPTR, 0, 0, 0, HK_NULL },
		{ "characterFilenames", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRINGPTR, 0, 0, 0, HK_NULL },
		{ "eventNames", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRINGPTR, 0, 0, 0, HK_NULL },
		{ "animationPath", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "behaviorPath", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "characterPath", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "scriptsPath", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "fullPathToSource", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "rootPath", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hkbProjectStringDataClass(
		"hkbProjectStringData",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbProjectStringDataClass_Members),
		HK_COUNT_OF(hkbProjectStringDataClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(2)
		);
	static hkInternalClassMember hkbMessageLogClass_Members[] =
	{
		{ "messages", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "maxMessages", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hkbMessageLogClass(
		"hkbMessageLog",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbMessageLogClass_Members),
		HK_COUNT_OF(hkbMessageLogClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbExtractRagdollPoseModifierClass_Members[] =
	{
		{ "poseMatchingBone0", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "poseMatchingBone1", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "poseMatchingBone2", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "enableComputeWorldFromModel", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkbExtractRagdollPoseModifier_DefaultStruct
		{
			int s_defaultOffsets[4];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkInt16 m_poseMatchingBone0;
			hkInt16 m_poseMatchingBone1;
			hkInt16 m_poseMatchingBone2;
		};
		const hkbExtractRagdollPoseModifier_DefaultStruct hkbExtractRagdollPoseModifier_Default =
		{
			{HK_OFFSET_OF(hkbExtractRagdollPoseModifier_DefaultStruct,m_poseMatchingBone0),HK_OFFSET_OF(hkbExtractRagdollPoseModifier_DefaultStruct,m_poseMatchingBone1),HK_OFFSET_OF(hkbExtractRagdollPoseModifier_DefaultStruct,m_poseMatchingBone2),hkClassMember::HK_CLASS_ZERO_DEFAULT},
			-1,-1,-1
		};
	}
	hkClass hkbExtractRagdollPoseModifierClass(
		"hkbExtractRagdollPoseModifier",
		&hkbModifierClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbExtractRagdollPoseModifierClass_Members),
		HK_COUNT_OF(hkbExtractRagdollPoseModifierClass_Members),
		&hkbExtractRagdollPoseModifier_Default,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkbGetUpModifierClass_Members[] =
	{
		{ "groundNormal", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "duration", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "alignWithGroundDuration", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "rootBoneIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "otherBoneIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "anotherBoneIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "timeSinceBegin", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "timeStep", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "initNextModify", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	namespace
	{
		struct hkbGetUpModifier_DefaultStruct
		{
			int s_defaultOffsets[9];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			_hkVector4 m_groundNormal;
			hkReal m_duration;
			hkInt16 m_rootBoneIndex;
			hkInt16 m_otherBoneIndex;
			hkInt16 m_anotherBoneIndex;
		};
		const hkbGetUpModifier_DefaultStruct hkbGetUpModifier_Default =
		{
			{HK_OFFSET_OF(hkbGetUpModifier_DefaultStruct,m_groundNormal),HK_OFFSET_OF(hkbGetUpModifier_DefaultStruct,m_duration),hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkbGetUpModifier_DefaultStruct,m_rootBoneIndex),HK_OFFSET_OF(hkbGetUpModifier_DefaultStruct,m_otherBoneIndex),HK_OFFSET_OF(hkbGetUpModifier_DefaultStruct,m_anotherBoneIndex),-1,-1,-1},
			{0,0,0,0},1.0,-1,-1,-1
		};
	}
	hkClass hkbGetUpModifierClass(
		"hkbGetUpModifier",
		&hkbModifierClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbGetUpModifierClass_Members),
		HK_COUNT_OF(hkbGetUpModifierClass_Members),
		&hkbGetUpModifier_Default,
		HK_NULL,
		0,
		hkUint32(2)
		);
	static hkInternalClassMember hkbExpressionConditionClass_Members[] =
	{
		{ "expression", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "compiledExpressionSet", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hkbExpressionConditionClass(
		"hkbExpressionCondition",
		&hkbConditionClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbExpressionConditionClass_Members),
		HK_COUNT_OF(hkbExpressionConditionClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkbManualSelectorGeneratorClass_Members[] =
	{
		{ "generators", &hkbGeneratorClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "selectedGeneratorIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "selectedIndexCanChangeAfterActivate", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "generatorChangedTransitionEffect", &hkbTransitionEffectClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "currentGeneratorIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "generatorIndexAtActivate", HK_NULL, HK_NULL, hkClassMember::TYPE_INT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "activeTransitions", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	namespace
	{
		struct hkbManualSelectorGenerator_DefaultStruct
		{
			int s_defaultOffsets[7];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			_hkBool m_selectedIndexCanChangeAfterActivate;
		};
		const hkbManualSelectorGenerator_DefaultStruct hkbManualSelectorGenerator_Default =
		{
			{-1,hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkbManualSelectorGenerator_DefaultStruct,m_selectedIndexCanChangeAfterActivate),hkClassMember::HK_CLASS_ZERO_DEFAULT,-1,-1,-1},
			true
		};
	}
	hkClass hkbManualSelectorGeneratorClass(
		"hkbManualSelectorGenerator",
		&hkbGeneratorClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbManualSelectorGeneratorClass_Members),
		HK_COUNT_OF(hkbManualSelectorGeneratorClass_Members),
		&hkbManualSelectorGenerator_Default,
		HK_NULL,
		0,
		hkUint32(2)
		);
	static hkInternalClassMember hkbMoveBoneAttachmentModifierClass_Members[] =
	{
		{ "activateEventId", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "attachment", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "localFrame", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkbMoveBoneAttachmentModifier_DefaultStruct
		{
			int s_defaultOffsets[3];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkInt32 m_activateEventId;
		};
		const hkbMoveBoneAttachmentModifier_DefaultStruct hkbMoveBoneAttachmentModifier_Default =
		{
			{HK_OFFSET_OF(hkbMoveBoneAttachmentModifier_DefaultStruct,m_activateEventId),-1,-1},
			hkbEvent::EVENT_ID_NULL
		};
	}
	hkClass hkbMoveBoneAttachmentModifierClass(
		"hkbMoveBoneAttachmentModifier",
		&hkbModifierClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbMoveBoneAttachmentModifierClass_Members),
		HK_COUNT_OF(hkbMoveBoneAttachmentModifierClass_Members),
		&hkbMoveBoneAttachmentModifier_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbCharacterSetupClass_Members[] =
	{
		{ "retargetingSkeletonMappers", &hkaSkeletonMapperClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "animationSkeleton", &hkaSkeletonClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "ragdollToAnimationSkeletonMapper", &hkaSkeletonMapperClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "animationToRagdollSkeletonMapper", &hkaSkeletonMapperClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "animationBindingSet", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "data", &hkbCharacterDataClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "unscaledAnimationSkeleton", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "mirroredSkeleton", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "characterPropertyIdMap", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "criticalSection", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hkbCharacterSetupClass(
		"hkbCharacterSetup",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbCharacterSetupClass_Members),
		HK_COUNT_OF(hkbCharacterSetupClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(2)
		);
	hkClass hkbConditionClass(
		"hkbCondition",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkbGeneratorTransitionEffectToGeneratorStateEnumItems[] =
	{
		{0, "STATE_INACTIVE"},
		{1, "STATE_READY_FOR_SET_LOCAL_TIME"},
		{2, "STATE_READY_FOR_APPLY_SELF_TRANSITION_MODE"},
		{3, "STATE_ACTIVE"},
	};
	static const hkInternalClassEnumItem hkbGeneratorTransitionEffectStageEnumItems[] =
	{
		{0, "STAGE_BLENDING_IN"},
		{1, "STAGE_PLAYING_TRANSITION_GENERATOR"},
		{2, "STAGE_BLENDING_OUT"},
	};
	static const hkInternalClassEnumItem hkbGeneratorTransitionEffectChildStateEnumItems[] =
	{
		{0, "CHILD_FROM_GENERATOR"},
		{1, "CHILD_TRANSITION_GENERATOR"},
		{2, "CHILD_TO_GENERATOR"},
		{3, "CHILD_NONE"},
	};
	static const hkInternalClassEnum hkbGeneratorTransitionEffectEnums[] = {
		{"ToGeneratorState", hkbGeneratorTransitionEffectToGeneratorStateEnumItems, 4, HK_NULL, 0 },
		{"Stage", hkbGeneratorTransitionEffectStageEnumItems, 3, HK_NULL, 0 },
		{"ChildState", hkbGeneratorTransitionEffectChildStateEnumItems, 4, HK_NULL, 0 }
	};
	const hkClassEnum* hkbGeneratorTransitionEffectToGeneratorStateEnum = reinterpret_cast<const hkClassEnum*>(&hkbGeneratorTransitionEffectEnums[0]);
	const hkClassEnum* hkbGeneratorTransitionEffectStageEnum = reinterpret_cast<const hkClassEnum*>(&hkbGeneratorTransitionEffectEnums[1]);
	const hkClassEnum* hkbGeneratorTransitionEffectChildStateEnum = reinterpret_cast<const hkClassEnum*>(&hkbGeneratorTransitionEffectEnums[2]);
	static hkInternalClassMember hkbGeneratorTransitionEffectClass_Members[] =
	{
		{ "transitionGenerator", &hkbGeneratorClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "blendInDuration", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "blendOutDuration", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "syncToGeneratorStartTime", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "childState", HK_NULL, HK_NULL, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "fromGenerator", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "toGenerator", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "timeInTransition", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "duration", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "effectiveBlendInDuration", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "effectiveBlendOutDuration", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "toGeneratorState", HK_NULL, HK_NULL, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "echoTransitionGenerator", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "echoToGenerator", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "justActivated", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "updateActiveNodes", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "stage", HK_NULL, HK_NULL, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	namespace
	{
		struct hkbGeneratorTransitionEffect_DefaultStruct
		{
			int s_defaultOffsets[17];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			_hkBool m_syncToGeneratorStartTime;
		};
		const hkbGeneratorTransitionEffect_DefaultStruct hkbGeneratorTransitionEffect_Default =
		{
			{-1,hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkbGeneratorTransitionEffect_DefaultStruct,m_syncToGeneratorStartTime),-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
			true
		};
	}
	hkClass hkbGeneratorTransitionEffectClass(
		"hkbGeneratorTransitionEffect",
		&hkbTransitionEffectClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkbGeneratorTransitionEffectEnums),
		3,
		reinterpret_cast<const hkClassMember*>(hkbGeneratorTransitionEffectClass_Members),
		HK_COUNT_OF(hkbGeneratorTransitionEffectClass_Members),
		&hkbGeneratorTransitionEffect_Default,
		HK_NULL,
		0,
		hkUint32(3)
		);
	static hkInternalClassMember hkbHandIkControlsModifier_HandClass_Members[] =
	{
		{ "controlData", &hkbHandIkControlDataClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "handIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "enable", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkbHandIkControlsModifierHand_DefaultStruct
		{
			int s_defaultOffsets[3];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
		};
		const hkbHandIkControlsModifierHand_DefaultStruct hkbHandIkControlsModifierHand_Default =
		{
			{-1,hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT},
		};
	}
	hkClass hkbHandIkControlsModifierHandClass(
		"hkbHandIkControlsModifierHand",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbHandIkControlsModifier_HandClass_Members),
		HK_COUNT_OF(hkbHandIkControlsModifier_HandClass_Members),
		&hkbHandIkControlsModifierHand_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbHandIkControlsModifierClass_Members[] =
	{
		{ "hands", &hkbHandIkControlsModifierHandClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkbHandIkControlsModifierClass(
		"hkbHandIkControlsModifier",
		&hkbModifierClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbHandIkControlsModifierClass_Members),
		HK_COUNT_OF(hkbHandIkControlsModifierClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbExtrapolatingTransitionEffectClass_Members[] =
	{
		{ "fromGeneratorSyncInfo", &hkbGeneratorSyncInfoClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "worldFromModel", HK_NULL, HK_NULL, hkClassMember::TYPE_QSTRANSFORM, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "motion", HK_NULL, HK_NULL, hkClassMember::TYPE_QSTRANSFORM, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "pose", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "additivePose", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "toGeneratorDuration", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "isFromGeneratorActive", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "gotPose", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "gotAdditivePose", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hkbExtrapolatingTransitionEffectClass(
		"hkbExtrapolatingTransitionEffect",
		&hkbBlendingTransitionEffectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbExtrapolatingTransitionEffectClass_Members),
		HK_COUNT_OF(hkbExtrapolatingTransitionEffectClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkbTwistModifierSetAngleMethodEnumItems[] =
	{
		{0, "LINEAR"},
		{1, "RAMPED"},
	};
	static const hkInternalClassEnumItem hkbTwistModifierRotationAxisCoordinatesEnumItems[] =
	{
		{0, "ROTATION_AXIS_IN_MODEL_COORDINATES"},
		{1, "ROTATION_AXIS_IN_LOCAL_COORDINATES"},
	};
	static const hkInternalClassEnum hkbTwistModifierEnums[] = {
		{"SetAngleMethod", hkbTwistModifierSetAngleMethodEnumItems, 2, HK_NULL, 0 },
		{"RotationAxisCoordinates", hkbTwistModifierRotationAxisCoordinatesEnumItems, 2, HK_NULL, 0 }
	};
	const hkClassEnum* hkbTwistModifierSetAngleMethodEnum = reinterpret_cast<const hkClassEnum*>(&hkbTwistModifierEnums[0]);
	const hkClassEnum* hkbTwistModifierRotationAxisCoordinatesEnum = reinterpret_cast<const hkClassEnum*>(&hkbTwistModifierEnums[1]);
	static hkInternalClassMember hkbTwistModifierClass_Members[] =
	{
		{ "axisOfRotation", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "twistAngle", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "startBoneIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "endBoneIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "setAngleMethod", HK_NULL, hkbTwistModifierSetAngleMethodEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL },
		{ "rotationAxisCoordinates", HK_NULL, hkbTwistModifierRotationAxisCoordinatesEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL },
		{ "isAdditive", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "boneChainIndices", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "parentBoneIndices", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	namespace
	{
		struct hkbTwistModifier_DefaultStruct
		{
			int s_defaultOffsets[9];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			_hkVector4 m_axisOfRotation;
			hkInt16 m_startBoneIndex;
			hkInt16 m_endBoneIndex;
			hkInt8 /* hkEnum< enum hkbTwistModifier::RotationAxisCoordinates, hkInt8 > */ m_rotationAxisCoordinates;
			_hkBool m_isAdditive;
		};
		const hkbTwistModifier_DefaultStruct hkbTwistModifier_Default =
		{
			{HK_OFFSET_OF(hkbTwistModifier_DefaultStruct,m_axisOfRotation),hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkbTwistModifier_DefaultStruct,m_startBoneIndex),HK_OFFSET_OF(hkbTwistModifier_DefaultStruct,m_endBoneIndex),hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkbTwistModifier_DefaultStruct,m_rotationAxisCoordinates),HK_OFFSET_OF(hkbTwistModifier_DefaultStruct,m_isAdditive),-1,-1},
			{1,0,0},-1,-1,hkbTwistModifier::ROTATION_AXIS_IN_MODEL_COORDINATES,1
		};
	}
	hkClass hkbTwistModifierClass(
		"hkbTwistModifier",
		&hkbModifierClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkbTwistModifierEnums),
		2,
		reinterpret_cast<const hkClassMember*>(hkbTwistModifierClass_Members),
		HK_COUNT_OF(hkbTwistModifierClass_Members),
		&hkbTwistModifier_Default,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkbProjectDataClass_Members[] =
	{
		{ "worldUpWS", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "stringData", &hkbProjectStringDataClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "defaultEventMode", HK_NULL, hkbTransitionEffectEventModeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL }
	};
	hkClass hkbProjectDataClass(
		"hkbProjectData",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbProjectDataClass_Members),
		HK_COUNT_OF(hkbProjectDataClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(2)
		);
	static hkInternalClassMember hkbReferencePoseGeneratorClass_Members[] =
	{
		{ "skeleton", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hkbReferencePoseGeneratorClass(
		"hkbReferencePoseGenerator",
		&hkbGeneratorClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbReferencePoseGeneratorClass_Members),
		HK_COUNT_OF(hkbReferencePoseGeneratorClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbNodeInternalStateInfoClass_Members[] =
	{
		{ "syncInfo", &hkbReferencedGeneratorSyncInfoClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "internalState", &hkReferencedObjectClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "nodeId", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "hasActivateBeenCalled", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "isModifierEnabled", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkbNodeInternalStateInfoClass(
		"hkbNodeInternalStateInfo",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbNodeInternalStateInfoClass_Members),
		HK_COUNT_OF(hkbNodeInternalStateInfoClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbBehaviorGraphInternalStateClass_Members[] =
	{
		{ "nodeInternalStateInfos", &hkbNodeInternalStateInfoClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "variableValueSet", &hkbVariableValueSetClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkbBehaviorGraphInternalStateClass(
		"hkbBehaviorGraphInternalState",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbBehaviorGraphInternalStateClass_Members),
		HK_COUNT_OF(hkbBehaviorGraphInternalStateClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkbEventRangeDataEventRangeModeEnumItems[] =
	{
		{0, "EVENT_MODE_SEND_ON_ENTER_RANGE"},
		{1, "EVENT_MODE_SEND_WHEN_IN_RANGE"},
	};
	static const hkInternalClassEnum hkbEventRangeDataEnums[] = {
		{"EventRangeMode", hkbEventRangeDataEventRangeModeEnumItems, 2, HK_NULL, 0 }
	};
	const hkClassEnum* hkbEventRangeDataEventRangeModeEnum = reinterpret_cast<const hkClassEnum*>(&hkbEventRangeDataEnums[0]);
	static hkInternalClassMember hkbEventRangeDataClass_Members[] =
	{
		{ "upperBound", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "event", &hkbEventPropertyClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "eventMode", HK_NULL, hkbEventRangeDataEventRangeModeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkbEventRangeData_DefaultStruct
		{
			int s_defaultOffsets[3];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkInt8 /* hkEnum< enum hkbEventRangeData::EventRangeMode, hkInt8 > */ m_eventMode;
		};
		const hkbEventRangeData_DefaultStruct hkbEventRangeData_Default =
		{
			{-1,-1,HK_OFFSET_OF(hkbEventRangeData_DefaultStruct,m_eventMode)},
			hkbEventRangeData::EVENT_MODE_SEND_ON_ENTER_RANGE
		};
	}
	hkClass hkbEventRangeDataClass(
		"hkbEventRangeData",
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkbEventRangeDataEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkbEventRangeDataClass_Members),
		HK_COUNT_OF(hkbEventRangeDataClass_Members),
		&hkbEventRangeData_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbEventRangeDataArrayClass_Members[] =
	{
		{ "eventData", &hkbEventRangeDataClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkbEventRangeDataArrayClass(
		"hkbEventRangeDataArray",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbEventRangeDataArrayClass_Members),
		HK_COUNT_OF(hkbEventRangeDataArrayClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbEventsFromRangeModifierClass_Members[] =
	{
		{ "inputValue", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "lowerBound", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "eventRanges", &hkbEventRangeDataArrayClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "wasActiveInPreviousFrame", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hkbEventsFromRangeModifierClass(
		"hkbEventsFromRangeModifier",
		&hkbModifierClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbEventsFromRangeModifierClass_Members),
		HK_COUNT_OF(hkbEventsFromRangeModifierClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbContextClass_Members[] =
	{
		{ "character", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "behavior", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "nodeToIndexMap", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "eventQueue", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "sharedEventQueue", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "generatorOutputListener", &hkbGeneratorOutputListenerClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "syncVariableSetup", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "eventTriggeredTransition", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "world", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "attachmentManager", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hkbContextClass(
		"hkbContext",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbContextClass_Members),
		HK_COUNT_OF(hkbContextClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static const hkInternalClassEnumItem hkbHandIkControlDataHandleChangeModeEnumItems[] =
	{
		{0, "HANDLE_CHANGE_MODE_ABRUPT"},
		{1, "HANDLE_CHANGE_MODE_CONSTANT_VELOCITY"},
	};
	static const hkInternalClassEnum hkbHandIkControlDataEnums[] = {
		{"HandleChangeMode", hkbHandIkControlDataHandleChangeModeEnumItems, 2, HK_NULL, 0 }
	};
	const hkClassEnum* hkbHandIkControlDataHandleChangeModeEnum = reinterpret_cast<const hkClassEnum*>(&hkbHandIkControlDataEnums[0]);
	static hkInternalClassMember hkbHandIkControlDataClass_Members[] =
	{
		{ "targetPosition", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "targetRotation", HK_NULL, HK_NULL, hkClassMember::TYPE_QUATERNION, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "targetNormal", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "targetHandle", &hkbHandleClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "transformOnFraction", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "normalOnFraction", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "fadeInDuration", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "fadeOutDuration", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "extrapolationTimeStep", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "handleChangeSpeed", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "handleChangeMode", HK_NULL, hkbHandIkControlDataHandleChangeModeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL },
		{ "fixUp", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkbHandIkControlData_DefaultStruct
		{
			int s_defaultOffsets[12];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			_hkVector4 m_targetPosition;
			_hkQuaternion m_targetRotation;
			_hkVector4 m_targetNormal;
			hkReal m_transformOnFraction;
			hkReal m_handleChangeSpeed;
			hkInt8 /* hkEnum< enum hkbHandIkControlData::HandleChangeMode, hkInt8 > */ m_handleChangeMode;
		};
		const hkbHandIkControlData_DefaultStruct hkbHandIkControlData_Default =
		{
			{HK_OFFSET_OF(hkbHandIkControlData_DefaultStruct,m_targetPosition),HK_OFFSET_OF(hkbHandIkControlData_DefaultStruct,m_targetRotation),HK_OFFSET_OF(hkbHandIkControlData_DefaultStruct,m_targetNormal),hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkbHandIkControlData_DefaultStruct,m_transformOnFraction),hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkbHandIkControlData_DefaultStruct,m_handleChangeSpeed),HK_OFFSET_OF(hkbHandIkControlData_DefaultStruct,m_handleChangeMode),hkClassMember::HK_CLASS_ZERO_DEFAULT},
		{0,0,0,0},	{0,0,0,1},	{0,0,0},1,1.0f,hkbHandIkControlData::HANDLE_CHANGE_MODE_ABRUPT
		};
	}
	hkClass hkbHandIkControlDataClass(
		"hkbHandIkControlData",
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkbHandIkControlDataEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkbHandIkControlDataClass_Members),
		HK_COUNT_OF(hkbHandIkControlDataClass_Members),
		&hkbHandIkControlData_Default,
		HK_NULL,
		0,
		hkUint32(2)
		);
	static hkInternalClassMember hkbMirroredSkeletonInfoClass_Members[] =
	{
		{ "mirrorAxis", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "bonePairMap", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_INT16, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkbMirroredSkeletonInfo_DefaultStruct
		{
			int s_defaultOffsets[2];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			_hkVector4 m_mirrorAxis;
		};
		const hkbMirroredSkeletonInfo_DefaultStruct hkbMirroredSkeletonInfo_Default =
		{
			{HK_OFFSET_OF(hkbMirroredSkeletonInfo_DefaultStruct,m_mirrorAxis),-1},
			{1,0,0,0}
		};
	}
	hkClass hkbMirroredSkeletonInfoClass(
		"hkbMirroredSkeletonInfo",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbMirroredSkeletonInfoClass_Members),
		HK_COUNT_OF(hkbMirroredSkeletonInfoClass_Members),
		&hkbMirroredSkeletonInfo_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbSetWorldFromModelModifierClass_Members[] =
	{
		{ "translation", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "rotation", HK_NULL, HK_NULL, hkClassMember::TYPE_QUATERNION, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "setTranslation", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "setRotation", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkbSetWorldFromModelModifier_DefaultStruct
		{
			int s_defaultOffsets[4];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			_hkVector4 m_translation;
			_hkQuaternion m_rotation;
			_hkBool m_setTranslation;
			_hkBool m_setRotation;
		};
		const hkbSetWorldFromModelModifier_DefaultStruct hkbSetWorldFromModelModifier_Default =
		{
			{HK_OFFSET_OF(hkbSetWorldFromModelModifier_DefaultStruct,m_translation),HK_OFFSET_OF(hkbSetWorldFromModelModifier_DefaultStruct,m_rotation),HK_OFFSET_OF(hkbSetWorldFromModelModifier_DefaultStruct,m_setTranslation),HK_OFFSET_OF(hkbSetWorldFromModelModifier_DefaultStruct,m_setRotation)},
		{0,0,0,0},	{0,0,0,1},true,true
		};
	}
	hkClass hkbSetWorldFromModelModifierClass(
		"hkbSetWorldFromModelModifier",
		&hkbModifierClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbSetWorldFromModelModifierClass_Members),
		HK_COUNT_OF(hkbSetWorldFromModelModifierClass_Members),
		&hkbSetWorldFromModelModifier_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkbBlendingTransitionEffectFlagBitsEnumItems[] =
	{
		{0, "FLAG_NONE"},
		{1, "FLAG_IGNORE_FROM_WORLD_FROM_MODEL"},
		{2, "FLAG_SYNC"},
		{4, "FLAG_IGNORE_TO_WORLD_FROM_MODEL"},
		{8, "FLAG_IGNORE_TO_WORLD_FROM_MODEL_ROTATION"},
	};
	static const hkInternalClassEnumItem hkbBlendingTransitionEffectEndModeEnumItems[] =
	{
		{0, "END_MODE_NONE"},
		{1, "END_MODE_TRANSITION_UNTIL_END_OF_FROM_GENERATOR"},
		{2, "END_MODE_CAP_DURATION_AT_END_OF_FROM_GENERATOR"},
	};
	static const hkInternalClassEnum hkbBlendingTransitionEffectEnums[] = {
		{"FlagBits", hkbBlendingTransitionEffectFlagBitsEnumItems, 5, HK_NULL, 0 },
		{"EndMode", hkbBlendingTransitionEffectEndModeEnumItems, 3, HK_NULL, 0 }
	};
	const hkClassEnum* hkbBlendingTransitionEffectFlagBitsEnum = reinterpret_cast<const hkClassEnum*>(&hkbBlendingTransitionEffectEnums[0]);
	const hkClassEnum* hkbBlendingTransitionEffectEndModeEnum = reinterpret_cast<const hkClassEnum*>(&hkbBlendingTransitionEffectEnums[1]);
	static hkInternalClassMember hkbBlendingTransitionEffectClass_Members[] =
	{
		{ "duration", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "toGeneratorStartTimeFraction", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "flags", HK_NULL, hkbBlendingTransitionEffectFlagBitsEnum, hkClassMember::TYPE_FLAGS, hkClassMember::TYPE_UINT16, 0, 0, 0, HK_NULL },
		{ "endMode", HK_NULL, hkbBlendingTransitionEffectEndModeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL },
		{ "blendCurve", HK_NULL, hkbBlendCurveUtilsBlendCurveEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL },
		{ "alignmentBone", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "fromPos", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "fromRot", HK_NULL, HK_NULL, hkClassMember::TYPE_QUATERNION, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "toPos", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "toRot", HK_NULL, HK_NULL, hkClassMember::TYPE_QUATERNION, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "lastPos", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "lastRot", HK_NULL, HK_NULL, hkClassMember::TYPE_QUATERNION, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "characterPoseAtBeginningOfTransition", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "timeRemaining", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "timeInTransition", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "applySelfTransition", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "initializeCharacterPose", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "alignThisFrame", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "alignmentFinished", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "fromGenerator", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "toGenerator", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	namespace
	{
		struct hkbBlendingTransitionEffect_DefaultStruct
		{
			int s_defaultOffsets[21];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkUint16 /* hkFlags< enum hkbBlendingTransitionEffect::FlagBits, hkUint16 > */ m_flags;
			hkInt8 /* hkEnum< enum hkbBlendingTransitionEffect::EndMode, hkInt8 > */ m_endMode;
			hkInt8 /* hkEnum< enum hkbBlendCurveUtils::BlendCurve, hkInt8 > */ m_blendCurve;
			hkInt16 m_alignmentBone;
		};
		const hkbBlendingTransitionEffect_DefaultStruct hkbBlendingTransitionEffect_Default =
		{
			{hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkbBlendingTransitionEffect_DefaultStruct,m_flags),HK_OFFSET_OF(hkbBlendingTransitionEffect_DefaultStruct,m_endMode),HK_OFFSET_OF(hkbBlendingTransitionEffect_DefaultStruct,m_blendCurve),HK_OFFSET_OF(hkbBlendingTransitionEffect_DefaultStruct,m_alignmentBone),-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
			hkbBlendingTransitionEffect::FLAG_NONE,hkbBlendingTransitionEffect::END_MODE_NONE,hkbBlendCurveUtils::BLEND_CURVE_SMOOTH,-1
		};
	}
	hkClass hkbBlendingTransitionEffectClass(
		"hkbBlendingTransitionEffect",
		&hkbTransitionEffectClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkbBlendingTransitionEffectEnums),
		2,
		reinterpret_cast<const hkClassMember*>(hkbBlendingTransitionEffectClass_Members),
		HK_COUNT_OF(hkbBlendingTransitionEffectClass_Members),
		&hkbBlendingTransitionEffect_Default,
		HK_NULL,
		0,
		hkUint32(2)
		);
	static hkInternalClassMember hkbDetectCloseToGroundModifierClass_Members[] =
	{
		{ "closeToGroundEvent", &hkbEventPropertyClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "closeToGroundHeight", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "raycastDistanceDown", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "collisionFilterInfo", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "boneIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "animBoneIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "isCloseToGround", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	namespace
	{
		struct hkbDetectCloseToGroundModifier_DefaultStruct
		{
			int s_defaultOffsets[7];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkReal m_closeToGroundHeight;
			hkReal m_raycastDistanceDown;
			hkUint32 m_collisionFilterInfo;
			hkInt16 m_boneIndex;
			hkInt16 m_animBoneIndex;
		};
		const hkbDetectCloseToGroundModifier_DefaultStruct hkbDetectCloseToGroundModifier_Default =
		{
			{-1,HK_OFFSET_OF(hkbDetectCloseToGroundModifier_DefaultStruct,m_closeToGroundHeight),HK_OFFSET_OF(hkbDetectCloseToGroundModifier_DefaultStruct,m_raycastDistanceDown),HK_OFFSET_OF(hkbDetectCloseToGroundModifier_DefaultStruct,m_collisionFilterInfo),HK_OFFSET_OF(hkbDetectCloseToGroundModifier_DefaultStruct,m_boneIndex),HK_OFFSET_OF(hkbDetectCloseToGroundModifier_DefaultStruct,m_animBoneIndex),-1},
			0.5,0.8f,3,-1,-1
		};
	}
	hkClass hkbDetectCloseToGroundModifierClass(
		"hkbDetectCloseToGroundModifier",
		&hkbModifierClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbDetectCloseToGroundModifierClass_Members),
		HK_COUNT_OF(hkbDetectCloseToGroundModifierClass_Members),
		&hkbDetectCloseToGroundModifier_Default,
		HK_NULL,
		0,
		hkUint32(2)
		);
	static hkInternalClassMember hkbModifierGeneratorClass_Members[] =
	{
		{ "modifier", &hkbModifierClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "generator", &hkbGeneratorClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkbModifierGeneratorClass(
		"hkbModifierGenerator",
		&hkbGeneratorClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbModifierGeneratorClass_Members),
		HK_COUNT_OF(hkbModifierGeneratorClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbJigglerGroupClass_Members[] =
	{
		{ "boneIndices", &hkbBoneIndexArrayClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "mass", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "stiffness", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "damping", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxElongation", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxCompression", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "propagateToChildren", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "affectSiblings", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "rotateBonesForSkinning", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "pad", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 5, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	namespace
	{
		struct hkbJigglerGroup_DefaultStruct
		{
			int s_defaultOffsets[10];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkReal m_mass;
			hkReal m_stiffness;
			hkReal m_damping;
			hkReal m_maxElongation;
			hkReal m_maxCompression;
			_hkBool m_propagateToChildren;
		};
		const hkbJigglerGroup_DefaultStruct hkbJigglerGroup_Default =
		{
			{-1,HK_OFFSET_OF(hkbJigglerGroup_DefaultStruct,m_mass),HK_OFFSET_OF(hkbJigglerGroup_DefaultStruct,m_stiffness),HK_OFFSET_OF(hkbJigglerGroup_DefaultStruct,m_damping),HK_OFFSET_OF(hkbJigglerGroup_DefaultStruct,m_maxElongation),HK_OFFSET_OF(hkbJigglerGroup_DefaultStruct,m_maxCompression),HK_OFFSET_OF(hkbJigglerGroup_DefaultStruct,m_propagateToChildren),hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,-1},
			1.0f,100.0f,1.0f,1.0f,0.5f,true
		};
	}
	hkClass hkbJigglerGroupClass(
		"hkbJigglerGroup",
		&hkbBindableClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbJigglerGroupClass_Members),
		HK_COUNT_OF(hkbJigglerGroupClass_Members),
		&hkbJigglerGroup_Default,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static const hkInternalClassEnumItem hkbSenseHandleModifierSensingModeEnumItems[] =
	{
		{0, "SENSE_IN_NEARBY_RIGID_BODIES"},
		{1, "SENSE_IN_RIGID_BODIES_OUTSIDE_THIS_CHARACTER"},
		{2, "SENSE_IN_OTHER_CHARACTER_RIGID_BODIES"},
		{3, "SENSE_IN_THIS_CHARACTER_RIGID_BODIES"},
		{4, "SENSE_IN_GIVEN_CHARACTER_RIGID_BODIES"},
		{5, "SENSE_IN_GIVEN_RIGID_BODY"},
		{6, "SENSE_IN_OTHER_CHARACTER_SKELETON"},
		{7, "SENSE_IN_THIS_CHARACTER_SKELETON"},
		{8, "SENSE_IN_GIVEN_CHARACTER_SKELETON"},
		{9, "SENSE_IN_GIVEN_LOCAL_FRAME_GROUP"},
	};
	static const hkInternalClassEnum hkbSenseHandleModifierEnums[] = {
		{"SensingMode", hkbSenseHandleModifierSensingModeEnumItems, 10, HK_NULL, 0 }
	};
	const hkClassEnum* hkbSenseHandleModifierSensingModeEnum = reinterpret_cast<const hkClassEnum*>(&hkbSenseHandleModifierEnums[0]);
	static hkInternalClassMember hkbSenseHandleModifier_RangeClass_Members[] =
	{
		{ "event", &hkbEventPropertyClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "minDistance", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxDistance", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "ignoreHandle", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkbSenseHandleModifierRange_DefaultStruct
		{
			int s_defaultOffsets[4];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkReal m_maxDistance;
		};
		const hkbSenseHandleModifierRange_DefaultStruct hkbSenseHandleModifierRange_Default =
		{
			{-1,hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkbSenseHandleModifierRange_DefaultStruct,m_maxDistance),-1},
			1.0f
		};
	}
	hkClass hkbSenseHandleModifierRangeClass(
		"hkbSenseHandleModifierRange",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbSenseHandleModifier_RangeClass_Members),
		HK_COUNT_OF(hkbSenseHandleModifier_RangeClass_Members),
		&hkbSenseHandleModifierRange_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbSenseHandleModifierClass_Members[] =
	{
		{ "handle", &hkbHandleClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "sensorLocalOffset", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "ranges", &hkbSenseHandleModifierRangeClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "handleOut", &hkbHandleClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "handleIn", &hkbHandleClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "localFrameName", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "sensorLocalFrameName", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "minDistance", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxDistance", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "distanceOut", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "collisionFilterInfo", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "sensorRagdollBoneIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "sensorAnimationBoneIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "sensingMode", HK_NULL, hkbSenseHandleModifierSensingModeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL },
		{ "extrapolateSensorPosition", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "keepFirstSensedHandle", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "foundHandleOut", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "timeSinceLastModify", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "rangeIndexForEventToSendNextUpdate", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	namespace
	{
		struct hkbSenseHandleModifier_DefaultStruct
		{
			int s_defaultOffsets[19];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			_hkVector4 m_sensorLocalOffset;
			hkReal m_maxDistance;
			hkInt16 m_sensorRagdollBoneIndex;
			hkInt16 m_sensorAnimationBoneIndex;
			hkInt8 /* hkEnum< enum hkbSenseHandleModifier::SensingMode, hkInt8 > */ m_sensingMode;
		};
		const hkbSenseHandleModifier_DefaultStruct hkbSenseHandleModifier_Default =
		{
			{-1,HK_OFFSET_OF(hkbSenseHandleModifier_DefaultStruct,m_sensorLocalOffset),-1,-1,-1,-1,-1,hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkbSenseHandleModifier_DefaultStruct,m_maxDistance),hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkbSenseHandleModifier_DefaultStruct,m_sensorRagdollBoneIndex),HK_OFFSET_OF(hkbSenseHandleModifier_DefaultStruct,m_sensorAnimationBoneIndex),HK_OFFSET_OF(hkbSenseHandleModifier_DefaultStruct,m_sensingMode),hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,-1,-1},
			{0,0,0},1.0f,-1,-1,hkbSenseHandleModifier::SENSE_IN_NEARBY_RIGID_BODIES
		};
	}
	hkClass hkbSenseHandleModifierClass(
		"hkbSenseHandleModifier",
		&hkbModifierClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkbSenseHandleModifierEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkbSenseHandleModifierClass_Members),
		HK_COUNT_OF(hkbSenseHandleModifierClass_Members),
		&hkbSenseHandleModifier_Default,
		HK_NULL,
		0,
		hkUint32(2)
		);
	hkClass hkbGeneratorOutputListenerClass(
		"hkbGeneratorOutputListener",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbAttachmentModifierClass_Members[] =
	{
		{ "sendToAttacherOnAttach", &hkbEventPropertyClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "sendToAttacheeOnAttach", &hkbEventPropertyClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "sendToAttacherOnDetach", &hkbEventPropertyClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "sendToAttacheeOnDetach", &hkbEventPropertyClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "attachmentSetup", &hkbAttachmentSetupClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "attacherHandle", &hkbHandleClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "attacheeHandle", &hkbHandleClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "attacheeLayer", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "attacheeRB", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "oldMotionType", HK_NULL, HK_NULL, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "oldFilterInfo", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "attachment", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	namespace
	{
		struct hkbAttachmentModifier_DefaultStruct
		{
			int s_defaultOffsets[12];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkInt32 m_attacheeLayer;
		};
		const hkbAttachmentModifier_DefaultStruct hkbAttachmentModifier_Default =
		{
			{-1,-1,-1,-1,-1,hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkbAttachmentModifier_DefaultStruct,m_attacheeLayer),hkClassMember::HK_CLASS_ZERO_DEFAULT,-1,hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT},
			-1
		};
	}
	hkClass hkbAttachmentModifierClass(
		"hkbAttachmentModifier",
		&hkbModifierClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbAttachmentModifierClass_Members),
		HK_COUNT_OF(hkbAttachmentModifierClass_Members),
		&hkbAttachmentModifier_Default,
		HK_NULL,
		0,
		hkUint32(1)
		);
	hkClass hkbEventPayloadClass(
		"hkbEventPayload",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbRealEventPayloadClass_Members[] =
	{
		{ "data", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkbRealEventPayloadClass(
		"hkbRealEventPayload",
		&hkbEventPayloadClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbRealEventPayloadClass_Members),
		HK_COUNT_OF(hkbRealEventPayloadClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbIntEventPayloadClass_Members[] =
	{
		{ "data", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkbIntEventPayloadClass(
		"hkbIntEventPayload",
		&hkbEventPayloadClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbIntEventPayloadClass_Members),
		HK_COUNT_OF(hkbIntEventPayloadClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbStringEventPayloadClass_Members[] =
	{
		{ "data", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkbStringEventPayloadClass(
		"hkbStringEventPayload",
		&hkbEventPayloadClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbStringEventPayloadClass_Members),
		HK_COUNT_OF(hkbStringEventPayloadClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbNamedEventPayloadClass_Members[] =
	{
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkbNamedEventPayloadClass(
		"hkbNamedEventPayload",
		&hkbEventPayloadClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbNamedEventPayloadClass_Members),
		HK_COUNT_OF(hkbNamedEventPayloadClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbNamedRealEventPayloadClass_Members[] =
	{
		{ "data", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkbNamedRealEventPayloadClass(
		"hkbNamedRealEventPayload",
		&hkbNamedEventPayloadClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbNamedRealEventPayloadClass_Members),
		HK_COUNT_OF(hkbNamedRealEventPayloadClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbNamedIntEventPayloadClass_Members[] =
	{
		{ "data", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkbNamedIntEventPayloadClass(
		"hkbNamedIntEventPayload",
		&hkbNamedEventPayloadClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbNamedIntEventPayloadClass_Members),
		HK_COUNT_OF(hkbNamedIntEventPayloadClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbNamedStringEventPayloadClass_Members[] =
	{
		{ "data", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkbNamedStringEventPayloadClass(
		"hkbNamedStringEventPayload",
		&hkbNamedEventPayloadClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbNamedStringEventPayloadClass_Members),
		HK_COUNT_OF(hkbNamedStringEventPayloadClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbEventPayloadListClass_Members[] =
	{
		{ "payloads", &hkbEventPayloadClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL }
	};
	hkClass hkbEventPayloadListClass(
		"hkbEventPayloadList",
		&hkbEventPayloadClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbEventPayloadListClass_Members),
		HK_COUNT_OF(hkbEventPayloadListClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbFootIkControlsModifier_LegClass_Members[] =
	{
		{ "groundPosition", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "ungroundedEvent", &hkbEventPropertyClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "verticalError", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "hitSomething", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "isPlantedMS", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkbFootIkControlsModifierLeg_DefaultStruct
		{
			int s_defaultOffsets[5];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
		};
		const hkbFootIkControlsModifierLeg_DefaultStruct hkbFootIkControlsModifierLeg_Default =
		{
			{-1,-1,hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT},
		};
	}
	hkClass hkbFootIkControlsModifierLegClass(
		"hkbFootIkControlsModifierLeg",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbFootIkControlsModifier_LegClass_Members),
		HK_COUNT_OF(hkbFootIkControlsModifier_LegClass_Members),
		&hkbFootIkControlsModifierLeg_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbFootIkControlsModifierClass_Members[] =
	{
		{ "controlData", &hkbFootIkControlDataClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "legs", &hkbFootIkControlsModifierLegClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkbFootIkControlsModifierClass(
		"hkbFootIkControlsModifier",
		&hkbModifierClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbFootIkControlsModifierClass_Members),
		HK_COUNT_OF(hkbFootIkControlsModifierClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkbFootIkControlDataClass_Members[] =
	{
		{ "gains", &hkbFootIkGainsClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::ALIGN_16, 0, HK_NULL }
	};
	hkClass hkbFootIkControlDataClass(
		"hkbFootIkControlData",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbFootIkControlDataClass_Members),
		HK_COUNT_OF(hkbFootIkControlDataClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbScriptGeneratorClass_Members[] =
	{
		{ "child", &hkbGeneratorClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "onActivateScript", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "onPreUpdateScript", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "onGenerateScript", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "onHandleEventScript", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "onDeactivateScript", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "refOnActivate", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "refOnPreUpdate", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "refOnGenerate", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "refOnHandleEvent", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "refOnDeactivate", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "timeStep", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hkbScriptGeneratorClass(
		"hkbScriptGenerator",
		&hkbGeneratorClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbScriptGeneratorClass_Members),
		HK_COUNT_OF(hkbScriptGeneratorClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkbBehaviorGraphVariableModeEnumItems[] =
	{
		{0, "VARIABLE_MODE_DISCARD_WHEN_INACTIVE"},
		{1, "VARIABLE_MODE_MAINTAIN_VALUES_WHEN_INACTIVE"},
	};
	static const hkInternalClassEnum hkbBehaviorGraphEnums[] = {
		{"VariableMode", hkbBehaviorGraphVariableModeEnumItems, 2, HK_NULL, 0 }
	};
	const hkClassEnum* hkbBehaviorGraphVariableModeEnum = reinterpret_cast<const hkClassEnum*>(&hkbBehaviorGraphEnums[0]);
	static hkInternalClassMember hkbBehaviorGraphClass_Members[] =
	{
		{ "variableMode", HK_NULL, hkbBehaviorGraphVariableModeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL },
		{ "uniqueIdPool", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "idToStateMachineTemplateMap", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "mirroredExternalIdMap", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "pseudoRandomGenerator", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "rootGenerator", &hkbGeneratorClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "data", &hkbBehaviorGraphDataClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "template", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "rootGeneratorClone", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "activeNodes", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "globalTransitionData", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "eventIdMap", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "attributeIdMap", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "variableIdMap", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "characterPropertyIdMap", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "variableValueSet", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "nodeTemplateToCloneMap", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "stateListenerTemplateToCloneMap", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "recentlyCreatedClones", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "nodePartitionInfo", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "numIntermediateOutputs", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "jobs", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "allPartitionMemory", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "internalToRootVariableIdMap", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "internalToCharacterCharacterPropertyIdMap", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "internalToRootAttributeIdMap", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "nextUniqueId", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "isActive", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "isLinked", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "updateActiveNodes", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "updateActiveNodesForEnable", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "checkNodeValidity", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "stateOrTransitionChanged", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hkbBehaviorGraphClass(
		"hkbBehaviorGraph",
		&hkbGeneratorClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkbBehaviorGraphEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkbBehaviorGraphClass_Members),
		HK_COUNT_OF(hkbBehaviorGraphClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkbCharacterData_CharacterControllerInfoClass_Members[] =
	{
		{ "capsuleHeight", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "capsuleRadius", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "collisionFilterInfo", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "characterControllerCinfo", &hkpCharacterControllerCinfoClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkbCharacterDataCharacterControllerInfo_DefaultStruct
		{
			int s_defaultOffsets[4];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkReal m_capsuleHeight;
			hkReal m_capsuleRadius;
			hkUint32 m_collisionFilterInfo;
		};
		const hkbCharacterDataCharacterControllerInfo_DefaultStruct hkbCharacterDataCharacterControllerInfo_Default =
		{
			{HK_OFFSET_OF(hkbCharacterDataCharacterControllerInfo_DefaultStruct,m_capsuleHeight),HK_OFFSET_OF(hkbCharacterDataCharacterControllerInfo_DefaultStruct,m_capsuleRadius),HK_OFFSET_OF(hkbCharacterDataCharacterControllerInfo_DefaultStruct,m_collisionFilterInfo),-1},
			1.7f,0.4f,1
		};
	}
	hkClass hkbCharacterDataCharacterControllerInfoClass(
		"hkbCharacterDataCharacterControllerInfo",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbCharacterData_CharacterControllerInfoClass_Members),
		HK_COUNT_OF(hkbCharacterData_CharacterControllerInfoClass_Members),
		&hkbCharacterDataCharacterControllerInfo_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbCharacterDataClass_Members[] =
	{
		{ "characterControllerInfo", &hkbCharacterDataCharacterControllerInfoClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "modelUpMS", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "modelForwardMS", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "modelRightMS", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "characterPropertyInfos", &hkbVariableInfoClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "numBonesPerLod", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_INT32, 0, 0, 0, HK_NULL },
		{ "characterPropertyValues", &hkbVariableValueSetClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "footIkDriverInfo", &hkbFootIkDriverInfoClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "handIkDriverInfo", &hkbHandIkDriverInfoClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "stringData", &hkbCharacterStringDataClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "mirroredSkeletonInfo", &hkbMirroredSkeletonInfoClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "boneAttachmentBoneIndices", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_INT16, 0, 0, 0, HK_NULL },
		{ "boneAttachmentTransforms", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_MATRIX4, 0, 0, 0, HK_NULL },
		{ "scale", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "numHands", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "numFloatSlots", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	namespace
	{
		struct hkbCharacterData_DefaultStruct
		{
			int s_defaultOffsets[16];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkReal m_scale;
		};
		const hkbCharacterData_DefaultStruct hkbCharacterData_Default =
		{
			{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,HK_OFFSET_OF(hkbCharacterData_DefaultStruct,m_scale),-1,-1},
			1.0f
		};
	}
	hkClass hkbCharacterDataClass(
		"hkbCharacterData",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbCharacterDataClass_Members),
		HK_COUNT_OF(hkbCharacterDataClass_Members),
		&hkbCharacterData_Default,
		HK_NULL,
		0,
		hkUint32(8)
		);
	static hkInternalClassMember hkbSequenceStringDataClass_Members[] =
	{
		{ "eventNames", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRINGPTR, 0, 0, 0, HK_NULL },
		{ "variableNames", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRINGPTR, 0, 0, 0, HK_NULL }
	};
	hkClass hkbSequenceStringDataClass(
		"hkbSequenceStringData",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbSequenceStringDataClass_Members),
		HK_COUNT_OF(hkbSequenceStringDataClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbGeneratorClass_Members[] =
	{
		{ "syncInfo", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hkbGeneratorClass(
		"hkbGenerator",
		&hkbNodeClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbGeneratorClass_Members),
		HK_COUNT_OF(hkbGeneratorClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkbEventBaseSystemEventIdsEnumItems[] =
	{
		{-1, "EVENT_ID_NULL"},
	};
	static const hkInternalClassEnum hkbEventBaseEnums[] = {
		{"SystemEventIds", hkbEventBaseSystemEventIdsEnumItems, 1, HK_NULL, 0 }
	};
	const hkClassEnum* hkbEventBaseSystemEventIdsEnum = reinterpret_cast<const hkClassEnum*>(&hkbEventBaseEnums[0]);
	static hkInternalClassMember hkbEventBaseClass_Members[] =
	{
		{ "id", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "payload", &hkbEventPayloadClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkbEventBase_DefaultStruct
		{
			int s_defaultOffsets[2];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkInt32 m_id;
		};
		const hkbEventBase_DefaultStruct hkbEventBase_Default =
		{
			{HK_OFFSET_OF(hkbEventBase_DefaultStruct,m_id),-1},
			hkbEventBase::EVENT_ID_NULL
		};
	}
	hkClass hkbEventBaseClass(
		"hkbEventBase",
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkbEventBaseEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkbEventBaseClass_Members),
		HK_COUNT_OF(hkbEventBaseClass_Members),
		&hkbEventBase_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbEventClass_Members[] =
	{
		{ "sender", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hkbEventClass(
		"hkbEvent",
		&hkbEventBaseClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbEventClass_Members),
		HK_COUNT_OF(hkbEventClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	hkClass hkbEventPropertyClass(
		"hkbEventProperty",
		&hkbEventBaseClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static const hkInternalClassEnumItem hkbTransitionEffectSelfTransitionModeEnumItems[] =
	{
		{0, "SELF_TRANSITION_MODE_CONTINUE_IF_CYCLIC_BLEND_IF_ACYCLIC"},
		{1, "SELF_TRANSITION_MODE_CONTINUE"},
		{2, "SELF_TRANSITION_MODE_RESET"},
		{3, "SELF_TRANSITION_MODE_BLEND"},
	};
	static const hkInternalClassEnumItem hkbTransitionEffectEventModeEnumItems[] =
	{
		{0, "EVENT_MODE_DEFAULT"},
		{1, "EVENT_MODE_PROCESS_ALL"},
		{2, "EVENT_MODE_IGNORE_FROM_GENERATOR"},
		{3, "EVENT_MODE_IGNORE_TO_GENERATOR"},
	};
	static const hkInternalClassEnum hkbTransitionEffectEnums[] = {
		{"SelfTransitionMode", hkbTransitionEffectSelfTransitionModeEnumItems, 4, HK_NULL, 0 },
		{"EventMode", hkbTransitionEffectEventModeEnumItems, 4, HK_NULL, 0 }
	};
	const hkClassEnum* hkbTransitionEffectSelfTransitionModeEnum = reinterpret_cast<const hkClassEnum*>(&hkbTransitionEffectEnums[0]);
	const hkClassEnum* hkbTransitionEffectEventModeEnum = reinterpret_cast<const hkClassEnum*>(&hkbTransitionEffectEnums[1]);
	static hkInternalClassMember hkbTransitionEffectClass_Members[] =
	{
		{ "selfTransitionMode", HK_NULL, hkbTransitionEffectSelfTransitionModeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL },
		{ "eventMode", HK_NULL, hkbTransitionEffectEventModeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL },
		{ "defaultEventMode", HK_NULL, HK_NULL, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	namespace
	{
		struct hkbTransitionEffect_DefaultStruct
		{
			int s_defaultOffsets[3];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkInt8 /* hkEnum< enum hkbTransitionEffect::SelfTransitionMode, hkInt8 > */ m_selfTransitionMode;
			hkInt8 /* hkEnum< enum hkbTransitionEffect::EventMode, hkInt8 > */ m_eventMode;
		};
		const hkbTransitionEffect_DefaultStruct hkbTransitionEffect_Default =
		{
			{HK_OFFSET_OF(hkbTransitionEffect_DefaultStruct,m_selfTransitionMode),HK_OFFSET_OF(hkbTransitionEffect_DefaultStruct,m_eventMode),-1},
			hkbTransitionEffect::SELF_TRANSITION_MODE_CONTINUE_IF_CYCLIC_BLEND_IF_ACYCLIC,hkbTransitionEffect::EVENT_MODE_DEFAULT
		};
	}
	hkClass hkbTransitionEffectClass(
		"hkbTransitionEffect",
		&hkbGeneratorClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkbTransitionEffectEnums),
		2,
		reinterpret_cast<const hkClassMember*>(hkbTransitionEffectClass_Members),
		HK_COUNT_OF(hkbTransitionEffectClass_Members),
		&hkbTransitionEffect_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbComputeRotationFromAxisAngleModifierClass_Members[] =
	{
		{ "rotationOut", HK_NULL, HK_NULL, hkClassMember::TYPE_QUATERNION, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "axis", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "angleDegrees", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkbComputeRotationFromAxisAngleModifier_DefaultStruct
		{
			int s_defaultOffsets[3];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			_hkQuaternion m_rotationOut;
			_hkVector4 m_axis;
		};
		const hkbComputeRotationFromAxisAngleModifier_DefaultStruct hkbComputeRotationFromAxisAngleModifier_Default =
		{
			{HK_OFFSET_OF(hkbComputeRotationFromAxisAngleModifier_DefaultStruct,m_rotationOut),HK_OFFSET_OF(hkbComputeRotationFromAxisAngleModifier_DefaultStruct,m_axis),hkClassMember::HK_CLASS_ZERO_DEFAULT},
		{0,0,0,1},	{1,0,0,0}
		};
	}
	hkClass hkbComputeRotationFromAxisAngleModifierClass(
		"hkbComputeRotationFromAxisAngleModifier",
		&hkbModifierClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbComputeRotationFromAxisAngleModifierClass_Members),
		HK_COUNT_OF(hkbComputeRotationFromAxisAngleModifierClass_Members),
		&hkbComputeRotationFromAxisAngleModifier_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkbFootIkModifierAlignModeEnumItems[] =
	{
		{0, "ALIGN_MODE_FORWARD_RIGHT"},
		{1, "ALIGN_MODE_FORWARD"},
	};
	static const hkInternalClassEnum hkbFootIkModifierEnums[] = {
		{"AlignMode", hkbFootIkModifierAlignModeEnumItems, 2, HK_NULL, 0 }
	};
	const hkClassEnum* hkbFootIkModifierAlignModeEnum = reinterpret_cast<const hkClassEnum*>(&hkbFootIkModifierEnums[0]);
	static hkInternalClassMember hkbFootIkModifier_LegClass_Members[] =
	{
		{ "originalAnkleTransformMS", HK_NULL, HK_NULL, hkClassMember::TYPE_QSTRANSFORM, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "kneeAxisLS", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "footEndLS", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "ungroundedEvent", &hkbEventPropertyClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "footPlantedAnkleHeightMS", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "footRaisedAnkleHeightMS", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxAnkleHeightMS", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "minAnkleHeightMS", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxKneeAngleDegrees", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "minKneeAngleDegrees", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "verticalError", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "hipIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "kneeIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "ankleIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "hitSomething", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "isPlantedMS", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "isOriginalAnkleTransformMSSet", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkbFootIkModifierLeg_DefaultStruct
		{
			int s_defaultOffsets[17];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			_hkQsTransform m_originalAnkleTransformMS;
			_hkVector4 m_kneeAxisLS;
			_hkVector4 m_footEndLS;
			hkReal m_footRaisedAnkleHeightMS;
			hkReal m_maxAnkleHeightMS;
			hkReal m_minAnkleHeightMS;
			hkReal m_maxKneeAngleDegrees;
			hkInt16 m_hipIndex;
			hkInt16 m_kneeIndex;
			hkInt16 m_ankleIndex;
		};
		const hkbFootIkModifierLeg_DefaultStruct hkbFootIkModifierLeg_Default =
		{
			{HK_OFFSET_OF(hkbFootIkModifierLeg_DefaultStruct,m_originalAnkleTransformMS),HK_OFFSET_OF(hkbFootIkModifierLeg_DefaultStruct,m_kneeAxisLS),HK_OFFSET_OF(hkbFootIkModifierLeg_DefaultStruct,m_footEndLS),-1,hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkbFootIkModifierLeg_DefaultStruct,m_footRaisedAnkleHeightMS),HK_OFFSET_OF(hkbFootIkModifierLeg_DefaultStruct,m_maxAnkleHeightMS),HK_OFFSET_OF(hkbFootIkModifierLeg_DefaultStruct,m_minAnkleHeightMS),HK_OFFSET_OF(hkbFootIkModifierLeg_DefaultStruct,m_maxKneeAngleDegrees),hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkbFootIkModifierLeg_DefaultStruct,m_hipIndex),HK_OFFSET_OF(hkbFootIkModifierLeg_DefaultStruct,m_kneeIndex),HK_OFFSET_OF(hkbFootIkModifierLeg_DefaultStruct,m_ankleIndex),hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT},
		{0,0,0,0,0,0,0,1,1,1,1,1},	{1,0,0},	{0,0,0},0.5f,0.7f,-0.1f,180.0f,-1,-1,-1
		};
	}
	hkClass hkbFootIkModifierLegClass(
		"hkbFootIkModifierLeg",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbFootIkModifier_LegClass_Members),
		HK_COUNT_OF(hkbFootIkModifier_LegClass_Members),
		&hkbFootIkModifierLeg_Default,
		HK_NULL,
		0,
		hkUint32(2)
		);
	static hkInternalClassMember hkbFootIkModifier_InternalLegDataClass_Members[] =
	{
		{ "groundPosition", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "footIkSolver", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hkbFootIkModifierInternalLegDataClass(
		"hkbFootIkModifierInternalLegData",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbFootIkModifier_InternalLegDataClass_Members),
		HK_COUNT_OF(hkbFootIkModifier_InternalLegDataClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkbFootIkModifierClass_Members[] =
	{
		{ "gains", &hkbFootIkGainsClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "legs", &hkbFootIkModifierLegClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "raycastDistanceUp", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "raycastDistanceDown", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "originalGroundHeightMS", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "errorOut", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "verticalOffset", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "collisionFilterInfo", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "forwardAlignFraction", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "sidewaysAlignFraction", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "sidewaysSampleWidth", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "useTrackData", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "lockFeetWhenPlanted", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "useCharacterUpVector", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "alignMode", HK_NULL, hkbFootIkModifierAlignModeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL },
		{ "internalLegData", &hkbFootIkModifierInternalLegDataClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "prevIsFootIkEnabled", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "isSetUp", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "isGroundPositionValid", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	namespace
	{
		struct hkbFootIkModifier_DefaultStruct
		{
			int s_defaultOffsets[19];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkReal m_raycastDistanceUp;
			hkReal m_raycastDistanceDown;
			hkUint32 m_collisionFilterInfo;
			hkReal m_forwardAlignFraction;
			hkReal m_sidewaysSampleWidth;
			hkInt8 /* hkEnum< enum hkbFootIkModifier::AlignMode, hkInt8 > */ m_alignMode;
		};
		const hkbFootIkModifier_DefaultStruct hkbFootIkModifier_Default =
		{
			{-1,-1,HK_OFFSET_OF(hkbFootIkModifier_DefaultStruct,m_raycastDistanceUp),HK_OFFSET_OF(hkbFootIkModifier_DefaultStruct,m_raycastDistanceDown),hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkbFootIkModifier_DefaultStruct,m_collisionFilterInfo),HK_OFFSET_OF(hkbFootIkModifier_DefaultStruct,m_forwardAlignFraction),hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkbFootIkModifier_DefaultStruct,m_sidewaysSampleWidth),hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkbFootIkModifier_DefaultStruct,m_alignMode),-1,-1,-1,-1},
			0.5f,0.8f,3,1.0f,0.2f,hkbFootIkModifier::ALIGN_MODE_FORWARD_RIGHT
		};
	}
	hkClass hkbFootIkModifierClass(
		"hkbFootIkModifier",
		&hkbModifierClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkbFootIkModifierEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkbFootIkModifierClass_Members),
		HK_COUNT_OF(hkbFootIkModifierClass_Members),
		&hkbFootIkModifier_Default,
		HK_NULL,
		0,
		hkUint32(3)
		);
	static const hkInternalClassEnumItem hkbStateMachineStartStateModeEnumItems[] =
	{
		{0, "START_STATE_MODE_DEFAULT"},
		{1, "START_STATE_MODE_SYNC"},
		{2, "START_STATE_MODE_RANDOM"},
		{3, "START_STATE_MODE_CHOOSER"},
	};
	static const hkInternalClassEnumItem hkbStateMachineStateMachineSelfTransitionModeEnumItems[] =
	{
		{0, "SELF_TRANSITION_MODE_NO_TRANSITION"},
		{1, "SELF_TRANSITION_MODE_TRANSITION_TO_START_STATE"},
		{2, "SELF_TRANSITION_MODE_FORCE_TRANSITION_TO_START_STATE"},
	};
	static const hkInternalClassEnum hkbStateMachineEnums[] = {
		{"StartStateMode", hkbStateMachineStartStateModeEnumItems, 4, HK_NULL, 0 },
		{"StateMachineSelfTransitionMode", hkbStateMachineStateMachineSelfTransitionModeEnumItems, 3, HK_NULL, 0 }
	};
	const hkClassEnum* hkbStateMachineStartStateModeEnum = reinterpret_cast<const hkClassEnum*>(&hkbStateMachineEnums[0]);
	const hkClassEnum* hkbStateMachineStateMachineSelfTransitionModeEnum = reinterpret_cast<const hkClassEnum*>(&hkbStateMachineEnums[1]);
	static hkInternalClassMember hkbStateMachine_TimeIntervalClass_Members[] =
	{
		{ "enterEventId", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "exitEventId", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "enterTime", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "exitTime", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkbStateMachineTimeIntervalClass(
		"hkbStateMachineTimeInterval",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbStateMachine_TimeIntervalClass_Members),
		HK_COUNT_OF(hkbStateMachine_TimeIntervalClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkbStateMachineTransitionInfoTransitionFlagsEnumItems[] =
	{
		{1, "FLAG_USE_TRIGGER_INTERVAL"},
		{2, "FLAG_USE_INITIATE_INTERVAL"},
		{4, "FLAG_UNINTERRUPTIBLE_WHILE_PLAYING"},
		{8, "FLAG_UNINTERRUPTIBLE_WHILE_DELAYED"},
		{16, "FLAG_DELAY_STATE_CHANGE"},
		{32, "FLAG_DISABLED"},
		{64, "FLAG_DISALLOW_RETURN_TO_PREVIOUS_STATE"},
		{128, "FLAG_DISALLOW_RANDOM_TRANSITION"},
		{256, "FLAG_DISABLE_CONDITION"},
		{512, "FLAG_ALLOW_SELF_TRANSITION_BY_TRANSITION_FROM_ANY_STATE"},
		{1024, "FLAG_IS_GLOBAL_WILDCARD"},
		{2048, "FLAG_IS_LOCAL_WILDCARD"},
		{4096, "FLAG_FROM_NESTED_STATE_ID_IS_VALID"},
		{8192, "FLAG_TO_NESTED_STATE_ID_IS_VALID"},
		{16384, "FLAG_ABUT_AT_END_OF_FROM_GENERATOR"},
	};
	static const hkInternalClassEnumItem hkbStateMachineTransitionInfoInternalFlagBitsEnumItems[] =
	{
		{1, "FLAG_INTERNAL_IN_TRIGGER_INTERVAL"},
		{2, "FLAG_INTERNAL_IN_INITIATE_INTERVAL"},
	};
	static const hkInternalClassEnum hkbStateMachineTransitionInfoEnums[] = {
		{"TransitionFlags", hkbStateMachineTransitionInfoTransitionFlagsEnumItems, 15, HK_NULL, 0 },
		{"InternalFlagBits", hkbStateMachineTransitionInfoInternalFlagBitsEnumItems, 2, HK_NULL, 0 }
	};
	const hkClassEnum* hkbStateMachineTransitionInfoTransitionFlagsEnum = reinterpret_cast<const hkClassEnum*>(&hkbStateMachineTransitionInfoEnums[0]);
	const hkClassEnum* hkbStateMachineTransitionInfoInternalFlagBitsEnum = reinterpret_cast<const hkClassEnum*>(&hkbStateMachineTransitionInfoEnums[1]);
	static hkInternalClassMember hkbStateMachine_TransitionInfoClass_Members[] =
	{
		{ "triggerInterval", &hkbStateMachineTimeIntervalClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "initiateInterval", &hkbStateMachineTimeIntervalClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "transition", &hkbTransitionEffectClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "condition", &hkbConditionClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "eventId", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "toStateId", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "fromNestedStateId", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "toNestedStateId", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "priority", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "flags", HK_NULL, hkbStateMachineTransitionInfoTransitionFlagsEnum, hkClassMember::TYPE_FLAGS, hkClassMember::TYPE_INT16, 0, 0, 0, HK_NULL }
	};
	hkClass hkbStateMachineTransitionInfoClass(
		"hkbStateMachineTransitionInfo",
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkbStateMachineTransitionInfoEnums),
		2,
		reinterpret_cast<const hkClassMember*>(hkbStateMachine_TransitionInfoClass_Members),
		HK_COUNT_OF(hkbStateMachine_TransitionInfoClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkbStateMachine_TransitionInfoReferenceClass_Members[] =
	{
		{ "fromStateIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "transitionIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "stateMachineId", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkbStateMachineTransitionInfoReferenceClass(
		"hkbStateMachineTransitionInfoReference",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbStateMachine_TransitionInfoReferenceClass_Members),
		HK_COUNT_OF(hkbStateMachine_TransitionInfoReferenceClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkbStateMachine_ActiveTransitionInfoClass_Members[] =
	{
		{ "transitionEffect", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "transitionEffectInternalStateInfo", &hkbNodeInternalStateInfoClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "transitionInfoReference", &hkbStateMachineTransitionInfoReferenceClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "transitionInfoReferenceForTE", &hkbStateMachineTransitionInfoReferenceClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "fromStateId", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "toStateId", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "isReturnToPreviousState", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkbStateMachineActiveTransitionInfoClass(
		"hkbStateMachineActiveTransitionInfo",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbStateMachine_ActiveTransitionInfoClass_Members),
		HK_COUNT_OF(hkbStateMachine_ActiveTransitionInfoClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkbStateMachine_ProspectiveTransitionInfoClass_Members[] =
	{
		{ "transitionInfoReference", &hkbStateMachineTransitionInfoReferenceClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "transitionInfoReferenceForTE", &hkbStateMachineTransitionInfoReferenceClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "toStateId", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkbStateMachineProspectiveTransitionInfoClass(
		"hkbStateMachineProspectiveTransitionInfo",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbStateMachine_ProspectiveTransitionInfoClass_Members),
		HK_COUNT_OF(hkbStateMachine_ProspectiveTransitionInfoClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(2)
		);
	static hkInternalClassMember hkbStateMachine_TransitionInfoArrayClass_Members[] =
	{
		{ "transitions", &hkbStateMachineTransitionInfoClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "hasEventlessTransitions", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "hasTimeBoundedTransitions", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hkbStateMachineTransitionInfoArrayClass(
		"hkbStateMachineTransitionInfoArray",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbStateMachine_TransitionInfoArrayClass_Members),
		HK_COUNT_OF(hkbStateMachine_TransitionInfoArrayClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbStateMachine_EventPropertyArrayClass_Members[] =
	{
		{ "events", &hkbEventPropertyClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkbStateMachineEventPropertyArrayClass(
		"hkbStateMachineEventPropertyArray",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbStateMachine_EventPropertyArrayClass_Members),
		HK_COUNT_OF(hkbStateMachine_EventPropertyArrayClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbStateMachine_StateInfoClass_Members[] =
	{
		{ "listeners", &hkbStateListenerClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "enterNotifyEvents", &hkbStateMachineEventPropertyArrayClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "exitNotifyEvents", &hkbStateMachineEventPropertyArrayClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "transitions", &hkbStateMachineTransitionInfoArrayClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "generator", &hkbGeneratorClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "stateId", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "probability", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "enable", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "hasEventlessTransitions", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	namespace
	{
		struct hkbStateMachineStateInfo_DefaultStruct
		{
			int s_defaultOffsets[10];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkReal m_probability;
			_hkBool m_enable;
		};
		const hkbStateMachineStateInfo_DefaultStruct hkbStateMachineStateInfo_Default =
		{
			{-1,-1,-1,-1,-1,-1,-1,HK_OFFSET_OF(hkbStateMachineStateInfo_DefaultStruct,m_probability),HK_OFFSET_OF(hkbStateMachineStateInfo_DefaultStruct,m_enable),-1},
			1.0f,true
		};
	}
	hkClass hkbStateMachineStateInfoClass(
		"hkbStateMachineStateInfo",
		&hkbBindableClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbStateMachine_StateInfoClass_Members),
		HK_COUNT_OF(hkbStateMachine_StateInfoClass_Members),
		&hkbStateMachineStateInfo_Default,
		HK_NULL,
		0,
		hkUint32(4)
		);
	static hkInternalClassMember hkbStateMachine_NestedStateMachineDataClass_Members[] =
	{
		{ "nestedStateMachine", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "eventIdMap", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hkbStateMachineNestedStateMachineDataClass(
		"hkbStateMachineNestedStateMachineData",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbStateMachine_NestedStateMachineDataClass_Members),
		HK_COUNT_OF(hkbStateMachine_NestedStateMachineDataClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbStateMachine_DelayedTransitionInfoClass_Members[] =
	{
		{ "delayedTransition", &hkbStateMachineProspectiveTransitionInfoClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "timeDelayed", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "isDelayedTransitionReturnToPreviousState", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "wasInAbutRangeLastFrame", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkbStateMachineDelayedTransitionInfoClass(
		"hkbStateMachineDelayedTransitionInfo",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbStateMachine_DelayedTransitionInfoClass_Members),
		HK_COUNT_OF(hkbStateMachine_DelayedTransitionInfoClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkbStateMachineClass_Members[] =
	{
		{ "eventToSendWhenStateOrTransitionChanges", &hkbEventClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "startStateChooser", &hkbStateChooserClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "startStateId", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "returnToPreviousStateEventId", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "randomTransitionEventId", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "transitionToNextHigherStateEventId", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "transitionToNextLowerStateEventId", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "syncVariableIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "currentStateId", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "wrapAroundStateId", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxSimultaneousTransitions", HK_NULL, HK_NULL, hkClassMember::TYPE_INT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "startStateMode", HK_NULL, hkbStateMachineStartStateModeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL },
		{ "selfTransitionMode", HK_NULL, hkbStateMachineStateMachineSelfTransitionModeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL },
		{ "isActive", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "states", &hkbStateMachineStateInfoClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "wildcardTransitions", &hkbStateMachineTransitionInfoArrayClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "stateIdToIndexMap", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "activeTransitions", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "transitionFlags", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "wildcardTransitionFlags", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "delayedTransitions", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "timeInState", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "lastLocalTime", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "previousStateId", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "nextStartStateIndexOverride", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "stateOrTransitionChanged", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "echoNextUpdate", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "hasEventlessWildcardTransitions", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	namespace
	{
		struct hkbStateMachine_DefaultStruct
		{
			int s_defaultOffsets[28];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkInt32 m_transitionToNextHigherStateEventId;
			hkInt32 m_transitionToNextLowerStateEventId;
			hkInt32 m_syncVariableIndex;
			_hkBool m_wrapAroundStateId;
			hkInt8 m_maxSimultaneousTransitions;
			hkInt8 /* hkEnum< enum hkbStateMachine::StateMachineSelfTransitionMode, hkInt8 > */ m_selfTransitionMode;
		};
		const hkbStateMachine_DefaultStruct hkbStateMachine_Default =
		{
			{-1,-1,-1,-1,-1,HK_OFFSET_OF(hkbStateMachine_DefaultStruct,m_transitionToNextHigherStateEventId),HK_OFFSET_OF(hkbStateMachine_DefaultStruct,m_transitionToNextLowerStateEventId),HK_OFFSET_OF(hkbStateMachine_DefaultStruct,m_syncVariableIndex),-1,HK_OFFSET_OF(hkbStateMachine_DefaultStruct,m_wrapAroundStateId),HK_OFFSET_OF(hkbStateMachine_DefaultStruct,m_maxSimultaneousTransitions),-1,HK_OFFSET_OF(hkbStateMachine_DefaultStruct,m_selfTransitionMode),-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
			-1,-1,-1,true,32,hkbStateMachine::SELF_TRANSITION_MODE_NO_TRANSITION
		};
	}
	hkClass hkbStateMachineClass(
		"hkbStateMachine",
		&hkbGeneratorClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkbStateMachineEnums),
		2,
		reinterpret_cast<const hkClassMember*>(hkbStateMachineClass_Members),
		HK_COUNT_OF(hkbStateMachineClass_Members),
		&hkbStateMachine_Default,
		HK_NULL,
		0,
		hkUint32(4)
		);
	static hkInternalClassMember hkbCharacterClass_Members[] =
	{
		{ "nearbyCharacters", &hkbCharacterClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "currentLod", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "numTracksInLod", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "userData", HK_NULL, HK_NULL, hkClassMember::TYPE_ULONG, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "generatorOutput", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "ragdollDriver", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "characterControllerDriver", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "footIkDriver", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "handIkDriver", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "dockingDriver", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "setup", &hkbCharacterSetupClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "behaviorGraph", &hkbBehaviorGraphClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "projectData", &hkbProjectDataClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "animationBindingSet", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "raycastInterface", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "world", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::NOT_OWNED|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "boneAttachments", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "eventQueue", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "characterLuaState", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hkbCharacterClass(
		"hkbCharacter",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbCharacterClass_Members),
		HK_COUNT_OF(hkbCharacterClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(3)
		);
	static hkInternalClassMember hkbBehaviorGraphDataClass_Members[] =
	{
		{ "attributeDefaults", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_REAL, 0, 0, 0, HK_NULL },
		{ "variableInfos", &hkbVariableInfoClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "characterPropertyInfos", &hkbVariableInfoClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "eventInfos", &hkbEventInfoClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "variableBounds", &hkbVariableBoundsClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "variableInitialValues", &hkbVariableValueSetClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "stringData", &hkbBehaviorGraphStringDataClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkbBehaviorGraphDataClass(
		"hkbBehaviorGraphData",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbBehaviorGraphDataClass_Members),
		HK_COUNT_OF(hkbBehaviorGraphDataClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(3)
		);
	static hkInternalClassMember hkbRotateCharacterModifierClass_Members[] =
	{
		{ "degreesPerSecond", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "speedMultiplier", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "axisOfRotation", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "angle", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	namespace
	{
		struct hkbRotateCharacterModifier_DefaultStruct
		{
			int s_defaultOffsets[4];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkReal m_degreesPerSecond;
			hkReal m_speedMultiplier;
			_hkVector4 m_axisOfRotation;
		};
		const hkbRotateCharacterModifier_DefaultStruct hkbRotateCharacterModifier_Default =
		{
			{HK_OFFSET_OF(hkbRotateCharacterModifier_DefaultStruct,m_degreesPerSecond),HK_OFFSET_OF(hkbRotateCharacterModifier_DefaultStruct,m_speedMultiplier),HK_OFFSET_OF(hkbRotateCharacterModifier_DefaultStruct,m_axisOfRotation),-1},
		1.0f,1.0f,	{1,0,0}
		};
	}
	hkClass hkbRotateCharacterModifierClass(
		"hkbRotateCharacterModifier",
		&hkbModifierClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbRotateCharacterModifierClass_Members),
		HK_COUNT_OF(hkbRotateCharacterModifierClass_Members),
		&hkbRotateCharacterModifier_Default,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkbPoweredRagdollControlDataClass_Members[] =
	{
		{ "maxForce", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::ALIGN_16, 0, HK_NULL },
		{ "tau", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "damping", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "proportionalRecoveryVelocity", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "constantRecoveryVelocity", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkbPoweredRagdollControlData_DefaultStruct
		{
			int s_defaultOffsets[5];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkReal m_maxForce;
			hkReal m_tau;
			hkReal m_damping;
			hkReal m_proportionalRecoveryVelocity;
			hkReal m_constantRecoveryVelocity;
		};
		const hkbPoweredRagdollControlData_DefaultStruct hkbPoweredRagdollControlData_Default =
		{
			{HK_OFFSET_OF(hkbPoweredRagdollControlData_DefaultStruct,m_maxForce),HK_OFFSET_OF(hkbPoweredRagdollControlData_DefaultStruct,m_tau),HK_OFFSET_OF(hkbPoweredRagdollControlData_DefaultStruct,m_damping),HK_OFFSET_OF(hkbPoweredRagdollControlData_DefaultStruct,m_proportionalRecoveryVelocity),HK_OFFSET_OF(hkbPoweredRagdollControlData_DefaultStruct,m_constantRecoveryVelocity)},
			50.0f,0.8f,1.0f,2.0f,1.0f
		};
	}
	hkClass hkbPoweredRagdollControlDataClass(
		"hkbPoweredRagdollControlData",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbPoweredRagdollControlDataClass_Members),
		HK_COUNT_OF(hkbPoweredRagdollControlDataClass_Members),
		&hkbPoweredRagdollControlData_Default,
		HK_NULL,
		0,
		hkUint32(3)
		);
	static hkInternalClassMember hkbDampingModifierClass_Members[] =
	{
		{ "kP", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "kI", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "kD", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "enableScalarDamping", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "enableVectorDamping", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "rawValue", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "dampedValue", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "rawVector", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "dampedVector", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "vecErrorSum", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "vecPreviousError", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "errorSum", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "previousError", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkbDampingModifier_DefaultStruct
		{
			int s_defaultOffsets[13];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkReal m_kP;
			hkReal m_kI;
			hkReal m_kD;
			_hkBool m_enableScalarDamping;
			_hkVector4 m_rawVector;
			_hkVector4 m_dampedVector;
			_hkVector4 m_vecErrorSum;
			_hkVector4 m_vecPreviousError;
		};
		const hkbDampingModifier_DefaultStruct hkbDampingModifier_Default =
		{
			{HK_OFFSET_OF(hkbDampingModifier_DefaultStruct,m_kP),HK_OFFSET_OF(hkbDampingModifier_DefaultStruct,m_kI),HK_OFFSET_OF(hkbDampingModifier_DefaultStruct,m_kD),HK_OFFSET_OF(hkbDampingModifier_DefaultStruct,m_enableScalarDamping),hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkbDampingModifier_DefaultStruct,m_rawVector),HK_OFFSET_OF(hkbDampingModifier_DefaultStruct,m_dampedVector),HK_OFFSET_OF(hkbDampingModifier_DefaultStruct,m_vecErrorSum),HK_OFFSET_OF(hkbDampingModifier_DefaultStruct,m_vecPreviousError),hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT},
	0.20f,0.015f,-0.10f,true,	{0,0,0},	{0,0,0},	{0,0,0},	{0,0,0}
		};
	}
	hkClass hkbDampingModifierClass(
		"hkbDampingModifier",
		&hkbModifierClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbDampingModifierClass_Members),
		HK_COUNT_OF(hkbDampingModifierClass_Members),
		&hkbDampingModifier_Default,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkbModifierListClass_Members[] =
	{
		{ "modifiers", &hkbModifierClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL }
	};
	hkClass hkbModifierListClass(
		"hkbModifierList",
		&hkbModifierClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbModifierListClass_Members),
		HK_COUNT_OF(hkbModifierListClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkbAttachmentSetupAttachmentTypeEnumItems[] =
	{
		{0, "ATTACHMENT_TYPE_KEYFRAME_RIGID_BODY"},
		{1, "ATTACHMENT_TYPE_BALL_SOCKET_CONSTRAINT"},
		{2, "ATTACHMENT_TYPE_RAGDOLL_CONSTRAINT"},
		{3, "ATTACHMENT_TYPE_SET_WORLD_FROM_MODEL"},
		{4, "ATTACHMENT_TYPE_NONE"},
	};
	static const hkInternalClassEnum hkbAttachmentSetupEnums[] = {
		{"AttachmentType", hkbAttachmentSetupAttachmentTypeEnumItems, 5, HK_NULL, 0 }
	};
	const hkClassEnum* hkbAttachmentSetupAttachmentTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkbAttachmentSetupEnums[0]);
	static hkInternalClassMember hkbAttachmentSetupClass_Members[] =
	{
		{ "blendInTime", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "moveAttacherFraction", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "gain", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "extrapolationTimeStep", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "fixUpGain", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxLinearDistance", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxAngularDistance", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "attachmentType", HK_NULL, hkbAttachmentSetupAttachmentTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkbAttachmentSetup_DefaultStruct
		{
			int s_defaultOffsets[8];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkReal m_gain;
			hkReal m_maxLinearDistance;
			hkReal m_maxAngularDistance;
			hkInt8 /* hkEnum< enum hkbAttachmentSetup::AttachmentType, hkInt8 > */ m_attachmentType;
		};
		const hkbAttachmentSetup_DefaultStruct hkbAttachmentSetup_Default =
		{
			{hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkbAttachmentSetup_DefaultStruct,m_gain),hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkbAttachmentSetup_DefaultStruct,m_maxLinearDistance),HK_OFFSET_OF(hkbAttachmentSetup_DefaultStruct,m_maxAngularDistance),HK_OFFSET_OF(hkbAttachmentSetup_DefaultStruct,m_attachmentType)},
			0.3f,1.0f,180.0f,hkbAttachmentSetup::ATTACHMENT_TYPE_KEYFRAME_RIGID_BODY
		};
	}
	hkClass hkbAttachmentSetupClass(
		"hkbAttachmentSetup",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkbAttachmentSetupEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkbAttachmentSetupClass_Members),
		HK_COUNT_OF(hkbAttachmentSetupClass_Members),
		&hkbAttachmentSetup_Default,
		HK_NULL,
		0,
		hkUint32(2)
		);
	static hkInternalClassMember hkbPoweredRagdollControlsModifierClass_Members[] =
	{
		{ "controlData", &hkbPoweredRagdollControlDataClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "bones", &hkbBoneIndexArrayClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "worldFromModelModeData", &hkbWorldFromModelModeDataClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "boneWeights", &hkbBoneWeightArrayClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "animationBlendFraction", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkbPoweredRagdollControlsModifier_DefaultStruct
		{
			int s_defaultOffsets[5];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
		};
		const hkbPoweredRagdollControlsModifier_DefaultStruct hkbPoweredRagdollControlsModifier_Default =
		{
			{-1,-1,-1,-1,hkClassMember::HK_CLASS_ZERO_DEFAULT},
		};
	}
	hkClass hkbPoweredRagdollControlsModifierClass(
		"hkbPoweredRagdollControlsModifier",
		&hkbModifierClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbPoweredRagdollControlsModifierClass_Members),
		HK_COUNT_OF(hkbPoweredRagdollControlsModifierClass_Members),
		&hkbPoweredRagdollControlsModifier_Default,
		HK_NULL,
		0,
		hkUint32(6)
		);
	static hkInternalClassMember hkbFootIkDriverInfo_LegClass_Members[] =
	{
		{ "kneeAxisLS", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "footEndLS", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "footPlantedAnkleHeightMS", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "footRaisedAnkleHeightMS", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxAnkleHeightMS", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "minAnkleHeightMS", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxKneeAngleDegrees", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "minKneeAngleDegrees", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "hipIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "kneeIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "ankleIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkbFootIkDriverInfoLeg_DefaultStruct
		{
			int s_defaultOffsets[11];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			_hkVector4 m_kneeAxisLS;
			_hkVector4 m_footEndLS;
			hkReal m_footRaisedAnkleHeightMS;
			hkReal m_maxAnkleHeightMS;
			hkReal m_minAnkleHeightMS;
			hkReal m_maxKneeAngleDegrees;
			hkInt16 m_hipIndex;
			hkInt16 m_kneeIndex;
			hkInt16 m_ankleIndex;
		};
		const hkbFootIkDriverInfoLeg_DefaultStruct hkbFootIkDriverInfoLeg_Default =
		{
			{HK_OFFSET_OF(hkbFootIkDriverInfoLeg_DefaultStruct,m_kneeAxisLS),HK_OFFSET_OF(hkbFootIkDriverInfoLeg_DefaultStruct,m_footEndLS),hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkbFootIkDriverInfoLeg_DefaultStruct,m_footRaisedAnkleHeightMS),HK_OFFSET_OF(hkbFootIkDriverInfoLeg_DefaultStruct,m_maxAnkleHeightMS),HK_OFFSET_OF(hkbFootIkDriverInfoLeg_DefaultStruct,m_minAnkleHeightMS),HK_OFFSET_OF(hkbFootIkDriverInfoLeg_DefaultStruct,m_maxKneeAngleDegrees),hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkbFootIkDriverInfoLeg_DefaultStruct,m_hipIndex),HK_OFFSET_OF(hkbFootIkDriverInfoLeg_DefaultStruct,m_kneeIndex),HK_OFFSET_OF(hkbFootIkDriverInfoLeg_DefaultStruct,m_ankleIndex)},
		{0,0,1},	{0,0,0},0.5f,0.7f,-0.1f,180.0f,-1,-1,-1
		};
	}
	hkClass hkbFootIkDriverInfoLegClass(
		"hkbFootIkDriverInfoLeg",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbFootIkDriverInfo_LegClass_Members),
		HK_COUNT_OF(hkbFootIkDriverInfo_LegClass_Members),
		&hkbFootIkDriverInfoLeg_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbFootIkDriverInfoClass_Members[] =
	{
		{ "legs", &hkbFootIkDriverInfoLegClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "raycastDistanceUp", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "raycastDistanceDown", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "originalGroundHeightMS", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "verticalOffset", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "collisionFilterInfo", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "forwardAlignFraction", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "sidewaysAlignFraction", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "sidewaysSampleWidth", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "lockFeetWhenPlanted", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "useCharacterUpVector", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "isQuadrupedNarrow", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkbFootIkDriverInfo_DefaultStruct
		{
			int s_defaultOffsets[12];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkReal m_raycastDistanceUp;
			hkReal m_raycastDistanceDown;
			hkUint32 m_collisionFilterInfo;
			hkReal m_forwardAlignFraction;
			hkReal m_sidewaysAlignFraction;
		};
		const hkbFootIkDriverInfo_DefaultStruct hkbFootIkDriverInfo_Default =
		{
			{-1,HK_OFFSET_OF(hkbFootIkDriverInfo_DefaultStruct,m_raycastDistanceUp),HK_OFFSET_OF(hkbFootIkDriverInfo_DefaultStruct,m_raycastDistanceDown),hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkbFootIkDriverInfo_DefaultStruct,m_collisionFilterInfo),HK_OFFSET_OF(hkbFootIkDriverInfo_DefaultStruct,m_forwardAlignFraction),HK_OFFSET_OF(hkbFootIkDriverInfo_DefaultStruct,m_sidewaysAlignFraction),hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT},
			0.5f,0.8f,3,1.0f,1.0f
		};
	}
	hkClass hkbFootIkDriverInfoClass(
		"hkbFootIkDriverInfo",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbFootIkDriverInfoClass_Members),
		HK_COUNT_OF(hkbFootIkDriverInfoClass_Members),
		&hkbFootIkDriverInfo_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbGetHandleOnBoneModifierClass_Members[] =
	{
		{ "handleOut", &hkbHandleClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "localFrameName", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "ragdollBoneIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "animationBoneIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkbGetHandleOnBoneModifier_DefaultStruct
		{
			int s_defaultOffsets[4];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkInt16 m_ragdollBoneIndex;
			hkInt16 m_animationBoneIndex;
		};
		const hkbGetHandleOnBoneModifier_DefaultStruct hkbGetHandleOnBoneModifier_Default =
		{
			{-1,-1,HK_OFFSET_OF(hkbGetHandleOnBoneModifier_DefaultStruct,m_ragdollBoneIndex),HK_OFFSET_OF(hkbGetHandleOnBoneModifier_DefaultStruct,m_animationBoneIndex)},
			-1,-1
		};
	}
	hkClass hkbGetHandleOnBoneModifierClass(
		"hkbGetHandleOnBoneModifier",
		&hkbModifierClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbGetHandleOnBoneModifierClass_Members),
		HK_COUNT_OF(hkbGetHandleOnBoneModifierClass_Members),
		&hkbGetHandleOnBoneModifier_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbRigidBodyRagdollControlsModifierClass_Members[] =
	{
		{ "controlData", &hkbRigidBodyRagdollControlDataClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "bones", &hkbBoneIndexArrayClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "animationBlendFraction", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkbRigidBodyRagdollControlsModifier_DefaultStruct
		{
			int s_defaultOffsets[3];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
		};
		const hkbRigidBodyRagdollControlsModifier_DefaultStruct hkbRigidBodyRagdollControlsModifier_Default =
		{
			{-1,-1,hkClassMember::HK_CLASS_ZERO_DEFAULT},
		};
	}
	hkClass hkbRigidBodyRagdollControlsModifierClass(
		"hkbRigidBodyRagdollControlsModifier",
		&hkbModifierClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbRigidBodyRagdollControlsModifierClass_Members),
		HK_COUNT_OF(hkbRigidBodyRagdollControlsModifierClass_Members),
		&hkbRigidBodyRagdollControlsModifier_Default,
		HK_NULL,
		0,
		hkUint32(4)
		);
	static const hkInternalClassEnumItem hkbEventInfoFlagsEnumItems[] =
	{
		{1, "FLAG_SILENT"},
		{2, "FLAG_SYNC_POINT"},
	};
	static const hkInternalClassEnum hkbEventInfoEnums[] = {
		{"Flags", hkbEventInfoFlagsEnumItems, 2, HK_NULL, 0 }
	};
	const hkClassEnum* hkbEventInfoFlagsEnum = reinterpret_cast<const hkClassEnum*>(&hkbEventInfoEnums[0]);
	static hkInternalClassMember hkbEventInfoClass_Members[] =
	{
		{ "flags", HK_NULL, hkbEventInfoFlagsEnum, hkClassMember::TYPE_FLAGS, hkClassMember::TYPE_UINT32, 0, 0, 0, HK_NULL }
	};
	hkClass hkbEventInfoClass(
		"hkbEventInfo",
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkbEventInfoEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkbEventInfoClass_Members),
		HK_COUNT_OF(hkbEventInfoClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbAttributeModifier_AssignmentClass_Members[] =
	{
		{ "attributeIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "attributeValue", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkbAttributeModifierAssignment_DefaultStruct
		{
			int s_defaultOffsets[2];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkInt32 m_attributeIndex;
		};
		const hkbAttributeModifierAssignment_DefaultStruct hkbAttributeModifierAssignment_Default =
		{
			{HK_OFFSET_OF(hkbAttributeModifierAssignment_DefaultStruct,m_attributeIndex),hkClassMember::HK_CLASS_ZERO_DEFAULT},
			-1
		};
	}
	hkClass hkbAttributeModifierAssignmentClass(
		"hkbAttributeModifierAssignment",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbAttributeModifier_AssignmentClass_Members),
		HK_COUNT_OF(hkbAttributeModifier_AssignmentClass_Members),
		&hkbAttributeModifierAssignment_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbAttributeModifierClass_Members[] =
	{
		{ "assignments", &hkbAttributeModifierAssignmentClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkbAttributeModifierClass(
		"hkbAttributeModifier",
		&hkbModifierClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbAttributeModifierClass_Members),
		HK_COUNT_OF(hkbAttributeModifierClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbVariableValueClass_Members[] =
	{
		{ "value", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkbVariableValueClass(
		"hkbVariableValue",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbVariableValueClass_Members),
		HK_COUNT_OF(hkbVariableValueClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbVariableBoundsClass_Members[] =
	{
		{ "min", &hkbVariableValueClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "max", &hkbVariableValueClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkbVariableBoundsClass(
		"hkbVariableBounds",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbVariableBoundsClass_Members),
		HK_COUNT_OF(hkbVariableBoundsClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbEventDrivenModifierClass_Members[] =
	{
		{ "activateEventId", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "deactivateEventId", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "activeByDefault", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "isActive", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	namespace
	{
		struct hkbEventDrivenModifier_DefaultStruct
		{
			int s_defaultOffsets[4];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkInt32 m_activateEventId;
			hkInt32 m_deactivateEventId;
		};
		const hkbEventDrivenModifier_DefaultStruct hkbEventDrivenModifier_Default =
		{
			{HK_OFFSET_OF(hkbEventDrivenModifier_DefaultStruct,m_activateEventId),HK_OFFSET_OF(hkbEventDrivenModifier_DefaultStruct,m_deactivateEventId),hkClassMember::HK_CLASS_ZERO_DEFAULT,-1},
			hkbEvent::EVENT_ID_NULL,hkbEvent::EVENT_ID_NULL
		};
	}
	hkClass hkbEventDrivenModifierClass(
		"hkbEventDrivenModifier",
		&hkbModifierWrapperClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbEventDrivenModifierClass_Members),
		HK_COUNT_OF(hkbEventDrivenModifierClass_Members),
		&hkbEventDrivenModifier_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbCharacterControllerModifierControlDataClass_Members[] =
	{
		{ "verticalGain", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "horizontalCatchUpGain", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxVerticalSeparation", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxHorizontalSeparation", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkbCharacterControllerModifierControlData_DefaultStruct
		{
			int s_defaultOffsets[4];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkReal m_verticalGain;
			hkReal m_horizontalCatchUpGain;
		};
		const hkbCharacterControllerModifierControlData_DefaultStruct hkbCharacterControllerModifierControlData_Default =
		{
			{HK_OFFSET_OF(hkbCharacterControllerModifierControlData_DefaultStruct,m_verticalGain),HK_OFFSET_OF(hkbCharacterControllerModifierControlData_DefaultStruct,m_horizontalCatchUpGain),hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT},
			1.0f,1.0f
		};
	}
	hkClass hkbCharacterControllerModifierControlDataClass(
		"hkbCharacterControllerModifierControlData",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbCharacterControllerModifierControlDataClass_Members),
		HK_COUNT_OF(hkbCharacterControllerModifierControlDataClass_Members),
		&hkbCharacterControllerModifierControlData_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkbCharacterControllerModifierInitialVelocityCoordinatesEnumItems[] =
	{
		{0, "INITIAL_VELOCITY_IN_WORLD_COORDINATES"},
		{1, "INITIAL_VELOCITY_IN_MODEL_COORDINATES"},
	};
	static const hkInternalClassEnumItem hkbCharacterControllerModifierMotionModeEnumItems[] =
	{
		{0, "MOTION_MODE_FOLLOW_ANIMATION"},
		{1, "MOTION_MODE_DYNAMIC"},
	};
	static const hkInternalClassEnum hkbCharacterControllerModifierEnums[] = {
		{"InitialVelocityCoordinates", hkbCharacterControllerModifierInitialVelocityCoordinatesEnumItems, 2, HK_NULL, 0 },
		{"MotionMode", hkbCharacterControllerModifierMotionModeEnumItems, 2, HK_NULL, 0 }
	};
	const hkClassEnum* hkbCharacterControllerModifierInitialVelocityCoordinatesEnum = reinterpret_cast<const hkClassEnum*>(&hkbCharacterControllerModifierEnums[0]);
	const hkClassEnum* hkbCharacterControllerModifierMotionModeEnum = reinterpret_cast<const hkClassEnum*>(&hkbCharacterControllerModifierEnums[1]);
	static hkInternalClassMember hkbCharacterControllerModifierClass_Members[] =
	{
		{ "controlData", &hkbCharacterControllerModifierControlDataClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "initialVelocity", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "initialVelocityCoordinates", HK_NULL, hkbCharacterControllerModifierInitialVelocityCoordinatesEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL },
		{ "motionMode", HK_NULL, hkbCharacterControllerModifierMotionModeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL },
		{ "forceDownwardMomentum", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "applyGravity", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "setInitialVelocity", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "isTouchingGround", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "gravity", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "isInitialVelocityAdded", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	namespace
	{
		struct hkbCharacterControllerModifier_DefaultStruct
		{
			int s_defaultOffsets[10];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			_hkVector4 m_initialVelocity;
			hkInt8 /* hkEnum< enum hkbCharacterControllerModifier::MotionMode, hkInt8 > */ m_motionMode;
			_hkBool m_forceDownwardMomentum;
			_hkBool m_applyGravity;
			_hkBool m_isTouchingGround;
		};
		const hkbCharacterControllerModifier_DefaultStruct hkbCharacterControllerModifier_Default =
		{
			{-1,HK_OFFSET_OF(hkbCharacterControllerModifier_DefaultStruct,m_initialVelocity),-1,HK_OFFSET_OF(hkbCharacterControllerModifier_DefaultStruct,m_motionMode),HK_OFFSET_OF(hkbCharacterControllerModifier_DefaultStruct,m_forceDownwardMomentum),HK_OFFSET_OF(hkbCharacterControllerModifier_DefaultStruct,m_applyGravity),hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkbCharacterControllerModifier_DefaultStruct,m_isTouchingGround),-1,-1},
			{0,0,0},hkbCharacterControllerModifier::MOTION_MODE_FOLLOW_ANIMATION,true,true,true
		};
	}
	hkClass hkbCharacterControllerModifierClass(
		"hkbCharacterControllerModifier",
		&hkbModifierClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkbCharacterControllerModifierEnums),
		2,
		reinterpret_cast<const hkClassMember*>(hkbCharacterControllerModifierClass_Members),
		HK_COUNT_OF(hkbCharacterControllerModifierClass_Members),
		&hkbCharacterControllerModifier_Default,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static const hkInternalClassEnumItem hkbBlenderGeneratorBlenderFlagsEnumItems[] =
	{
		{1, "FLAG_SYNC"},
		{4, "FLAG_SMOOTH_GENERATOR_WEIGHTS"},
		{8, "FLAG_DONT_DEACTIVATE_CHILDREN_WITH_ZERO_WEIGHTS"},
		{16, "FLAG_PARAMETRIC_BLEND"},
		{32, "FLAG_IS_PARAMETRIC_BLEND_CYCLIC"},
		{64, "FLAG_FORCE_DENSE_POSE"},
	};
	static const hkInternalClassEnum hkbBlenderGeneratorEnums[] = {
		{"BlenderFlags", hkbBlenderGeneratorBlenderFlagsEnumItems, 6, HK_NULL, 0 }
	};
	const hkClassEnum* hkbBlenderGeneratorBlenderFlagsEnum = reinterpret_cast<const hkClassEnum*>(&hkbBlenderGeneratorEnums[0]);
	static hkInternalClassMember hkbBlenderGenerator_ChildInternalStateClass_Members[] =
	{
		{ "isActive", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "syncNextFrame", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkbBlenderGeneratorChildInternalStateClass(
		"hkbBlenderGeneratorChildInternalState",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbBlenderGenerator_ChildInternalStateClass_Members),
		HK_COUNT_OF(hkbBlenderGenerator_ChildInternalStateClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbBlenderGeneratorClass_Members[] =
	{
		{ "referencePoseWeightThreshold", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "blendParameter", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "minCyclicBlendParameter", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxCyclicBlendParameter", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "indexOfSyncMasterChild", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "flags", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "subtractLastChild", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "children", &hkbBlenderGeneratorChildClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "childrenInternalStates", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "sortedChildren", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "endIntervalWeight", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "numActiveChildren", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "beginIntervalIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "endIntervalIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "initSync", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "doSubtractiveBlend", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	namespace
	{
		struct hkbBlenderGenerator_DefaultStruct
		{
			int s_defaultOffsets[16];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkReal m_maxCyclicBlendParameter;
			hkInt16 m_indexOfSyncMasterChild;
		};
		const hkbBlenderGenerator_DefaultStruct hkbBlenderGenerator_Default =
		{
			{hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkbBlenderGenerator_DefaultStruct,m_maxCyclicBlendParameter),HK_OFFSET_OF(hkbBlenderGenerator_DefaultStruct,m_indexOfSyncMasterChild),hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,-1,-1,-1,-1,-1,-1,-1,-1,-1},
			1.0,-1
		};
	}
	hkClass hkbBlenderGeneratorClass(
		"hkbBlenderGenerator",
		&hkbGeneratorClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkbBlenderGeneratorEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkbBlenderGeneratorClass_Members),
		HK_COUNT_OF(hkbBlenderGeneratorClass_Members),
		&hkbBlenderGenerator_Default,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkbStringConditionClass_Members[] =
	{
		{ "conditionString", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkbStringConditionClass(
		"hkbStringCondition",
		&hkbConditionClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbStringConditionClass_Members),
		HK_COUNT_OF(hkbStringConditionClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkbRoleAttributeRoleEnumItems[] =
	{
		{0, "ROLE_DEFAULT"},
		{1, "ROLE_FILE_NAME"},
		{2, "ROLE_BONE_INDEX"},
		{3, "ROLE_BONE_INDEX_MAP"},
		{4, "ROLE_EVENT_ID"},
		{5, "ROLE_VARIABLE_INDEX"},
		{6, "ROLE_ATTRIBUTE_INDEX"},
		{7, "ROLE_TIME"},
		{8, "ROLE_SCRIPT"},
		{9, "ROLE_LOCAL_FRAME"},
		{10, "ROLE_BONE_ATTACHMENT"},
	};
	static const hkInternalClassEnumItem hkbRoleAttributeRoleFlagsEnumItems[] =
	{
		{0, "FLAG_NONE"},
		{1, "FLAG_RAGDOLL"},
		{2, "FLAG_NORMALIZED"},
		{4, "FLAG_NOT_VARIABLE"},
		{8, "FLAG_HIDDEN"},
		{16, "FLAG_OUTPUT"},
		{32, "FLAG_NOT_CHARACTER_PROPERTY"},
	};
	static const hkInternalClassEnum hkbRoleAttributeEnums[] = {
		{"Role", hkbRoleAttributeRoleEnumItems, 11, HK_NULL, 0 },
		{"RoleFlags", hkbRoleAttributeRoleFlagsEnumItems, 7, HK_NULL, 0 }
	};
	const hkClassEnum* hkbRoleAttributeRoleEnum = reinterpret_cast<const hkClassEnum*>(&hkbRoleAttributeEnums[0]);
	const hkClassEnum* hkbRoleAttributeRoleFlagsEnum = reinterpret_cast<const hkClassEnum*>(&hkbRoleAttributeEnums[1]);
	static hkInternalClassMember hkbRoleAttributeClass_Members[] =
	{
		{ "role", HK_NULL, hkbRoleAttributeRoleEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT16, 0, 0, 0, HK_NULL },
		{ "flags", HK_NULL, hkbRoleAttributeRoleFlagsEnum, hkClassMember::TYPE_FLAGS, hkClassMember::TYPE_INT16, 0, 0, 0, HK_NULL }
	};
	hkClass hkbRoleAttributeClass(
		"hkbRoleAttribute",
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkbRoleAttributeEnums),
		2,
		reinterpret_cast<const hkClassMember*>(hkbRoleAttributeClass_Members),
		HK_COUNT_OF(hkbRoleAttributeClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbBoneIndexArrayClass_Members[] =
	{
		{ "boneIndices", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_INT16, 0, 0, 0, HK_NULL }
	};
	hkClass hkbBoneIndexArrayClass(
		"hkbBoneIndexArray",
		&hkbBindableClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbBoneIndexArrayClass_Members),
		HK_COUNT_OF(hkbBoneIndexArrayClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbHandIkDriverInfo_HandClass_Members[] =
	{
		{ "elbowAxisLS", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "backHandNormalLS", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "handOffsetLS", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "handOrienationOffsetLS", HK_NULL, HK_NULL, hkClassMember::TYPE_QUATERNION, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxElbowAngleDegrees", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "minElbowAngleDegrees", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "shoulderIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "shoulderSiblingIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "elbowIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "elbowSiblingIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "wristIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "enforceEndPosition", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "enforceEndRotation", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "localFrameName", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkbHandIkDriverInfoHand_DefaultStruct
		{
			int s_defaultOffsets[14];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			_hkVector4 m_elbowAxisLS;
			_hkVector4 m_backHandNormalLS;
			_hkVector4 m_handOffsetLS;
			_hkQuaternion m_handOrienationOffsetLS;
			hkReal m_maxElbowAngleDegrees;
			hkInt16 m_shoulderIndex;
			hkInt16 m_shoulderSiblingIndex;
			hkInt16 m_elbowIndex;
			hkInt16 m_elbowSiblingIndex;
			hkInt16 m_wristIndex;
			_hkBool m_enforceEndPosition;
		};
		const hkbHandIkDriverInfoHand_DefaultStruct hkbHandIkDriverInfoHand_Default =
		{
			{HK_OFFSET_OF(hkbHandIkDriverInfoHand_DefaultStruct,m_elbowAxisLS),HK_OFFSET_OF(hkbHandIkDriverInfoHand_DefaultStruct,m_backHandNormalLS),HK_OFFSET_OF(hkbHandIkDriverInfoHand_DefaultStruct,m_handOffsetLS),HK_OFFSET_OF(hkbHandIkDriverInfoHand_DefaultStruct,m_handOrienationOffsetLS),HK_OFFSET_OF(hkbHandIkDriverInfoHand_DefaultStruct,m_maxElbowAngleDegrees),hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkbHandIkDriverInfoHand_DefaultStruct,m_shoulderIndex),HK_OFFSET_OF(hkbHandIkDriverInfoHand_DefaultStruct,m_shoulderSiblingIndex),HK_OFFSET_OF(hkbHandIkDriverInfoHand_DefaultStruct,m_elbowIndex),HK_OFFSET_OF(hkbHandIkDriverInfoHand_DefaultStruct,m_elbowSiblingIndex),HK_OFFSET_OF(hkbHandIkDriverInfoHand_DefaultStruct,m_wristIndex),HK_OFFSET_OF(hkbHandIkDriverInfoHand_DefaultStruct,m_enforceEndPosition),hkClassMember::HK_CLASS_ZERO_DEFAULT,-1},
		{0,1,0},	{0,1,0},	{0,0,0},	{0,0,0,1},180.0f,-1,-1,-1,-1,-1,true
		};
	}
	hkClass hkbHandIkDriverInfoHandClass(
		"hkbHandIkDriverInfoHand",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbHandIkDriverInfo_HandClass_Members),
		HK_COUNT_OF(hkbHandIkDriverInfo_HandClass_Members),
		&hkbHandIkDriverInfoHand_Default,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkbHandIkDriverInfoClass_Members[] =
	{
		{ "hands", &hkbHandIkDriverInfoHandClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "fadeInOutCurve", HK_NULL, hkbBlendCurveUtilsBlendCurveEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkbHandIkDriverInfo_DefaultStruct
		{
			int s_defaultOffsets[2];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkInt8 /* hkEnum< enum hkbBlendCurveUtils::BlendCurve, hkInt8 > */ m_fadeInOutCurve;
		};
		const hkbHandIkDriverInfo_DefaultStruct hkbHandIkDriverInfo_Default =
		{
			{-1,HK_OFFSET_OF(hkbHandIkDriverInfo_DefaultStruct,m_fadeInOutCurve)},
			hkbBlendCurveUtils::BLEND_CURVE_SMOOTH
		};
	}
	hkClass hkbHandIkDriverInfoClass(
		"hkbHandIkDriverInfo",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbHandIkDriverInfoClass_Members),
		HK_COUNT_OF(hkbHandIkDriverInfoClass_Members),
		&hkbHandIkDriverInfo_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbModifierClass_Members[] =
	{
		{ "enable", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "padModifier", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 3, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	namespace
	{
		struct hkbModifier_DefaultStruct
		{
			int s_defaultOffsets[2];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			_hkBool m_enable;
		};
		const hkbModifier_DefaultStruct hkbModifier_Default =
		{
			{HK_OFFSET_OF(hkbModifier_DefaultStruct,m_enable),-1},
			true
		};
	}
	hkClass hkbModifierClass(
		"hkbModifier",
		&hkbNodeClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbModifierClass_Members),
		HK_COUNT_OF(hkbModifierClass_Members),
		&hkbModifier_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbSequenceClass_Members[] =
	{
		{ "eventSequencedData", &hkbEventSequencedDataClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "realVariableSequencedData", &hkbRealVariableSequencedDataClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "boolVariableSequencedData", &hkbBoolVariableSequencedDataClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "intVariableSequencedData", &hkbIntVariableSequencedDataClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "enableEventId", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "disableEventId", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "stringData", &hkbSequenceStringDataClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "variableIdMap", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "eventIdMap", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "nextSampleEvents", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "nextSampleReals", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "nextSampleBools", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "nextSampleInts", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "time", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "isEnabled", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	namespace
	{
		struct hkbSequence_DefaultStruct
		{
			int s_defaultOffsets[15];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkInt32 m_enableEventId;
			hkInt32 m_disableEventId;
		};
		const hkbSequence_DefaultStruct hkbSequence_Default =
		{
			{-1,-1,-1,-1,HK_OFFSET_OF(hkbSequence_DefaultStruct,m_enableEventId),HK_OFFSET_OF(hkbSequence_DefaultStruct,m_disableEventId),-1,-1,-1,-1,-1,-1,-1,-1,-1},
			hkbEvent::EVENT_ID_NULL,hkbEvent::EVENT_ID_NULL
		};
	}
	hkClass hkbSequenceClass(
		"hkbSequence",
		&hkbModifierClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbSequenceClass_Members),
		HK_COUNT_OF(hkbSequenceClass_Members),
		&hkbSequence_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbTimerModifierClass_Members[] =
	{
		{ "alarmTimeSeconds", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "alarmEvent", &hkbEventPropertyClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "secondsElapsed", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	namespace
	{
		struct hkbTimerModifier_DefaultStruct
		{
			int s_defaultOffsets[3];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
		};
		const hkbTimerModifier_DefaultStruct hkbTimerModifier_Default =
		{
			{hkClassMember::HK_CLASS_ZERO_DEFAULT,-1,-1},
		};
	}
	hkClass hkbTimerModifierClass(
		"hkbTimerModifier",
		&hkbModifierClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbTimerModifierClass_Members),
		HK_COUNT_OF(hkbTimerModifierClass_Members),
		&hkbTimerModifier_Default,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkbBindableClass_Members[] =
	{
		{ "variableBindingSet", &hkbVariableBindingSetClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "cachedBindables", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "areBindablesCached", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "hasEnableChanged", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hkbBindableClass(
		"hkbBindable",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbBindableClass_Members),
		HK_COUNT_OF(hkbBindableClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkbNodeGetChildrenFlagBitsEnumItems[] =
	{
		{1, "FLAG_ACTIVE_ONLY"},
		{2, "FLAG_GENERATORS_ONLY"},
		{4, "FLAG_IGNORE_REFERENCED_BEHAVIORS"},
	};
	static const hkInternalClassEnumItem hkbNodeCloneStateEnumItems[] =
	{
		{0, "CLONE_STATE_DEFAULT"},
		{1, "CLONE_STATE_TEMPLATE"},
		{2, "CLONE_STATE_CLONE"},
	};
	static const hkInternalClassEnumItem hkbNodeTemplateOrCloneEnumItems[] =
	{
		{0, "NODE_IS_TEMPLATE"},
		{1, "NODE_IS_CLONE"},
	};
	static const hkInternalClassEnum hkbNodeEnums[] = {
		{"GetChildrenFlagBits", hkbNodeGetChildrenFlagBitsEnumItems, 3, HK_NULL, 0 },
		{"CloneState", hkbNodeCloneStateEnumItems, 3, HK_NULL, 0 },
		{"TemplateOrClone", hkbNodeTemplateOrCloneEnumItems, 2, HK_NULL, 0 }
	};
	const hkClassEnum* hkbNodeGetChildrenFlagBitsEnum = reinterpret_cast<const hkClassEnum*>(&hkbNodeEnums[0]);
	const hkClassEnum* hkbNodeCloneStateEnum = reinterpret_cast<const hkClassEnum*>(&hkbNodeEnums[1]);
	const hkClassEnum* hkbNodeTemplateOrCloneEnum = reinterpret_cast<const hkClassEnum*>(&hkbNodeEnums[2]);
	static hkInternalClassMember hkbNodeClass_Members[] =
	{
		{ "userData", HK_NULL, HK_NULL, hkClassMember::TYPE_ULONG, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "id", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "cloneState", HK_NULL, HK_NULL, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "type", HK_NULL, HK_NULL, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "nodeInfo", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hkbNodeClass(
		"hkbNode",
		&hkbBindableClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkbNodeEnums),
		3,
		reinterpret_cast<const hkClassMember*>(hkbNodeClass_Members),
		HK_COUNT_OF(hkbNodeClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkbMirrorModifierClass_Members[] =
	{
		{ "isAdditive", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkbMirrorModifier_DefaultStruct
		{
			int s_defaultOffsets[1];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
		};
		const hkbMirrorModifier_DefaultStruct hkbMirrorModifier_Default =
		{
			{hkClassMember::HK_CLASS_ZERO_DEFAULT},
		};
	}
	hkClass hkbMirrorModifierClass(
		"hkbMirrorModifier",
		&hkbModifierClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbMirrorModifierClass_Members),
		HK_COUNT_OF(hkbMirrorModifierClass_Members),
		&hkbMirrorModifier_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkbVariableBindingSetBindingBindingTypeEnumItems[] =
	{
		{0, "BINDING_TYPE_VARIABLE"},
		{1, "BINDING_TYPE_CHARACTER_PROPERTY"},
	};
	static const hkInternalClassEnumItem hkbVariableBindingSetBindingInternalBindingFlagsEnumItems[] =
	{
		{0, "FLAG_NONE"},
		{1, "FLAG_OUTPUT"},
	};
	static const hkInternalClassEnum hkbVariableBindingSetBindingEnums[] = {
		{"BindingType", hkbVariableBindingSetBindingBindingTypeEnumItems, 2, HK_NULL, 0 },
		{"InternalBindingFlags", hkbVariableBindingSetBindingInternalBindingFlagsEnumItems, 2, HK_NULL, 0 }
	};
	const hkClassEnum* hkbVariableBindingSetBindingBindingTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkbVariableBindingSetBindingEnums[0]);
	const hkClassEnum* hkbVariableBindingSetBindingInternalBindingFlagsEnum = reinterpret_cast<const hkClassEnum*>(&hkbVariableBindingSetBindingEnums[1]);
	static hkInternalClassMember hkbVariableBindingSet_BindingClass_Members[] =
	{
		{ "memberPath", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "memberClass", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "offsetInObjectPlusOne", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "offsetInArrayPlusOne", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "rootVariableIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "variableIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "bitIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "bindingType", HK_NULL, hkbVariableBindingSetBindingBindingTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL },
		{ "memberType", HK_NULL, HK_NULL, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "variableType", HK_NULL, HK_NULL, hkClassMember::TYPE_INT8, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "flags", HK_NULL, HK_NULL, hkClassMember::TYPE_FLAGS, hkClassMember::TYPE_INT8, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	namespace
	{
		struct hkbVariableBindingSetBinding_DefaultStruct
		{
			int s_defaultOffsets[11];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkInt8 m_bitIndex;
		};
		const hkbVariableBindingSetBinding_DefaultStruct hkbVariableBindingSetBinding_Default =
		{
			{-1,-1,-1,-1,-1,-1,HK_OFFSET_OF(hkbVariableBindingSetBinding_DefaultStruct,m_bitIndex),-1,-1,-1,-1},
			-1
		};
	}
	hkClass hkbVariableBindingSetBindingClass(
		"hkbVariableBindingSetBinding",
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkbVariableBindingSetBindingEnums),
		2,
		reinterpret_cast<const hkClassMember*>(hkbVariableBindingSet_BindingClass_Members),
		HK_COUNT_OF(hkbVariableBindingSet_BindingClass_Members),
		&hkbVariableBindingSetBinding_Default,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkbVariableBindingSetClass_Members[] =
	{
		{ "bindings", &hkbVariableBindingSetBindingClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "indexOfBindingToEnable", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "hasOutputBinding", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	namespace
	{
		struct hkbVariableBindingSet_DefaultStruct
		{
			int s_defaultOffsets[3];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkInt32 m_indexOfBindingToEnable;
		};
		const hkbVariableBindingSet_DefaultStruct hkbVariableBindingSet_Default =
		{
			{-1,HK_OFFSET_OF(hkbVariableBindingSet_DefaultStruct,m_indexOfBindingToEnable),-1},
			-1
		};
	}
	hkClass hkbVariableBindingSetClass(
		"hkbVariableBindingSet",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbVariableBindingSetClass_Members),
		HK_COUNT_OF(hkbVariableBindingSetClass_Members),
		&hkbVariableBindingSet_Default,
		HK_NULL,
		0,
		hkUint32(2)
		);
	static const hkInternalClassEnumItem hkbExpressionDataExpressionEventModeEnumItems[] =
	{
		{0, "EVENT_MODE_SEND_ONCE"},
		{1, "EVENT_MODE_SEND_ON_TRUE"},
		{2, "EVENT_MODE_SEND_ON_FALSE_TO_TRUE"},
		{3, "EVENT_MODE_SEND_EVERY_FRAME_ONCE_TRUE"},
	};
	static const hkInternalClassEnum hkbExpressionDataEnums[] = {
		{"ExpressionEventMode", hkbExpressionDataExpressionEventModeEnumItems, 4, HK_NULL, 0 }
	};
	const hkClassEnum* hkbExpressionDataExpressionEventModeEnum = reinterpret_cast<const hkClassEnum*>(&hkbExpressionDataEnums[0]);
	static hkInternalClassMember hkbExpressionDataClass_Members[] =
	{
		{ "expression", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "assignmentVariableIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "assignmentEventIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "eventMode", HK_NULL, hkbExpressionDataExpressionEventModeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL },
		{ "raisedEvent", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "wasTrueInPreviousFrame", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	namespace
	{
		struct hkbExpressionData_DefaultStruct
		{
			int s_defaultOffsets[6];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkInt8 /* hkEnum< enum hkbExpressionData::ExpressionEventMode, hkInt8 > */ m_eventMode;
		};
		const hkbExpressionData_DefaultStruct hkbExpressionData_Default =
		{
			{-1,-1,-1,HK_OFFSET_OF(hkbExpressionData_DefaultStruct,m_eventMode),-1,-1},
			hkbExpressionData::EVENT_MODE_SEND_ONCE
		};
	}
	hkClass hkbExpressionDataClass(
		"hkbExpressionData",
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkbExpressionDataEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkbExpressionDataClass_Members),
		HK_COUNT_OF(hkbExpressionDataClass_Members),
		&hkbExpressionData_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbExpressionDataArrayClass_Members[] =
	{
		{ "expressionsData", &hkbExpressionDataClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkbExpressionDataArrayClass(
		"hkbExpressionDataArray",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbExpressionDataArrayClass_Members),
		HK_COUNT_OF(hkbExpressionDataArrayClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbEvaluateExpressionModifier_InternalExpressionDataClass_Members[] =
	{
		{ "raisedEvent", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "wasTrueInPreviousFrame", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkbEvaluateExpressionModifierInternalExpressionDataClass(
		"hkbEvaluateExpressionModifierInternalExpressionData",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbEvaluateExpressionModifier_InternalExpressionDataClass_Members),
		HK_COUNT_OF(hkbEvaluateExpressionModifier_InternalExpressionDataClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbEvaluateExpressionModifierClass_Members[] =
	{
		{ "expressions", &hkbExpressionDataArrayClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "compiledExpressionSet", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "internalExpressionsData", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hkbEvaluateExpressionModifierClass(
		"hkbEvaluateExpressionModifier",
		&hkbModifierClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbEvaluateExpressionModifierClass_Members),
		HK_COUNT_OF(hkbEvaluateExpressionModifierClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkbBlenderGeneratorChildClass_Members[] =
	{
		{ "generator", &hkbGeneratorClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0|hkClassMember::ALIGN_16, 0, HK_NULL },
		{ "boneWeights", &hkbBoneWeightArrayClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "weight", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "worldFromModelWeight", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkbBlenderGeneratorChild_DefaultStruct
		{
			int s_defaultOffsets[4];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkReal m_worldFromModelWeight;
		};
		const hkbBlenderGeneratorChild_DefaultStruct hkbBlenderGeneratorChild_Default =
		{
			{-1,-1,-1,HK_OFFSET_OF(hkbBlenderGeneratorChild_DefaultStruct,m_worldFromModelWeight)},
			1.0
		};
	}
	hkClass hkbBlenderGeneratorChildClass(
		"hkbBlenderGeneratorChild",
		&hkbBindableClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbBlenderGeneratorChildClass_Members),
		HK_COUNT_OF(hkbBlenderGeneratorChildClass_Members),
		&hkbBlenderGeneratorChild_Default,
		HK_NULL,
		0,
		hkUint32(2)
		);
	static const hkInternalClassEnumItem hkbWorldEnumsSimulationStateEnumItems[] =
	{
		{0, "SIMULATION_STATE_PLAY"},
		{1, "SIMULATION_STATE_PAUSE"},
		{2, "SIMULATION_STATE_STEP"},
		{3, "SIMULATION_STATE_STOP"},
	};
	static const hkInternalClassEnumItem hkbWorldEnumsAccumulateMotionStateEnumItems[] =
	{
		{0, "ACCUMULATE_MOTION"},
		{1, "DO_NOT_ACCUMULATE_MOTION"},
	};
	static const hkInternalClassEnum hkbWorldEnumsEnums[] = {
		{"SimulationState", hkbWorldEnumsSimulationStateEnumItems, 4, HK_NULL, 0 },
		{"AccumulateMotionState", hkbWorldEnumsAccumulateMotionStateEnumItems, 2, HK_NULL, 0 }
	};
	const hkClassEnum* hkbWorldEnumsSimulationStateEnum = reinterpret_cast<const hkClassEnum*>(&hkbWorldEnumsEnums[0]);
	const hkClassEnum* hkbWorldEnumsAccumulateMotionStateEnum = reinterpret_cast<const hkClassEnum*>(&hkbWorldEnumsEnums[1]);
	hkClass hkbWorldEnumsClass(
		"hkbWorldEnums",
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkbWorldEnumsEnums),
		2,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbDelayedModifierClass_Members[] =
	{
		{ "delaySeconds", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "durationSeconds", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "secondsElapsed", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "isActive", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	namespace
	{
		struct hkbDelayedModifier_DefaultStruct
		{
			int s_defaultOffsets[4];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
		};
		const hkbDelayedModifier_DefaultStruct hkbDelayedModifier_Default =
		{
			{hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,-1,-1},
		};
	}
	hkClass hkbDelayedModifierClass(
		"hkbDelayedModifier",
		&hkbModifierWrapperClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbDelayedModifierClass_Members),
		HK_COUNT_OF(hkbDelayedModifierClass_Members),
		&hkbDelayedModifier_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbCombineTransformsModifierClass_Members[] =
	{
		{ "translationOut", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "rotationOut", HK_NULL, HK_NULL, hkClassMember::TYPE_QUATERNION, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "leftTranslation", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "leftRotation", HK_NULL, HK_NULL, hkClassMember::TYPE_QUATERNION, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "rightTranslation", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "rightRotation", HK_NULL, HK_NULL, hkClassMember::TYPE_QUATERNION, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "invertLeftTransform", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "invertRightTransform", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "invertResult", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkbCombineTransformsModifier_DefaultStruct
		{
			int s_defaultOffsets[9];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			_hkVector4 m_translationOut;
			_hkQuaternion m_rotationOut;
			_hkVector4 m_leftTranslation;
			_hkQuaternion m_leftRotation;
			_hkVector4 m_rightTranslation;
			_hkQuaternion m_rightRotation;
		};
		const hkbCombineTransformsModifier_DefaultStruct hkbCombineTransformsModifier_Default =
		{
			{HK_OFFSET_OF(hkbCombineTransformsModifier_DefaultStruct,m_translationOut),HK_OFFSET_OF(hkbCombineTransformsModifier_DefaultStruct,m_rotationOut),HK_OFFSET_OF(hkbCombineTransformsModifier_DefaultStruct,m_leftTranslation),HK_OFFSET_OF(hkbCombineTransformsModifier_DefaultStruct,m_leftRotation),HK_OFFSET_OF(hkbCombineTransformsModifier_DefaultStruct,m_rightTranslation),HK_OFFSET_OF(hkbCombineTransformsModifier_DefaultStruct,m_rightRotation),hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT},
		{0,0,0,0},	{0,0,0,1},	{0,0,0,0},	{0,0,0,0},	{0,0,0,0},	{0,0,0,0}
		};
	}
	hkClass hkbCombineTransformsModifierClass(
		"hkbCombineTransformsModifier",
		&hkbModifierClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbCombineTransformsModifierClass_Members),
		HK_COUNT_OF(hkbCombineTransformsModifierClass_Members),
		&hkbCombineTransformsModifier_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbLookAtModifierClass_Members[] =
	{
		{ "targetWS", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "headForwardLS", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "neckForwardLS", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "neckRightLS", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "eyePositionHS", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "newTargetGain", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "onGain", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "offGain", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "limitAngleDegrees", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "limitAngleLeft", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "limitAngleRight", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "limitAngleUp", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "limitAngleDown", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "headIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "neckIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "isOn", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "individualLimitsOn", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "isTargetInsideLimitCone", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "lookAtLastTargetWS", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "lookAtWeight", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	namespace
	{
		struct hkbLookAtModifier_DefaultStruct
		{
			int s_defaultOffsets[20];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			_hkVector4 m_targetWS;
			_hkVector4 m_headForwardLS;
			_hkVector4 m_neckForwardLS;
			_hkVector4 m_neckRightLS;
			_hkVector4 m_eyePositionHS;
			hkReal m_newTargetGain;
			hkReal m_onGain;
			hkReal m_offGain;
			hkReal m_limitAngleDegrees;
			hkReal m_limitAngleLeft;
			hkReal m_limitAngleRight;
			hkReal m_limitAngleUp;
			hkReal m_limitAngleDown;
			hkInt16 m_headIndex;
			hkInt16 m_neckIndex;
			_hkBool m_isOn;
		};
		const hkbLookAtModifier_DefaultStruct hkbLookAtModifier_Default =
		{
			{HK_OFFSET_OF(hkbLookAtModifier_DefaultStruct,m_targetWS),HK_OFFSET_OF(hkbLookAtModifier_DefaultStruct,m_headForwardLS),HK_OFFSET_OF(hkbLookAtModifier_DefaultStruct,m_neckForwardLS),HK_OFFSET_OF(hkbLookAtModifier_DefaultStruct,m_neckRightLS),HK_OFFSET_OF(hkbLookAtModifier_DefaultStruct,m_eyePositionHS),HK_OFFSET_OF(hkbLookAtModifier_DefaultStruct,m_newTargetGain),HK_OFFSET_OF(hkbLookAtModifier_DefaultStruct,m_onGain),HK_OFFSET_OF(hkbLookAtModifier_DefaultStruct,m_offGain),HK_OFFSET_OF(hkbLookAtModifier_DefaultStruct,m_limitAngleDegrees),HK_OFFSET_OF(hkbLookAtModifier_DefaultStruct,m_limitAngleLeft),HK_OFFSET_OF(hkbLookAtModifier_DefaultStruct,m_limitAngleRight),HK_OFFSET_OF(hkbLookAtModifier_DefaultStruct,m_limitAngleUp),HK_OFFSET_OF(hkbLookAtModifier_DefaultStruct,m_limitAngleDown),HK_OFFSET_OF(hkbLookAtModifier_DefaultStruct,m_headIndex),HK_OFFSET_OF(hkbLookAtModifier_DefaultStruct,m_neckIndex),HK_OFFSET_OF(hkbLookAtModifier_DefaultStruct,m_isOn),-1,-1,-1,-1},
		{0,0,0},	{0,1,0},	{0,1,0},	{1,0,0},	{0,0,0},0.2f,0.05f,0.05f,45.0,90.0f,-90.0f,30.0f,-30.0f,-1,-1,true
		};
	}
	hkClass hkbLookAtModifierClass(
		"hkbLookAtModifier",
		&hkbModifierClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbLookAtModifierClass_Members),
		HK_COUNT_OF(hkbLookAtModifierClass_Members),
		&hkbLookAtModifier_Default,
		HK_NULL,
		0,
		hkUint32(3)
		);
	static const hkInternalClassEnumItem hkbPoseMatchingGeneratorModeEnumItems[] =
	{
		{0, "MODE_MATCH"},
		{1, "MODE_PLAY"},
	};
	static const hkInternalClassEnum hkbPoseMatchingGeneratorEnums[] = {
		{"Mode", hkbPoseMatchingGeneratorModeEnumItems, 2, HK_NULL, 0 }
	};
	const hkClassEnum* hkbPoseMatchingGeneratorModeEnum = reinterpret_cast<const hkClassEnum*>(&hkbPoseMatchingGeneratorEnums[0]);
	static hkInternalClassMember hkbPoseMatchingGeneratorClass_Members[] =
	{
		{ "worldFromModelRotation", HK_NULL, HK_NULL, hkClassMember::TYPE_QUATERNION, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "blendSpeed", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "minSpeedToSwitch", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "minSwitchTimeNoError", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "minSwitchTimeFullError", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "startPlayingEventId", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "startMatchingEventId", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "rootBoneIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "otherBoneIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "anotherBoneIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "pelvisIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "mode", HK_NULL, hkbPoseMatchingGeneratorModeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL },
		{ "currentMatch", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "bestMatch", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "timeSinceBetterMatch", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "error", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "resetCurrentMatchLocalTime", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "poseMatchingUtility", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	namespace
	{
		struct hkbPoseMatchingGenerator_DefaultStruct
		{
			int s_defaultOffsets[18];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			_hkQuaternion m_worldFromModelRotation;
			hkReal m_blendSpeed;
			hkReal m_minSpeedToSwitch;
			hkReal m_minSwitchTimeNoError;
			hkInt32 m_startPlayingEventId;
			hkInt32 m_startMatchingEventId;
			hkInt16 m_rootBoneIndex;
			hkInt16 m_otherBoneIndex;
			hkInt16 m_anotherBoneIndex;
			hkInt16 m_pelvisIndex;
			hkInt8 /* hkEnum< enum hkbPoseMatchingGenerator::Mode, hkInt8 > */ m_mode;
		};
		const hkbPoseMatchingGenerator_DefaultStruct hkbPoseMatchingGenerator_Default =
		{
			{HK_OFFSET_OF(hkbPoseMatchingGenerator_DefaultStruct,m_worldFromModelRotation),HK_OFFSET_OF(hkbPoseMatchingGenerator_DefaultStruct,m_blendSpeed),HK_OFFSET_OF(hkbPoseMatchingGenerator_DefaultStruct,m_minSpeedToSwitch),HK_OFFSET_OF(hkbPoseMatchingGenerator_DefaultStruct,m_minSwitchTimeNoError),hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkbPoseMatchingGenerator_DefaultStruct,m_startPlayingEventId),HK_OFFSET_OF(hkbPoseMatchingGenerator_DefaultStruct,m_startMatchingEventId),HK_OFFSET_OF(hkbPoseMatchingGenerator_DefaultStruct,m_rootBoneIndex),HK_OFFSET_OF(hkbPoseMatchingGenerator_DefaultStruct,m_otherBoneIndex),HK_OFFSET_OF(hkbPoseMatchingGenerator_DefaultStruct,m_anotherBoneIndex),HK_OFFSET_OF(hkbPoseMatchingGenerator_DefaultStruct,m_pelvisIndex),HK_OFFSET_OF(hkbPoseMatchingGenerator_DefaultStruct,m_mode),-1,-1,-1,-1,-1,-1},
			{0,0,0,1},1.0f,0.2f,0.2f,hkbEvent::EVENT_ID_NULL,hkbEvent::EVENT_ID_NULL,-1,-1,-1,-1,hkbPoseMatchingGenerator::MODE_MATCH
		};
	}
	hkClass hkbPoseMatchingGeneratorClass(
		"hkbPoseMatchingGenerator",
		&hkbBlenderGeneratorClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkbPoseMatchingGeneratorEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkbPoseMatchingGeneratorClass_Members),
		HK_COUNT_OF(hkbPoseMatchingGeneratorClass_Members),
		&hkbPoseMatchingGenerator_Default,
		HK_NULL,
		0,
		hkUint32(2)
		);
	static const hkInternalClassEnumItem hkbVariableInfoVariableTypeEnumItems[] =
	{
		{-1, "VARIABLE_TYPE_INVALID"},
		{0, "VARIABLE_TYPE_BOOL"},
		{1, "VARIABLE_TYPE_INT8"},
		{2, "VARIABLE_TYPE_INT16"},
		{3, "VARIABLE_TYPE_INT32"},
		{4, "VARIABLE_TYPE_REAL"},
		{5, "VARIABLE_TYPE_POINTER"},
		{6, "VARIABLE_TYPE_VECTOR3"},
		{7, "VARIABLE_TYPE_VECTOR4"},
		{8, "VARIABLE_TYPE_QUATERNION"},
	};
	static const hkInternalClassEnum hkbVariableInfoEnums[] = {
		{"VariableType", hkbVariableInfoVariableTypeEnumItems, 10, HK_NULL, 0 }
	};
	const hkClassEnum* hkbVariableInfoVariableTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkbVariableInfoEnums[0]);
	static hkInternalClassMember hkbVariableInfoClass_Members[] =
	{
		{ "role", &hkbRoleAttributeClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "type", HK_NULL, hkbVariableInfoVariableTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL }
	};
	hkClass hkbVariableInfoClass(
		"hkbVariableInfo",
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkbVariableInfoEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkbVariableInfoClass_Members),
		HK_COUNT_OF(hkbVariableInfoClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkbVariableValueSetClass_Members[] =
	{
		{ "wordVariableValues", &hkbVariableValueClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "quadVariableValues", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VECTOR4, 0, 0, 0, HK_NULL },
		{ "variantVariableValues", &hkReferencedObjectClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL }
	};
	hkClass hkbVariableValueSetClass(
		"hkbVariableValueSet",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbVariableValueSetClass_Members),
		HK_COUNT_OF(hkbVariableValueSetClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkbKeyframeBonesModifier_KeyframeInfoClass_Members[] =
	{
		{ "keyframedPosition", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "keyframedRotation", HK_NULL, HK_NULL, hkClassMember::TYPE_QUATERNION, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "boneIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "isValid", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkbKeyframeBonesModifierKeyframeInfo_DefaultStruct
		{
			int s_defaultOffsets[4];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			_hkVector4 m_keyframedPosition;
			_hkQuaternion m_keyframedRotation;
			hkInt16 m_boneIndex;
		};
		const hkbKeyframeBonesModifierKeyframeInfo_DefaultStruct hkbKeyframeBonesModifierKeyframeInfo_Default =
		{
			{HK_OFFSET_OF(hkbKeyframeBonesModifierKeyframeInfo_DefaultStruct,m_keyframedPosition),HK_OFFSET_OF(hkbKeyframeBonesModifierKeyframeInfo_DefaultStruct,m_keyframedRotation),HK_OFFSET_OF(hkbKeyframeBonesModifierKeyframeInfo_DefaultStruct,m_boneIndex),hkClassMember::HK_CLASS_ZERO_DEFAULT},
		{0,0,0},	{0,0,0,1},-1
		};
	}
	hkClass hkbKeyframeBonesModifierKeyframeInfoClass(
		"hkbKeyframeBonesModifierKeyframeInfo",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbKeyframeBonesModifier_KeyframeInfoClass_Members),
		HK_COUNT_OF(hkbKeyframeBonesModifier_KeyframeInfoClass_Members),
		&hkbKeyframeBonesModifierKeyframeInfo_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbKeyframeBonesModifierClass_Members[] =
	{
		{ "keyframeInfo", &hkbKeyframeBonesModifierKeyframeInfoClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "keyframedBonesList", &hkbBoneIndexArrayClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkbKeyframeBonesModifierClass(
		"hkbKeyframeBonesModifier",
		&hkbModifierClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbKeyframeBonesModifierClass_Members),
		HK_COUNT_OF(hkbKeyframeBonesModifierClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(3)
		);
	hkClass hkbSequencedDataClass(
		"hkbSequencedData",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbEventSequencedData_SequencedEventClass_Members[] =
	{
		{ "event", &hkbEventClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "time", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkbEventSequencedDataSequencedEvent_DefaultStruct
		{
			int s_defaultOffsets[2];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
		};
		const hkbEventSequencedDataSequencedEvent_DefaultStruct hkbEventSequencedDataSequencedEvent_Default =
		{
			{-1,hkClassMember::HK_CLASS_ZERO_DEFAULT},
		};
	}
	hkClass hkbEventSequencedDataSequencedEventClass(
		"hkbEventSequencedDataSequencedEvent",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbEventSequencedData_SequencedEventClass_Members),
		HK_COUNT_OF(hkbEventSequencedData_SequencedEventClass_Members),
		&hkbEventSequencedDataSequencedEvent_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbEventSequencedDataClass_Members[] =
	{
		{ "events", &hkbEventSequencedDataSequencedEventClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkbEventSequencedDataClass(
		"hkbEventSequencedData",
		&hkbSequencedDataClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbEventSequencedDataClass_Members),
		HK_COUNT_OF(hkbEventSequencedDataClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbRealVariableSequencedData_SampleClass_Members[] =
	{
		{ "time", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "value", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkbRealVariableSequencedDataSample_DefaultStruct
		{
			int s_defaultOffsets[2];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
		};
		const hkbRealVariableSequencedDataSample_DefaultStruct hkbRealVariableSequencedDataSample_Default =
		{
			{hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT},
		};
	}
	hkClass hkbRealVariableSequencedDataSampleClass(
		"hkbRealVariableSequencedDataSample",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbRealVariableSequencedData_SampleClass_Members),
		HK_COUNT_OF(hkbRealVariableSequencedData_SampleClass_Members),
		&hkbRealVariableSequencedDataSample_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbRealVariableSequencedDataClass_Members[] =
	{
		{ "samples", &hkbRealVariableSequencedDataSampleClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "variableIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkbRealVariableSequencedData_DefaultStruct
		{
			int s_defaultOffsets[2];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkInt32 m_variableIndex;
		};
		const hkbRealVariableSequencedData_DefaultStruct hkbRealVariableSequencedData_Default =
		{
			{-1,HK_OFFSET_OF(hkbRealVariableSequencedData_DefaultStruct,m_variableIndex)},
			-1
		};
	}
	hkClass hkbRealVariableSequencedDataClass(
		"hkbRealVariableSequencedData",
		&hkbSequencedDataClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbRealVariableSequencedDataClass_Members),
		HK_COUNT_OF(hkbRealVariableSequencedDataClass_Members),
		&hkbRealVariableSequencedData_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbBoolVariableSequencedData_SampleClass_Members[] =
	{
		{ "time", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "value", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkbBoolVariableSequencedDataSample_DefaultStruct
		{
			int s_defaultOffsets[2];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
		};
		const hkbBoolVariableSequencedDataSample_DefaultStruct hkbBoolVariableSequencedDataSample_Default =
		{
			{hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT},
		};
	}
	hkClass hkbBoolVariableSequencedDataSampleClass(
		"hkbBoolVariableSequencedDataSample",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbBoolVariableSequencedData_SampleClass_Members),
		HK_COUNT_OF(hkbBoolVariableSequencedData_SampleClass_Members),
		&hkbBoolVariableSequencedDataSample_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbBoolVariableSequencedDataClass_Members[] =
	{
		{ "samples", &hkbBoolVariableSequencedDataSampleClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "variableIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkbBoolVariableSequencedData_DefaultStruct
		{
			int s_defaultOffsets[2];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkInt32 m_variableIndex;
		};
		const hkbBoolVariableSequencedData_DefaultStruct hkbBoolVariableSequencedData_Default =
		{
			{-1,HK_OFFSET_OF(hkbBoolVariableSequencedData_DefaultStruct,m_variableIndex)},
			-1
		};
	}
	hkClass hkbBoolVariableSequencedDataClass(
		"hkbBoolVariableSequencedData",
		&hkbSequencedDataClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbBoolVariableSequencedDataClass_Members),
		HK_COUNT_OF(hkbBoolVariableSequencedDataClass_Members),
		&hkbBoolVariableSequencedData_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbIntVariableSequencedData_SampleClass_Members[] =
	{
		{ "time", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "value", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkbIntVariableSequencedDataSample_DefaultStruct
		{
			int s_defaultOffsets[2];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
		};
		const hkbIntVariableSequencedDataSample_DefaultStruct hkbIntVariableSequencedDataSample_Default =
		{
			{hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT},
		};
	}
	hkClass hkbIntVariableSequencedDataSampleClass(
		"hkbIntVariableSequencedDataSample",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbIntVariableSequencedData_SampleClass_Members),
		HK_COUNT_OF(hkbIntVariableSequencedData_SampleClass_Members),
		&hkbIntVariableSequencedDataSample_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbIntVariableSequencedDataClass_Members[] =
	{
		{ "samples", &hkbIntVariableSequencedDataSampleClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "variableIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkbIntVariableSequencedData_DefaultStruct
		{
			int s_defaultOffsets[2];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkInt32 m_variableIndex;
		};
		const hkbIntVariableSequencedData_DefaultStruct hkbIntVariableSequencedData_Default =
		{
			{-1,HK_OFFSET_OF(hkbIntVariableSequencedData_DefaultStruct,m_variableIndex)},
			-1
		};
	}
	hkClass hkbIntVariableSequencedDataClass(
		"hkbIntVariableSequencedData",
		&hkbSequencedDataClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbIntVariableSequencedDataClass_Members),
		HK_COUNT_OF(hkbIntVariableSequencedDataClass_Members),
		&hkbIntVariableSequencedData_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbHandIkModifier_HandClass_Members[] =
	{
		{ "elbowAxisLS", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "backHandNormalLS", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "handOffsetLS", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "handOrientationOffsetLS", HK_NULL, HK_NULL, hkClassMember::TYPE_QUATERNION, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxElbowAngleDegrees", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "minElbowAngleDegrees", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "shoulderIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "shoulderSiblingIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "elbowIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "elbowSiblingIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "wristIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "enforceEndPosition", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "enforceEndRotation", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "localFrameName", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkbHandIkModifierHand_DefaultStruct
		{
			int s_defaultOffsets[14];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			_hkVector4 m_elbowAxisLS;
			_hkVector4 m_backHandNormalLS;
			_hkVector4 m_handOffsetLS;
			_hkQuaternion m_handOrientationOffsetLS;
			hkReal m_maxElbowAngleDegrees;
			hkInt16 m_shoulderIndex;
			hkInt16 m_shoulderSiblingIndex;
			hkInt16 m_elbowIndex;
			hkInt16 m_elbowSiblingIndex;
			hkInt16 m_wristIndex;
			_hkBool m_enforceEndPosition;
		};
		const hkbHandIkModifierHand_DefaultStruct hkbHandIkModifierHand_Default =
		{
			{HK_OFFSET_OF(hkbHandIkModifierHand_DefaultStruct,m_elbowAxisLS),HK_OFFSET_OF(hkbHandIkModifierHand_DefaultStruct,m_backHandNormalLS),HK_OFFSET_OF(hkbHandIkModifierHand_DefaultStruct,m_handOffsetLS),HK_OFFSET_OF(hkbHandIkModifierHand_DefaultStruct,m_handOrientationOffsetLS),HK_OFFSET_OF(hkbHandIkModifierHand_DefaultStruct,m_maxElbowAngleDegrees),hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkbHandIkModifierHand_DefaultStruct,m_shoulderIndex),HK_OFFSET_OF(hkbHandIkModifierHand_DefaultStruct,m_shoulderSiblingIndex),HK_OFFSET_OF(hkbHandIkModifierHand_DefaultStruct,m_elbowIndex),HK_OFFSET_OF(hkbHandIkModifierHand_DefaultStruct,m_elbowSiblingIndex),HK_OFFSET_OF(hkbHandIkModifierHand_DefaultStruct,m_wristIndex),HK_OFFSET_OF(hkbHandIkModifierHand_DefaultStruct,m_enforceEndPosition),hkClassMember::HK_CLASS_ZERO_DEFAULT,-1},
		{0,1,0},	{0,1,0},	{0,0,0},	{0,0,0,1},180.0f,-1,-1,-1,-1,-1,true
		};
	}
	hkClass hkbHandIkModifierHandClass(
		"hkbHandIkModifierHand",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbHandIkModifier_HandClass_Members),
		HK_COUNT_OF(hkbHandIkModifier_HandClass_Members),
		&hkbHandIkModifierHand_Default,
		HK_NULL,
		0,
		hkUint32(4)
		);
	static hkInternalClassMember hkbHandIkModifierClass_Members[] =
	{
		{ "hands", &hkbHandIkModifierHandClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "fadeInOutCurve", HK_NULL, hkbBlendCurveUtilsBlendCurveEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL },
		{ "internalHandData", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	namespace
	{
		struct hkbHandIkModifier_DefaultStruct
		{
			int s_defaultOffsets[3];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkInt8 /* hkEnum< enum hkbBlendCurveUtils::BlendCurve, hkInt8 > */ m_fadeInOutCurve;
		};
		const hkbHandIkModifier_DefaultStruct hkbHandIkModifier_Default =
		{
			{-1,HK_OFFSET_OF(hkbHandIkModifier_DefaultStruct,m_fadeInOutCurve),-1},
			hkbBlendCurveUtils::BLEND_CURVE_SMOOTH
		};
	}
	hkClass hkbHandIkModifierClass(
		"hkbHandIkModifier",
		&hkbModifierClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbHandIkModifierClass_Members),
		HK_COUNT_OF(hkbHandIkModifierClass_Members),
		&hkbHandIkModifier_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbTransformVectorModifierClass_Members[] =
	{
		{ "rotation", HK_NULL, HK_NULL, hkClassMember::TYPE_QUATERNION, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "translation", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "vectorIn", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "vectorOut", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "rotateOnly", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "inverse", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "computeOnActivate", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "computeOnModify", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkbTransformVectorModifier_DefaultStruct
		{
			int s_defaultOffsets[8];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			_hkQuaternion m_rotation;
			_hkBool m_computeOnActivate;
		};
		const hkbTransformVectorModifier_DefaultStruct hkbTransformVectorModifier_Default =
		{
			{HK_OFFSET_OF(hkbTransformVectorModifier_DefaultStruct,m_rotation),-1,-1,-1,-1,-1,HK_OFFSET_OF(hkbTransformVectorModifier_DefaultStruct,m_computeOnActivate),-1},
			{0,0,0,1},true
		};
	}
	hkClass hkbTransformVectorModifierClass(
		"hkbTransformVectorModifier",
		&hkbModifierClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbTransformVectorModifierClass_Members),
		HK_COUNT_OF(hkbTransformVectorModifierClass_Members),
		&hkbTransformVectorModifier_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hkbStateChooserClass(
		"hkbStateChooser",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbComputeWorldFromModelModifierClass_Members[] =
	{
		{ "poseMatchingRootBoneIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "poseMatchingOtherBoneIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "poseMatchingAnotherBoneIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkbComputeWorldFromModelModifier_DefaultStruct
		{
			int s_defaultOffsets[3];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkInt16 m_poseMatchingRootBoneIndex;
			hkInt16 m_poseMatchingOtherBoneIndex;
			hkInt16 m_poseMatchingAnotherBoneIndex;
		};
		const hkbComputeWorldFromModelModifier_DefaultStruct hkbComputeWorldFromModelModifier_Default =
		{
			{HK_OFFSET_OF(hkbComputeWorldFromModelModifier_DefaultStruct,m_poseMatchingRootBoneIndex),HK_OFFSET_OF(hkbComputeWorldFromModelModifier_DefaultStruct,m_poseMatchingOtherBoneIndex),HK_OFFSET_OF(hkbComputeWorldFromModelModifier_DefaultStruct,m_poseMatchingAnotherBoneIndex)},
			-1,-1,-1
		};
	}
	hkClass hkbComputeWorldFromModelModifierClass(
		"hkbComputeWorldFromModelModifier",
		&hkbModifierClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbComputeWorldFromModelModifierClass_Members),
		HK_COUNT_OF(hkbComputeWorldFromModelModifierClass_Members),
		&hkbComputeWorldFromModelModifier_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbCameraShakeEventPayloadClass_Members[] =
	{
		{ "amplitude", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "halfLife", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkbCameraShakeEventPayload_DefaultStruct
		{
			int s_defaultOffsets[2];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkReal m_amplitude;
			hkReal m_halfLife;
		};
		const hkbCameraShakeEventPayload_DefaultStruct hkbCameraShakeEventPayload_Default =
		{
			{HK_OFFSET_OF(hkbCameraShakeEventPayload_DefaultStruct,m_amplitude),HK_OFFSET_OF(hkbCameraShakeEventPayload_DefaultStruct,m_halfLife)},
			1.0f,1.0f
		};
	}
	hkClass hkbCameraShakeEventPayloadClass(
		"hkbCameraShakeEventPayload",
		&hkbEventPayloadClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbCameraShakeEventPayloadClass_Members),
		HK_COUNT_OF(hkbCameraShakeEventPayloadClass_Members),
		&hkbCameraShakeEventPayload_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbControlledReachModifierClass_Members[] =
	{
		{ "target", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "time", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "fadeInStart", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "fadeInEnd", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "fadeOutStart", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "fadeOutEnd", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "fadeOutDuration", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "sensorAngle", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "handIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 2, 0, 0, HK_NULL },
		{ "isHandEnabled", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 2, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkbControlledReachModifier_DefaultStruct
		{
			int s_defaultOffsets[10];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
		};
		const hkbControlledReachModifier_DefaultStruct hkbControlledReachModifier_Default =
		{
			{hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,-1,-1,-1,-1,-1,-1,-1,-1},
		};
	}
	hkClass hkbControlledReachModifierClass(
		"hkbControlledReachModifier",
		&hkbModifierClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbControlledReachModifierClass_Members),
		HK_COUNT_OF(hkbControlledReachModifierClass_Members),
		&hkbControlledReachModifier_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbStateDependentModifierClass_Members[] =
	{
		{ "applyModifierDuringTransition", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "stateIds", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_INT32, 0, 0, 0, HK_NULL },
		{ "modifier", &hkbModifierClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "isActive", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "stateMachine", &hkbStateMachineClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkbStateDependentModifierClass(
		"hkbStateDependentModifier",
		&hkbModifierClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbStateDependentModifierClass_Members),
		HK_COUNT_OF(hkbStateDependentModifierClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbHoldFromBlendingTransitionEffectClass_Members[] =
	{
		{ "heldFromPose", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "heldFromPoseSize", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "heldWorldFromModel", HK_NULL, HK_NULL, hkClassMember::TYPE_QSTRANSFORM, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "heldFromSkeleton", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	namespace
	{
		struct hkbHoldFromBlendingTransitionEffect_DefaultStruct
		{
			int s_defaultOffsets[4];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
		};
		const hkbHoldFromBlendingTransitionEffect_DefaultStruct hkbHoldFromBlendingTransitionEffect_Default =
		{
			{hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,-1,hkClassMember::HK_CLASS_ZERO_DEFAULT},
		};
	}
	hkClass hkbHoldFromBlendingTransitionEffectClass(
		"hkbHoldFromBlendingTransitionEffect",
		&hkbBlendingTransitionEffectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbHoldFromBlendingTransitionEffectClass_Members),
		HK_COUNT_OF(hkbHoldFromBlendingTransitionEffectClass_Members),
		&hkbHoldFromBlendingTransitionEffect_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbBalanceRadialSelectorGeneratorClass_Members[] =
	{
		{ "xAxisMS", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "yAxisMS", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "checkBalanceModifier", &hkbCheckBalanceModifierClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkbBalanceRadialSelectorGenerator_DefaultStruct
		{
			int s_defaultOffsets[3];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkInt32 m_yAxisMS;
		};
		const hkbBalanceRadialSelectorGenerator_DefaultStruct hkbBalanceRadialSelectorGenerator_Default =
		{
			{hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkbBalanceRadialSelectorGenerator_DefaultStruct,m_yAxisMS),-1},
			1
		};
	}
	hkClass hkbBalanceRadialSelectorGeneratorClass(
		"hkbBalanceRadialSelectorGenerator",
		&hkbRadialSelectorGeneratorClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbBalanceRadialSelectorGeneratorClass_Members),
		HK_COUNT_OF(hkbBalanceRadialSelectorGeneratorClass_Members),
		&hkbBalanceRadialSelectorGenerator_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkbConstrainRigidBodyModifierPivotPlacementEnumItems[] =
	{
		{0, "PIVOT_MIDWAY_BETWEEN_CENTROIDS"},
		{1, "PIVOT_AT_TARGET_CONTACT_POINT"},
		{2, "PIVOT_MIDWAY_BETWEEN_TARGET_SHAPE_CENTROID_AND_BODY_TO_CONSTRAIN_CENTROID"},
	};
	static const hkInternalClassEnumItem hkbConstrainRigidBodyModifierBoneToConstrainPlacementEnumItems[] =
	{
		{0, "BTCP_AT_CURRENT_POSITION"},
		{1, "BTCP_ALIGN_COM_AND_PIVOT"},
	};
	static const hkInternalClassEnum hkbConstrainRigidBodyModifierEnums[] = {
		{"PivotPlacement", hkbConstrainRigidBodyModifierPivotPlacementEnumItems, 3, HK_NULL, 0 },
		{"BoneToConstrainPlacement", hkbConstrainRigidBodyModifierBoneToConstrainPlacementEnumItems, 2, HK_NULL, 0 }
	};
	const hkClassEnum* hkbConstrainRigidBodyModifierPivotPlacementEnum = reinterpret_cast<const hkClassEnum*>(&hkbConstrainRigidBodyModifierEnums[0]);
	const hkClassEnum* hkbConstrainRigidBodyModifierBoneToConstrainPlacementEnum = reinterpret_cast<const hkClassEnum*>(&hkbConstrainRigidBodyModifierEnums[1]);
	static hkInternalClassMember hkbConstrainRigidBodyModifierClass_Members[] =
	{
		{ "targetIn", &hkbTargetClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "breakThreshold", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "ragdollBoneToConstrain", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "breakable", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "pivotPlacement", HK_NULL, hkbConstrainRigidBodyModifierPivotPlacementEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL },
		{ "boneToConstrainPlacement", HK_NULL, hkbConstrainRigidBodyModifierBoneToConstrainPlacementEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL },
		{ "constraintType", HK_NULL, hkpConstraintDataConstraintTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL },
		{ "clearTargetData", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "isConstraintHinge", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "constraint", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	namespace
	{
		struct hkbConstrainRigidBodyModifier_DefaultStruct
		{
			int s_defaultOffsets[10];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkReal m_breakThreshold;
			hkInt16 m_ragdollBoneToConstrain;
			_hkBool m_isConstraintHinge;
		};
		const hkbConstrainRigidBodyModifier_DefaultStruct hkbConstrainRigidBodyModifier_Default =
		{
			{-1,HK_OFFSET_OF(hkbConstrainRigidBodyModifier_DefaultStruct,m_breakThreshold),HK_OFFSET_OF(hkbConstrainRigidBodyModifier_DefaultStruct,m_ragdollBoneToConstrain),hkClassMember::HK_CLASS_ZERO_DEFAULT,-1,-1,-1,hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkbConstrainRigidBodyModifier_DefaultStruct,m_isConstraintHinge),-1},
			1.0f,-1,true
		};
	}
	hkClass hkbConstrainRigidBodyModifierClass(
		"hkbConstrainRigidBodyModifier",
		&hkbModifierClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkbConstrainRigidBodyModifierEnums),
		2,
		reinterpret_cast<const hkClassMember*>(hkbConstrainRigidBodyModifierClass_Members),
		HK_COUNT_OF(hkbConstrainRigidBodyModifierClass_Members),
		&hkbConstrainRigidBodyModifier_Default,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkbBalanceModifier_StepInfoClass_Members[] =
	{
		{ "boneIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "fractionOfSolution", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkbBalanceModifierStepInfoClass(
		"hkbBalanceModifierStepInfo",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbBalanceModifier_StepInfoClass_Members),
		HK_COUNT_OF(hkbBalanceModifier_StepInfoClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbBalanceModifierClass_Members[] =
	{
		{ "giveUp", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "comDistThreshold", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "passThrough", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "ragdollLeftFootBoneIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "ragdollRightFootBoneIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "balanceOnAnklesFraction", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "upAxis", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "fadeInTime", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "comBiasX", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "stepInfo", &hkbBalanceModifierStepInfoClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "timeLapsed", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hkbBalanceModifierClass(
		"hkbBalanceModifier",
		&hkbModifierClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbBalanceModifierClass_Members),
		HK_COUNT_OF(hkbBalanceModifierClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkbReachTowardTargetModifierFadeStateEnumItems[] =
	{
		{0, "FADE_IN"},
		{1, "FADE_OUT"},
	};
	static const hkInternalClassEnum hkbReachTowardTargetModifierEnums[] = {
		{"FadeState", hkbReachTowardTargetModifierFadeStateEnumItems, 2, HK_NULL, 0 }
	};
	const hkClassEnum* hkbReachTowardTargetModifierFadeStateEnum = reinterpret_cast<const hkClassEnum*>(&hkbReachTowardTargetModifierEnums[0]);
	static hkInternalClassMember hkbReachTowardTargetModifier_HandClass_Members[] =
	{
		{ "shoulderIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "isEnabled", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkbReachTowardTargetModifierHand_DefaultStruct
		{
			int s_defaultOffsets[2];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkInt16 m_shoulderIndex;
			_hkBool m_isEnabled;
		};
		const hkbReachTowardTargetModifierHand_DefaultStruct hkbReachTowardTargetModifierHand_Default =
		{
			{HK_OFFSET_OF(hkbReachTowardTargetModifierHand_DefaultStruct,m_shoulderIndex),HK_OFFSET_OF(hkbReachTowardTargetModifierHand_DefaultStruct,m_isEnabled)},
			-1,true
		};
	}
	hkClass hkbReachTowardTargetModifierHandClass(
		"hkbReachTowardTargetModifierHand",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbReachTowardTargetModifier_HandClass_Members),
		HK_COUNT_OF(hkbReachTowardTargetModifier_HandClass_Members),
		&hkbReachTowardTargetModifierHand_Default,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkbReachTowardTargetModifierClass_Members[] =
	{
		{ "leftHand", &hkbReachTowardTargetModifierHandClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "rightHand", &hkbReachTowardTargetModifierHandClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "targetIn", &hkbTargetClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "distanceBetweenHands", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "reachDistance", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "fadeInGainSpeed", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "fadeOutGainSpeed", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "fadeOutDuration", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "targetChangeSpeed", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "holdTarget", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "reachPastTarget", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "giveUpIfNoTarget", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "targetRB", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "prevTargetInMS", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "currentGain", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "timeSinceLastModify", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "fadeState", HK_NULL, HK_NULL, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "haveGivenUp", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "isTherePrevTarget", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	namespace
	{
		struct hkbReachTowardTargetModifier_DefaultStruct
		{
			int s_defaultOffsets[19];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkReal m_distanceBetweenHands;
			hkReal m_reachDistance;
			hkReal m_fadeInGainSpeed;
			hkReal m_fadeOutGainSpeed;
			hkReal m_targetChangeSpeed;
			_hkBool m_reachPastTarget;
		};
		const hkbReachTowardTargetModifier_DefaultStruct hkbReachTowardTargetModifier_Default =
		{
			{-1,-1,-1,HK_OFFSET_OF(hkbReachTowardTargetModifier_DefaultStruct,m_distanceBetweenHands),HK_OFFSET_OF(hkbReachTowardTargetModifier_DefaultStruct,m_reachDistance),HK_OFFSET_OF(hkbReachTowardTargetModifier_DefaultStruct,m_fadeInGainSpeed),HK_OFFSET_OF(hkbReachTowardTargetModifier_DefaultStruct,m_fadeOutGainSpeed),hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkbReachTowardTargetModifier_DefaultStruct,m_targetChangeSpeed),hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkbReachTowardTargetModifier_DefaultStruct,m_reachPastTarget),hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,-1,-1,-1,-1,hkClassMember::HK_CLASS_ZERO_DEFAULT,-1},
			0.3f,0.5f,1.0f,1.0f,1.0f,true
		};
	}
	hkClass hkbReachTowardTargetModifierClass(
		"hkbReachTowardTargetModifier",
		&hkbModifierClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkbReachTowardTargetModifierEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkbReachTowardTargetModifierClass_Members),
		HK_COUNT_OF(hkbReachTowardTargetModifierClass_Members),
		&hkbReachTowardTargetModifier_Default,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkbPoseStoringGeneratorOutputListener_StoredPoseClass_Members[] =
	{
		{ "node", &hkbNodeClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "pose", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_QSTRANSFORM, 0, 0, 0, HK_NULL },
		{ "worldFromModel", HK_NULL, HK_NULL, hkClassMember::TYPE_QSTRANSFORM, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "isPoseValid", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkbPoseStoringGeneratorOutputListenerStoredPoseClass(
		"hkbPoseStoringGeneratorOutputListenerStoredPose",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbPoseStoringGeneratorOutputListener_StoredPoseClass_Members),
		HK_COUNT_OF(hkbPoseStoringGeneratorOutputListener_StoredPoseClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbPoseStoringGeneratorOutputListenerClass_Members[] =
	{
		{ "storedPoses", &hkbPoseStoringGeneratorOutputListenerStoredPoseClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "dirty", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "nodeToIndexMap", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hkbPoseStoringGeneratorOutputListenerClass(
		"hkbPoseStoringGeneratorOutputListener",
		&hkbGeneratorOutputListenerClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbPoseStoringGeneratorOutputListenerClass_Members),
		HK_COUNT_OF(hkbPoseStoringGeneratorOutputListenerClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkbCustomTestGeneratorModesEnumItems[] =
	{
		{0, "MODE_ALA"},
		{1, "MODE_DEPECHE"},
		{5, "MODE_FURIOUS"},
	};
	static const hkInternalClassEnumItem hkbCustomTestGeneratorStrangeFlagsEnumItems[] =
	{
		{1, "FLAG_UNO"},
		{2, "FLAG_ZWEI"},
		{4, "FLAG_SHI_OR_YON"},
		{240, "FLAG_LOTS_O_BITS"},
	};
	static const hkInternalClassEnum hkbCustomTestGeneratorEnums[] = {
		{"Modes", hkbCustomTestGeneratorModesEnumItems, 3, HK_NULL, 0 },
		{"StrangeFlags", hkbCustomTestGeneratorStrangeFlagsEnumItems, 4, HK_NULL, 0 }
	};
	const hkClassEnum* hkbCustomTestGeneratorModesEnum = reinterpret_cast<const hkClassEnum*>(&hkbCustomTestGeneratorEnums[0]);
	const hkClassEnum* hkbCustomTestGeneratorStrangeFlagsEnum = reinterpret_cast<const hkClassEnum*>(&hkbCustomTestGeneratorEnums[1]);
	static hkInternalClassMember hkbCustomTestGenerator_StruckClass_Members[] =
	{
		{ "hkBool", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "string", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "int", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "hkInt8", HK_NULL, HK_NULL, hkClassMember::TYPE_INT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "hkInt16", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "hkInt32", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "hkUint8", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "hkUint16", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "hkUint32", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "hkReal", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "mode_hkInt8", HK_NULL, hkbCustomTestGeneratorModesEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL },
		{ "mode_hkInt16", HK_NULL, hkbCustomTestGeneratorModesEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT16, 0, 0, 0, HK_NULL },
		{ "mode_hkInt32", HK_NULL, hkbCustomTestGeneratorModesEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT32, 0, 0, 0, HK_NULL },
		{ "mode_hkUint8", HK_NULL, hkbCustomTestGeneratorModesEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "mode_hkUint16", HK_NULL, hkbCustomTestGeneratorModesEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT16, 0, 0, 0, HK_NULL },
		{ "mode_hkUint32", HK_NULL, hkbCustomTestGeneratorModesEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT32, 0, 0, 0, HK_NULL },
		{ "flags_hkInt8", HK_NULL, hkbCustomTestGeneratorStrangeFlagsEnum, hkClassMember::TYPE_FLAGS, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL },
		{ "flags_hkInt16", HK_NULL, hkbCustomTestGeneratorStrangeFlagsEnum, hkClassMember::TYPE_FLAGS, hkClassMember::TYPE_INT16, 0, 0, 0, HK_NULL },
		{ "flags_hkInt32", HK_NULL, hkbCustomTestGeneratorStrangeFlagsEnum, hkClassMember::TYPE_FLAGS, hkClassMember::TYPE_INT32, 0, 0, 0, HK_NULL },
		{ "flags_hkUint8", HK_NULL, hkbCustomTestGeneratorStrangeFlagsEnum, hkClassMember::TYPE_FLAGS, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "flags_hkUint16", HK_NULL, hkbCustomTestGeneratorStrangeFlagsEnum, hkClassMember::TYPE_FLAGS, hkClassMember::TYPE_UINT16, 0, 0, 0, HK_NULL },
		{ "flags_hkUint32", HK_NULL, hkbCustomTestGeneratorStrangeFlagsEnum, hkClassMember::TYPE_FLAGS, hkClassMember::TYPE_UINT32, 0, 0, 0, HK_NULL },
		{ "generator1", &hkbGeneratorClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "generator2", &hkbGeneratorClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "modifier1", &hkbModifierClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "modifier2", &hkbModifierClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkbCustomTestGeneratorStruckClass(
		"hkbCustomTestGeneratorStruck",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbCustomTestGenerator_StruckClass_Members),
		HK_COUNT_OF(hkbCustomTestGenerator_StruckClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbCustomTestGeneratorClass_Members[] =
	{
		{ "hkBool", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "string", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "int", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "hkInt8", HK_NULL, HK_NULL, hkClassMember::TYPE_INT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "hkInt16", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "hkInt32", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "hkUint8", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "hkUint16", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "hkUint32", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "hkReal", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "hkVector4", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "hkQuaternion", HK_NULL, HK_NULL, hkClassMember::TYPE_QUATERNION, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "hkRigidBody", &hkpRigidBodyClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "mode_hkInt8", HK_NULL, hkbCustomTestGeneratorModesEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL },
		{ "mode_hkInt16", HK_NULL, hkbCustomTestGeneratorModesEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT16, 0, 0, 0, HK_NULL },
		{ "mode_hkInt32", HK_NULL, hkbCustomTestGeneratorModesEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT32, 0, 0, 0, HK_NULL },
		{ "mode_hkUint8", HK_NULL, hkbCustomTestGeneratorModesEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "mode_hkUint16", HK_NULL, hkbCustomTestGeneratorModesEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT16, 0, 0, 0, HK_NULL },
		{ "mode_hkUint32", HK_NULL, hkbCustomTestGeneratorModesEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT32, 0, 0, 0, HK_NULL },
		{ "flags_hkInt8", HK_NULL, hkbCustomTestGeneratorStrangeFlagsEnum, hkClassMember::TYPE_FLAGS, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL },
		{ "flags_hkInt16", HK_NULL, hkbCustomTestGeneratorStrangeFlagsEnum, hkClassMember::TYPE_FLAGS, hkClassMember::TYPE_INT16, 0, 0, 0, HK_NULL },
		{ "flags_hkInt32", HK_NULL, hkbCustomTestGeneratorStrangeFlagsEnum, hkClassMember::TYPE_FLAGS, hkClassMember::TYPE_INT32, 0, 0, 0, HK_NULL },
		{ "flags_hkUint8", HK_NULL, hkbCustomTestGeneratorStrangeFlagsEnum, hkClassMember::TYPE_FLAGS, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "flags_hkUint16", HK_NULL, hkbCustomTestGeneratorStrangeFlagsEnum, hkClassMember::TYPE_FLAGS, hkClassMember::TYPE_UINT16, 0, 0, 0, HK_NULL },
		{ "flags_hkUint32", HK_NULL, hkbCustomTestGeneratorStrangeFlagsEnum, hkClassMember::TYPE_FLAGS, hkClassMember::TYPE_UINT32, 0, 0, 0, HK_NULL },
		{ "myInt", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "generator1", &hkbGeneratorClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "generator2", &hkbGeneratorClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "modifier1", &hkbModifierClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "modifier2", &hkbModifierClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "array_hkBool", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_BOOL, 0, 0, 0, HK_NULL },
		{ "array_int", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_INT32, 0, 0, 0, HK_NULL },
		{ "array_hkInt8", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL },
		{ "array_hkInt16", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_INT16, 0, 0, 0, HK_NULL },
		{ "array_hkInt32", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_INT32, 0, 0, 0, HK_NULL },
		{ "array_hkUint8", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL },
		{ "array_hkUint16", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_INT16, 0, 0, 0, HK_NULL },
		{ "array_hkUint32", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_INT32, 0, 0, 0, HK_NULL },
		{ "array_hkReal", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_REAL, 0, 0, 0, HK_NULL },
		{ "array_hkbGenerator", &hkbGeneratorClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "array_hkbModifier", &hkbModifierClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "Struck", &hkbCustomTestGeneratorStruckClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "array_Struck", &hkbCustomTestGeneratorStruckClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkbCustomTestGenerator_DefaultStruct
		{
			int s_defaultOffsets[43];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
		};
		const hkbCustomTestGenerator_DefaultStruct hkbCustomTestGenerator_Default =
		{
			{-1,hkClassMember::HK_CLASS_ZERO_DEFAULT,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,hkClassMember::HK_CLASS_ZERO_DEFAULT,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
		};
	}
	hkClass hkbCustomTestGeneratorClass(
		"hkbCustomTestGenerator",
		&hkbReferencePoseGeneratorClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkbCustomTestGeneratorEnums),
		2,
		reinterpret_cast<const hkClassMember*>(hkbCustomTestGeneratorClass_Members),
		HK_COUNT_OF(hkbCustomTestGeneratorClass_Members),
		&hkbCustomTestGenerator_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbTestStateChooserClass_Members[] =
	{
		{ "int", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "real", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "string", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkbTestStateChooserClass(
		"hkbTestStateChooser",
		&hkbStateChooserClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbTestStateChooserClass_Members),
		HK_COUNT_OF(hkbTestStateChooserClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkVariableTweakingHelper_BoolVariableInfoClass_Members[] =
	{
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "value", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "tweakOn", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkVariableTweakingHelperBoolVariableInfoClass(
		"hkVariableTweakingHelperBoolVariableInfo",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkVariableTweakingHelper_BoolVariableInfoClass_Members),
		HK_COUNT_OF(hkVariableTweakingHelper_BoolVariableInfoClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkVariableTweakingHelper_IntVariableInfoClass_Members[] =
	{
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "value", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "tweakOn", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkVariableTweakingHelperIntVariableInfoClass(
		"hkVariableTweakingHelperIntVariableInfo",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkVariableTweakingHelper_IntVariableInfoClass_Members),
		HK_COUNT_OF(hkVariableTweakingHelper_IntVariableInfoClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkVariableTweakingHelper_RealVariableInfoClass_Members[] =
	{
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "value", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "tweakOn", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkVariableTweakingHelperRealVariableInfoClass(
		"hkVariableTweakingHelperRealVariableInfo",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkVariableTweakingHelper_RealVariableInfoClass_Members),
		HK_COUNT_OF(hkVariableTweakingHelper_RealVariableInfoClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkVariableTweakingHelper_Vector4VariableInfoClass_Members[] =
	{
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "x", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "y", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "z", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "w", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "tweakOn", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkVariableTweakingHelperVector4VariableInfoClass(
		"hkVariableTweakingHelperVector4VariableInfo",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkVariableTweakingHelper_Vector4VariableInfoClass_Members),
		HK_COUNT_OF(hkVariableTweakingHelper_Vector4VariableInfoClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkVariableTweakingHelperClass_Members[] =
	{
		{ "boolVariableInfo", &hkVariableTweakingHelperBoolVariableInfoClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "intVariableInfo", &hkVariableTweakingHelperIntVariableInfoClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "realVariableInfo", &hkVariableTweakingHelperRealVariableInfoClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "vector4VariableInfo", &hkVariableTweakingHelperVector4VariableInfoClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "behavior", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "boolIndices", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "intIndices", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "realIndices", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "vector4Indices", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hkVariableTweakingHelperClass(
		"hkVariableTweakingHelper",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkVariableTweakingHelperClass_Members),
		HK_COUNT_OF(hkVariableTweakingHelperClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbRadialSelectorGenerator_GeneratorInfoClass_Members[] =
	{
		{ "generator", &hkbGeneratorClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "angle", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "radialSpeed", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkbRadialSelectorGeneratorGeneratorInfo_DefaultStruct
		{
			int s_defaultOffsets[3];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
		};
		const hkbRadialSelectorGeneratorGeneratorInfo_DefaultStruct hkbRadialSelectorGeneratorGeneratorInfo_Default =
		{
			{hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT},
		};
	}
	hkClass hkbRadialSelectorGeneratorGeneratorInfoClass(
		"hkbRadialSelectorGeneratorGeneratorInfo",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbRadialSelectorGenerator_GeneratorInfoClass_Members),
		HK_COUNT_OF(hkbRadialSelectorGenerator_GeneratorInfoClass_Members),
		&hkbRadialSelectorGeneratorGeneratorInfo_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbRadialSelectorGenerator_GeneratorPairClass_Members[] =
	{
		{ "generators", &hkbRadialSelectorGeneratorGeneratorInfoClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 2, 0, 0, HK_NULL },
		{ "minAngle", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxAngle", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkbRadialSelectorGeneratorGeneratorPair_DefaultStruct
		{
			int s_defaultOffsets[3];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
		};
		const hkbRadialSelectorGeneratorGeneratorPair_DefaultStruct hkbRadialSelectorGeneratorGeneratorPair_Default =
		{
			{-1,hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT},
		};
	}
	hkClass hkbRadialSelectorGeneratorGeneratorPairClass(
		"hkbRadialSelectorGeneratorGeneratorPair",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbRadialSelectorGenerator_GeneratorPairClass_Members),
		HK_COUNT_OF(hkbRadialSelectorGenerator_GeneratorPairClass_Members),
		&hkbRadialSelectorGeneratorGeneratorPair_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbRadialSelectorGeneratorClass_Members[] =
	{
		{ "generatorPairs", &hkbRadialSelectorGeneratorGeneratorPairClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "angle", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "radius", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "currentGeneratorPairIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "currentEndpointIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "currentFraction", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "hasSetLocalTime", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	namespace
	{
		struct hkbRadialSelectorGenerator_DefaultStruct
		{
			int s_defaultOffsets[7];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkInt32 m_currentGeneratorPairIndex;
			hkInt32 m_currentEndpointIndex;
		};
		const hkbRadialSelectorGenerator_DefaultStruct hkbRadialSelectorGenerator_Default =
		{
			{-1,hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkbRadialSelectorGenerator_DefaultStruct,m_currentGeneratorPairIndex),HK_OFFSET_OF(hkbRadialSelectorGenerator_DefaultStruct,m_currentEndpointIndex),-1,-1},
			-1,-1
		};
	}
	hkClass hkbRadialSelectorGeneratorClass(
		"hkbRadialSelectorGenerator",
		&hkbGeneratorClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbRadialSelectorGeneratorClass_Members),
		HK_COUNT_OF(hkbRadialSelectorGeneratorClass_Members),
		&hkbRadialSelectorGenerator_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkbAlignBoneModifierAlignModeABAMEnumItems[] =
	{
		{0, "ALIGN_MODE_CHARACTER_WORLD_FROM_MODEL"},
		{1, "ALIGN_MODE_ANIMATION_SKELETON_BONE"},
	};
	static const hkInternalClassEnumItem hkbAlignBoneModifierAlignTargetModeEnumItems[] =
	{
		{0, "ALIGN_TARGET_MODE_CHARACTER_WORLD_FROM_MODEL"},
		{1, "ALIGN_TARGET_MODE_RAGDOLL_SKELETON_BONE"},
		{2, "ALIGN_TARGET_MODE_ANIMATION_SKELETON_BONE"},
		{3, "ALIGN_TARGET_MODE_USER_SPECIFIED_FRAME_OF_REFERENCE"},
	};
	static const hkInternalClassEnum hkbAlignBoneModifierEnums[] = {
		{"AlignModeABAM", hkbAlignBoneModifierAlignModeABAMEnumItems, 2, HK_NULL, 0 },
		{"AlignTargetMode", hkbAlignBoneModifierAlignTargetModeEnumItems, 4, HK_NULL, 0 }
	};
	const hkClassEnum* hkbAlignBoneModifierAlignModeABAMEnum = reinterpret_cast<const hkClassEnum*>(&hkbAlignBoneModifierEnums[0]);
	const hkClassEnum* hkbAlignBoneModifierAlignTargetModeEnum = reinterpret_cast<const hkClassEnum*>(&hkbAlignBoneModifierEnums[1]);
	static hkInternalClassMember hkbAlignBoneModifierClass_Members[] =
	{
		{ "alignMode", HK_NULL, hkbAlignBoneModifierAlignModeABAMEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL },
		{ "alignTargetMode", HK_NULL, hkbAlignBoneModifierAlignTargetModeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL },
		{ "alignSingleAxis", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "alignAxis", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "alignTargetAxis", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "frameOfReference", HK_NULL, HK_NULL, hkClassMember::TYPE_QUATERNION, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "duration", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "alignModeIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "alignTargetModeIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "time", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "timeSinceLastModify", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hkbAlignBoneModifierClass(
		"hkbAlignBoneModifier",
		&hkbModifierClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkbAlignBoneModifierEnums),
		2,
		reinterpret_cast<const hkClassMember*>(hkbAlignBoneModifierClass_Members),
		HK_COUNT_OF(hkbAlignBoneModifierClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbClientCharacterStateClass_Members[] =
	{
		{ "deformableSkinIds", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT64, 0, 0, 0, HK_NULL },
		{ "rigidSkinIds", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT64, 0, 0, 0, HK_NULL },
		{ "externalEventIds", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_INT16, 0, 0, 0, HK_NULL },
		{ "auxiliaryInfo", &hkbAuxiliaryNodeInfoClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "activeEventIds", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_INT16, 0, 0, 0, HK_NULL },
		{ "activeVariableIds", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_INT16, 0, 0, 0, HK_NULL },
		{ "characterId", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT64, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "instanceName", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "templateName", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "fullPathToProject", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "localScriptsPath", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "remoteScriptsPath", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "behaviorData", &hkbBehaviorGraphDataClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "behaviorInternalState", &hkbBehaviorGraphInternalStateClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "nodeIdToInternalStateMap", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "visible", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "elapsedSimulationTime", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "skeleton", &hkaSkeletonClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "worldFromModel", HK_NULL, HK_NULL, hkClassMember::TYPE_QSTRANSFORM, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "poseModelSpace", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_QSTRANSFORM, 0, 0, 0, HK_NULL },
		{ "rigidAttachmentTransforms", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_QSTRANSFORM, 0, 0, 0, HK_NULL }
	};
	hkClass hkbClientCharacterStateClass(
		"hkbClientCharacterState",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbClientCharacterStateClass_Members),
		HK_COUNT_OF(hkbClientCharacterStateClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(2)
		);
	static const hkInternalClassEnumItem hkbTargetRigidBodyModifierEventModeTRBAMEnumItems[] =
	{
		{0, "EVENT_MODE_DO_NOT_SEND"},
		{1, "EVENT_MODE_SEND_ONCE"},
		{2, "EVENT_MODE_RESEND"},
	};
	static const hkInternalClassEnumItem hkbTargetRigidBodyModifierTargetModeEnumItems[] =
	{
		{0, "TARGET_MODE_CONE_AROUND_CHARACTER_FORWARD"},
		{1, "TARGET_MODE_CONE_AROUND_LOCAL_AXIS"},
		{2, "TARGET_MODE_RAYCAST_ALONG_CHARACTER_FORWARD"},
		{3, "TARGET_MODE_RAYCAST_ALONG_LOCAL_AXIS"},
		{4, "TARGET_MODE_ANY_DIRECTION"},
	};
	static const hkInternalClassEnumItem hkbTargetRigidBodyModifierComputeTargetAngleModeEnumItems[] =
	{
		{0, "COMPUTE_ANGLE_USING_TARGET_COM"},
		{1, "COMPUTE_ANGLE_USING_TARGET_CONTACT_POINT"},
	};
	static const hkInternalClassEnumItem hkbTargetRigidBodyModifierComputeTargetDistanceModeEnumItems[] =
	{
		{0, "COMPUTE_DISTANCE_USING_TARGET_POSITION"},
		{1, "COMPUTE_DISTANCE_USING_TARGET_CONTACT_POINT"},
	};
	static const hkInternalClassEnum hkbTargetRigidBodyModifierEnums[] = {
		{"EventModeTRBAM", hkbTargetRigidBodyModifierEventModeTRBAMEnumItems, 3, HK_NULL, 0 },
		{"TargetMode", hkbTargetRigidBodyModifierTargetModeEnumItems, 5, HK_NULL, 0 },
		{"ComputeTargetAngleMode", hkbTargetRigidBodyModifierComputeTargetAngleModeEnumItems, 2, HK_NULL, 0 },
		{"ComputeTargetDistanceMode", hkbTargetRigidBodyModifierComputeTargetDistanceModeEnumItems, 2, HK_NULL, 0 }
	};
	const hkClassEnum* hkbTargetRigidBodyModifierEventModeTRBAMEnum = reinterpret_cast<const hkClassEnum*>(&hkbTargetRigidBodyModifierEnums[0]);
	const hkClassEnum* hkbTargetRigidBodyModifierTargetModeEnum = reinterpret_cast<const hkClassEnum*>(&hkbTargetRigidBodyModifierEnums[1]);
	const hkClassEnum* hkbTargetRigidBodyModifierComputeTargetAngleModeEnum = reinterpret_cast<const hkClassEnum*>(&hkbTargetRigidBodyModifierEnums[2]);
	const hkClassEnum* hkbTargetRigidBodyModifierComputeTargetDistanceModeEnum = reinterpret_cast<const hkClassEnum*>(&hkbTargetRigidBodyModifierEnums[3]);
	static hkInternalClassMember hkbTargetRigidBodyModifierClass_Members[] =
	{
		{ "targetOut", &hkbTargetClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "targetMode", HK_NULL, hkbTargetRigidBodyModifierTargetModeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL },
		{ "sensingLayer", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "targetOnlyOnce", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "ignoreMySystemGroup", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxTargetDistance", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxTargetHeightAboveSensor", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "closeToTargetDistanceThreshold", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "targetAngleMode", HK_NULL, hkbTargetRigidBodyModifierComputeTargetAngleModeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL },
		{ "targetDistanceMode", HK_NULL, hkbTargetRigidBodyModifierComputeTargetDistanceModeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL },
		{ "maxAngleToTarget", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "sensorRagdollBoneIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "sensorAnimationBoneIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "closeToTargetRagdollBoneIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "closeToTargetAnimationBoneIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "sensorOffsetInBoneSpace", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "closeToTargetOffsetInBoneSpace", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "sensorDirectionBS", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "eventMode", HK_NULL, hkbTargetRigidBodyModifierEventModeTRBAMEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL },
		{ "sensingPropertyKey", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "sensorInWS", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "eventToSend", &hkbEventPropertyClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "eventToSendToTarget", &hkbEventPropertyClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "closeToTargetEvent", &hkbEventPropertyClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "useVelocityPrediction", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "targetOnlySpheres", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "isCloseToTargetOut", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "targetPriority", HK_NULL, HK_NULL, hkClassMember::TYPE_INT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "targetRb", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "targetDistance", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "timeSinceLastModify", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "eventHasBeenSent", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "closeToTargetEventHasBeenSent", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "isActive", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	namespace
	{
		struct hkbTargetRigidBodyModifier_DefaultStruct
		{
			int s_defaultOffsets[34];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkInt32 m_sensingLayer;
			_hkBool m_targetOnlyOnce;
			_hkBool m_ignoreMySystemGroup;
			hkReal m_maxTargetDistance;
			hkReal m_maxTargetHeightAboveSensor;
			hkReal m_closeToTargetDistanceThreshold;
			hkReal m_maxAngleToTarget;
			hkInt16 m_sensorRagdollBoneIndex;
			hkInt16 m_sensorAnimationBoneIndex;
			hkInt16 m_closeToTargetRagdollBoneIndex;
			hkInt16 m_closeToTargetAnimationBoneIndex;
			_hkVector4 m_sensorOffsetInBoneSpace;
			_hkVector4 m_closeToTargetOffsetInBoneSpace;
			_hkVector4 m_sensorDirectionBS;
			hkReal m_targetDistance;
		};
		const hkbTargetRigidBodyModifier_DefaultStruct hkbTargetRigidBodyModifier_Default =
		{
			{-1,-1,HK_OFFSET_OF(hkbTargetRigidBodyModifier_DefaultStruct,m_sensingLayer),HK_OFFSET_OF(hkbTargetRigidBodyModifier_DefaultStruct,m_targetOnlyOnce),HK_OFFSET_OF(hkbTargetRigidBodyModifier_DefaultStruct,m_ignoreMySystemGroup),HK_OFFSET_OF(hkbTargetRigidBodyModifier_DefaultStruct,m_maxTargetDistance),HK_OFFSET_OF(hkbTargetRigidBodyModifier_DefaultStruct,m_maxTargetHeightAboveSensor),HK_OFFSET_OF(hkbTargetRigidBodyModifier_DefaultStruct,m_closeToTargetDistanceThreshold),-1,-1,HK_OFFSET_OF(hkbTargetRigidBodyModifier_DefaultStruct,m_maxAngleToTarget),HK_OFFSET_OF(hkbTargetRigidBodyModifier_DefaultStruct,m_sensorRagdollBoneIndex),HK_OFFSET_OF(hkbTargetRigidBodyModifier_DefaultStruct,m_sensorAnimationBoneIndex),HK_OFFSET_OF(hkbTargetRigidBodyModifier_DefaultStruct,m_closeToTargetRagdollBoneIndex),HK_OFFSET_OF(hkbTargetRigidBodyModifier_DefaultStruct,m_closeToTargetAnimationBoneIndex),HK_OFFSET_OF(hkbTargetRigidBodyModifier_DefaultStruct,m_sensorOffsetInBoneSpace),HK_OFFSET_OF(hkbTargetRigidBodyModifier_DefaultStruct,m_closeToTargetOffsetInBoneSpace),HK_OFFSET_OF(hkbTargetRigidBodyModifier_DefaultStruct,m_sensorDirectionBS),-1,hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,-1,-1,-1,hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkbTargetRigidBodyModifier_DefaultStruct,m_targetDistance),-1,-1,-1,-1},
	-1,true,true,1.0f,2.0f,0.1f,1.0f,-1,-1,-1,-1,	{0,1,0},	{0,1,0},	{0,1,0},HK_REAL_MAX
		};
	}
	hkClass hkbTargetRigidBodyModifierClass(
		"hkbTargetRigidBodyModifier",
		&hkbModifierClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkbTargetRigidBodyModifierEnums),
		4,
		reinterpret_cast<const hkClassMember*>(hkbTargetRigidBodyModifierClass_Members),
		HK_COUNT_OF(hkbTargetRigidBodyModifierClass_Members),
		&hkbTargetRigidBodyModifier_Default,
		HK_NULL,
		0,
		hkUint32(3)
		);
	static const hkInternalClassEnumItem hkbCatchFallModifierFadeStateEnumItems[] =
	{
		{0, "FADE_IN"},
		{1, "FADE_OUT"},
	};
	static const hkInternalClassEnum hkbCatchFallModifierEnums[] = {
		{"FadeState", hkbCatchFallModifierFadeStateEnumItems, 2, HK_NULL, 0 }
	};
	const hkClassEnum* hkbCatchFallModifierFadeStateEnum = reinterpret_cast<const hkClassEnum*>(&hkbCatchFallModifierEnums[0]);
	static hkInternalClassMember hkbCatchFallModifier_HandClass_Members[] =
	{
		{ "animShoulderIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "ragdollShoulderIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "ragdollAnkleIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkbCatchFallModifierHand_DefaultStruct
		{
			int s_defaultOffsets[3];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkInt16 m_animShoulderIndex;
			hkInt16 m_ragdollShoulderIndex;
			hkInt16 m_ragdollAnkleIndex;
		};
		const hkbCatchFallModifierHand_DefaultStruct hkbCatchFallModifierHand_Default =
		{
			{HK_OFFSET_OF(hkbCatchFallModifierHand_DefaultStruct,m_animShoulderIndex),HK_OFFSET_OF(hkbCatchFallModifierHand_DefaultStruct,m_ragdollShoulderIndex),HK_OFFSET_OF(hkbCatchFallModifierHand_DefaultStruct,m_ragdollAnkleIndex)},
			-1,-1,-1
		};
	}
	hkClass hkbCatchFallModifierHandClass(
		"hkbCatchFallModifierHand",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbCatchFallModifier_HandClass_Members),
		HK_COUNT_OF(hkbCatchFallModifier_HandClass_Members),
		&hkbCatchFallModifierHand_Default,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkbCatchFallModifierClass_Members[] =
	{
		{ "directionOfFallForwardLS", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "directionOfFallRightLS", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "directionOfFallUpLS", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "spineIndices", &hkbBoneIndexArrayClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "leftHand", &hkbCatchFallModifierHandClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "rightHand", &hkbCatchFallModifierHandClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "catchFallDoneEvent", &hkbEventPropertyClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "spreadHandsMultiplier", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "radarRange", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "previousTargetBlendWeight", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "handsBendDistance", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxReachDistanceForward", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxReachDistanceBackward", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "fadeInReachGainSpeed", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "fadeOutReachGainSpeed", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "fadeOutDuration", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "fadeInTwistSpeed", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "fadeOutTwistSpeed", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "raycastLayer", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "velocityRagdollBoneIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "directionOfFallRagdollBoneIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "orientHands", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "catchFallPosInBS", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 2, 0, 0, HK_NULL },
		{ "currentReachGain", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 2, 0, 0, HK_NULL },
		{ "timeSinceLastModify", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "currentTwistGain", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "currentTwistDirection", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "catchFallPosIsValid", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 2, 0, 0, HK_NULL },
		{ "catchFallBegin", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "catchFallEnd", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "fadeState", HK_NULL, HK_NULL, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	namespace
	{
		struct hkbCatchFallModifier_DefaultStruct
		{
			int s_defaultOffsets[31];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			_hkVector4 m_directionOfFallForwardLS;
			_hkVector4 m_directionOfFallRightLS;
			_hkVector4 m_directionOfFallUpLS;
			hkReal m_spreadHandsMultiplier;
			hkReal m_radarRange;
			hkReal m_previousTargetBlendWeight;
			hkReal m_handsBendDistance;
			hkReal m_maxReachDistanceForward;
			hkReal m_maxReachDistanceBackward;
			hkReal m_fadeInReachGainSpeed;
			hkReal m_fadeOutReachGainSpeed;
			hkReal m_fadeInTwistSpeed;
			hkReal m_fadeOutTwistSpeed;
			hkInt16 m_raycastLayer;
			hkInt16 m_velocityRagdollBoneIndex;
			hkInt16 m_directionOfFallRagdollBoneIndex;
			_hkBool m_orientHands;
		};
		const hkbCatchFallModifier_DefaultStruct hkbCatchFallModifier_Default =
		{
			{HK_OFFSET_OF(hkbCatchFallModifier_DefaultStruct,m_directionOfFallForwardLS),HK_OFFSET_OF(hkbCatchFallModifier_DefaultStruct,m_directionOfFallRightLS),HK_OFFSET_OF(hkbCatchFallModifier_DefaultStruct,m_directionOfFallUpLS),-1,-1,-1,-1,HK_OFFSET_OF(hkbCatchFallModifier_DefaultStruct,m_spreadHandsMultiplier),HK_OFFSET_OF(hkbCatchFallModifier_DefaultStruct,m_radarRange),HK_OFFSET_OF(hkbCatchFallModifier_DefaultStruct,m_previousTargetBlendWeight),HK_OFFSET_OF(hkbCatchFallModifier_DefaultStruct,m_handsBendDistance),HK_OFFSET_OF(hkbCatchFallModifier_DefaultStruct,m_maxReachDistanceForward),HK_OFFSET_OF(hkbCatchFallModifier_DefaultStruct,m_maxReachDistanceBackward),HK_OFFSET_OF(hkbCatchFallModifier_DefaultStruct,m_fadeInReachGainSpeed),HK_OFFSET_OF(hkbCatchFallModifier_DefaultStruct,m_fadeOutReachGainSpeed),hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkbCatchFallModifier_DefaultStruct,m_fadeInTwistSpeed),HK_OFFSET_OF(hkbCatchFallModifier_DefaultStruct,m_fadeOutTwistSpeed),HK_OFFSET_OF(hkbCatchFallModifier_DefaultStruct,m_raycastLayer),HK_OFFSET_OF(hkbCatchFallModifier_DefaultStruct,m_velocityRagdollBoneIndex),HK_OFFSET_OF(hkbCatchFallModifier_DefaultStruct,m_directionOfFallRagdollBoneIndex),HK_OFFSET_OF(hkbCatchFallModifier_DefaultStruct,m_orientHands),-1,-1,-1,-1,-1,-1,-1,-1,-1},
		{0,1,0},	{0,0,1},	{1,0,0},1,1.0f,0.75f,0.1f,0.6f,0.8f,1.0f,1.0f,1.0f,1.0f,-1,-1,-1,true
		};
	}
	hkClass hkbCatchFallModifierClass(
		"hkbCatchFallModifier",
		&hkbModifierClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkbCatchFallModifierEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkbCatchFallModifierClass_Members),
		HK_COUNT_OF(hkbCatchFallModifierClass_Members),
		&hkbCatchFallModifier_Default,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkbCheckBalanceModifierClass_Members[] =
	{
		{ "ragdollLeftFootBoneIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "ragdollRightFootBoneIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "balanceOnAnklesFraction", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "eventToSendWhenOffBalance", &hkbEventClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "offBalanceEventThreshold", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "worldUpAxisIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "comBiasX", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "extractRagdollPose", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "mass", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "comWS", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "desiredComWS", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "offBalanceDistance", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "errorMS", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hkbCheckBalanceModifierClass(
		"hkbCheckBalanceModifier",
		&hkbModifierClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbCheckBalanceModifierClass_Members),
		HK_COUNT_OF(hkbCheckBalanceModifierClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbAnimatedSkeletonGeneratorClass_Members[] =
	{
		{ "animatedSkeleton", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hkbAnimatedSkeletonGeneratorClass(
		"hkbAnimatedSkeletonGenerator",
		&hkbGeneratorClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbAnimatedSkeletonGeneratorClass_Members),
		HK_COUNT_OF(hkbAnimatedSkeletonGeneratorClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbGravityModifierClass_Members[] =
	{
		{ "initialVelocityInMS", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "gravityConstant", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "currentVelocityInMS", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "secondsElapsed", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	namespace
	{
		struct hkbGravityModifier_DefaultStruct
		{
			int s_defaultOffsets[4];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			_hkVector4 m_initialVelocityInMS;
			hkReal m_gravityConstant;
		};
		const hkbGravityModifier_DefaultStruct hkbGravityModifier_Default =
		{
			{HK_OFFSET_OF(hkbGravityModifier_DefaultStruct,m_initialVelocityInMS),HK_OFFSET_OF(hkbGravityModifier_DefaultStruct,m_gravityConstant),-1,-1},
			{0,0,0},9.8f
		};
	}
	hkClass hkbGravityModifierClass(
		"hkbGravityModifier",
		&hkbModifierClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbGravityModifierClass_Members),
		HK_COUNT_OF(hkbGravityModifierClass_Members),
		&hkbGravityModifier_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbCheckRagdollSpeedModifierClass_Members[] =
	{
		{ "eventToSend", &hkbEventPropertyClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "minSpeedThreshold", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxSpeedThreshold", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkbCheckRagdollSpeedModifierClass(
		"hkbCheckRagdollSpeedModifier",
		&hkbModifierClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbCheckRagdollSpeedModifierClass_Members),
		HK_COUNT_OF(hkbCheckRagdollSpeedModifierClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkbFaceTargetModifierClass_Members[] =
	{
		{ "targetIn", &hkbTargetClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "offsetAngle", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "onlyOnce", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "done", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hkbFaceTargetModifierClass(
		"hkbFaceTargetModifier",
		&hkbModifierClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbFaceTargetModifierClass_Members),
		HK_COUNT_OF(hkbFaceTargetModifierClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static const hkInternalClassEnumItem hkbReachModifierReachModeEnumItems[] =
	{
		{0, "REACH_MODE_TERRAIN"},
		{1, "REACH_MODE_WORLD_POSITION"},
		{2, "REACH_MODE_MODEL_POSITION"},
		{3, "REACH_MODE_BONE_POSITION"},
	};
	static const hkInternalClassEnum hkbReachModifierEnums[] = {
		{"ReachMode", hkbReachModifierReachModeEnumItems, 4, HK_NULL, 0 }
	};
	const hkClassEnum* hkbReachModifierReachModeEnum = reinterpret_cast<const hkClassEnum*>(&hkbReachModifierEnums[0]);
	static hkInternalClassMember hkbReachModifier_HandClass_Members[] =
	{
		{ "targetOrSensingPosition", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "targetBackHandNormal", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "sensingRadius", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "boneIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "handIkTrackIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkbReachModifierHand_DefaultStruct
		{
			int s_defaultOffsets[5];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			_hkVector4 m_targetOrSensingPosition;
			_hkVector4 m_targetBackHandNormal;
			hkReal m_sensingRadius;
			hkInt16 m_boneIndex;
			hkInt16 m_handIkTrackIndex;
		};
		const hkbReachModifierHand_DefaultStruct hkbReachModifierHand_Default =
		{
			{HK_OFFSET_OF(hkbReachModifierHand_DefaultStruct,m_targetOrSensingPosition),HK_OFFSET_OF(hkbReachModifierHand_DefaultStruct,m_targetBackHandNormal),HK_OFFSET_OF(hkbReachModifierHand_DefaultStruct,m_sensingRadius),HK_OFFSET_OF(hkbReachModifierHand_DefaultStruct,m_boneIndex),HK_OFFSET_OF(hkbReachModifierHand_DefaultStruct,m_handIkTrackIndex)},
		{0,0,0},	{0,0,0},0.4f,-1,-1
		};
	}
	hkClass hkbReachModifierHandClass(
		"hkbReachModifierHand",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbReachModifier_HandClass_Members),
		HK_COUNT_OF(hkbReachModifier_HandClass_Members),
		&hkbReachModifierHand_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbReachModifierClass_Members[] =
	{
		{ "hands", &hkbReachModifierHandClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "newTargetGain", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "noTargetGain", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "targetGain", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "fadeOutDuration", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "raycastLayer", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "sensingPropertyKey", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "reachMode", HK_NULL, hkbReachModifierReachModeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL },
		{ "ignoreMySystemGroup", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "extrapolate", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "internalHandData", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "timeLapse", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	namespace
	{
		struct hkbReachModifier_DefaultStruct
		{
			int s_defaultOffsets[12];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkReal m_newTargetGain;
			hkReal m_noTargetGain;
			hkReal m_targetGain;
			hkInt32 m_raycastLayer;
			_hkBool m_ignoreMySystemGroup;
			hkReal m_extrapolate;
		};
		const hkbReachModifier_DefaultStruct hkbReachModifier_Default =
		{
			{-1,HK_OFFSET_OF(hkbReachModifier_DefaultStruct,m_newTargetGain),HK_OFFSET_OF(hkbReachModifier_DefaultStruct,m_noTargetGain),HK_OFFSET_OF(hkbReachModifier_DefaultStruct,m_targetGain),hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkbReachModifier_DefaultStruct,m_raycastLayer),hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkbReachModifier_DefaultStruct,m_ignoreMySystemGroup),HK_OFFSET_OF(hkbReachModifier_DefaultStruct,m_extrapolate),-1,-1},
			0.085f,0.19f,0.3f,-1,true,1.0f
		};
	}
	hkClass hkbReachModifierClass(
		"hkbReachModifier",
		&hkbModifierClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkbReachModifierEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkbReachModifierClass_Members),
		HK_COUNT_OF(hkbReachModifierClass_Members),
		&hkbReachModifier_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbDemoConfigCharacterInfoClass_Members[] =
	{
		{ "overrideCharacterDataFilename", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "overrideBehaviorFilename", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "initialPosition", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "initialRotation", HK_NULL, HK_NULL, hkClassMember::TYPE_QUATERNION, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "modelUpAxis", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "ragdollBoneLayers", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_INT32, 0, 0, 0, HK_NULL }
	};
	hkClass hkbDemoConfigCharacterInfoClass(
		"hkbDemoConfigCharacterInfo",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbDemoConfigCharacterInfoClass_Members),
		HK_COUNT_OF(hkbDemoConfigCharacterInfoClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(3)
		);
	static hkInternalClassMember hkbDemoConfig_TerrainInfoClass_Members[] =
	{
		{ "filename", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "layer", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "systemGroup", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "createDisplayObjects", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "terrainRigidBody", &hkpRigidBodyClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkbDemoConfigTerrainInfoClass(
		"hkbDemoConfigTerrainInfo",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbDemoConfig_TerrainInfoClass_Members),
		HK_COUNT_OF(hkbDemoConfig_TerrainInfoClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkbDemoConfigStickVariableInfoStickEnumItems[] =
	{
		{0, "STICK_0"},
		{1, "STICK_1"},
		{2, "STICK_DPAD"},
	};
	static const hkInternalClassEnum hkbDemoConfigStickVariableInfoEnums[] = {
		{"Stick", hkbDemoConfigStickVariableInfoStickEnumItems, 3, HK_NULL, 0 }
	};
	const hkClassEnum* hkbDemoConfigStickVariableInfoStickEnum = reinterpret_cast<const hkClassEnum*>(&hkbDemoConfigStickVariableInfoEnums[0]);
	static hkInternalClassMember hkbDemoConfig_StickVariableInfoClass_Members[] =
	{
		{ "variableName", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "minValue", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxValue", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "minStickValue", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxStickValue", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "stickAxis", HK_NULL, HK_NULL, hkClassMember::TYPE_INT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "stick", HK_NULL, hkbDemoConfigStickVariableInfoStickEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL },
		{ "complimentVariableValue", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "negateVariableValue", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkbDemoConfigStickVariableInfoClass(
		"hkbDemoConfigStickVariableInfo",
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkbDemoConfigStickVariableInfoEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkbDemoConfig_StickVariableInfoClass_Members),
		HK_COUNT_OF(hkbDemoConfig_StickVariableInfoClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkbDemoConfigClass_Members[] =
	{
		{ "characterInfo", &hkbDemoConfigCharacterInfoClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "terrainInfo", &hkbDemoConfigTerrainInfoClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "skinAttributeIndices", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_INT32, 0, 0, 0, HK_NULL },
		{ "buttonPressToEventMap", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 16, 0, 0, HK_NULL },
		{ "buttonReleaseToEventMap", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 16, 0, 0, HK_NULL },
		{ "worldUpAxis", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "extraCharacterClones", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "numTracks", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "proxyHeight", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "proxyRadius", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "proxyOffset", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "rootPath", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "projectDataFilename", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "useAttachments", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "useProxy", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "useSkyBox", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "useTrackingCamera", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "accumulateMotion", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "testCloning", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "useSplineCompression", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "forceLoad", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "stickVariables", &hkbDemoConfigStickVariableInfoClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "gamePadToRotateTerrainAboutItsAxisMap", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 6, 0, 0, HK_NULL },
		{ "gamePadToAddRemoveCharacterMap", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 2, 0, 0, HK_NULL },
		{ "filter", &hkpGroupFilterClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkbDemoConfig_DefaultStruct
		{
			int s_defaultOffsets[25];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkInt32 m_numTracks;
			_hkBool m_testCloning;
		};
		const hkbDemoConfig_DefaultStruct hkbDemoConfig_Default =
		{
			{-1,-1,-1,-1,-1,-1,hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkbDemoConfig_DefaultStruct,m_numTracks),-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,HK_OFFSET_OF(hkbDemoConfig_DefaultStruct,m_testCloning),hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,-1,-1,-1,-1},
			hkbGeneratorOutput::NUM_STANDARD_TRACKS,true
		};
	}
	hkClass hkbDemoConfigClass(
		"hkbDemoConfig",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbDemoConfigClass_Members),
		HK_COUNT_OF(hkbDemoConfigClass_Members),
		&hkbDemoConfig_Default,
		HK_NULL,
		0,
		hkUint32(5)
		);
	static const hkInternalClassEnumItem hkbParticleSystemEventPayloadSystemTypeEnumItems[] =
	{
		{0, "DEBRIS"},
		{1, "DUST"},
		{2, "EXPLOSION"},
		{3, "SMOKE"},
		{4, "SPARKS"},
	};
	static const hkInternalClassEnum hkbParticleSystemEventPayloadEnums[] = {
		{"SystemType", hkbParticleSystemEventPayloadSystemTypeEnumItems, 5, HK_NULL, 0 }
	};
	const hkClassEnum* hkbParticleSystemEventPayloadSystemTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkbParticleSystemEventPayloadEnums[0]);
	static hkInternalClassMember hkbParticleSystemEventPayloadClass_Members[] =
	{
		{ "type", HK_NULL, hkbParticleSystemEventPayloadSystemTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "emitBoneIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "offset", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "direction", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "numParticles", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "speed", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkbParticleSystemEventPayload_DefaultStruct
		{
			int s_defaultOffsets[6];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkUint8 /* hkEnum< enum hkbParticleSystemEventPayload::SystemType, hkUint8 > */ m_type;
			hkInt16 m_emitBoneIndex;
			_hkVector4 m_offset;
			_hkVector4 m_direction;
			hkInt32 m_numParticles;
			hkReal m_speed;
		};
		const hkbParticleSystemEventPayload_DefaultStruct hkbParticleSystemEventPayload_Default =
		{
			{HK_OFFSET_OF(hkbParticleSystemEventPayload_DefaultStruct,m_type),HK_OFFSET_OF(hkbParticleSystemEventPayload_DefaultStruct,m_emitBoneIndex),HK_OFFSET_OF(hkbParticleSystemEventPayload_DefaultStruct,m_offset),HK_OFFSET_OF(hkbParticleSystemEventPayload_DefaultStruct,m_direction),HK_OFFSET_OF(hkbParticleSystemEventPayload_DefaultStruct,m_numParticles),HK_OFFSET_OF(hkbParticleSystemEventPayload_DefaultStruct,m_speed)},
	hkbParticleSystemEventPayload::DUST,-1,	{0,0,0},	{0,0,1},100,1.0f
		};
	}
	hkClass hkbParticleSystemEventPayloadClass(
		"hkbParticleSystemEventPayload",
		&hkbEventPayloadClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkbParticleSystemEventPayloadEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkbParticleSystemEventPayloadClass_Members),
		HK_COUNT_OF(hkbParticleSystemEventPayloadClass_Members),
		&hkbParticleSystemEventPayload_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkbMoveBoneTowardTargetModifierTargetModeMBTTEnumItems[] =
	{
		{0, "TARGET_POSITION"},
		{1, "TARGET_COM"},
		{2, "TARGET_CONTACT_POINT"},
		{3, "TARGET_SHAPE_CENTROID"},
	};
	static const hkInternalClassEnumItem hkbMoveBoneTowardTargetModifierAlignModeBitsEnumItems[] =
	{
		{1, "ALIGN_AXES"},
		{2, "ALIGN_BONE_AXIS_WITH_CONTACT_NORMAL"},
		{4, "ALIGN_WITH_CHARACTER_FORWARD"},
	};
	static const hkInternalClassEnum hkbMoveBoneTowardTargetModifierEnums[] = {
		{"TargetModeMBTT", hkbMoveBoneTowardTargetModifierTargetModeMBTTEnumItems, 4, HK_NULL, 0 },
		{"AlignModeBits", hkbMoveBoneTowardTargetModifierAlignModeBitsEnumItems, 3, HK_NULL, 0 }
	};
	const hkClassEnum* hkbMoveBoneTowardTargetModifierTargetModeMBTTEnum = reinterpret_cast<const hkClassEnum*>(&hkbMoveBoneTowardTargetModifierEnums[0]);
	const hkClassEnum* hkbMoveBoneTowardTargetModifierAlignModeBitsEnum = reinterpret_cast<const hkClassEnum*>(&hkbMoveBoneTowardTargetModifierEnums[1]);
	static hkInternalClassMember hkbMoveBoneTowardTargetModifierClass_Members[] =
	{
		{ "targetIn", &hkbTargetClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "offsetInBoneSpace", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "alignAxisBS", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "targetAlignAxisTS", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "alignWithCharacterForwardBS", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "currentBonePositionOut", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "currentBoneRotationOut", HK_NULL, HK_NULL, hkClassMember::TYPE_QUATERNION, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "eventToSendWhenTargetReached", &hkbEventPropertyClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "childGenerator", &hkbGeneratorClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "duration", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "ragdollBoneIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "animationBoneIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "targetMode", HK_NULL, hkbMoveBoneTowardTargetModifierTargetModeMBTTEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL },
		{ "alignMode", HK_NULL, HK_NULL, hkClassMember::TYPE_INT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "useVelocityPrediction", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "affectOrientation", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "currentBoneIsValidOut", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "targetInternal", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "targetPointTS", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "time", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "timeSinceLastModify", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "lastAnimBonePositionMS", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "finalAnimBonePositionMS", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "initialAnimBonePositionMS", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "finalAnimBoneOrientationMS", HK_NULL, HK_NULL, hkClassMember::TYPE_QUATERNION, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "animationFromRagdoll", HK_NULL, HK_NULL, hkClassMember::TYPE_QUATERNION, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "totalMotion", HK_NULL, HK_NULL, hkClassMember::TYPE_QSTRANSFORM, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "accumulatedMotion", HK_NULL, HK_NULL, hkClassMember::TYPE_QSTRANSFORM, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "useAnimationData", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkbMoveBoneTowardTargetModifier_DefaultStruct
		{
			int s_defaultOffsets[29];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			_hkVector4 m_offsetInBoneSpace;
			_hkVector4 m_alignAxisBS;
			_hkVector4 m_targetAlignAxisTS;
			_hkVector4 m_alignWithCharacterForwardBS;
			_hkVector4 m_currentBonePositionOut;
			_hkQuaternion m_currentBoneRotationOut;
			hkReal m_duration;
			hkInt16 m_ragdollBoneIndex;
			hkInt16 m_animationBoneIndex;
			_hkBool m_affectOrientation;
		};
		const hkbMoveBoneTowardTargetModifier_DefaultStruct hkbMoveBoneTowardTargetModifier_Default =
		{
			{-1,HK_OFFSET_OF(hkbMoveBoneTowardTargetModifier_DefaultStruct,m_offsetInBoneSpace),HK_OFFSET_OF(hkbMoveBoneTowardTargetModifier_DefaultStruct,m_alignAxisBS),HK_OFFSET_OF(hkbMoveBoneTowardTargetModifier_DefaultStruct,m_targetAlignAxisTS),HK_OFFSET_OF(hkbMoveBoneTowardTargetModifier_DefaultStruct,m_alignWithCharacterForwardBS),HK_OFFSET_OF(hkbMoveBoneTowardTargetModifier_DefaultStruct,m_currentBonePositionOut),HK_OFFSET_OF(hkbMoveBoneTowardTargetModifier_DefaultStruct,m_currentBoneRotationOut),-1,-1,HK_OFFSET_OF(hkbMoveBoneTowardTargetModifier_DefaultStruct,m_duration),HK_OFFSET_OF(hkbMoveBoneTowardTargetModifier_DefaultStruct,m_ragdollBoneIndex),HK_OFFSET_OF(hkbMoveBoneTowardTargetModifier_DefaultStruct,m_animationBoneIndex),-1,hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkbMoveBoneTowardTargetModifier_DefaultStruct,m_affectOrientation),hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,-1,hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,-1,-1,-1,-1,-1,-1,-1,-1},
		{0,1,0},	{0,1,0},	{0,1,0},	{0,1,0},	{0,0,0},	{0,0,0,1},1,-1,-1,true
		};
	}
	hkClass hkbMoveBoneTowardTargetModifierClass(
		"hkbMoveBoneTowardTargetModifier",
		&hkbModifierClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkbMoveBoneTowardTargetModifierEnums),
		2,
		reinterpret_cast<const hkClassMember*>(hkbMoveBoneTowardTargetModifierClass_Members),
		HK_COUNT_OF(hkbMoveBoneTowardTargetModifierClass_Members),
		&hkbMoveBoneTowardTargetModifier_Default,
		HK_NULL,
		0,
		hkUint32(2)
		);
	static hkInternalClassMember hkbTargetClass_Members[] =
	{
		{ "target", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "contactPointTS", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "contactNormalTS", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "shapeCentroidTS", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "distance", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "targetPriority", HK_NULL, HK_NULL, hkClassMember::TYPE_INT8, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	namespace
	{
		struct hkbTarget_DefaultStruct
		{
			int s_defaultOffsets[6];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
		};
		const hkbTarget_DefaultStruct hkbTarget_Default =
		{
			{hkClassMember::HK_CLASS_ZERO_DEFAULT,-1,-1,-1,-1,-1},
		};
	}
	hkClass hkbTargetClass(
		"hkbTarget",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbTargetClass_Members),
		HK_COUNT_OF(hkbTargetClass_Members),
		&hkbTarget_Default,
		HK_NULL,
		0,
		hkUint32(2)
		);
	static const hkInternalClassEnumItem hkbSimulationControlCommandSimulationControlCommandEnumItems[] =
	{
		{0, "COMMAND_PLAY"},
		{1, "COMMAND_PAUSE"},
		{2, "COMMAND_STEP"},
		{3, "COMMAND_STOP"},
		{4, "COMMAND_ACCUMULATE_MOTION"},
		{5, "COMMAND_DO_NOT_ACCUMULATE_MOTION"},
	};
	static const hkInternalClassEnum hkbSimulationControlCommandEnums[] = {
		{"SimulationControlCommand", hkbSimulationControlCommandSimulationControlCommandEnumItems, 6, HK_NULL, 0 }
	};
	const hkClassEnum* hkbSimulationControlCommandSimulationControlCommandEnum = reinterpret_cast<const hkClassEnum*>(&hkbSimulationControlCommandEnums[0]);
	static hkInternalClassMember hkbSimulationControlCommandClass_Members[] =
	{
		{ "command", HK_NULL, hkbSimulationControlCommandSimulationControlCommandEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL }
	};
	hkClass hkbSimulationControlCommandClass(
		"hkbSimulationControlCommand",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkbSimulationControlCommandEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkbSimulationControlCommandClass_Members),
		HK_COUNT_OF(hkbSimulationControlCommandClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkbCharacterControlCommandCharacterControlCommandEnumItems[] =
	{
		{0, "COMMAND_HIDE"},
		{1, "COMMAND_SHOW"},
	};
	static const hkInternalClassEnum hkbCharacterControlCommandEnums[] = {
		{"CharacterControlCommand", hkbCharacterControlCommandCharacterControlCommandEnumItems, 2, HK_NULL, 0 }
	};
	const hkClassEnum* hkbCharacterControlCommandCharacterControlCommandEnum = reinterpret_cast<const hkClassEnum*>(&hkbCharacterControlCommandEnums[0]);
	static hkInternalClassMember hkbCharacterControlCommandClass_Members[] =
	{
		{ "characterId", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT64, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "command", HK_NULL, hkbCharacterControlCommandCharacterControlCommandEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "padding", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkbCharacterControlCommandClass(
		"hkbCharacterControlCommand",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkbCharacterControlCommandEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkbCharacterControlCommandClass_Members),
		HK_COUNT_OF(hkbCharacterControlCommandClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkbRaiseEventCommandClass_Members[] =
	{
		{ "characterId", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT64, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "global", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "externalId", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkbRaiseEventCommandClass(
		"hkbRaiseEventCommand",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbRaiseEventCommandClass_Members),
		HK_COUNT_OF(hkbRaiseEventCommandClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbSetSelectedCharacterCommandClass_Members[] =
	{
		{ "characterId", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT64, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkbSetSelectedCharacterCommandClass(
		"hkbSetSelectedCharacterCommand",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbSetSelectedCharacterCommandClass_Members),
		HK_COUNT_OF(hkbSetSelectedCharacterCommandClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbSetWordVariableCommandClass_Members[] =
	{
		{ "characterId", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT64, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "variableName", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "value", &hkbVariableValueClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "quadValue", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "type", HK_NULL, hkbVariableInfoVariableTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "global", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkbSetWordVariableCommandClass(
		"hkbSetWordVariableCommand",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbSetWordVariableCommandClass_Members),
		HK_COUNT_OF(hkbSetWordVariableCommandClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbSetLocalTimeOfClipGeneratorCommandClass_Members[] =
	{
		{ "characterId", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT64, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "localTime", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "nodeId", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkbSetLocalTimeOfClipGeneratorCommandClass(
		"hkbSetLocalTimeOfClipGeneratorCommand",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbSetLocalTimeOfClipGeneratorCommandClass_Members),
		HK_COUNT_OF(hkbSetLocalTimeOfClipGeneratorCommandClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbSetBehaviorCommandClass_Members[] =
	{
		{ "characterId", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT64, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "behavior", &hkbBehaviorGraphClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "rootGenerator", &hkbGeneratorClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "referencedBehaviors", &hkbBehaviorGraphClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "startStateIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "randomizeSimulation", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "padding", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkbSetBehaviorCommandClass(
		"hkbSetBehaviorCommand",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbSetBehaviorCommandClass_Members),
		HK_COUNT_OF(hkbSetBehaviorCommandClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkbSetNodePropertyCommandClass_Members[] =
	{
		{ "characterId", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT64, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "nodeName", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "propertyName", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "propertyValue", &hkbVariableValueClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "padding", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkbSetNodePropertyCommandClass(
		"hkbSetNodePropertyCommand",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbSetNodePropertyCommandClass_Members),
		HK_COUNT_OF(hkbSetNodePropertyCommandClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkbRebuildScriptsCommandClass_Members[] =
	{
		{ "characterId", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT64, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkbRebuildScriptsCommandClass(
		"hkbRebuildScriptsCommand",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbRebuildScriptsCommandClass_Members),
		HK_COUNT_OF(hkbRebuildScriptsCommandClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkbToolNodeTypeNodeTypeEnumItems[] =
	{
		{0, "NODE_TYPE_UNKNOWN"},
		{1, "NODE_TYPE_STATE_MACHINE"},
		{2, "NODE_TYPE_CLIP"},
		{4, "NODE_TYPE_BLEND"},
		{8, "NODE_TYPE_MODIFIER"},
		{16, "NODE_TYPE_GENERATOR"},
		{32, "NODE_TYPE_MODIFIER_GENERATOR"},
		{64, "NODE_TYPE_TRANSITION_EFFECT"},
		{128, "NODE_TYPE_BEHAVIOR_FILE_REFERENCE"},
	};
	static const hkInternalClassEnum hkbToolNodeTypeEnums[] = {
		{"NodeType", hkbToolNodeTypeNodeTypeEnumItems, 9, HK_NULL, 0 }
	};
	const hkClassEnum* hkbToolNodeTypeNodeTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkbToolNodeTypeEnums[0]);
	hkClass hkbToolNodeTypeClass(
		"hkbToolNodeType",
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkbToolNodeTypeEnums),
		1,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbCharacterAddedInfoClass_Members[] =
	{
		{ "characterId", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT64, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "instanceName", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "templateName", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "fullPathToProject", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "localScriptsPath", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "remoteScriptsPath", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "skeleton", &hkaSkeletonClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "worldFromModel", HK_NULL, HK_NULL, hkClassMember::TYPE_QSTRANSFORM, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "poseModelSpace", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_QSTRANSFORM, 0, 0, 0, HK_NULL }
	};
	hkClass hkbCharacterAddedInfoClass(
		"hkbCharacterAddedInfo",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbCharacterAddedInfoClass_Members),
		HK_COUNT_OF(hkbCharacterAddedInfoClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static const hkInternalClassEnumItem hkbCharacterInfoEventEnumItems[] =
	{
		{0, "REMOVED_FROM_WORLD"},
		{1, "SHOWN"},
		{2, "HIDDEN"},
		{3, "ACTIVATED"},
		{4, "DEACTIVATED"},
	};
	static const hkInternalClassEnum hkbCharacterInfoEnums[] = {
		{"Event", hkbCharacterInfoEventEnumItems, 5, HK_NULL, 0 }
	};
	const hkClassEnum* hkbCharacterInfoEventEnum = reinterpret_cast<const hkClassEnum*>(&hkbCharacterInfoEnums[0]);
	static hkInternalClassMember hkbCharacterInfoClass_Members[] =
	{
		{ "characterId", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT64, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "event", HK_NULL, hkbCharacterInfoEventEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "padding", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkbCharacterInfoClass(
		"hkbCharacterInfo",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkbCharacterInfoEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkbCharacterInfoClass_Members),
		HK_COUNT_OF(hkbCharacterInfoClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(2)
		);
	static hkInternalClassMember hkbCharacterSteppedInfoClass_Members[] =
	{
		{ "characterId", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT64, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "deltaTime", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "worldFromModel", HK_NULL, HK_NULL, hkClassMember::TYPE_QSTRANSFORM, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "poseModelSpace", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_QSTRANSFORM, 0, 0, 0, HK_NULL },
		{ "rigidAttachmentTransforms", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_QSTRANSFORM, 0, 0, 0, HK_NULL }
	};
	hkClass hkbCharacterSteppedInfoClass(
		"hkbCharacterSteppedInfo",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbCharacterSteppedInfoClass_Members),
		HK_COUNT_OF(hkbCharacterSteppedInfoClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(2)
		);
	static hkInternalClassMember hkbCharacterSkinInfoClass_Members[] =
	{
		{ "characterId", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT64, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "deformableSkins", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT64, 0, 0, 0, HK_NULL },
		{ "rigidSkins", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT64, 0, 0, 0, HK_NULL }
	};
	hkClass hkbCharacterSkinInfoClass(
		"hkbCharacterSkinInfo",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbCharacterSkinInfoClass_Members),
		HK_COUNT_OF(hkbCharacterSkinInfoClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(2)
		);
	static hkInternalClassMember hkbBehaviorInfo_IdToNamePairClass_Members[] =
	{
		{ "behaviorName", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "nodeName", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "toolType", HK_NULL, hkbToolNodeTypeNodeTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "id", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkbBehaviorInfoIdToNamePairClass(
		"hkbBehaviorInfoIdToNamePair",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbBehaviorInfo_IdToNamePairClass_Members),
		HK_COUNT_OF(hkbBehaviorInfo_IdToNamePairClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbBehaviorInfoClass_Members[] =
	{
		{ "characterId", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT64, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "data", &hkbBehaviorGraphDataClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "idToNamePairs", &hkbBehaviorInfoIdToNamePairClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkbBehaviorInfoClass(
		"hkbBehaviorInfo",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbBehaviorInfoClass_Members),
		HK_COUNT_OF(hkbBehaviorInfoClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkbBehaviorEventsInfoClass_Members[] =
	{
		{ "characterId", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT64, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "externalEventIds", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_INT16, 0, 0, 0, HK_NULL },
		{ "padding", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkbBehaviorEventsInfoClass(
		"hkbBehaviorEventsInfo",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbBehaviorEventsInfoClass_Members),
		HK_COUNT_OF(hkbBehaviorEventsInfoClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkbEventRaisedInfoClass_Members[] =
	{
		{ "characterId", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT64, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "eventName", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "raisedBySdk", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "senderId", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "padding", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkbEventRaisedInfoClass(
		"hkbEventRaisedInfo",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbEventRaisedInfoClass_Members),
		HK_COUNT_OF(hkbEventRaisedInfoClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(2)
		);
	static hkInternalClassMember hkbSimulationStateInfoClass_Members[] =
	{
		{ "simulationState", HK_NULL, hkbWorldEnumsSimulationStateEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL }
	};
	hkClass hkbSimulationStateInfoClass(
		"hkbSimulationStateInfo",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbSimulationStateInfoClass_Members),
		HK_COUNT_OF(hkbSimulationStateInfoClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbLinkedSymbolInfoClass_Members[] =
	{
		{ "eventNames", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRINGPTR, 0, 0, 0, HK_NULL },
		{ "variableNames", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRINGPTR, 0, 0, 0, HK_NULL }
	};
	hkClass hkbLinkedSymbolInfoClass(
		"hkbLinkedSymbolInfo",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbLinkedSymbolInfoClass_Members),
		HK_COUNT_OF(hkbLinkedSymbolInfoClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkbAuxiliaryNodeInfoClass_Members[] =
	{
		{ "type", HK_NULL, hkbToolNodeTypeNodeTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "depth", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "referenceBehaviorName", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "selfTransitionNames", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRINGPTR, 0, 0, 0, HK_NULL }
	};
	hkClass hkbAuxiliaryNodeInfoClass(
		"hkbAuxiliaryNodeInfo",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbAuxiliaryNodeInfoClass_Members),
		HK_COUNT_OF(hkbAuxiliaryNodeInfoClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkbBehaviorGraphInternalStateInfoClass_Members[] =
	{
		{ "characterId", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT64, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "internalState", &hkbBehaviorGraphInternalStateClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "auxiliaryNodeInfo", &hkbAuxiliaryNodeInfoClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "activeEventIds", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_INT16, 0, 0, 0, HK_NULL },
		{ "activeVariableIds", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_INT16, 0, 0, 0, HK_NULL }
	};
	hkClass hkbBehaviorGraphInternalStateInfoClass(
		"hkbBehaviorGraphInternalStateInfo",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbBehaviorGraphInternalStateInfoClass_Members),
		HK_COUNT_OF(hkbBehaviorGraphInternalStateInfoClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkbCharacterSelectedInfoClass_Members[] =
	{
		{ "characterId", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT64, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "scriptDebuggingPort", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "padding", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkbCharacterSelectedInfoClass(
		"hkbCharacterSelectedInfo",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkbCharacterSelectedInfoClass_Members),
		HK_COUNT_OF(hkbCharacterSelectedInfoClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclSkeletonTransformSetSetupObjectClass_Members[] =
	{
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "skeleton", &hkaSkeletonClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "worldFromModel", HK_NULL, HK_NULL, hkClassMember::TYPE_MATRIX4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclSkeletonTransformSetSetupObjectClass(
		"hclSkeletonTransformSetSetupObject",
		&hclTransformSetSetupObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclSkeletonTransformSetSetupObjectClass_Members),
		HK_COUNT_OF(hclSkeletonTransformSetSetupObjectClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclBendLinkConstraintSetMx_BatchClass_Members[] =
	{
		{ "bendMinLengths", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 16, 0, 0, HK_NULL },
		{ "stretchMaxLengths", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 16, 0, 0, HK_NULL },
		{ "stretchStiffnesses", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 16, 0, 0, HK_NULL },
		{ "bendStiffnesses", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 16, 0, 0, HK_NULL },
		{ "invMassesA", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 16, 0, 0, HK_NULL },
		{ "invMassesB", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 16, 0, 0, HK_NULL },
		{ "particlesA", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 16, 0, 0, HK_NULL },
		{ "particlesB", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 16, 0, 0, HK_NULL }
	};
	hkClass hclBendLinkConstraintSetMxBatchClass(
		"hclBendLinkConstraintSetMxBatch",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclBendLinkConstraintSetMx_BatchClass_Members),
		HK_COUNT_OF(hclBendLinkConstraintSetMx_BatchClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclBendLinkConstraintSetMx_SingleClass_Members[] =
	{
		{ "bendMinLength", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "stretchMaxLength", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "stretchStiffness", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "bendStiffness", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "invMassA", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "invMassB", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "particleA", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "particleB", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclBendLinkConstraintSetMxSingleClass(
		"hclBendLinkConstraintSetMxSingle",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclBendLinkConstraintSetMx_SingleClass_Members),
		HK_COUNT_OF(hclBendLinkConstraintSetMx_SingleClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclBendLinkConstraintSetMxClass_Members[] =
	{
		{ "batches", &hclBendLinkConstraintSetMxBatchClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "singles", &hclBendLinkConstraintSetMxSingleClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hclBendLinkConstraintSetMxClass(
		"hclBendLinkConstraintSetMx",
		&hclConstraintSetClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclBendLinkConstraintSetMxClass_Members),
		HK_COUNT_OF(hclBendLinkConstraintSetMxClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hclSkinOperatorBONE_GROUP_SIZEEnumItems[] =
	{
		{1, "GROUP_SIZE_1"},
		{4, "GROUP_SIZE_4"},
		{8, "GROUP_SIZE_8"},
		{16, "GROUP_SIZE_16"},
	};
	static const hkInternalClassEnum hclSkinOperatorEnums[] = {
		{"BONE_GROUP_SIZE", hclSkinOperatorBONE_GROUP_SIZEEnumItems, 4, HK_NULL, 0 }
	};
	const hkClassEnum* hclSkinOperatorBONE_GROUP_SIZEEnum = reinterpret_cast<const hkClassEnum*>(&hclSkinOperatorEnums[0]);
	static hkInternalClassMember hclSkinOperator_BoneInfluenceClass_Members[] =
	{
		{ "boneIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "weight", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclSkinOperatorBoneInfluenceClass(
		"hclSkinOperatorBoneInfluence",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclSkinOperator_BoneInfluenceClass_Members),
		HK_COUNT_OF(hclSkinOperator_BoneInfluenceClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(2)
		);
	static hkInternalClassMember hclSkinOperatorClass_Members[] =
	{
		{ "boneInfluences", &hclSkinOperatorBoneInfluenceClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "boneInfluenceStartPerVertex", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT16, 0, 0, 0, HK_NULL },
		{ "boneFromSkinMeshTransforms", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_MATRIX4, 0, 0, 0, HK_NULL },
		{ "usedBoneGroupIds", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT16, 0, 0, 0, HK_NULL },
		{ "skinPositions", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "skinNormals", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "skinTangents", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "skinBiTangents", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "inputBufferIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "outputBufferIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "transformSetIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "startVertex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "endVertex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "partialSkinning", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "dualQuaternionSkinning", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "boneGroupSize", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclSkinOperatorClass(
		"hclSkinOperator",
		&hclOperatorClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hclSkinOperatorEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hclSkinOperatorClass_Members),
		HK_COUNT_OF(hclSkinOperatorClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(4)
		);
	static hkInternalClassMember hclObjectSpaceSkinPNTOperatorClass_Members[] =
	{
		{ "localPNTs", &hclObjectSpaceDeformerLocalBlockPNTClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hclObjectSpaceSkinPNTOperatorClass(
		"hclObjectSpaceSkinPNTOperator",
		&hclObjectSpaceSkinOperatorClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclObjectSpaceSkinPNTOperatorClass_Members),
		HK_COUNT_OF(hclObjectSpaceSkinPNTOperatorClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclCompressibleLinkConstraintSet_LinkClass_Members[] =
	{
		{ "particleA", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "particleB", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "restLength", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "compressionLength", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "stiffness", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclCompressibleLinkConstraintSetLinkClass(
		"hclCompressibleLinkConstraintSetLink",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclCompressibleLinkConstraintSet_LinkClass_Members),
		HK_COUNT_OF(hclCompressibleLinkConstraintSet_LinkClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclCompressibleLinkConstraintSetClass_Members[] =
	{
		{ "links", &hclCompressibleLinkConstraintSetLinkClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hclCompressibleLinkConstraintSetClass(
		"hclCompressibleLinkConstraintSet",
		&hclConstraintSetClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclCompressibleLinkConstraintSetClass_Members),
		HK_COUNT_OF(hclCompressibleLinkConstraintSetClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hclObjectSpaceMeshMeshDeformOperatorScaleNormalBehaviourEnumItems[] =
	{
		{0, "SCALE_NORMAL_IGNORE"},
		{1, "SCALE_NORMAL_APPLY"},
		{2, "SCALE_NORMAL_INVERT"},
	};
	static const hkInternalClassEnum hclObjectSpaceMeshMeshDeformOperatorEnums[] = {
		{"ScaleNormalBehaviour", hclObjectSpaceMeshMeshDeformOperatorScaleNormalBehaviourEnumItems, 3, HK_NULL, 0 }
	};
	const hkClassEnum* hclObjectSpaceMeshMeshDeformOperatorScaleNormalBehaviourEnum = reinterpret_cast<const hkClassEnum*>(&hclObjectSpaceMeshMeshDeformOperatorEnums[0]);
	static hkInternalClassMember hclObjectSpaceMeshMeshDeformOperatorClass_Members[] =
	{
		{ "inputBufferIdx", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "outputBufferIdx", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "scaleNormalBehaviour", HK_NULL, hclObjectSpaceMeshMeshDeformOperatorScaleNormalBehaviourEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT32, 0, 0, 0, HK_NULL },
		{ "inputTrianglesSubset", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT16, 0, 0, 0, HK_NULL },
		{ "triangleFromMeshTransforms", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_MATRIX4, 0, 0, 0, HK_NULL },
		{ "objectSpaceDeformer", &hclObjectSpaceDeformerClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclObjectSpaceMeshMeshDeformOperatorClass(
		"hclObjectSpaceMeshMeshDeformOperator",
		&hclOperatorClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hclObjectSpaceMeshMeshDeformOperatorEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hclObjectSpaceMeshMeshDeformOperatorClass_Members),
		HK_COUNT_OF(hclObjectSpaceMeshMeshDeformOperatorClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hclTransformSetUsageComponentEnumItems[] =
	{
		{0, "COMPONENT_TRANSFORM"},
		{1, "COMPONENT_INVTRANSPOSE"},
	};
	static const hkInternalClassEnumItem hclTransformSetUsageInternalFlagsEnumItems[] =
	{
		{0, "USAGE_NONE"},
		{1, "USAGE_READ"},
		{2, "USAGE_WRITE"},
		{4, "USAGE_FULL_WRITE"},
		{8, "USAGE_READ_BEFORE_WRITE"},
	};
	static const hkInternalClassEnum hclTransformSetUsageEnums[] = {
		{"Component", hclTransformSetUsageComponentEnumItems, 2, HK_NULL, 0 },
		{"InternalFlags", hclTransformSetUsageInternalFlagsEnumItems, 5, HK_NULL, 0 }
	};
	const hkClassEnum* hclTransformSetUsageComponentEnum = reinterpret_cast<const hkClassEnum*>(&hclTransformSetUsageEnums[0]);
	const hkClassEnum* hclTransformSetUsageInternalFlagsEnum = reinterpret_cast<const hkClassEnum*>(&hclTransformSetUsageEnums[1]);
	static hkInternalClassMember hclTransformSetUsageClass_Members[] =
	{
		{ "perComponentFlags", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 2, 0, 0, HK_NULL }
	};
	hkClass hclTransformSetUsageClass(
		"hclTransformSetUsage",
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hclTransformSetUsageEnums),
		2,
		reinterpret_cast<const hkClassMember*>(hclTransformSetUsageClass_Members),
		HK_COUNT_OF(hclTransformSetUsageClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclBoneSpaceSkinPOperatorClass_Members[] =
	{
		{ "localPs", &hclBoneSpaceDeformerLocalBlockPClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hclBoneSpaceSkinPOperatorClass(
		"hclBoneSpaceSkinPOperator",
		&hclBoneSpaceSkinOperatorClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclBoneSpaceSkinPOperatorClass_Members),
		HK_COUNT_OF(hclBoneSpaceSkinPOperatorClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclCompressibleLinkConstraintSetMx_BatchClass_Members[] =
	{
		{ "restLengths", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 16, 0, 0, HK_NULL },
		{ "compressionLengths", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 16, 0, 0, HK_NULL },
		{ "stiffnessesA", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 16, 0, 0, HK_NULL },
		{ "stiffnessesB", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 16, 0, 0, HK_NULL },
		{ "particlesA", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 16, 0, 0, HK_NULL },
		{ "particlesB", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 16, 0, 0, HK_NULL }
	};
	hkClass hclCompressibleLinkConstraintSetMxBatchClass(
		"hclCompressibleLinkConstraintSetMxBatch",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclCompressibleLinkConstraintSetMx_BatchClass_Members),
		HK_COUNT_OF(hclCompressibleLinkConstraintSetMx_BatchClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclCompressibleLinkConstraintSetMx_SingleClass_Members[] =
	{
		{ "restLength", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "compressionLength", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "stiffnessA", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "stiffnessB", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "particleA", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "particleB", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclCompressibleLinkConstraintSetMxSingleClass(
		"hclCompressibleLinkConstraintSetMxSingle",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclCompressibleLinkConstraintSetMx_SingleClass_Members),
		HK_COUNT_OF(hclCompressibleLinkConstraintSetMx_SingleClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclCompressibleLinkConstraintSetMxClass_Members[] =
	{
		{ "batches", &hclCompressibleLinkConstraintSetMxBatchClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "singles", &hclCompressibleLinkConstraintSetMxSingleClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hclCompressibleLinkConstraintSetMxClass(
		"hclCompressibleLinkConstraintSetMx",
		&hclConstraintSetClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclCompressibleLinkConstraintSetMxClass_Members),
		HK_COUNT_OF(hclCompressibleLinkConstraintSetMxClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclSimulateOperatorClass_Members[] =
	{
		{ "simClothIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "subSteps", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "numberOfSolveIterations", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "collideAndSolve", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "constraintExecution", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_INT32, 0, 0, 0, HK_NULL }
	};
	hkClass hclSimulateOperatorClass(
		"hclSimulateOperator",
		&hclOperatorClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclSimulateOperatorClass_Members),
		HK_COUNT_OF(hclSimulateOperatorClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hclObjectSpaceSkinPNTBOperatorClass_Members[] =
	{
		{ "localPNTBs", &hclObjectSpaceDeformerLocalBlockPNTBClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hclObjectSpaceSkinPNTBOperatorClass(
		"hclObjectSpaceSkinPNTBOperator",
		&hclObjectSpaceSkinOperatorClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclObjectSpaceSkinPNTBOperatorClass_Members),
		HK_COUNT_OF(hclObjectSpaceSkinPNTBOperatorClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclTaperedCapsuleShapeClass_Members[] =
	{
		{ "small", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "big", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "coneApex", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "coneAxis", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "lVec", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "dVec", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "tanThetaVecNeg", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "smallRadius", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "bigRadius", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "l", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "d", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "cosTheta", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "sinTheta", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "tanTheta", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "tanThetaSqr", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclTaperedCapsuleShapeClass(
		"hclTaperedCapsuleShape",
		&hclShapeClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclTaperedCapsuleShapeClass_Members),
		HK_COUNT_OF(hclTaperedCapsuleShapeClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(2)
		);
	static hkInternalClassMember hclBoneSpaceMeshMeshDeformPNTBOperatorClass_Members[] =
	{
		{ "localPNTBs", &hclBoneSpaceDeformerLocalBlockPNTBClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hclBoneSpaceMeshMeshDeformPNTBOperatorClass(
		"hclBoneSpaceMeshMeshDeformPNTBOperator",
		&hclBoneSpaceMeshMeshDeformOperatorClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclBoneSpaceMeshMeshDeformPNTBOperatorClass_Members),
		HK_COUNT_OF(hclBoneSpaceMeshMeshDeformPNTBOperatorClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclSimpleMeshBoneDeformOperator_TriangleBonePairClass_Members[] =
	{
		{ "boneOffset", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "triangleOffset", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclSimpleMeshBoneDeformOperatorTriangleBonePairClass(
		"hclSimpleMeshBoneDeformOperatorTriangleBonePair",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclSimpleMeshBoneDeformOperator_TriangleBonePairClass_Members),
		HK_COUNT_OF(hclSimpleMeshBoneDeformOperator_TriangleBonePairClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclSimpleMeshBoneDeformOperatorClass_Members[] =
	{
		{ "inputBufferIdx", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "outputTransformSetIdx", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "triangleBonePairs", &hclSimpleMeshBoneDeformOperatorTriangleBonePairClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "localBoneTransforms", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_MATRIX4, 0, 0, 0, HK_NULL }
	};
	hkClass hclSimpleMeshBoneDeformOperatorClass(
		"hclSimpleMeshBoneDeformOperator",
		&hclOperatorClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclSimpleMeshBoneDeformOperatorClass_Members),
		HK_COUNT_OF(hclSimpleMeshBoneDeformOperatorClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclBoneSpaceSkinPNOperatorClass_Members[] =
	{
		{ "localPNs", &hclBoneSpaceDeformerLocalBlockPNClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hclBoneSpaceSkinPNOperatorClass(
		"hclBoneSpaceSkinPNOperator",
		&hclBoneSpaceSkinOperatorClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclBoneSpaceSkinPNOperatorClass_Members),
		HK_COUNT_OF(hclBoneSpaceSkinPNOperatorClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclPlaneShapeClass_Members[] =
	{
		{ "planeEquation", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclPlaneShapeClass(
		"hclPlaneShape",
		&hclShapeClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclPlaneShapeClass_Members),
		HK_COUNT_OF(hclPlaneShapeClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hclBoneSpaceDeformerControlByteEnumItems[] =
	{
		{0, "FOUR_BLEND"},
		{1, "THREE_BLEND"},
		{2, "TWO_BLEND"},
		{3, "ONE_BLEND"},
		{4, "NEXT_SPU_BATCH"},
	};
	static const hkInternalClassEnum hclBoneSpaceDeformerEnums[] = {
		{"ControlByte", hclBoneSpaceDeformerControlByteEnumItems, 5, HK_NULL, 0 }
	};
	const hkClassEnum* hclBoneSpaceDeformerControlByteEnum = reinterpret_cast<const hkClassEnum*>(&hclBoneSpaceDeformerEnums[0]);
	static hkInternalClassMember hclBoneSpaceDeformer_FourBlendEntryBlockClass_Members[] =
	{
		{ "vertexIndices", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 4, 0, 0, HK_NULL },
		{ "boneIndices", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 16, 0, 0, HK_NULL },
		{ "padding", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 8, 0, 0, HK_NULL }
	};
	hkClass hclBoneSpaceDeformerFourBlendEntryBlockClass(
		"hclBoneSpaceDeformerFourBlendEntryBlock",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclBoneSpaceDeformer_FourBlendEntryBlockClass_Members),
		HK_COUNT_OF(hclBoneSpaceDeformer_FourBlendEntryBlockClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclBoneSpaceDeformer_ThreeBlendEntryBlockClass_Members[] =
	{
		{ "vertexIndices", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 5, 0, 0, HK_NULL },
		{ "boneIndices", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 15, 0, 0, HK_NULL },
		{ "padding", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 8, 0, 0, HK_NULL }
	};
	hkClass hclBoneSpaceDeformerThreeBlendEntryBlockClass(
		"hclBoneSpaceDeformerThreeBlendEntryBlock",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclBoneSpaceDeformer_ThreeBlendEntryBlockClass_Members),
		HK_COUNT_OF(hclBoneSpaceDeformer_ThreeBlendEntryBlockClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclBoneSpaceDeformer_TwoBlendEntryBlockClass_Members[] =
	{
		{ "vertexIndices", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 8, 0, 0, HK_NULL },
		{ "boneIndices", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 16, 0, 0, HK_NULL }
	};
	hkClass hclBoneSpaceDeformerTwoBlendEntryBlockClass(
		"hclBoneSpaceDeformerTwoBlendEntryBlock",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclBoneSpaceDeformer_TwoBlendEntryBlockClass_Members),
		HK_COUNT_OF(hclBoneSpaceDeformer_TwoBlendEntryBlockClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclBoneSpaceDeformer_OneBlendEntryBlockClass_Members[] =
	{
		{ "vertexIndices", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 16, 0, 0, HK_NULL },
		{ "boneIndices", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 16, 0, 0, HK_NULL }
	};
	hkClass hclBoneSpaceDeformerOneBlendEntryBlockClass(
		"hclBoneSpaceDeformerOneBlendEntryBlock",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclBoneSpaceDeformer_OneBlendEntryBlockClass_Members),
		HK_COUNT_OF(hclBoneSpaceDeformer_OneBlendEntryBlockClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclBoneSpaceDeformer_LocalBlockPClass_Members[] =
	{
		{ "localPosition", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 16, 0, 0, HK_NULL }
	};
	hkClass hclBoneSpaceDeformerLocalBlockPClass(
		"hclBoneSpaceDeformerLocalBlockP",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclBoneSpaceDeformer_LocalBlockPClass_Members),
		HK_COUNT_OF(hclBoneSpaceDeformer_LocalBlockPClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclBoneSpaceDeformer_LocalBlockPNClass_Members[] =
	{
		{ "localPosition", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 16, 0, 0, HK_NULL },
		{ "localNormal", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 64, 0, 0, HK_NULL }
	};
	hkClass hclBoneSpaceDeformerLocalBlockPNClass(
		"hclBoneSpaceDeformerLocalBlockPN",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclBoneSpaceDeformer_LocalBlockPNClass_Members),
		HK_COUNT_OF(hclBoneSpaceDeformer_LocalBlockPNClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclBoneSpaceDeformer_LocalBlockPNTClass_Members[] =
	{
		{ "localPosition", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 16, 0, 0, HK_NULL },
		{ "localNormal", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 64, 0, 0, HK_NULL },
		{ "localTangent", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 64, 0, 0, HK_NULL }
	};
	hkClass hclBoneSpaceDeformerLocalBlockPNTClass(
		"hclBoneSpaceDeformerLocalBlockPNT",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclBoneSpaceDeformer_LocalBlockPNTClass_Members),
		HK_COUNT_OF(hclBoneSpaceDeformer_LocalBlockPNTClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclBoneSpaceDeformer_LocalBlockPNTBClass_Members[] =
	{
		{ "localPosition", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 16, 0, 0, HK_NULL },
		{ "localNormal", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 64, 0, 0, HK_NULL },
		{ "localTangent", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 64, 0, 0, HK_NULL },
		{ "localBiTangent", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 64, 0, 0, HK_NULL }
	};
	hkClass hclBoneSpaceDeformerLocalBlockPNTBClass(
		"hclBoneSpaceDeformerLocalBlockPNTB",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclBoneSpaceDeformer_LocalBlockPNTBClass_Members),
		HK_COUNT_OF(hclBoneSpaceDeformer_LocalBlockPNTBClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclBoneSpaceDeformerClass_Members[] =
	{
		{ "fourBlendEntries", &hclBoneSpaceDeformerFourBlendEntryBlockClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "threeBlendEntries", &hclBoneSpaceDeformerThreeBlendEntryBlockClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "twoBlendEntries", &hclBoneSpaceDeformerTwoBlendEntryBlockClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "oneBlendEntries", &hclBoneSpaceDeformerOneBlendEntryBlockClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "controlBytes", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "startVertexIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "endVertexIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "batchSizeSpu", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "partialWrite", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclBoneSpaceDeformerClass(
		"hclBoneSpaceDeformer",
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hclBoneSpaceDeformerEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hclBoneSpaceDeformerClass_Members),
		HK_COUNT_OF(hclBoneSpaceDeformerClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclTransformSetDefinitionClass_Members[] =
	{
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "type", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "numTransforms", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclTransformSetDefinitionClass(
		"hclTransformSetDefinition",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclTransformSetDefinitionClass_Members),
		HK_COUNT_OF(hclTransformSetDefinitionClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclAntiPinchConstraintSet_PerParticleClass_Members[] =
	{
		{ "particleIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "referenceVertex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclAntiPinchConstraintSetPerParticleClass(
		"hclAntiPinchConstraintSetPerParticle",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclAntiPinchConstraintSet_PerParticleClass_Members),
		HK_COUNT_OF(hclAntiPinchConstraintSet_PerParticleClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hclAntiPinchConstraintSetClass_Members[] =
	{
		{ "perParticleData", &hclAntiPinchConstraintSetPerParticleClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "toAnimPeriod", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "toSimPeriod", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "toSimMaxDistance", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "referenceMeshBufferIdx", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclAntiPinchConstraintSetClass(
		"hclAntiPinchConstraintSet",
		&hclConstraintSetClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclAntiPinchConstraintSetClass_Members),
		HK_COUNT_OF(hclAntiPinchConstraintSetClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hclShapeClass_Members[] =
	{
		{ "type", HK_NULL, HK_NULL, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT32, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hclShapeClass(
		"hclShape",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclShapeClass_Members),
		HK_COUNT_OF(hclShapeClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hclBlendSomeVerticesOperatorVectorContextEnumItems[] =
	{
		{0, "VEC_POSITION"},
		{1, "VEC_DIRECTION"},
	};
	static const hkInternalClassEnum hclBlendSomeVerticesOperatorEnums[] = {
		{"VectorContext", hclBlendSomeVerticesOperatorVectorContextEnumItems, 2, HK_NULL, 0 }
	};
	const hkClassEnum* hclBlendSomeVerticesOperatorVectorContextEnum = reinterpret_cast<const hkClassEnum*>(&hclBlendSomeVerticesOperatorEnums[0]);
	static hkInternalClassMember hclBlendSomeVerticesOperator_BlendEntryClass_Members[] =
	{
		{ "vertexIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "blendWeight", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclBlendSomeVerticesOperatorBlendEntryClass(
		"hclBlendSomeVerticesOperatorBlendEntry",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclBlendSomeVerticesOperator_BlendEntryClass_Members),
		HK_COUNT_OF(hclBlendSomeVerticesOperator_BlendEntryClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclBlendSomeVerticesOperatorClass_Members[] =
	{
		{ "blendEntries", &hclBlendSomeVerticesOperatorBlendEntryClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "bufferIdx_A", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "bufferIdx_B", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "bufferIdx_C", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "blendNormals", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "blendTangents", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "blendBitangents", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclBlendSomeVerticesOperatorClass(
		"hclBlendSomeVerticesOperator",
		&hclOperatorClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hclBlendSomeVerticesOperatorEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hclBlendSomeVerticesOperatorClass_Members),
		HK_COUNT_OF(hclBlendSomeVerticesOperatorClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hclStandardLinkConstraintSet_LinkClass_Members[] =
	{
		{ "particleA", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "particleB", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "restLength", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "stiffness", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclStandardLinkConstraintSetLinkClass(
		"hclStandardLinkConstraintSetLink",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclStandardLinkConstraintSet_LinkClass_Members),
		HK_COUNT_OF(hclStandardLinkConstraintSet_LinkClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclStandardLinkConstraintSetClass_Members[] =
	{
		{ "links", &hclStandardLinkConstraintSetLinkClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hclStandardLinkConstraintSetClass(
		"hclStandardLinkConstraintSet",
		&hclConstraintSetClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclStandardLinkConstraintSetClass_Members),
		HK_COUNT_OF(hclStandardLinkConstraintSetClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclObjectSpaceMeshMeshDeformPNOperatorClass_Members[] =
	{
		{ "localPNs", &hclObjectSpaceDeformerLocalBlockPNClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hclObjectSpaceMeshMeshDeformPNOperatorClass(
		"hclObjectSpaceMeshMeshDeformPNOperator",
		&hclObjectSpaceMeshMeshDeformOperatorClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclObjectSpaceMeshMeshDeformPNOperatorClass_Members),
		HK_COUNT_OF(hclObjectSpaceMeshMeshDeformPNOperatorClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hclConstraintSetMaxConstraintSetSizeEnumItems[] =
	{
		{128, "MAX_CONSTRAINT_SET_SIZE"},
	};
	static const hkInternalClassEnum hclConstraintSetEnums[] = {
		{"MaxConstraintSetSize", hclConstraintSetMaxConstraintSetSizeEnumItems, 1, HK_NULL, 0 }
	};
	const hkClassEnum* hclConstraintSetMaxConstraintSetSizeEnum = reinterpret_cast<const hkClassEnum*>(&hclConstraintSetEnums[0]);
	static hkInternalClassMember hclConstraintSetClass_Members[] =
	{
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "type", HK_NULL, HK_NULL, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT32, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hclConstraintSetClass(
		"hclConstraintSet",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hclConstraintSetEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hclConstraintSetClass_Members),
		HK_COUNT_OF(hclConstraintSetClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclScratchBufferDefinitionClass_Members[] =
	{
		{ "triangleIndices", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT16, 0, 0, 0, HK_NULL },
		{ "storeNormals", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "storeTangentsAndBiTangents", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hclScratchBufferDefinition_DefaultStruct
		{
			int s_defaultOffsets[3];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
		};
		const hclScratchBufferDefinition_DefaultStruct hclScratchBufferDefinition_Default =
		{
			{-1,hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT},
		};
	}
	hkClass hclScratchBufferDefinitionClass(
		"hclScratchBufferDefinition",
		&hclBufferDefinitionClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclScratchBufferDefinitionClass_Members),
		HK_COUNT_OF(hclScratchBufferDefinitionClass_Members),
		&hclScratchBufferDefinition_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclObjectSpaceSkinPOperatorClass_Members[] =
	{
		{ "localPs", &hclObjectSpaceDeformerLocalBlockPClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hclObjectSpaceSkinPOperatorClass(
		"hclObjectSpaceSkinPOperator",
		&hclObjectSpaceSkinOperatorClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclObjectSpaceSkinPOperatorClass_Members),
		HK_COUNT_OF(hclObjectSpaceSkinPOperatorClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclStretchLinkConstraintSet_LinkClass_Members[] =
	{
		{ "particleA", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "particleB", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "restLength", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "stiffness", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclStretchLinkConstraintSetLinkClass(
		"hclStretchLinkConstraintSetLink",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclStretchLinkConstraintSet_LinkClass_Members),
		HK_COUNT_OF(hclStretchLinkConstraintSet_LinkClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclStretchLinkConstraintSetClass_Members[] =
	{
		{ "links", &hclStretchLinkConstraintSetLinkClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hclStretchLinkConstraintSetClass(
		"hclStretchLinkConstraintSet",
		&hclConstraintSetClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclStretchLinkConstraintSetClass_Members),
		HK_COUNT_OF(hclStretchLinkConstraintSetClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclGatherSomeVerticesOperator_VertexPairClass_Members[] =
	{
		{ "indexInput", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "indexOutput", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclGatherSomeVerticesOperatorVertexPairClass(
		"hclGatherSomeVerticesOperatorVertexPair",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclGatherSomeVerticesOperator_VertexPairClass_Members),
		HK_COUNT_OF(hclGatherSomeVerticesOperator_VertexPairClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclGatherSomeVerticesOperatorClass_Members[] =
	{
		{ "vertexPairs", &hclGatherSomeVerticesOperatorVertexPairClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "inputBufferIdx", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "outputBufferIdx", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "gatherNormals", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclGatherSomeVerticesOperatorClass(
		"hclGatherSomeVerticesOperator",
		&hclOperatorClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclGatherSomeVerticesOperatorClass_Members),
		HK_COUNT_OF(hclGatherSomeVerticesOperatorClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclRecalculateSomeNormalsOperatorClass_Members[] =
	{
		{ "bufferIdx", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "vertexIndices", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT16, 0, 0, 0, HK_NULL },
		{ "triangleIndices", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT16, 0, 0, 0, HK_NULL }
	};
	hkClass hclRecalculateSomeNormalsOperatorClass(
		"hclRecalculateSomeNormalsOperator",
		&hclOperatorClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclRecalculateSomeNormalsOperatorClass_Members),
		HK_COUNT_OF(hclRecalculateSomeNormalsOperatorClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclTransitionConstraintSet_PerParticleClass_Members[] =
	{
		{ "particleIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "referenceVertex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "toAnimDelay", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "toSimDelay", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "toSimMaxDistance", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclTransitionConstraintSetPerParticleClass(
		"hclTransitionConstraintSetPerParticle",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclTransitionConstraintSet_PerParticleClass_Members),
		HK_COUNT_OF(hclTransitionConstraintSet_PerParticleClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hclTransitionConstraintSetClass_Members[] =
	{
		{ "perParticleData", &hclTransitionConstraintSetPerParticleClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "toAnimPeriod", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "toAnimPlusDelayPeriod", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "toSimPeriod", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "toSimPlusDelayPeriod", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "referenceMeshBufferIdx", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclTransitionConstraintSetClass(
		"hclTransitionConstraintSet",
		&hclConstraintSetClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclTransitionConstraintSetClass_Members),
		HK_COUNT_OF(hclTransitionConstraintSetClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hclClothState_BufferAccessClass_Members[] =
	{
		{ "bufferIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "bufferUsage", &hclBufferUsageClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "shadowBufferIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclClothStateBufferAccessClass(
		"hclClothStateBufferAccess",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclClothState_BufferAccessClass_Members),
		HK_COUNT_OF(hclClothState_BufferAccessClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(2)
		);
	static hkInternalClassMember hclClothState_TransformSetAccessClass_Members[] =
	{
		{ "transformSetIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "transformSetUsage", &hclTransformSetUsageClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclClothStateTransformSetAccessClass(
		"hclClothStateTransformSetAccess",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclClothState_TransformSetAccessClass_Members),
		HK_COUNT_OF(hclClothState_TransformSetAccessClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclClothStateClass_Members[] =
	{
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "operators", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT32, 0, 0, 0, HK_NULL },
		{ "usedBuffers", &hclClothStateBufferAccessClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "usedTransformSets", &hclClothStateTransformSetAccessClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "usedSimCloths", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT32, 0, 0, 0, HK_NULL }
	};
	hkClass hclClothStateClass(
		"hclClothState",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclClothStateClass_Members),
		HK_COUNT_OF(hclClothStateClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hclInputConvertOperatorClass_Members[] =
	{
		{ "userBufferIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "shadowBufferIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "conversionInfo", &hclRuntimeConversionInfoClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclInputConvertOperatorClass(
		"hclInputConvertOperator",
		&hclOperatorClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclInputConvertOperatorClass_Members),
		HK_COUNT_OF(hclInputConvertOperatorClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclHingeConstraintSet_HingeClass_Members[] =
	{
		{ "particleA", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "particleB", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "particle1", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "particle2", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "hingeStiffness", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "relaxFactor", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "sinHalfAngle", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclHingeConstraintSetHingeClass(
		"hclHingeConstraintSetHinge",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclHingeConstraintSet_HingeClass_Members),
		HK_COUNT_OF(hclHingeConstraintSet_HingeClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclHingeConstraintSetClass_Members[] =
	{
		{ "hinges", &hclHingeConstraintSetHingeClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hclHingeConstraintSetClass(
		"hclHingeConstraintSet",
		&hclConstraintSetClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclHingeConstraintSetClass_Members),
		HK_COUNT_OF(hclHingeConstraintSetClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hclClothDataPlatformEnumItems[] =
	{
		{1, "PLATFORM_WIN32"},
		{2, "PLATFORM_X64"},
		{4, "PLATFORM_MACPPC"},
		{8, "PLATFORM_IOS"},
		{16, "PLATFORM_MAC386"},
		{32, "PLATFORM_PS3"},
		{64, "PLATFORM_XBOX360"},
		{128, "PLATFORM_WII"},
		{256, "PLATFORM_LRB"},
		{512, "PLATFORM_LINUX"},
		{1024, "PLATFORM_NGP"},
		{2048, "PLATFORM_ANDROID"},
		{4096, "PLATFORM_CTR"},
	};
	static const hkInternalClassEnum hclClothDataEnums[] = {
		{"Platform", hclClothDataPlatformEnumItems, 13, HK_NULL, 0 }
	};
	const hkClassEnum* hclClothDataPlatformEnum = reinterpret_cast<const hkClassEnum*>(&hclClothDataEnums[0]);
	static hkInternalClassMember hclClothDataClass_Members[] =
	{
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "simClothDatas", &hclSimClothDataClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "bufferDefinitions", &hclBufferDefinitionClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "transformSetDefinitions", &hclTransformSetDefinitionClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "operators", &hclOperatorClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "clothStateDatas", &hclClothStateClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "actions", &hclActionClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "targetPlatform", HK_NULL, hclClothDataPlatformEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT32, 0, 0, 0, HK_NULL }
	};
	hkClass hclClothDataClass(
		"hclClothData",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hclClothDataEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hclClothDataClass_Members),
		HK_COUNT_OF(hclClothDataClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hclBendLinkConstraintSet_LinkClass_Members[] =
	{
		{ "particleA", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "particleB", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "bendMinLength", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "stretchMaxLength", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "bendStiffness", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "stretchStiffness", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclBendLinkConstraintSetLinkClass(
		"hclBendLinkConstraintSetLink",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclBendLinkConstraintSet_LinkClass_Members),
		HK_COUNT_OF(hclBendLinkConstraintSet_LinkClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclBendLinkConstraintSetClass_Members[] =
	{
		{ "links", &hclBendLinkConstraintSetLinkClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hclBendLinkConstraintSetClass(
		"hclBendLinkConstraintSet",
		&hclConstraintSetClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclBendLinkConstraintSetClass_Members),
		HK_COUNT_OF(hclBendLinkConstraintSetClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclObjectSpaceSkinPNOperatorClass_Members[] =
	{
		{ "localPNs", &hclObjectSpaceDeformerLocalBlockPNClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hclObjectSpaceSkinPNOperatorClass(
		"hclObjectSpaceSkinPNOperator",
		&hclObjectSpaceSkinOperatorClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclObjectSpaceSkinPNOperatorClass_Members),
		HK_COUNT_OF(hclObjectSpaceSkinPNOperatorClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclCollidableClass_Members[] =
	{
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "transform", HK_NULL, HK_NULL, hkClassMember::TYPE_TRANSFORM, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "linearVelocity", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "angularVelocity", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "pinchDetectionEnabled", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "pinchDetectionPriority", HK_NULL, HK_NULL, hkClassMember::TYPE_INT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "pinchDetectionRadius", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "shape", &hclShapeClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hclCollidableClass(
		"hclCollidable",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclCollidableClass_Members),
		HK_COUNT_OF(hclCollidableClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(3)
		);
	static hkInternalClassMember hclSimClothData_LandscapeCollisionDataClass_Members[] =
	{
		{ "landscapeRadius", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "enableStuckParticleDetection", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "stuckParticlesStretchFactorSq", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "pinchDetectionEnabled", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "pinchDetectionPriority", HK_NULL, HK_NULL, hkClassMember::TYPE_INT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "pinchDetectionRadius", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclSimClothDataLandscapeCollisionDataClass(
		"hclSimClothDataLandscapeCollisionData",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclSimClothData_LandscapeCollisionDataClass_Members),
		HK_COUNT_OF(hclSimClothData_LandscapeCollisionDataClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclSimClothData_SimulationInfoClass_Members[] =
	{
		{ "gravity", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "globalDampingPerSecond", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "collisionTolerance", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "doNormals", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclSimClothDataSimulationInfoClass(
		"hclSimClothDataSimulationInfo",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclSimClothData_SimulationInfoClass_Members),
		HK_COUNT_OF(hclSimClothData_SimulationInfoClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(2)
		);
	static hkInternalClassMember hclSimClothData_ParticleDataClass_Members[] =
	{
		{ "mass", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "invMass", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "radius", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "friction", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclSimClothDataParticleDataClass(
		"hclSimClothDataParticleData",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclSimClothData_ParticleDataClass_Members),
		HK_COUNT_OF(hclSimClothData_ParticleDataClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(2)
		);
	static hkInternalClassMember hclSimClothData_CollidableTransformMapClass_Members[] =
	{
		{ "transformSetIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "transformIndices", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT32, 0, 0, 0, HK_NULL },
		{ "offsets", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_MATRIX4, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hclSimClothDataCollidableTransformMap_DefaultStruct
		{
			int s_defaultOffsets[3];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkInt32 m_transformSetIndex;
		};
		const hclSimClothDataCollidableTransformMap_DefaultStruct hclSimClothDataCollidableTransformMap_Default =
		{
			{HK_OFFSET_OF(hclSimClothDataCollidableTransformMap_DefaultStruct,m_transformSetIndex),-1,-1},
			-1
		};
	}
	hkClass hclSimClothDataCollidableTransformMapClass(
		"hclSimClothDataCollidableTransformMap",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclSimClothData_CollidableTransformMapClass_Members),
		HK_COUNT_OF(hclSimClothData_CollidableTransformMapClass_Members),
		&hclSimClothDataCollidableTransformMap_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclSimClothData_CollidablePinchingDataClass_Members[] =
	{
		{ "pinchDetectionEnabled", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "pinchDetectionPriority", HK_NULL, HK_NULL, hkClassMember::TYPE_INT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "pinchDetectionRadius", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclSimClothDataCollidablePinchingDataClass(
		"hclSimClothDataCollidablePinchingData",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclSimClothData_CollidablePinchingDataClass_Members),
		HK_COUNT_OF(hclSimClothData_CollidablePinchingDataClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hclSimClothDataClass_Members[] =
	{
		{ "simulationInfo", &hclSimClothDataSimulationInfoClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "particleDatas", &hclSimClothDataParticleDataClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "triangleIndices", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT16, 0, 0, 0, HK_NULL },
		{ "triangleFlips", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT32, 0, 0, 0, HK_NULL },
		{ "totalMass", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "collidableTransformMap", &hclSimClothDataCollidableTransformMapClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "perInstanceCollidables", &hclCollidableClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "staticConstraintSets", &hclConstraintSetClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "antiPinchConstraintSets", &hclConstraintSetClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "simClothPoses", &hclSimClothPoseClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "actions", &hclActionClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "staticCollisionMasks", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT32, 0, 0, 0, HK_NULL },
		{ "perParticlePinchDetectionEnabledFlags", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_BOOL, 0, 0, 0, HK_NULL },
		{ "collidablePinchingDatas", &hclSimClothDataCollidablePinchingDataClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "minPinchedParticleIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxPinchedParticleIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxCollisionPairs", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxParticleRadius", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "pinchDetectionEnabled", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "landscapeCollisionEnabled", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "landscapeCollisionData", &hclSimClothDataLandscapeCollisionDataClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "numLandscapeCollidableParticles", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclSimClothDataClass(
		"hclSimClothData",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclSimClothDataClass_Members),
		HK_COUNT_OF(hclSimClothDataClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(8)
		);
	static hkInternalClassMember hclShadowBufferDefinitionClass_Members[] =
	{
		{ "triangleIndices", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT16, 0, 0, 0, HK_NULL },
		{ "shadowPositions", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "shadowNormals", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "shadowTangents", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "shadowBiTangents", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclShadowBufferDefinitionClass(
		"hclShadowBufferDefinition",
		&hclBufferDefinitionClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclShadowBufferDefinitionClass_Members),
		HK_COUNT_OF(hclShadowBufferDefinitionClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclStaticShadowBufferDefinitionClass_Members[] =
	{
		{ "staticPositions", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VECTOR4, 0, 0, 0, HK_NULL },
		{ "staticNormals", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VECTOR4, 0, 0, 0, HK_NULL },
		{ "staticTangents", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VECTOR4, 0, 0, 0, HK_NULL },
		{ "staticBiTangents", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VECTOR4, 0, 0, 0, HK_NULL },
		{ "triangleIndices", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT16, 0, 0, 0, HK_NULL }
	};
	hkClass hclStaticShadowBufferDefinitionClass(
		"hclStaticShadowBufferDefinition",
		&hclBufferDefinitionClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclStaticShadowBufferDefinitionClass_Members),
		HK_COUNT_OF(hclStaticShadowBufferDefinitionClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclBoneSpaceMeshMeshDeformPNOperatorClass_Members[] =
	{
		{ "localPNs", &hclBoneSpaceDeformerLocalBlockPNClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hclBoneSpaceMeshMeshDeformPNOperatorClass(
		"hclBoneSpaceMeshMeshDeformPNOperator",
		&hclBoneSpaceMeshMeshDeformOperatorClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclBoneSpaceMeshMeshDeformPNOperatorClass_Members),
		HK_COUNT_OF(hclBoneSpaceMeshMeshDeformPNOperatorClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclCapsuleShapeClass_Members[] =
	{
		{ "start", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "end", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "dir", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "radius", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "capLenSqrdInv", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclCapsuleShapeClass(
		"hclCapsuleShape",
		&hclShapeClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclCapsuleShapeClass_Members),
		HK_COUNT_OF(hclCapsuleShapeClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hclObjectSpaceSkinOperatorClass_Members[] =
	{
		{ "boneFromSkinMeshTransforms", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_MATRIX4, 0, 0, 0, HK_NULL },
		{ "outputBufferIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "transformSetIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "objectSpaceDeformer", &hclObjectSpaceDeformerClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclObjectSpaceSkinOperatorClass(
		"hclObjectSpaceSkinOperator",
		&hclOperatorClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclObjectSpaceSkinOperatorClass_Members),
		HK_COUNT_OF(hclObjectSpaceSkinOperatorClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclBonePlanesConstraintSet_BonePlaneClass_Members[] =
	{
		{ "planeEquationBone", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "particleIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "transformIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "stiffness", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclBonePlanesConstraintSetBonePlaneClass(
		"hclBonePlanesConstraintSetBonePlane",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclBonePlanesConstraintSet_BonePlaneClass_Members),
		HK_COUNT_OF(hclBonePlanesConstraintSet_BonePlaneClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclBonePlanesConstraintSetClass_Members[] =
	{
		{ "bonePlanes", &hclBonePlanesConstraintSetBonePlaneClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "transformSetIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclBonePlanesConstraintSetClass(
		"hclBonePlanesConstraintSet",
		&hclConstraintSetClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclBonePlanesConstraintSetClass_Members),
		HK_COUNT_OF(hclBonePlanesConstraintSetClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclCopyVerticesOperatorClass_Members[] =
	{
		{ "inputBufferIdx", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "outputBufferIdx", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "numberOfVertices", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "startVertexIn", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "startVertexOut", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "copyNormals", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclCopyVerticesOperatorClass(
		"hclCopyVerticesOperator",
		&hclOperatorClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclCopyVerticesOperatorClass_Members),
		HK_COUNT_OF(hclCopyVerticesOperatorClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hclRuntimeConversionInfoVectorConversionEnumItems[] =
	{
		{0, "VC_FLOAT4"},
		{1, "VC_FLOAT3"},
		{2, "VC_BYTE4"},
		{3, "VC_SHORT3"},
		{4, "VC_HFLOAT3"},
		{20, "VC_CUSTOM_A"},
		{21, "VC_CUSTOM_B"},
		{22, "VC_CUSTOM_C"},
		{23, "VC_CUSTOM_D"},
		{24, "VC_CUSTOM_E"},
		{250, "VC_NONE"},
	};
	static const hkInternalClassEnum hclRuntimeConversionInfoEnums[] = {
		{"VectorConversion", hclRuntimeConversionInfoVectorConversionEnumItems, 11, HK_NULL, 0 }
	};
	const hkClassEnum* hclRuntimeConversionInfoVectorConversionEnum = reinterpret_cast<const hkClassEnum*>(&hclRuntimeConversionInfoEnums[0]);
	static hkInternalClassMember hclRuntimeConversionInfo_SlotConversionClass_Members[] =
	{
		{ "elements", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 4, 0, 0, HK_NULL },
		{ "numElements", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "index", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "partialWrite", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclRuntimeConversionInfoSlotConversionClass(
		"hclRuntimeConversionInfoSlotConversion",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclRuntimeConversionInfo_SlotConversionClass_Members),
		HK_COUNT_OF(hclRuntimeConversionInfo_SlotConversionClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclRuntimeConversionInfo_ElementConversionClass_Members[] =
	{
		{ "index", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "offset", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "conversion", HK_NULL, hclRuntimeConversionInfoVectorConversionEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL }
	};
	hkClass hclRuntimeConversionInfoElementConversionClass(
		"hclRuntimeConversionInfoElementConversion",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclRuntimeConversionInfo_ElementConversionClass_Members),
		HK_COUNT_OF(hclRuntimeConversionInfo_ElementConversionClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclRuntimeConversionInfoClass_Members[] =
	{
		{ "slotConversions", &hclRuntimeConversionInfoSlotConversionClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 4, 0, 0, HK_NULL },
		{ "elementConversions", &hclRuntimeConversionInfoElementConversionClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 4, 0, 0, HK_NULL },
		{ "numSlotsConverted", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "numElementsConverted", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclRuntimeConversionInfoClass(
		"hclRuntimeConversionInfo",
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hclRuntimeConversionInfoEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hclRuntimeConversionInfoClass_Members),
		HK_COUNT_OF(hclRuntimeConversionInfoClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclConvexGeometryShapeClass_Members[] =
	{
		{ "tetrahedraGrid", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT16, 0, 0, 0, HK_NULL },
		{ "gridCells", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "tetrahedraEquations", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_MATRIX4, 0, 0, 0, HK_NULL },
		{ "objAabb", &hkAabbClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::ALIGN_16, 0, HK_NULL },
		{ "localFromWorld", HK_NULL, HK_NULL, hkClassMember::TYPE_TRANSFORM, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "worldFromLocal", HK_NULL, HK_NULL, hkClassMember::TYPE_TRANSFORM, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "geomCentroid", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "invCellSize", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "gridRes", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclConvexGeometryShapeClass(
		"hclConvexGeometryShape",
		&hclShapeClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclConvexGeometryShapeClass_Members),
		HK_COUNT_OF(hclConvexGeometryShapeClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclStretchLinkConstraintSetMx_BatchClass_Members[] =
	{
		{ "restLengths", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 16, 0, 0, HK_NULL },
		{ "stiffnesses", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 16, 0, 0, HK_NULL },
		{ "particlesA", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 16, 0, 0, HK_NULL },
		{ "particlesB", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 16, 0, 0, HK_NULL }
	};
	hkClass hclStretchLinkConstraintSetMxBatchClass(
		"hclStretchLinkConstraintSetMxBatch",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclStretchLinkConstraintSetMx_BatchClass_Members),
		HK_COUNT_OF(hclStretchLinkConstraintSetMx_BatchClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclStretchLinkConstraintSetMx_SingleClass_Members[] =
	{
		{ "restLength", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "stiffness", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "particleA", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "particleB", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclStretchLinkConstraintSetMxSingleClass(
		"hclStretchLinkConstraintSetMxSingle",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclStretchLinkConstraintSetMx_SingleClass_Members),
		HK_COUNT_OF(hclStretchLinkConstraintSetMx_SingleClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclStretchLinkConstraintSetMxClass_Members[] =
	{
		{ "batches", &hclStretchLinkConstraintSetMxBatchClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "singles", &hclStretchLinkConstraintSetMxSingleClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hclStretchLinkConstraintSetMxClass(
		"hclStretchLinkConstraintSetMx",
		&hclConstraintSetClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclStretchLinkConstraintSetMxClass_Members),
		HK_COUNT_OF(hclStretchLinkConstraintSetMxClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclClothContainerClass_Members[] =
	{
		{ "collidables", &hclCollidableClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "clothDatas", &hclClothDataClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL }
	};
	hkClass hclClothContainerClass(
		"hclClothContainer",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclClothContainerClass_Members),
		HK_COUNT_OF(hclClothContainerClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	hkClass hclActionClass(
		"hclAction",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclSphereShapeClass_Members[] =
	{
		{ "sphere", &hkSphereClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclSphereShapeClass(
		"hclSphereShape",
		&hclShapeClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclSphereShapeClass_Members),
		HK_COUNT_OF(hclSphereShapeClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclConvexHeightFieldShapeClass_Members[] =
	{
		{ "res", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "resIncBorder", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "floatCorrectionOffset", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "heights", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "faces", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 6, 0, 0, HK_NULL },
		{ "localToMapTransform", HK_NULL, HK_NULL, hkClassMember::TYPE_TRANSFORM, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "localToMapScale", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclConvexHeightFieldShapeClass(
		"hclConvexHeightFieldShape",
		&hclShapeClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclConvexHeightFieldShapeClass_Members),
		HK_COUNT_OF(hclConvexHeightFieldShapeClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static const hkInternalClassEnumItem hclBufferUsageComponentEnumItems[] =
	{
		{0, "COMPONENT_POSITION"},
		{1, "COMPONENT_NORMAL"},
		{2, "COMPONENT_TANGENT"},
		{3, "COMPONENT_BITANGENT"},
	};
	static const hkInternalClassEnumItem hclBufferUsageInternalFlagsEnumItems[] =
	{
		{0, "USAGE_NONE"},
		{1, "USAGE_READ"},
		{2, "USAGE_WRITE"},
		{4, "USAGE_FULL_WRITE"},
		{8, "USAGE_READ_BEFORE_WRITE"},
	};
	static const hkInternalClassEnum hclBufferUsageEnums[] = {
		{"Component", hclBufferUsageComponentEnumItems, 4, HK_NULL, 0 },
		{"InternalFlags", hclBufferUsageInternalFlagsEnumItems, 5, HK_NULL, 0 }
	};
	const hkClassEnum* hclBufferUsageComponentEnum = reinterpret_cast<const hkClassEnum*>(&hclBufferUsageEnums[0]);
	const hkClassEnum* hclBufferUsageInternalFlagsEnum = reinterpret_cast<const hkClassEnum*>(&hclBufferUsageEnums[1]);
	static hkInternalClassMember hclBufferUsageClass_Members[] =
	{
		{ "perComponentFlags", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 4, 0, 0, HK_NULL },
		{ "trianglesRead", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclBufferUsageClass(
		"hclBufferUsage",
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hclBufferUsageEnums),
		2,
		reinterpret_cast<const hkClassMember*>(hclBufferUsageClass_Members),
		HK_COUNT_OF(hclBufferUsageClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclVolumeConstraint_FrameDataClass_Members[] =
	{
		{ "frameVector", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "particleIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "weight", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclVolumeConstraintFrameDataClass(
		"hclVolumeConstraintFrameData",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclVolumeConstraint_FrameDataClass_Members),
		HK_COUNT_OF(hclVolumeConstraint_FrameDataClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclVolumeConstraint_ApplyDataClass_Members[] =
	{
		{ "frameVector", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "particleIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "stiffness", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclVolumeConstraintApplyDataClass(
		"hclVolumeConstraintApplyData",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclVolumeConstraint_ApplyDataClass_Members),
		HK_COUNT_OF(hclVolumeConstraint_ApplyDataClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclVolumeConstraintClass_Members[] =
	{
		{ "frameDatas", &hclVolumeConstraintFrameDataClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "applyDatas", &hclVolumeConstraintApplyDataClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "useDeprecatedMethod", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclVolumeConstraintClass(
		"hclVolumeConstraint",
		&hclConstraintSetClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclVolumeConstraintClass_Members),
		HK_COUNT_OF(hclVolumeConstraintClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hclSimClothPoseClass_Members[] =
	{
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "positions", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VECTOR4, 0, 0, 0, HK_NULL }
	};
	hkClass hclSimClothPoseClass(
		"hclSimClothPose",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclSimClothPoseClass_Members),
		HK_COUNT_OF(hclSimClothPoseClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclObjectSpaceMeshMeshDeformPOperatorClass_Members[] =
	{
		{ "localPs", &hclObjectSpaceDeformerLocalBlockPClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hclObjectSpaceMeshMeshDeformPOperatorClass(
		"hclObjectSpaceMeshMeshDeformPOperator",
		&hclObjectSpaceMeshMeshDeformOperatorClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclObjectSpaceMeshMeshDeformPOperatorClass_Members),
		HK_COUNT_OF(hclObjectSpaceMeshMeshDeformPOperatorClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclBoneSpaceMeshMeshDeformPOperatorClass_Members[] =
	{
		{ "localPs", &hclBoneSpaceDeformerLocalBlockPClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hclBoneSpaceMeshMeshDeformPOperatorClass(
		"hclBoneSpaceMeshMeshDeformPOperator",
		&hclBoneSpaceMeshMeshDeformOperatorClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclBoneSpaceMeshMeshDeformPOperatorClass_Members),
		HK_COUNT_OF(hclBoneSpaceMeshMeshDeformPOperatorClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hclObjectSpaceDeformerControlByteEnumItems[] =
	{
		{0, "FOUR_BLEND"},
		{1, "THREE_BLEND"},
		{2, "TWO_BLEND"},
		{3, "ONE_BLEND"},
		{4, "NEXT_SPU_BATCH"},
	};
	static const hkInternalClassEnum hclObjectSpaceDeformerEnums[] = {
		{"ControlByte", hclObjectSpaceDeformerControlByteEnumItems, 5, HK_NULL, 0 }
	};
	const hkClassEnum* hclObjectSpaceDeformerControlByteEnum = reinterpret_cast<const hkClassEnum*>(&hclObjectSpaceDeformerEnums[0]);
	static hkInternalClassMember hclObjectSpaceDeformer_FourBlendEntryBlockClass_Members[] =
	{
		{ "vertexIndices", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 16, 0, 0, HK_NULL },
		{ "boneIndices", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 64, 0, 0, HK_NULL },
		{ "boneWeights", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 64, 0, 0, HK_NULL }
	};
	hkClass hclObjectSpaceDeformerFourBlendEntryBlockClass(
		"hclObjectSpaceDeformerFourBlendEntryBlock",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclObjectSpaceDeformer_FourBlendEntryBlockClass_Members),
		HK_COUNT_OF(hclObjectSpaceDeformer_FourBlendEntryBlockClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclObjectSpaceDeformer_ThreeBlendEntryBlockClass_Members[] =
	{
		{ "vertexIndices", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 16, 0, 0, HK_NULL },
		{ "boneIndices", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 48, 0, 0, HK_NULL },
		{ "boneWeights", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 48, 0, 0, HK_NULL }
	};
	hkClass hclObjectSpaceDeformerThreeBlendEntryBlockClass(
		"hclObjectSpaceDeformerThreeBlendEntryBlock",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclObjectSpaceDeformer_ThreeBlendEntryBlockClass_Members),
		HK_COUNT_OF(hclObjectSpaceDeformer_ThreeBlendEntryBlockClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclObjectSpaceDeformer_TwoBlendEntryBlockClass_Members[] =
	{
		{ "vertexIndices", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 16, 0, 0, HK_NULL },
		{ "boneIndices", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 32, 0, 0, HK_NULL },
		{ "boneWeights", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 32, 0, 0, HK_NULL }
	};
	hkClass hclObjectSpaceDeformerTwoBlendEntryBlockClass(
		"hclObjectSpaceDeformerTwoBlendEntryBlock",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclObjectSpaceDeformer_TwoBlendEntryBlockClass_Members),
		HK_COUNT_OF(hclObjectSpaceDeformer_TwoBlendEntryBlockClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclObjectSpaceDeformer_OneBlendEntryBlockClass_Members[] =
	{
		{ "vertexIndices", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 16, 0, 0, HK_NULL },
		{ "boneIndices", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 16, 0, 0, HK_NULL }
	};
	hkClass hclObjectSpaceDeformerOneBlendEntryBlockClass(
		"hclObjectSpaceDeformerOneBlendEntryBlock",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclObjectSpaceDeformer_OneBlendEntryBlockClass_Members),
		HK_COUNT_OF(hclObjectSpaceDeformer_OneBlendEntryBlockClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclObjectSpaceDeformer_LocalBlockPClass_Members[] =
	{
		{ "localPosition", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 64, 0, 0, HK_NULL }
	};
	hkClass hclObjectSpaceDeformerLocalBlockPClass(
		"hclObjectSpaceDeformerLocalBlockP",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclObjectSpaceDeformer_LocalBlockPClass_Members),
		HK_COUNT_OF(hclObjectSpaceDeformer_LocalBlockPClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclObjectSpaceDeformer_LocalBlockPNClass_Members[] =
	{
		{ "localPosition", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 64, 0, 0, HK_NULL },
		{ "localNormal", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 64, 0, 0, HK_NULL }
	};
	hkClass hclObjectSpaceDeformerLocalBlockPNClass(
		"hclObjectSpaceDeformerLocalBlockPN",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclObjectSpaceDeformer_LocalBlockPNClass_Members),
		HK_COUNT_OF(hclObjectSpaceDeformer_LocalBlockPNClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclObjectSpaceDeformer_LocalBlockPNTClass_Members[] =
	{
		{ "localPosition", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 64, 0, 0, HK_NULL },
		{ "localNormal", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 64, 0, 0, HK_NULL },
		{ "localTangent", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 64, 0, 0, HK_NULL }
	};
	hkClass hclObjectSpaceDeformerLocalBlockPNTClass(
		"hclObjectSpaceDeformerLocalBlockPNT",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclObjectSpaceDeformer_LocalBlockPNTClass_Members),
		HK_COUNT_OF(hclObjectSpaceDeformer_LocalBlockPNTClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclObjectSpaceDeformer_LocalBlockPNTBClass_Members[] =
	{
		{ "localPosition", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 64, 0, 0, HK_NULL },
		{ "localNormal", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 64, 0, 0, HK_NULL },
		{ "localTangent", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 64, 0, 0, HK_NULL },
		{ "localBiTangent", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 64, 0, 0, HK_NULL }
	};
	hkClass hclObjectSpaceDeformerLocalBlockPNTBClass(
		"hclObjectSpaceDeformerLocalBlockPNTB",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclObjectSpaceDeformer_LocalBlockPNTBClass_Members),
		HK_COUNT_OF(hclObjectSpaceDeformer_LocalBlockPNTBClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclObjectSpaceDeformerClass_Members[] =
	{
		{ "fourBlendEntries", &hclObjectSpaceDeformerFourBlendEntryBlockClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "threeBlendEntries", &hclObjectSpaceDeformerThreeBlendEntryBlockClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "twoBlendEntries", &hclObjectSpaceDeformerTwoBlendEntryBlockClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "oneBlendEntries", &hclObjectSpaceDeformerOneBlendEntryBlockClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "controlBytes", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "startVertexIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "endVertexIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "batchSizeSpu", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "partialWrite", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclObjectSpaceDeformerClass(
		"hclObjectSpaceDeformer",
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hclObjectSpaceDeformerEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hclObjectSpaceDeformerClass_Members),
		HK_COUNT_OF(hclObjectSpaceDeformerClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclUpdateSomeVertexFramesOperator_TriangleClass_Members[] =
	{
		{ "indices", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 3, 0, 0, HK_NULL }
	};
	hkClass hclUpdateSomeVertexFramesOperatorTriangleClass(
		"hclUpdateSomeVertexFramesOperatorTriangle",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclUpdateSomeVertexFramesOperator_TriangleClass_Members),
		HK_COUNT_OF(hclUpdateSomeVertexFramesOperator_TriangleClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclUpdateSomeVertexFramesOperatorClass_Members[] =
	{
		{ "involvedTriangles", &hclUpdateSomeVertexFramesOperatorTriangleClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "involvedVertices", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT16, 0, 0, 0, HK_NULL },
		{ "selectionVertexToInvolvedVertex", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT16, 0, 0, 0, HK_NULL },
		{ "involvedVertexToNormalID", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT16, 0, 0, 0, HK_NULL },
		{ "triangleFlips", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT32, 0, 0, 0, HK_NULL },
		{ "referenceVertices", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT16, 0, 0, 0, HK_NULL },
		{ "tangentEdgeCosAngle", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_REAL, 0, 0, 0, HK_NULL },
		{ "tangentEdgeSinAngle", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_REAL, 0, 0, 0, HK_NULL },
		{ "biTangentFlip", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_REAL, 0, 0, 0, HK_NULL },
		{ "bufferIdx", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "numUniqueNormalIDs", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "updateNormals", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "updateTangents", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "updateBiTangents", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclUpdateSomeVertexFramesOperatorClass(
		"hclUpdateSomeVertexFramesOperator",
		&hclOperatorClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclUpdateSomeVertexFramesOperatorClass_Members),
		HK_COUNT_OF(hclUpdateSomeVertexFramesOperatorClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(2)
		);
	static hkInternalClassMember hclBoneSpaceMeshMeshDeformPNTOperatorClass_Members[] =
	{
		{ "localPNTs", &hclBoneSpaceDeformerLocalBlockPNTClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hclBoneSpaceMeshMeshDeformPNTOperatorClass(
		"hclBoneSpaceMeshMeshDeformPNTOperator",
		&hclBoneSpaceMeshMeshDeformOperatorClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclBoneSpaceMeshMeshDeformPNTOperatorClass_Members),
		HK_COUNT_OF(hclBoneSpaceMeshMeshDeformPNTOperatorClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hclMeshMeshDeformOperatorScaleNormalBehaviourEnumItems[] =
	{
		{0, "SCALE_NORMAL_IGNORE"},
		{1, "SCALE_NORMAL_APPLY"},
		{2, "SCALE_NORMAL_INVERT"},
	};
	static const hkInternalClassEnum hclMeshMeshDeformOperatorEnums[] = {
		{"ScaleNormalBehaviour", hclMeshMeshDeformOperatorScaleNormalBehaviourEnumItems, 3, HK_NULL, 0 }
	};
	const hkClassEnum* hclMeshMeshDeformOperatorScaleNormalBehaviourEnum = reinterpret_cast<const hkClassEnum*>(&hclMeshMeshDeformOperatorEnums[0]);
	static hkInternalClassMember hclMeshMeshDeformOperator_TriangleVertexPairClass_Members[] =
	{
		{ "localPosition", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "localNormal", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "triangleIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "weight", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hclMeshMeshDeformOperatorTriangleVertexPair_DefaultStruct
		{
			int s_defaultOffsets[4];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			_hkVector4 m_localNormal;
		};
		const hclMeshMeshDeformOperatorTriangleVertexPair_DefaultStruct hclMeshMeshDeformOperatorTriangleVertexPair_Default =
		{
			{-1,HK_OFFSET_OF(hclMeshMeshDeformOperatorTriangleVertexPair_DefaultStruct,m_localNormal),-1,-1},
			{0.0f,0.0f,1.0f}
		};
	}
	hkClass hclMeshMeshDeformOperatorTriangleVertexPairClass(
		"hclMeshMeshDeformOperatorTriangleVertexPair",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclMeshMeshDeformOperator_TriangleVertexPairClass_Members),
		HK_COUNT_OF(hclMeshMeshDeformOperator_TriangleVertexPairClass_Members),
		&hclMeshMeshDeformOperatorTriangleVertexPair_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclMeshMeshDeformOperatorClass_Members[] =
	{
		{ "inputTrianglesSubset", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT16, 0, 0, 0, HK_NULL },
		{ "triangleVertexPairs", &hclMeshMeshDeformOperatorTriangleVertexPairClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "triangleVertexStartForVertex", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT16, 0, 0, 0, HK_NULL },
		{ "inputBufferIdx", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "outputBufferIdx", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "startVertex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "endVertex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "scaleNormalBehaviour", HK_NULL, hclMeshMeshDeformOperatorScaleNormalBehaviourEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT32, 0, 0, 0, HK_NULL },
		{ "deformNormals", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "partialDeform", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hclMeshMeshDeformOperator_DefaultStruct
		{
			int s_defaultOffsets[10];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
		};
		const hclMeshMeshDeformOperator_DefaultStruct hclMeshMeshDeformOperator_Default =
		{
			{-1,-1,-1,-1,-1,-1,-1,-1,hkClassMember::HK_CLASS_ZERO_DEFAULT,-1},
		};
	}
	hkClass hclMeshMeshDeformOperatorClass(
		"hclMeshMeshDeformOperator",
		&hclOperatorClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hclMeshMeshDeformOperatorEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hclMeshMeshDeformOperatorClass_Members),
		HK_COUNT_OF(hclMeshMeshDeformOperatorClass_Members),
		&hclMeshMeshDeformOperator_Default,
		HK_NULL,
		0,
		hkUint32(2)
		);
	static hkInternalClassMember hclOutputConvertOperatorClass_Members[] =
	{
		{ "userBufferIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "shadowBufferIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "conversionInfo", &hclRuntimeConversionInfoClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclOutputConvertOperatorClass(
		"hclOutputConvertOperator",
		&hclOperatorClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclOutputConvertOperatorClass_Members),
		HK_COUNT_OF(hclOutputConvertOperatorClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclBendStiffnessConstraintSetMx_BatchClass_Members[] =
	{
		{ "weightsA", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 16, 0, 0, HK_NULL },
		{ "weightsB", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 16, 0, 0, HK_NULL },
		{ "weightsC", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 16, 0, 0, HK_NULL },
		{ "weightsD", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 16, 0, 0, HK_NULL },
		{ "bendStiffnesses", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 16, 0, 0, HK_NULL },
		{ "restCurvatures", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 16, 0, 0, HK_NULL },
		{ "invMassesA", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 16, 0, 0, HK_NULL },
		{ "invMassesB", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 16, 0, 0, HK_NULL },
		{ "invMassesC", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 16, 0, 0, HK_NULL },
		{ "invMassesD", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 16, 0, 0, HK_NULL },
		{ "particlesA", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 16, 0, 0, HK_NULL },
		{ "particlesB", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 16, 0, 0, HK_NULL },
		{ "particlesC", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 16, 0, 0, HK_NULL },
		{ "particlesD", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 16, 0, 0, HK_NULL }
	};
	hkClass hclBendStiffnessConstraintSetMxBatchClass(
		"hclBendStiffnessConstraintSetMxBatch",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclBendStiffnessConstraintSetMx_BatchClass_Members),
		HK_COUNT_OF(hclBendStiffnessConstraintSetMx_BatchClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclBendStiffnessConstraintSetMx_SingleClass_Members[] =
	{
		{ "weightA", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "weightB", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "weightC", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "weightD", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "bendStiffness", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "restCurvature", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "invMassA", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "invMassB", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "invMassC", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "invMassD", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "particleA", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "particleB", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "particleC", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "particleD", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclBendStiffnessConstraintSetMxSingleClass(
		"hclBendStiffnessConstraintSetMxSingle",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclBendStiffnessConstraintSetMx_SingleClass_Members),
		HK_COUNT_OF(hclBendStiffnessConstraintSetMx_SingleClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclBendStiffnessConstraintSetMxClass_Members[] =
	{
		{ "batches", &hclBendStiffnessConstraintSetMxBatchClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "singles", &hclBendStiffnessConstraintSetMxSingleClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "useRestPoseConfig", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclBendStiffnessConstraintSetMxClass(
		"hclBendStiffnessConstraintSetMx",
		&hclConstraintSetClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclBendStiffnessConstraintSetMxClass_Members),
		HK_COUNT_OF(hclBendStiffnessConstraintSetMxClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclRecalculateAllNormalsOperatorClass_Members[] =
	{
		{ "bufferIdx", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclRecalculateAllNormalsOperatorClass(
		"hclRecalculateAllNormalsOperator",
		&hclOperatorClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclRecalculateAllNormalsOperatorClass_Members),
		HK_COUNT_OF(hclRecalculateAllNormalsOperatorClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclBendStiffnessConstraintSet_LinkClass_Members[] =
	{
		{ "weightA", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "weightB", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "weightC", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "weightD", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "bendStiffness", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "restCurvature", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "particleA", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "particleB", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "particleC", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "particleD", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclBendStiffnessConstraintSetLinkClass(
		"hclBendStiffnessConstraintSetLink",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclBendStiffnessConstraintSet_LinkClass_Members),
		HK_COUNT_OF(hclBendStiffnessConstraintSet_LinkClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hclBendStiffnessConstraintSetClass_Members[] =
	{
		{ "links", &hclBendStiffnessConstraintSetLinkClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "useRestPoseConfig", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclBendStiffnessConstraintSetClass(
		"hclBendStiffnessConstraintSet",
		&hclConstraintSetClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclBendStiffnessConstraintSetClass_Members),
		HK_COUNT_OF(hclBendStiffnessConstraintSetClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hclObjectSpaceMeshMeshDeformPNTOperatorClass_Members[] =
	{
		{ "localPNTs", &hclObjectSpaceDeformerLocalBlockPNTClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hclObjectSpaceMeshMeshDeformPNTOperatorClass(
		"hclObjectSpaceMeshMeshDeformPNTOperator",
		&hclObjectSpaceMeshMeshDeformOperatorClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclObjectSpaceMeshMeshDeformPNTOperatorClass_Members),
		HK_COUNT_OF(hclObjectSpaceMeshMeshDeformPNTOperatorClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclMeshBoneDeformOperator_TriangleBonePairClass_Members[] =
	{
		{ "localBoneTransform", HK_NULL, HK_NULL, hkClassMember::TYPE_MATRIX4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "weight", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "triangleIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclMeshBoneDeformOperatorTriangleBonePairClass(
		"hclMeshBoneDeformOperatorTriangleBonePair",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclMeshBoneDeformOperator_TriangleBonePairClass_Members),
		HK_COUNT_OF(hclMeshBoneDeformOperator_TriangleBonePairClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclMeshBoneDeformOperatorClass_Members[] =
	{
		{ "inputBufferIdx", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "outputTransformSetIdx", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "triangleBonePairs", &hclMeshBoneDeformOperatorTriangleBonePairClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "triangleBoneStartForBone", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT16, 0, 0, 0, HK_NULL }
	};
	hkClass hclMeshBoneDeformOperatorClass(
		"hclMeshBoneDeformOperator",
		&hclOperatorClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclMeshBoneDeformOperatorClass_Members),
		HK_COUNT_OF(hclMeshBoneDeformOperatorClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclOperatorClass_Members[] =
	{
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "type", HK_NULL, HK_NULL, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT32, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hclOperatorClass(
		"hclOperator",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclOperatorClass_Members),
		HK_COUNT_OF(hclOperatorClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclGatherAllVerticesOperatorClass_Members[] =
	{
		{ "vertexInputFromVertexOutput", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_INT16, 0, 0, 0, HK_NULL },
		{ "inputBufferIdx", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "outputBufferIdx", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "gatherNormals", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "partialGather", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclGatherAllVerticesOperatorClass(
		"hclGatherAllVerticesOperator",
		&hclOperatorClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclGatherAllVerticesOperatorClass_Members),
		HK_COUNT_OF(hclGatherAllVerticesOperatorClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hclBoneSpaceSkinPNTOperatorClass_Members[] =
	{
		{ "localPNTs", &hclBoneSpaceDeformerLocalBlockPNTClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hclBoneSpaceSkinPNTOperatorClass(
		"hclBoneSpaceSkinPNTOperator",
		&hclBoneSpaceSkinOperatorClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclBoneSpaceSkinPNTOperatorClass_Members),
		HK_COUNT_OF(hclBoneSpaceSkinPNTOperatorClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclVolumeConstraintMx_FrameBatchDataClass_Members[] =
	{
		{ "frameVector", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 16, 0, 0, HK_NULL },
		{ "particleIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 16, 0, 0, HK_NULL },
		{ "weight", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 16, 0, 0, HK_NULL }
	};
	hkClass hclVolumeConstraintMxFrameBatchDataClass(
		"hclVolumeConstraintMxFrameBatchData",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclVolumeConstraintMx_FrameBatchDataClass_Members),
		HK_COUNT_OF(hclVolumeConstraintMx_FrameBatchDataClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclVolumeConstraintMx_FrameSingleDataClass_Members[] =
	{
		{ "frameVector", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "particleIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "weight", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclVolumeConstraintMxFrameSingleDataClass(
		"hclVolumeConstraintMxFrameSingleData",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclVolumeConstraintMx_FrameSingleDataClass_Members),
		HK_COUNT_OF(hclVolumeConstraintMx_FrameSingleDataClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclVolumeConstraintMx_ApplyBatchDataClass_Members[] =
	{
		{ "frameVector", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 16, 0, 0, HK_NULL },
		{ "particleIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 16, 0, 0, HK_NULL },
		{ "stiffness", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 16, 0, 0, HK_NULL }
	};
	hkClass hclVolumeConstraintMxApplyBatchDataClass(
		"hclVolumeConstraintMxApplyBatchData",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclVolumeConstraintMx_ApplyBatchDataClass_Members),
		HK_COUNT_OF(hclVolumeConstraintMx_ApplyBatchDataClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclVolumeConstraintMx_ApplySingleDataClass_Members[] =
	{
		{ "frameVector", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "particleIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "stiffness", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclVolumeConstraintMxApplySingleDataClass(
		"hclVolumeConstraintMxApplySingleData",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclVolumeConstraintMx_ApplySingleDataClass_Members),
		HK_COUNT_OF(hclVolumeConstraintMx_ApplySingleDataClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclVolumeConstraintMxClass_Members[] =
	{
		{ "frameBatchDatas", &hclVolumeConstraintMxFrameBatchDataClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "frameSingleDatas", &hclVolumeConstraintMxFrameSingleDataClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "applyBatchDatas", &hclVolumeConstraintMxApplyBatchDataClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "applySingleDatas", &hclVolumeConstraintMxApplySingleDataClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hclVolumeConstraintMxClass(
		"hclVolumeConstraintMx",
		&hclConstraintSetClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclVolumeConstraintMxClass_Members),
		HK_COUNT_OF(hclVolumeConstraintMxClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclSimpleWindActionClass_Members[] =
	{
		{ "windDirection", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "windMinSpeed", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "windMaxSpeed", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "windFrequency", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maximumDrag", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "airVelocity", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "currentTime", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclSimpleWindActionClass(
		"hclSimpleWindAction",
		&hclActionClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclSimpleWindActionClass_Members),
		HK_COUNT_OF(hclSimpleWindActionClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclStandardLinkConstraintSetMx_BatchClass_Members[] =
	{
		{ "restLengths", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 16, 0, 0, HK_NULL },
		{ "stiffnessesA", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 16, 0, 0, HK_NULL },
		{ "stiffnessesB", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 16, 0, 0, HK_NULL },
		{ "particlesA", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 16, 0, 0, HK_NULL },
		{ "particlesB", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 16, 0, 0, HK_NULL }
	};
	hkClass hclStandardLinkConstraintSetMxBatchClass(
		"hclStandardLinkConstraintSetMxBatch",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclStandardLinkConstraintSetMx_BatchClass_Members),
		HK_COUNT_OF(hclStandardLinkConstraintSetMx_BatchClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclStandardLinkConstraintSetMx_SingleClass_Members[] =
	{
		{ "restLength", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "stiffnessA", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "stiffnessB", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "particleA", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "particleB", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclStandardLinkConstraintSetMxSingleClass(
		"hclStandardLinkConstraintSetMxSingle",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclStandardLinkConstraintSetMx_SingleClass_Members),
		HK_COUNT_OF(hclStandardLinkConstraintSetMx_SingleClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclStandardLinkConstraintSetMxClass_Members[] =
	{
		{ "batches", &hclStandardLinkConstraintSetMxBatchClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "singles", &hclStandardLinkConstraintSetMxSingleClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hclStandardLinkConstraintSetMxClass(
		"hclStandardLinkConstraintSetMx",
		&hclConstraintSetClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclStandardLinkConstraintSetMxClass_Members),
		HK_COUNT_OF(hclStandardLinkConstraintSetMxClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hclMoveParticlesOperatorForceUpgrade610EnumItems[] =
	{
		{0, "HCL_FORCE_UPGRADE610"},
	};
	static const hkInternalClassEnum hclMoveParticlesOperatorEnums[] = {
		{"ForceUpgrade610", hclMoveParticlesOperatorForceUpgrade610EnumItems, 1, HK_NULL, 0 }
	};
	const hkClassEnum* hclMoveParticlesOperatorForceUpgrade610Enum = reinterpret_cast<const hkClassEnum*>(&hclMoveParticlesOperatorEnums[0]);
	static hkInternalClassMember hclMoveParticlesOperator_VertexParticlePairClass_Members[] =
	{
		{ "vertexIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "particleIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclMoveParticlesOperatorVertexParticlePairClass(
		"hclMoveParticlesOperatorVertexParticlePair",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclMoveParticlesOperator_VertexParticlePairClass_Members),
		HK_COUNT_OF(hclMoveParticlesOperator_VertexParticlePairClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclMoveParticlesOperatorClass_Members[] =
	{
		{ "vertexParticlePairs", &hclMoveParticlesOperatorVertexParticlePairClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "simClothIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "refBufferIdx", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclMoveParticlesOperatorClass(
		"hclMoveParticlesOperator",
		&hclOperatorClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hclMoveParticlesOperatorEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hclMoveParticlesOperatorClass_Members),
		HK_COUNT_OF(hclMoveParticlesOperatorClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclBoneSpaceSkinPNTBOperatorClass_Members[] =
	{
		{ "localPNTBs", &hclBoneSpaceDeformerLocalBlockPNTBClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hclBoneSpaceSkinPNTBOperatorClass(
		"hclBoneSpaceSkinPNTBOperator",
		&hclBoneSpaceSkinOperatorClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclBoneSpaceSkinPNTBOperatorClass_Members),
		HK_COUNT_OF(hclBoneSpaceSkinPNTBOperatorClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hclLocalRangeConstraintSetForceUpgrade6EnumItems[] =
	{
		{0, "HCL_FORCE_UPGRADE6"},
	};
	static const hkInternalClassEnum hclLocalRangeConstraintSetEnums[] = {
		{"ForceUpgrade6", hclLocalRangeConstraintSetForceUpgrade6EnumItems, 1, HK_NULL, 0 }
	};
	const hkClassEnum* hclLocalRangeConstraintSetForceUpgrade6Enum = reinterpret_cast<const hkClassEnum*>(&hclLocalRangeConstraintSetEnums[0]);
	static hkInternalClassMember hclLocalRangeConstraintSet_LocalConstraintClass_Members[] =
	{
		{ "particleIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "referenceVertex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maximumDistance", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxNormalDistance", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "minNormalDistance", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclLocalRangeConstraintSetLocalConstraintClass(
		"hclLocalRangeConstraintSetLocalConstraint",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclLocalRangeConstraintSet_LocalConstraintClass_Members),
		HK_COUNT_OF(hclLocalRangeConstraintSet_LocalConstraintClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclLocalRangeConstraintSetClass_Members[] =
	{
		{ "localConstraints", &hclLocalRangeConstraintSetLocalConstraintClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "referenceMeshBufferIdx", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "applyNormalComponent", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "stiffness", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclLocalRangeConstraintSetClass(
		"hclLocalRangeConstraintSet",
		&hclConstraintSetClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hclLocalRangeConstraintSetEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hclLocalRangeConstraintSetClass_Members),
		HK_COUNT_OF(hclLocalRangeConstraintSetClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(2)
		);
	static hkInternalClassMember hclUpdateAllVertexFramesOperatorClass_Members[] =
	{
		{ "vertToNormalID", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT16, 0, 0, 0, HK_NULL },
		{ "triangleFlips", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT32, 0, 0, 0, HK_NULL },
		{ "referenceVertices", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT16, 0, 0, 0, HK_NULL },
		{ "tangentEdgeCosAngle", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_REAL, 0, 0, 0, HK_NULL },
		{ "tangentEdgeSinAngle", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_REAL, 0, 0, 0, HK_NULL },
		{ "biTangentFlip", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_REAL, 0, 0, 0, HK_NULL },
		{ "bufferIdx", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "numUniqueNormalIDs", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "updateNormals", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "updateTangents", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "updateBiTangents", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclUpdateAllVertexFramesOperatorClass(
		"hclUpdateAllVertexFramesOperator",
		&hclOperatorClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclUpdateAllVertexFramesOperatorClass_Members),
		HK_COUNT_OF(hclUpdateAllVertexFramesOperatorClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(2)
		);
	static hkInternalClassMember hclBufferDefinitionClass_Members[] =
	{
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "type", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "subType", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "numVertices", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "numTriangles", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "bufferLayout", &hclBufferLayoutClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclBufferDefinitionClass(
		"hclBufferDefinition",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclBufferDefinitionClass_Members),
		HK_COUNT_OF(hclBufferDefinitionClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static const hkInternalClassEnumItem hclBoneSpaceMeshMeshDeformOperatorScaleNormalBehaviourEnumItems[] =
	{
		{0, "SCALE_NORMAL_IGNORE"},
		{1, "SCALE_NORMAL_APPLY"},
		{2, "SCALE_NORMAL_INVERT"},
	};
	static const hkInternalClassEnum hclBoneSpaceMeshMeshDeformOperatorEnums[] = {
		{"ScaleNormalBehaviour", hclBoneSpaceMeshMeshDeformOperatorScaleNormalBehaviourEnumItems, 3, HK_NULL, 0 }
	};
	const hkClassEnum* hclBoneSpaceMeshMeshDeformOperatorScaleNormalBehaviourEnum = reinterpret_cast<const hkClassEnum*>(&hclBoneSpaceMeshMeshDeformOperatorEnums[0]);
	static hkInternalClassMember hclBoneSpaceMeshMeshDeformOperatorClass_Members[] =
	{
		{ "inputBufferIdx", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "outputBufferIdx", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "scaleNormalBehaviour", HK_NULL, hclBoneSpaceMeshMeshDeformOperatorScaleNormalBehaviourEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT32, 0, 0, 0, HK_NULL },
		{ "inputTrianglesSubset", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT16, 0, 0, 0, HK_NULL },
		{ "boneSpaceDeformer", &hclBoneSpaceDeformerClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclBoneSpaceMeshMeshDeformOperatorClass(
		"hclBoneSpaceMeshMeshDeformOperator",
		&hclOperatorClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hclBoneSpaceMeshMeshDeformOperatorEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hclBoneSpaceMeshMeshDeformOperatorClass_Members),
		HK_COUNT_OF(hclBoneSpaceMeshMeshDeformOperatorClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hclBufferLayoutSlotFlagsEnumItems[] =
	{
		{0, "SF_NO_ALIGNED_START"},
		{1, "SF_16BYTE_ALIGNED_START"},
		{3, "SF_64BYTE_ALIGNED_START"},
	};
	static const hkInternalClassEnumItem hclBufferLayoutTriangleFormatEnumItems[] =
	{
		{0, "TF_THREE_INT32S"},
		{1, "TF_THREE_INT16S"},
		{2, "TF_OTHER"},
	};
	static const hkInternalClassEnum hclBufferLayoutEnums[] = {
		{"SlotFlags", hclBufferLayoutSlotFlagsEnumItems, 3, HK_NULL, 0 },
		{"TriangleFormat", hclBufferLayoutTriangleFormatEnumItems, 3, HK_NULL, 0 }
	};
	const hkClassEnum* hclBufferLayoutSlotFlagsEnum = reinterpret_cast<const hkClassEnum*>(&hclBufferLayoutEnums[0]);
	const hkClassEnum* hclBufferLayoutTriangleFormatEnum = reinterpret_cast<const hkClassEnum*>(&hclBufferLayoutEnums[1]);
	static hkInternalClassMember hclBufferLayout_BufferElementClass_Members[] =
	{
		{ "vectorConversion", HK_NULL, hclRuntimeConversionInfoVectorConversionEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "vectorSize", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "slotId", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "slotStart", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclBufferLayoutBufferElementClass(
		"hclBufferLayoutBufferElement",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclBufferLayout_BufferElementClass_Members),
		HK_COUNT_OF(hclBufferLayout_BufferElementClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclBufferLayout_SlotClass_Members[] =
	{
		{ "flags", HK_NULL, hclBufferLayoutSlotFlagsEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "stride", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclBufferLayoutSlotClass(
		"hclBufferLayoutSlot",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclBufferLayout_SlotClass_Members),
		HK_COUNT_OF(hclBufferLayout_SlotClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclBufferLayoutClass_Members[] =
	{
		{ "elementsLayout", &hclBufferLayoutBufferElementClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 4, 0, 0, HK_NULL },
		{ "slots", &hclBufferLayoutSlotClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 4, 0, 0, HK_NULL },
		{ "numSlots", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "triangleFormat", HK_NULL, hclBufferLayoutTriangleFormatEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL }
	};
	hkClass hclBufferLayoutClass(
		"hclBufferLayout",
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hclBufferLayoutEnums),
		2,
		reinterpret_cast<const hkClassMember*>(hclBufferLayoutClass_Members),
		HK_COUNT_OF(hclBufferLayoutClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclObjectSpaceMeshMeshDeformPNTBOperatorClass_Members[] =
	{
		{ "localPNTBs", &hclObjectSpaceDeformerLocalBlockPNTBClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hclObjectSpaceMeshMeshDeformPNTBOperatorClass(
		"hclObjectSpaceMeshMeshDeformPNTBOperator",
		&hclObjectSpaceMeshMeshDeformOperatorClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclObjectSpaceMeshMeshDeformPNTBOperatorClass_Members),
		HK_COUNT_OF(hclObjectSpaceMeshMeshDeformPNTBOperatorClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclBoneSpaceSkinOperatorClass_Members[] =
	{
		{ "outputBufferIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "transformSetIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "boneSpaceDeformer", &hclBoneSpaceDeformerClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclBoneSpaceSkinOperatorClass(
		"hclBoneSpaceSkinOperator",
		&hclOperatorClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclBoneSpaceSkinOperatorClass_Members),
		HK_COUNT_OF(hclBoneSpaceSkinOperatorClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hclConstraintSetSetupObjectClass(
		"hclConstraintSetSetupObject",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hclVertexGatherSetupObjectDirectionEnumItems[] =
	{
		{0, "SIMULATION_TO_DISPLAY"},
		{1, "DISPLAY_TO_SIMULATION"},
	};
	static const hkInternalClassEnum hclVertexGatherSetupObjectEnums[] = {
		{"Direction", hclVertexGatherSetupObjectDirectionEnumItems, 2, HK_NULL, 0 }
	};
	const hkClassEnum* hclVertexGatherSetupObjectDirectionEnum = reinterpret_cast<const hkClassEnum*>(&hclVertexGatherSetupObjectEnums[0]);
	static hkInternalClassMember hclVertexGatherSetupObjectClass_Members[] =
	{
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "direction", HK_NULL, hclVertexGatherSetupObjectDirectionEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT32, 0, 0, 0, HK_NULL },
		{ "simulationBuffer", &hclSimClothBufferSetupObjectClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "simulationParticleSelection", &hclVertexSelectionInputClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "displayBuffer", &hclBufferSetupObjectClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "displayVertexSelection", &hclVertexSelectionInputClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "gatherAllThreshold", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "gatherNormals", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclVertexGatherSetupObjectClass(
		"hclVertexGatherSetupObject",
		&hclOperatorSetupObjectClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hclVertexGatherSetupObjectEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hclVertexGatherSetupObjectClass_Members),
		HK_COUNT_OF(hclVertexGatherSetupObjectClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclClothStateSetupObjectClass_Members[] =
	{
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "operatorSetupObjects", &hclOperatorSetupObjectClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL }
	};
	hkClass hclClothStateSetupObjectClass(
		"hclClothStateSetupObject",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclClothStateSetupObjectClass_Members),
		HK_COUNT_OF(hclClothStateSetupObjectClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hclVertexFloatInputVertexFloatTypeEnumItems[] =
	{
		{0, "VERTEX_FLOAT_CONSTANT"},
		{1, "VERTEX_FLOAT_CHANNEL"},
	};
	static const hkInternalClassEnum hclVertexFloatInputEnums[] = {
		{"VertexFloatType", hclVertexFloatInputVertexFloatTypeEnumItems, 2, HK_NULL, 0 }
	};
	const hkClassEnum* hclVertexFloatInputVertexFloatTypeEnum = reinterpret_cast<const hkClassEnum*>(&hclVertexFloatInputEnums[0]);
	static hkInternalClassMember hclVertexFloatInputClass_Members[] =
	{
		{ "type", HK_NULL, hclVertexFloatInputVertexFloatTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT32, 0, 0, 0, HK_NULL },
		{ "constantValue", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "channelName", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclVertexFloatInputClass(
		"hclVertexFloatInput",
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hclVertexFloatInputEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hclVertexFloatInputClass_Members),
		HK_COUNT_OF(hclVertexFloatInputClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hclEdgeSelectionInputEdgeSelectionTypeEnumItems[] =
	{
		{0, "EDGE_SELECTION_ALL"},
		{1, "EDGE_SELECTION_NONE"},
		{2, "EDGE_SELECTION_CHANNEL"},
		{3, "EDGE_SELECTION_INVERSE_CHANNEL"},
	};
	static const hkInternalClassEnum hclEdgeSelectionInputEnums[] = {
		{"EdgeSelectionType", hclEdgeSelectionInputEdgeSelectionTypeEnumItems, 4, HK_NULL, 0 }
	};
	const hkClassEnum* hclEdgeSelectionInputEdgeSelectionTypeEnum = reinterpret_cast<const hkClassEnum*>(&hclEdgeSelectionInputEnums[0]);
	static hkInternalClassMember hclEdgeSelectionInputClass_Members[] =
	{
		{ "type", HK_NULL, hclEdgeSelectionInputEdgeSelectionTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT32, 0, 0, 0, HK_NULL },
		{ "channelName", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclEdgeSelectionInputClass(
		"hclEdgeSelectionInput",
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hclEdgeSelectionInputEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hclEdgeSelectionInputClass_Members),
		HK_COUNT_OF(hclEdgeSelectionInputClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclStandardLinkSetupObjectClass_Members[] =
	{
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "simulationMesh", &hclSimulationSetupMeshClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "vertexSelection", &hclVertexSelectionInputClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "edgeSelection", &hclEdgeSelectionInputClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "ignoreHiddenEdges", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "stiffness", &hclVertexFloatInputClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "allowedCompression", &hclVertexFloatInputClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "allowedStretching", &hclVertexFloatInputClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclStandardLinkSetupObjectClass(
		"hclStandardLinkSetupObject",
		&hclConstraintSetSetupObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclStandardLinkSetupObjectClass_Members),
		HK_COUNT_OF(hclStandardLinkSetupObjectClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(2)
		);
	static hkInternalClassMember hclSceneDataSetupMeshSectionClass_Members[] =
	{
		{ "setupMesh", &hclSceneDataSetupMeshClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "meshSection", &hkxMeshSectionClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "skinnedSection", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclSceneDataSetupMeshSectionClass(
		"hclSceneDataSetupMeshSection",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		1,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclSceneDataSetupMeshSectionClass_Members),
		HK_COUNT_OF(hclSceneDataSetupMeshSectionClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclMeshBoneDeformSetupObjectClass_Members[] =
	{
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "inputBufferSetupObject", &hclBufferSetupObjectClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "inputTriangleSelection", &hclTriangleSelectionInputClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "outputTransformSetSetupObject", &hclTransformSetSetupObjectClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "deformedBones", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRINGPTR, 0, 0, 0, HK_NULL },
		{ "maxTrianglesPerBone", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "minimumTriangleWeight", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclMeshBoneDeformSetupObjectClass(
		"hclMeshBoneDeformSetupObject",
		&hclOperatorSetupObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclMeshBoneDeformSetupObjectClass_Members),
		HK_COUNT_OF(hclMeshBoneDeformSetupObjectClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclScratchBufferSetupObjectClass_Members[] =
	{
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "setupMesh", &hclSetupMeshClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "storeNormals", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "storeTangentsAndBiTangents", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "storeTriangles", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclScratchBufferSetupObjectClass(
		"hclScratchBufferSetupObject",
		&hclBufferSetupObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclScratchBufferSetupObjectClass_Members),
		HK_COUNT_OF(hclScratchBufferSetupObjectClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclRecalculateNormalsSetupObjectClass_Members[] =
	{
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "buffer", &hclBufferSetupObjectClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "vertexSelection", &hclVertexSelectionInputClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclRecalculateNormalsSetupObjectClass(
		"hclRecalculateNormalsSetupObject",
		&hclOperatorSetupObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclRecalculateNormalsSetupObjectClass_Members),
		HK_COUNT_OF(hclRecalculateNormalsSetupObjectClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclSceneDataSetupMeshClass_Members[] =
	{
		{ "node", &hkxNodeClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "worldFromMesh", HK_NULL, HK_NULL, hkClassMember::TYPE_MATRIX4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "mesh", &hkxMeshClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "skinBinding", &hkxSkinBindingClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "vertexChannels", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT32, 0, 0, 0, HK_NULL },
		{ "triangleChannels", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT32, 0, 0, 0, HK_NULL },
		{ "edgeChannels", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT32, 0, 0, 0, HK_NULL },
		{ "meshBufferInterfaces", &hclSceneDataSetupMeshSectionClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL }
	};
	hkClass hclSceneDataSetupMeshClass(
		"hclSceneDataSetupMesh",
		&hclSetupMeshClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclSceneDataSetupMeshClass_Members),
		HK_COUNT_OF(hclSceneDataSetupMeshClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(2)
		);
	static hkInternalClassMember hclStretchLinkSetupObjectClass_Members[] =
	{
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "simulationMesh", &hclSimulationSetupMeshClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "movableParticlesSelection", &hclVertexSelectionInputClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "fixedParticlesSelection", &hclVertexSelectionInputClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "rigidFactor", &hclVertexFloatInputClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "stiffness", &hclVertexFloatInputClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "stretchDirection", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclStretchLinkSetupObjectClass(
		"hclStretchLinkSetupObject",
		&hclConstraintSetSetupObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclStretchLinkSetupObjectClass_Members),
		HK_COUNT_OF(hclStretchLinkSetupObjectClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclBonePlanesSetupObject_PerParticlePlaneClass_Members[] =
	{
		{ "transformName", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "particles", &hclVertexSelectionInputClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "directionBoneSpace", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "allowedDistance", &hclVertexFloatInputClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "stiffness", &hclVertexFloatInputClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclBonePlanesSetupObjectPerParticlePlaneClass(
		"hclBonePlanesSetupObjectPerParticlePlane",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclBonePlanesSetupObject_PerParticlePlaneClass_Members),
		HK_COUNT_OF(hclBonePlanesSetupObject_PerParticlePlaneClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclBonePlanesSetupObject_GlobalPlaneClass_Members[] =
	{
		{ "transformName", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "particles", &hclVertexSelectionInputClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "planeEquationBoneSpace", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "allowedPenetration", &hclVertexFloatInputClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "stiffness", &hclVertexFloatInputClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclBonePlanesSetupObjectGlobalPlaneClass(
		"hclBonePlanesSetupObjectGlobalPlane",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclBonePlanesSetupObject_GlobalPlaneClass_Members),
		HK_COUNT_OF(hclBonePlanesSetupObject_GlobalPlaneClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclBonePlanesSetupObject_PerParticleAngleClass_Members[] =
	{
		{ "transformName", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "particlesMaxAngle", &hclVertexSelectionInputClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "particlesMinAngle", &hclVertexSelectionInputClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "originBoneSpace", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "axisBoneSpace", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "minAngle", &hclVertexFloatInputClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxAngle", &hclVertexFloatInputClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "stiffness", &hclVertexFloatInputClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclBonePlanesSetupObjectPerParticleAngleClass(
		"hclBonePlanesSetupObjectPerParticleAngle",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclBonePlanesSetupObject_PerParticleAngleClass_Members),
		HK_COUNT_OF(hclBonePlanesSetupObject_PerParticleAngleClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclBonePlanesSetupObjectClass_Members[] =
	{
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "simulationMesh", &hclSimulationSetupMeshClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "transformSetSetup", &hclTransformSetSetupObjectClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "perParticlePlanes", &hclBonePlanesSetupObjectPerParticlePlaneClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "globalPlanes", &hclBonePlanesSetupObjectGlobalPlaneClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "perParticleAngle", &hclBonePlanesSetupObjectPerParticleAngleClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hclBonePlanesSetupObjectClass(
		"hclBonePlanesSetupObject",
		&hclConstraintSetSetupObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclBonePlanesSetupObjectClass_Members),
		HK_COUNT_OF(hclBonePlanesSetupObjectClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclSetupMeshSection_TriangleClass_Members[] =
	{
		{ "indices", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 3, 0, 0, HK_NULL }
	};
	hkClass hclSetupMeshSectionTriangleClass(
		"hclSetupMeshSectionTriangle",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclSetupMeshSection_TriangleClass_Members),
		HK_COUNT_OF(hclSetupMeshSection_TriangleClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hclSetupMeshSectionClass(
		"hclSetupMeshSection",
		HK_NULL,
		0,
		HK_NULL,
		1,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hclBufferSetupObjectClass(
		"hclBufferSetupObject",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclStaticDisplayBufferSetupObjectClass_Members[] =
	{
		{ "setupMesh", &hclSetupMeshClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclStaticDisplayBufferSetupObjectClass(
		"hclStaticDisplayBufferSetupObject",
		&hclBufferSetupObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclStaticDisplayBufferSetupObjectClass_Members),
		HK_COUNT_OF(hclStaticDisplayBufferSetupObjectClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hclSetupMeshVertexChannelTypeEnumItems[] =
	{
		{0, "HCL_VERTEX_CHANNEL_INVALID"},
		{1, "HCL_VERTEX_CHANNEL_FLOAT"},
		{2, "HCL_VERTEX_CHANNEL_DISTANCE"},
		{3, "HCL_VERTEX_CHANNEL_ANGLE"},
		{4, "HCL_VERTEX_CHANNEL_SELECTION"},
	};
	static const hkInternalClassEnumItem hclSetupMeshTriangleChannelTypeEnumItems[] =
	{
		{0, "HCL_TRIANGLE_CHANNEL_INVALID"},
		{1, "HCL_TRIANGLE_CHANNEL_SELECTION"},
	};
	static const hkInternalClassEnumItem hclSetupMeshEdgeChannelTypeEnumItems[] =
	{
		{0, "HCL_EDGE_CHANNEL_INVALID"},
		{1, "HCL_EDGE_CHANNEL_SELECTION"},
	};
	static const hkInternalClassEnum hclSetupMeshEnums[] = {
		{"VertexChannelType", hclSetupMeshVertexChannelTypeEnumItems, 5, HK_NULL, 0 },
		{"TriangleChannelType", hclSetupMeshTriangleChannelTypeEnumItems, 2, HK_NULL, 0 },
		{"EdgeChannelType", hclSetupMeshEdgeChannelTypeEnumItems, 2, HK_NULL, 0 }
	};
	const hkClassEnum* hclSetupMeshVertexChannelTypeEnum = reinterpret_cast<const hkClassEnum*>(&hclSetupMeshEnums[0]);
	const hkClassEnum* hclSetupMeshTriangleChannelTypeEnum = reinterpret_cast<const hkClassEnum*>(&hclSetupMeshEnums[1]);
	const hkClassEnum* hclSetupMeshEdgeChannelTypeEnum = reinterpret_cast<const hkClassEnum*>(&hclSetupMeshEnums[2]);
	hkClass hclSetupMeshClass(
		"hclSetupMesh",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hclSetupMeshEnums),
		3,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclUpdateVertexFramesSetupObjectClass_Members[] =
	{
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "buffer", &hclBufferSetupObjectClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "vertexSelection", &hclVertexSelectionInputClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "updateNormals", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "updateTangents", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "updateBiTangents", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclUpdateVertexFramesSetupObjectClass(
		"hclUpdateVertexFramesSetupObject",
		&hclOperatorSetupObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclUpdateVertexFramesSetupObjectClass_Members),
		HK_COUNT_OF(hclUpdateVertexFramesSetupObjectClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(2)
		);
	static hkInternalClassMember hclDisplayBufferSetupObjectClass_Members[] =
	{
		{ "setupMesh", &hclSetupMeshClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclDisplayBufferSetupObjectClass(
		"hclDisplayBufferSetupObject",
		&hclBufferSetupObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclDisplayBufferSetupObjectClass_Members),
		HK_COUNT_OF(hclDisplayBufferSetupObjectClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclVertexCopySetupObjectClass_Members[] =
	{
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "inputBufferSetupObject", &hclBufferSetupObjectClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "outputBufferSetupObject", &hclBufferSetupObjectClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "copyNormals", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclVertexCopySetupObjectClass(
		"hclVertexCopySetupObject",
		&hclOperatorSetupObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclVertexCopySetupObjectClass_Members),
		HK_COUNT_OF(hclVertexCopySetupObjectClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclSimulateSetupObjectClass_Members[] =
	{
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "simClothSetupObject", &hclSimClothSetupObjectClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "numberOfSubsteps", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "numberOfSolveIterations", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "collideAndSolve", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "explicitConstraintOrder", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "constraintSetExecutionOrder", &hclConstraintSetSetupObjectClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL }
	};
	hkClass hclSimulateSetupObjectClass(
		"hclSimulateSetupObject",
		&hclOperatorSetupObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclSimulateSetupObjectClass_Members),
		HK_COUNT_OF(hclSimulateSetupObjectClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	hkClass hclOperatorSetupObjectClass(
		"hclOperatorSetupObject",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclBendLinkSetupObjectClass_Members[] =
	{
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "simulationMesh", &hclSimulationSetupMeshClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "createStandardLinks", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "vertexSelection", &hclVertexSelectionInputClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "bendStiffness", &hclVertexFloatInputClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "stretchStiffness", &hclVertexFloatInputClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "flatnessFactor", &hclVertexFloatInputClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclBendLinkSetupObjectClass(
		"hclBendLinkSetupObject",
		&hclConstraintSetSetupObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclBendLinkSetupObjectClass_Members),
		HK_COUNT_OF(hclBendLinkSetupObjectClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclMeshMeshDeformSetupObjectClass_Members[] =
	{
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "inputBufferSetupObject", &hclBufferSetupObjectClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "inputTriangleSelection", &hclTriangleSelectionInputClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "outputBufferSetupObject", &hclBufferSetupObjectClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "outputVertexSelection", &hclVertexSelectionInputClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "scaleNormalBehaviour", HK_NULL, hclMeshMeshDeformOperatorScaleNormalBehaviourEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT32, 0, 0, 0, HK_NULL },
		{ "influenceRadius", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxTrianglesPerVertex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "minimumTriangleWeight", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "inputTrianglesSubsetThreshold", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "deformNormals", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "deformTangents", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "deformBiTangents", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclMeshMeshDeformSetupObjectClass(
		"hclMeshMeshDeformSetupObject",
		&hclOperatorSetupObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclMeshMeshDeformSetupObjectClass_Members),
		HK_COUNT_OF(hclMeshMeshDeformSetupObjectClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hclSimulationSetupMeshClass_Members[] =
	{
		{ "originalMesh", &hclSetupMeshClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "mergeOptions", &hclSimulationSetupMeshMapOptionsClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "mergedMeshMap", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "worldFromOriginalMesh", HK_NULL, HK_NULL, hkClassMember::TYPE_MATRIX4, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "worldFromOriginalMeshInvTranspose", HK_NULL, HK_NULL, hkClassMember::TYPE_MATRIX4, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "originalMeshSections", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "haveWorldTransforms", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hclSimulationSetupMeshClass(
		"hclSimulationSetupMesh",
		&hclSetupMeshClass,
		0,
		HK_NULL,
		1,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclSimulationSetupMeshClass_Members),
		HK_COUNT_OF(hclSimulationSetupMeshClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclVolumeConstraintSetupObjectClass_Members[] =
	{
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "simulationMesh", &hclSimulationSetupMeshClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "applyToParticles", &hclVertexSelectionInputClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "stiffness", &hclVertexFloatInputClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "influenceParticles", &hclVertexSelectionInputClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "particleWeights", &hclVertexFloatInputClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "useDeprecatedMethod", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclVolumeConstraintSetupObjectClass(
		"hclVolumeConstraintSetupObject",
		&hclConstraintSetSetupObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclVolumeConstraintSetupObjectClass_Members),
		HK_COUNT_OF(hclVolumeConstraintSetupObjectClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hclStorageSetupMesh_VertexChannelClass_Members[] =
	{
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "type", HK_NULL, hclSetupMeshVertexChannelTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT32, 0, 0, 0, HK_NULL }
	};
	hkClass hclStorageSetupMeshVertexChannelClass(
		"hclStorageSetupMeshVertexChannel",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclStorageSetupMesh_VertexChannelClass_Members),
		HK_COUNT_OF(hclStorageSetupMesh_VertexChannelClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclStorageSetupMesh_EdgeChannelClass_Members[] =
	{
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "type", HK_NULL, hclSetupMeshEdgeChannelTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT32, 0, 0, 0, HK_NULL }
	};
	hkClass hclStorageSetupMeshEdgeChannelClass(
		"hclStorageSetupMeshEdgeChannel",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclStorageSetupMesh_EdgeChannelClass_Members),
		HK_COUNT_OF(hclStorageSetupMesh_EdgeChannelClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclStorageSetupMesh_TriangleChannelClass_Members[] =
	{
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "type", HK_NULL, hclSetupMeshTriangleChannelTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT32, 0, 0, 0, HK_NULL }
	};
	hkClass hclStorageSetupMeshTriangleChannelClass(
		"hclStorageSetupMeshTriangleChannel",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclStorageSetupMesh_TriangleChannelClass_Members),
		HK_COUNT_OF(hclStorageSetupMesh_TriangleChannelClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclStorageSetupMesh_BoneClass_Members[] =
	{
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "boneFromSkin", HK_NULL, HK_NULL, hkClassMember::TYPE_MATRIX4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclStorageSetupMeshBoneClass(
		"hclStorageSetupMeshBone",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclStorageSetupMesh_BoneClass_Members),
		HK_COUNT_OF(hclStorageSetupMesh_BoneClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclStorageSetupMeshClass_Members[] =
	{
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "worldFromMesh", HK_NULL, HK_NULL, hkClassMember::TYPE_MATRIX4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "sections", &hclStorageSetupMeshSectionClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "vertexChannels", &hclStorageSetupMeshVertexChannelClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "edgeChannels", &hclStorageSetupMeshEdgeChannelClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "triangleChannels", &hclStorageSetupMeshTriangleChannelClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "bones", &hclStorageSetupMeshBoneClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "isSkinned", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "stringPool", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hclStorageSetupMeshClass(
		"hclStorageSetupMesh",
		&hclSetupMeshClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclStorageSetupMeshClass_Members),
		HK_COUNT_OF(hclStorageSetupMeshClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(2)
		);
	static hkInternalClassMember hclBendStiffnessSetupObjectClass_Members[] =
	{
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "simulationMesh", &hclSimulationSetupMeshClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "vertexSelection", &hclVertexSelectionInputClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "bendStiffness", &hclVertexFloatInputClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "useRestPoseConfig", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclBendStiffnessSetupObjectClass(
		"hclBendStiffnessSetupObject",
		&hclConstraintSetSetupObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclBendStiffnessSetupObjectClass_Members),
		HK_COUNT_OF(hclBendStiffnessSetupObjectClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hclBlendSetupObjectClass_Members[] =
	{
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "A", &hclBufferSetupObjectClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "B", &hclBufferSetupObjectClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "C", &hclBufferSetupObjectClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "vertexSelection", &hclVertexSelectionInputClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "blendWeights", &hclVertexFloatInputClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "mapToScurve", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "blendNormals", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "blendTangents", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "blendBitangents", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclBlendSetupObjectClass(
		"hclBlendSetupObject",
		&hclOperatorSetupObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclBlendSetupObjectClass_Members),
		HK_COUNT_OF(hclBlendSetupObjectClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hclLocalRangeSetupObjectClass_Members[] =
	{
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "simulationMesh", &hclSimulationSetupMeshClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "referenceBufferSetup", &hclBufferSetupObjectClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "vertexSelection", &hclVertexSelectionInputClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maximumDistance", &hclVertexFloatInputClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "minNormalDistance", &hclVertexFloatInputClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxNormalDistance", &hclVertexFloatInputClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "stiffness", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "useMinNormalDistance", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "useMaxNormalDistance", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclLocalRangeSetupObjectClass(
		"hclLocalRangeSetupObject",
		&hclConstraintSetSetupObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclLocalRangeSetupObjectClass_Members),
		HK_COUNT_OF(hclLocalRangeSetupObjectClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hclClothSetupObjectClass_Members[] =
	{
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "bufferSetupObjects", &hclBufferSetupObjectClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "transformSetSetupObjects", &hclTransformSetSetupObjectClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "simClothSetupObjects", &hclSimClothSetupObjectClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "operatorSetupObjects", &hclOperatorSetupObjectClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "clothStateSetupObjects", &hclClothStateSetupObjectClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL }
	};
	hkClass hclClothSetupObjectClass(
		"hclClothSetupObject",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclClothSetupObjectClass_Members),
		HK_COUNT_OF(hclClothSetupObjectClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclHingeSetupObjectClass_Members[] =
	{
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "simulationMesh", &hclSimulationSetupMeshClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "vertexSelection", &hclVertexSelectionInputClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "hingeStiffness", &hclVertexFloatInputClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "relaxFactor", &hclVertexFloatInputClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclHingeSetupObjectClass(
		"hclHingeSetupObject",
		&hclConstraintSetSetupObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclHingeSetupObjectClass_Members),
		HK_COUNT_OF(hclHingeSetupObjectClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclClothSetupContainerClass_Members[] =
	{
		{ "clothSetupDatas", &hclClothSetupObjectClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "namedSetupMeshWrappers", &hclNamedSetupMeshClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "namedTransformSetWrappers", &hclNamedTransformSetSetupObjectClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL }
	};
	hkClass hclClothSetupContainerClass(
		"hclClothSetupContainer",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclClothSetupContainerClass_Members),
		HK_COUNT_OF(hclClothSetupContainerClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	hkClass hclTransformSetSetupObjectClass(
		"hclTransformSetSetupObject",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclNamedSetupMeshClass_Members[] =
	{
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "meshName", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "setupMesh", &hclSetupMeshClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hclNamedSetupMeshClass(
		"hclNamedSetupMesh",
		&hclSetupMeshClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclNamedSetupMeshClass_Members),
		HK_COUNT_OF(hclNamedSetupMeshClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclSimulationSetupMeshMapOptionsClass_Members[] =
	{
		{ "collapseVertices", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "collapseThreshold", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "vertexSelection", &hclVertexSelectionInputClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclSimulationSetupMeshMapOptionsClass(
		"hclSimulationSetupMeshMapOptions",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclSimulationSetupMeshMapOptionsClass_Members),
		HK_COUNT_OF(hclSimulationSetupMeshMapOptionsClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hclStorageSetupMeshSectionSectionVertexChannelClass(
		"hclStorageSetupMeshSectionSectionVertexChannel",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclStorageSetupMeshSection_SectionVertexSelectionChannelClass_Members[] =
	{
		{ "vertexIndices", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT32, 0, 0, 0, HK_NULL }
	};
	hkClass hclStorageSetupMeshSectionSectionVertexSelectionChannelClass(
		"hclStorageSetupMeshSectionSectionVertexSelectionChannel",
		&hclStorageSetupMeshSectionSectionVertexChannelClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclStorageSetupMeshSection_SectionVertexSelectionChannelClass_Members),
		HK_COUNT_OF(hclStorageSetupMeshSection_SectionVertexSelectionChannelClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclStorageSetupMeshSection_SectionVertexFloatChannelClass_Members[] =
	{
		{ "vertexFloats", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_REAL, 0, 0, 0, HK_NULL }
	};
	hkClass hclStorageSetupMeshSectionSectionVertexFloatChannelClass(
		"hclStorageSetupMeshSectionSectionVertexFloatChannel",
		&hclStorageSetupMeshSectionSectionVertexChannelClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclStorageSetupMeshSection_SectionVertexFloatChannelClass_Members),
		HK_COUNT_OF(hclStorageSetupMeshSection_SectionVertexFloatChannelClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclStorageSetupMeshSection_SectionEdgeSelectionChannelClass_Members[] =
	{
		{ "edgeIndices", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT32, 0, 0, 0, HK_NULL }
	};
	hkClass hclStorageSetupMeshSectionSectionEdgeSelectionChannelClass(
		"hclStorageSetupMeshSectionSectionEdgeSelectionChannel",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclStorageSetupMeshSection_SectionEdgeSelectionChannelClass_Members),
		HK_COUNT_OF(hclStorageSetupMeshSection_SectionEdgeSelectionChannelClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclStorageSetupMeshSection_SectionTriangleSelectionChannelClass_Members[] =
	{
		{ "triangleIndices", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT32, 0, 0, 0, HK_NULL }
	};
	hkClass hclStorageSetupMeshSectionSectionTriangleSelectionChannelClass(
		"hclStorageSetupMeshSectionSectionTriangleSelectionChannel",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclStorageSetupMeshSection_SectionTriangleSelectionChannelClass_Members),
		HK_COUNT_OF(hclStorageSetupMeshSection_SectionTriangleSelectionChannelClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclStorageSetupMeshSection_BoneInfluencesClass_Members[] =
	{
		{ "boneIndices", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT32, 0, 0, 0, HK_NULL },
		{ "weights", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_REAL, 0, 0, 0, HK_NULL }
	};
	hkClass hclStorageSetupMeshSectionBoneInfluencesClass(
		"hclStorageSetupMeshSectionBoneInfluences",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclStorageSetupMeshSection_BoneInfluencesClass_Members),
		HK_COUNT_OF(hclStorageSetupMeshSection_BoneInfluencesClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclStorageSetupMeshSectionClass_Members[] =
	{
		{ "parentSetupMesh", &hclSetupMeshClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "vertices", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VECTOR4, 0, 0, 0, HK_NULL },
		{ "normals", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VECTOR4, 0, 0, 0, HK_NULL },
		{ "tangents", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VECTOR4, 0, 0, 0, HK_NULL },
		{ "bitangents", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VECTOR4, 0, 0, 0, HK_NULL },
		{ "triangles", &hclSetupMeshSectionTriangleClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "sectionVertexChannels", &hclStorageSetupMeshSectionSectionVertexChannelClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "sectionEdgeChannels", &hclStorageSetupMeshSectionSectionEdgeSelectionChannelClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "sectionTriangleChannels", &hclStorageSetupMeshSectionSectionTriangleSelectionChannelClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "boneInfluences", &hclStorageSetupMeshSectionBoneInfluencesClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "normalIDs", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT16, 0, 0, 0, HK_NULL }
	};
	hkClass hclStorageSetupMeshSectionClass(
		"hclStorageSetupMeshSection",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		1,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclStorageSetupMeshSectionClass_Members),
		HK_COUNT_OF(hclStorageSetupMeshSectionClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(2)
		);
	static hkInternalClassMember hclToolNamedObjectReferenceClass_Members[] =
	{
		{ "pluginName", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "objectName", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "hash", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclToolNamedObjectReferenceClass(
		"hclToolNamedObjectReference",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclToolNamedObjectReferenceClass_Members),
		HK_COUNT_OF(hclToolNamedObjectReferenceClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclTransitionSetupObjectClass_Members[] =
	{
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "simulationMesh", &hclSimulationSetupMeshClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "vertexSelection", &hclVertexSelectionInputClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "toAnimDelay", &hclVertexFloatInputClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "toSimDelay", &hclVertexFloatInputClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "toSimMaxDistance", &hclVertexFloatInputClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "toAnimPeriod", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "toSimPeriod", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "referenceBufferSetup", &hclBufferSetupObjectClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hclTransitionSetupObjectClass(
		"hclTransitionSetupObject",
		&hclConstraintSetSetupObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclTransitionSetupObjectClass_Members),
		HK_COUNT_OF(hclTransitionSetupObjectClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hclVertexSelectionInputVertexSelectionTypeEnumItems[] =
	{
		{0, "VERTEX_SELECTION_ALL"},
		{1, "VERTEX_SELECTION_NONE"},
		{2, "VERTEX_SELECTION_CHANNEL"},
		{3, "VERTEX_SELECTION_INVERSE_CHANNEL"},
	};
	static const hkInternalClassEnum hclVertexSelectionInputEnums[] = {
		{"VertexSelectionType", hclVertexSelectionInputVertexSelectionTypeEnumItems, 4, HK_NULL, 0 }
	};
	const hkClassEnum* hclVertexSelectionInputVertexSelectionTypeEnum = reinterpret_cast<const hkClassEnum*>(&hclVertexSelectionInputEnums[0]);
	static hkInternalClassMember hclVertexSelectionInputClass_Members[] =
	{
		{ "type", HK_NULL, hclVertexSelectionInputVertexSelectionTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT32, 0, 0, 0, HK_NULL },
		{ "channelName", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclVertexSelectionInputClass(
		"hclVertexSelectionInput",
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hclVertexSelectionInputEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hclVertexSelectionInputClass_Members),
		HK_COUNT_OF(hclVertexSelectionInputClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclNamedTransformSetSetupObjectClass_Members[] =
	{
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "skelName", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "transformSet", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hclNamedTransformSetSetupObjectClass(
		"hclNamedTransformSetSetupObject",
		&hclTransformSetSetupObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclNamedTransformSetSetupObjectClass_Members),
		HK_COUNT_OF(hclNamedTransformSetSetupObjectClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclMoveFixedParticlesSetupObjectClass_Members[] =
	{
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "simClothSetupObject", &hclSimClothSetupObjectClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "displayBufferSetup", &hclBufferSetupObjectClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hclMoveFixedParticlesSetupObjectClass(
		"hclMoveFixedParticlesSetupObject",
		&hclOperatorSetupObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclMoveFixedParticlesSetupObjectClass_Members),
		HK_COUNT_OF(hclMoveFixedParticlesSetupObjectClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hclTriangleSelectionInputTriangleSelectionTypeEnumItems[] =
	{
		{0, "TRIANGLE_SELECTION_ALL"},
		{1, "TRIANGLE_SELECTION_NONE"},
		{2, "TRIANGLE_SELECTION_CHANNEL"},
		{3, "TRIANGLE_SELECTION_INVERSE_CHANNEL"},
	};
	static const hkInternalClassEnum hclTriangleSelectionInputEnums[] = {
		{"TriangleSelectionType", hclTriangleSelectionInputTriangleSelectionTypeEnumItems, 4, HK_NULL, 0 }
	};
	const hkClassEnum* hclTriangleSelectionInputTriangleSelectionTypeEnum = reinterpret_cast<const hkClassEnum*>(&hclTriangleSelectionInputEnums[0]);
	static hkInternalClassMember hclTriangleSelectionInputClass_Members[] =
	{
		{ "type", HK_NULL, hclTriangleSelectionInputTriangleSelectionTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT32, 0, 0, 0, HK_NULL },
		{ "channelName", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclTriangleSelectionInputClass(
		"hclTriangleSelectionInput",
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hclTriangleSelectionInputEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hclTriangleSelectionInputClass_Members),
		HK_COUNT_OF(hclTriangleSelectionInputClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hclSimClothBufferSetupObjectTypeEnumItems[] =
	{
		{0, "SIM_CLOTH_MESH_CURRENT_POSITIONS"},
		{1, "SIM_CLOTH_MESH_PREVIOUS_POSITIONS"},
		{2, "SIM_CLOTH_MESH_ORIGINAL_POSE"},
	};
	static const hkInternalClassEnum hclSimClothBufferSetupObjectEnums[] = {
		{"Type", hclSimClothBufferSetupObjectTypeEnumItems, 3, HK_NULL, 0 }
	};
	const hkClassEnum* hclSimClothBufferSetupObjectTypeEnum = reinterpret_cast<const hkClassEnum*>(&hclSimClothBufferSetupObjectEnums[0]);
	static hkInternalClassMember hclSimClothBufferSetupObjectClass_Members[] =
	{
		{ "type", HK_NULL, hclSimClothBufferSetupObjectTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT32, 0, 0, 0, HK_NULL },
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "simClothSetupObject", &hclSimClothSetupObjectClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hclSimClothBufferSetupObjectClass(
		"hclSimClothBufferSetupObject",
		&hclBufferSetupObjectClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hclSimClothBufferSetupObjectEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hclSimClothBufferSetupObjectClass_Members),
		HK_COUNT_OF(hclSimClothBufferSetupObjectClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hclSimClothSetupObject_PerInstanceCollidableClass_Members[] =
	{
		{ "collidable", &hclCollidableClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "collidingParticles", &hclVertexSelectionInputClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "drivingBoneName", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "pinchDetectionEnabled", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "pinchDetectionPriority", HK_NULL, HK_NULL, hkClassMember::TYPE_INT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "pinchDetectionRadius", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclSimClothSetupObjectPerInstanceCollidableClass(
		"hclSimClothSetupObjectPerInstanceCollidable",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclSimClothSetupObject_PerInstanceCollidableClass_Members),
		HK_COUNT_OF(hclSimClothSetupObject_PerInstanceCollidableClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(3)
		);
	static hkInternalClassMember hclSimClothSetupObjectClass_Members[] =
	{
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "simulationMesh", &hclSimulationSetupMeshClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "collidableTransformSet", &hclTransformSetSetupObjectClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "gravity", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "globalDampingPerSecond", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "doNormals", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "specifyDensity", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "vertexDensity", &hclVertexFloatInputClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "rescaleMass", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "totalMass", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "particleMass", &hclVertexFloatInputClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "particleRadius", &hclVertexFloatInputClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "particleFriction", &hclVertexFloatInputClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "fixedParticles", &hclVertexSelectionInputClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "enablePinchDetection", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "pinchDetectionEnabledParticles", &hclVertexSelectionInputClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "toAnimPeriod", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "toSimPeriod", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "drivePinchedParticlesToReferenceMesh", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "pinchReferenceBufferSetup", &hclBufferSetupObjectClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "collisionTolerance", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "landscapeCollisionParticleSelection", &hclVertexSelectionInputClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "landscapeCollisionParticleRadius", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "enableStuckParticleDetection", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "stuckParticlesStretchFactor", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "enableLandscapePinchDetection", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "landscapePinchDetectionPriority", HK_NULL, HK_NULL, hkClassMember::TYPE_INT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "landscapePinchDetectionRadius", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "constraintSetSetups", &hclConstraintSetSetupObjectClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "perInstanceCollidables", &hclSimClothSetupObjectPerInstanceCollidableClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "orderMap", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hclSimClothSetupObjectClass(
		"hclSimClothSetupObject",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclSimClothSetupObjectClass_Members),
		HK_COUNT_OF(hclSimClothSetupObjectClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(4)
		);
	static hkInternalClassMember hclSkinSetupObjectClass_Members[] =
	{
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "transformSetSetup", &hclTransformSetSetupObjectClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "referenceBufferSetup", &hclBufferSetupObjectClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "outputBufferSetup", &hclBufferSetupObjectClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "vertexSelection", &hclVertexSelectionInputClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "skinNormals", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "skinTangents", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "skinBiTangents", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "useDualQuaternionMethod", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hclSkinSetupObjectClass(
		"hclSkinSetupObject",
		&hclOperatorSetupObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hclSkinSetupObjectClass_Members),
		HK_COUNT_OF(hclSkinSetupObjectClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkAabbClass_Members[] =
	{
		{ "min", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "max", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkAabbClass(
		"hkAabb",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkAabbClass_Members),
		HK_COUNT_OF(hkAabbClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkAabbUint32Class_Members[] =
	{
		{ "min", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 3, 0|hkClassMember::ALIGN_16, 0, HK_NULL },
		{ "expansionMin", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 3, 0, 0, HK_NULL },
		{ "expansionShift", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "max", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 3, 0, 0, HK_NULL },
		{ "expansionMax", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 3, 0, 0, HK_NULL },
		{ "shapeKeyByte", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkAabbUint32Class(
		"hkAabbUint32",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkAabbUint32Class_Members),
		HK_COUNT_OF(hkAabbUint32Class_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hkLocalFrameClass(
		"hkLocalFrame",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkLocalFrameGroupClass_Members[] =
	{
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkLocalFrameGroupClass(
		"hkLocalFrameGroup",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkLocalFrameGroupClass_Members),
		HK_COUNT_OF(hkLocalFrameGroupClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkSimpleLocalFrameClass_Members[] =
	{
		{ "transform", HK_NULL, HK_NULL, hkClassMember::TYPE_TRANSFORM, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "children", &hkLocalFrameClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "parentFrame", &hkLocalFrameClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0|hkClassMember::NOT_OWNED, 0, HK_NULL },
		{ "group", &hkLocalFrameGroupClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkSimpleLocalFrameClass(
		"hkSimpleLocalFrame",
		&hkLocalFrameClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkSimpleLocalFrameClass_Members),
		HK_COUNT_OF(hkSimpleLocalFrameClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static const hkInternalClassEnumItem hkMultiThreadCheckAccessTypeEnumItems[] =
	{
		{0, "HK_ACCESS_IGNORE"},
		{1, "HK_ACCESS_RO"},
		{2, "HK_ACCESS_RW"},
	};
	static const hkInternalClassEnumItem hkMultiThreadCheckReadModeEnumItems[] =
	{
		{0, "THIS_OBJECT_ONLY"},
		{1, "RECURSIVE"},
	};
	static const hkInternalClassEnum hkMultiThreadCheckEnums[] = {
		{"AccessType", hkMultiThreadCheckAccessTypeEnumItems, 3, HK_NULL, 0 },
		{"ReadMode", hkMultiThreadCheckReadModeEnumItems, 2, HK_NULL, 0 }
	};
	const hkClassEnum* hkMultiThreadCheckAccessTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkMultiThreadCheckEnums[0]);
	const hkClassEnum* hkMultiThreadCheckReadModeEnum = reinterpret_cast<const hkClassEnum*>(&hkMultiThreadCheckEnums[1]);
	static hkInternalClassMember hkMultiThreadCheckClass_Members[] =
	{
		{ "threadId", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "stackTraceId", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "markCount", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "markBitStack", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hkMultiThreadCheckClass(
		"hkMultiThreadCheck",
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkMultiThreadCheckEnums),
		2,
		reinterpret_cast<const hkClassMember*>(hkMultiThreadCheckClass_Members),
		HK_COUNT_OF(hkMultiThreadCheckClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkClassMemberTypeEnumItems[] =
	{
		{0, "TYPE_VOID"},
		{1, "TYPE_BOOL"},
		{2, "TYPE_CHAR"},
		{3, "TYPE_INT8"},
		{4, "TYPE_UINT8"},
		{5, "TYPE_INT16"},
		{6, "TYPE_UINT16"},
		{7, "TYPE_INT32"},
		{8, "TYPE_UINT32"},
		{9, "TYPE_INT64"},
		{10, "TYPE_UINT64"},
		{11, "TYPE_REAL"},
		{12, "TYPE_VECTOR4"},
		{13, "TYPE_QUATERNION"},
		{14, "TYPE_MATRIX3"},
		{15, "TYPE_ROTATION"},
		{16, "TYPE_QSTRANSFORM"},
		{17, "TYPE_MATRIX4"},
		{18, "TYPE_TRANSFORM"},
		{19, "TYPE_ZERO"},
		{20, "TYPE_POINTER"},
		{21, "TYPE_FUNCTIONPOINTER"},
		{22, "TYPE_ARRAY"},
		{23, "TYPE_INPLACEARRAY"},
		{24, "TYPE_ENUM"},
		{25, "TYPE_STRUCT"},
		{26, "TYPE_SIMPLEARRAY"},
		{27, "TYPE_HOMOGENEOUSARRAY"},
		{28, "TYPE_VARIANT"},
		{29, "TYPE_CSTRING"},
		{30, "TYPE_ULONG"},
		{31, "TYPE_FLAGS"},
		{32, "TYPE_HALF"},
		{33, "TYPE_STRINGPTR"},
		{34, "TYPE_RELARRAY"},
		{35, "TYPE_MAX"},
	};
	static const hkInternalClassEnumItem hkClassMemberFlagValuesEnumItems[] =
	{
		{0, "FLAGS_NONE"},
		{128, "ALIGN_8"},
		{256, "ALIGN_16"},
		{512, "NOT_OWNED"},
		{1024, "SERIALIZE_IGNORED"},
	};
	static const hkInternalClassEnumItem hkClassMemberDeprecatedFlagValuesEnumItems[] =
	{
		{8, "DEPRECATED_SIZE_8"},
		{8, "DEPRECATED_ENUM_8"},
		{16, "DEPRECATED_SIZE_16"},
		{16, "DEPRECATED_ENUM_16"},
		{32, "DEPRECATED_SIZE_32"},
		{32, "DEPRECATED_ENUM_32"},
	};
	static const hkInternalClassEnum hkClassMemberEnums[] = {
		{"Type", hkClassMemberTypeEnumItems, 36, HK_NULL, 0 },
		{"FlagValues", hkClassMemberFlagValuesEnumItems, 5, HK_NULL, 0 },
		{"DeprecatedFlagValues", hkClassMemberDeprecatedFlagValuesEnumItems, 6, HK_NULL, 0 }
	};
	const hkClassEnum* hkClassMemberTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkClassMemberEnums[0]);
	const hkClassEnum* hkClassMemberFlagValuesEnum = reinterpret_cast<const hkClassEnum*>(&hkClassMemberEnums[1]);
	const hkClassEnum* hkClassMemberDeprecatedFlagValuesEnum = reinterpret_cast<const hkClassEnum*>(&hkClassMemberEnums[2]);
	static hkInternalClassMember hkClassMemberClass_Members[] =
	{
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_CSTRING, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "class", &hkClassClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "enum", &hkClassEnumClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "type", HK_NULL, hkClassMemberTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "subtype", HK_NULL, hkClassMemberTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "cArraySize", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "flags", HK_NULL, hkClassMemberFlagValuesEnum, hkClassMember::TYPE_FLAGS, hkClassMember::TYPE_UINT16, 0, 0, 0, HK_NULL },
		{ "offset", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "attributes", &hkCustomAttributesClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hkClassMemberClass(
		"hkClassMember",
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkClassMemberEnums),
		3,
		reinterpret_cast<const hkClassMember*>(hkClassMemberClass_Members),
		HK_COUNT_OF(hkClassMemberClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkGeometry_TriangleClass_Members[] =
	{
		{ "a", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "b", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "c", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "material", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkGeometryTriangleClass(
		"hkGeometryTriangle",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkGeometry_TriangleClass_Members),
		HK_COUNT_OF(hkGeometry_TriangleClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkGeometryClass_Members[] =
	{
		{ "vertices", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VECTOR4, 0, 0, 0, HK_NULL },
		{ "triangles", &hkGeometryTriangleClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkGeometryClass(
		"hkGeometry",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkGeometryClass_Members),
		HK_COUNT_OF(hkGeometryClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkSweptTransformClass_Members[] =
	{
		{ "centerOfMass0", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "centerOfMass1", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "rotation0", HK_NULL, HK_NULL, hkClassMember::TYPE_QUATERNION, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "rotation1", HK_NULL, HK_NULL, hkClassMember::TYPE_QUATERNION, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "centerOfMassLocal", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkSweptTransformClass(
		"hkSweptTransform",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkSweptTransformClass_Members),
		HK_COUNT_OF(hkSweptTransformClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkColorExtendedColorsEnumItems[] =
	{
		{4286578688u, "MAROON"},
		{4287299584u, "DARKRED"},
		{4294901760u, "RED"},
		{4294948545u, "LIGHTPINK"},
		{4292613180u, "CRIMSON"},
		{4292571283u, "PALEVIOLETRED"},
		{4294928820u, "HOTPINK"},
		{4294907027u, "DEEPPINK"},
		{4291237253u, "MEDIUMVIOLETRED"},
		{4286578816u, "PURPLE"},
		{4287299723u, "DARKMAGENTA"},
		{4292505814u, "ORCHID"},
		{4292394968u, "THISTLE"},
		{4292714717u, "PLUM"},
		{4293821166u, "VIOLET"},
		{4294902015u, "FUCHSIA"},
		{4294902015u, "MAGENTA"},
		{4290401747u, "MEDIUMORCHID"},
		{4287889619u, "DARKVIOLET"},
		{4288230092u, "DARKORCHID"},
		{4287245282u, "BLUEVIOLET"},
		{4283105410u, "INDIGO"},
		{4287852763u, "MEDIUMPURPLE"},
		{4285160141u, "SLATEBLUE"},
		{4286277870u, "MEDIUMSLATEBLUE"},
		{4278190219u, "DARKBLUE"},
		{4278190285u, "MEDIUMBLUE"},
		{4278190335u, "BLUE"},
		{4278190208u, "NAVY"},
		{4279834992u, "MIDNIGHTBLUE"},
		{4282924427u, "DARKSLATEBLUE"},
		{4282477025u, "ROYALBLUE"},
		{4284782061u, "CORNFLOWERBLUE"},
		{4289774814u, "LIGHTSTEELBLUE"},
		{4293982463u, "ALICEBLUE"},
		{4294506751u, "GHOSTWHITE"},
		{4293322490u, "LAVENDER"},
		{4280193279u, "DODGERBLUE"},
		{4282811060u, "STEELBLUE"},
		{4278239231u, "DEEPSKYBLUE"},
		{4285563024u, "SLATEGRAY"},
		{4286023833u, "LIGHTSLATEGRAY"},
		{4287090426u, "LIGHTSKYBLUE"},
		{4287090411u, "SKYBLUE"},
		{4289583334u, "LIGHTBLUE"},
		{4278222976u, "TEAL"},
		{4278225803u, "DARKCYAN"},
		{4278243025u, "DARKTURQUOISE"},
		{4278255615u, "CYAN"},
		{4282962380u, "MEDIUMTURQUOISE"},
		{4284456608u, "CADETBLUE"},
		{4289720046u, "PALETURQUOISE"},
		{4292935679u, "LIGHTCYAN"},
		{4293984255u, "AZURE"},
		{4280332970u, "LIGHTSEAGREEN"},
		{4282441936u, "TURQUOISE"},
		{4289781990u, "POWDERBLUE"},
		{4281290575u, "DARKSLATEGRAY"},
		{4286578644u, "AQUAMARINE"},
		{4278254234u, "MEDIUMSPRINGGREEN"},
		{4284927402u, "MEDIUMAQUAMARINE"},
		{4278255487u, "SPRINGGREEN"},
		{4282168177u, "MEDIUMSEAGREEN"},
		{4281240407u, "SEAGREEN"},
		{4281519410u, "LIMEGREEN"},
		{4278215680u, "DARKGREEN"},
		{4278222848u, "GREEN"},
		{4278255360u, "LIME"},
		{4280453922u, "FORESTGREEN"},
		{4287609999u, "DARKSEAGREEN"},
		{4287688336u, "LIGHTGREEN"},
		{4288215960u, "PALEGREEN"},
		{4294311930u, "MINTCREAM"},
		{4293984240u, "HONEYDEW"},
		{4286578432u, "CHARTREUSE"},
		{4286381056u, "LAWNGREEN"},
		{4285238819u, "OLIVEDRAB"},
		{4283788079u, "DARKOLIVEGREEN"},
		{4288335154u, "YELLOWGREEN"},
		{4289593135u, "GREENYELLOW"},
		{4294309340u, "BEIGE"},
		{4294635750u, "LINEN"},
		{4294638290u, "LIGHTGOLDENRODYELLOW"},
		{4286611456u, "OLIVE"},
		{4294967040u, "YELLOW"},
		{4294967264u, "LIGHTYELLOW"},
		{4294967280u, "IVORY"},
		{4290623339u, "DARKKHAKI"},
		{4293977740u, "KHAKI"},
		{4293847210u, "PALEGOLDENROD"},
		{4294303411u, "WHEAT"},
		{4294956800u, "GOLD"},
		{4294965965u, "LEMONCHIFFON"},
		{4294963157u, "PAPAYAWHIP"},
		{4290283019u, "DARKGOLDENROD"},
		{4292519200u, "GOLDENROD"},
		{4294634455u, "ANTIQUEWHITE"},
		{4294965468u, "CORNSILK"},
		{4294833638u, "OLDLACE"},
		{4294960309u, "MOCCASIN"},
		{4294958765u, "NAVAJOWHITE"},
		{4294944000u, "ORANGE"},
		{4294960324u, "BISQUE"},
		{4291998860u, "TAN"},
		{4294937600u, "DARKORANGE"},
		{4292786311u, "BURLYWOOD"},
		{4287317267u, "SADDLEBROWN"},
		{4294222944u, "SANDYBROWN"},
		{4294962125u, "BLANCHEDALMOND"},
		{4294963445u, "LAVENDERBLUSH"},
		{4294964718u, "SEASHELL"},
		{4294966000u, "FLORALWHITE"},
		{4294966010u, "SNOW"},
		{4291659071u, "PERU"},
		{4294957753u, "PEACHPUFF"},
		{4291979550u, "CHOCOLATE"},
		{4288696877u, "SIENNA"},
		{4294942842u, "LIGHTSALMON"},
		{4294934352u, "CORAL"},
		{4293498490u, "DARKSALMON"},
		{4294960353u, "MISTYROSE"},
		{4294919424u, "ORANGERED"},
		{4294606962u, "SALMON"},
		{4294927175u, "TOMATO"},
		{4290547599u, "ROSYBROWN"},
		{4294951115u, "PINK"},
		{4291648604u, "INDIANRED"},
		{4293951616u, "LIGHTCORAL"},
		{4289014314u, "BROWN"},
		{4289864226u, "FIREBRICK"},
		{4278190080u, "BLACK"},
		{4285098345u, "DIMGRAY"},
		{4286611584u, "GRAY"},
		{4289309097u, "DARKGRAY"},
		{4290822336u, "SILVER"},
		{4292072403u, "LIGHTGREY"},
		{4292664540u, "GAINSBORO"},
		{4294309365u, "WHITESMOKE"},
		{4294967295u, "WHITE"},
		{4287137928u, "GREY"},
		{4282400832u, "GREY25"},
		{4286611584u, "GREY50"},
		{4290822336u, "GREY75"},
	};
	static const hkInternalClassEnum hkColorEnums[] = {
		{"ExtendedColors", hkColorExtendedColorsEnumItems, 143, HK_NULL, 0 }
	};
	const hkClassEnum* hkColorExtendedColorsEnum = reinterpret_cast<const hkClassEnum*>(&hkColorEnums[0]);
	hkClass hkColorClass(
		"hkColor",
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkColorEnums),
		1,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkQTransformClass_Members[] =
	{
		{ "rotation", HK_NULL, HK_NULL, hkClassMember::TYPE_QUATERNION, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "translation", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkQTransformClass(
		"hkQTransform",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkQTransformClass_Members),
		HK_COUNT_OF(hkQTransformClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkFloat16Class_Members[] =
	{
		{ "value", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkFloat16Class(
		"hkFloat16",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkFloat16Class_Members),
		HK_COUNT_OF(hkFloat16Class_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkRefCountedProperties_EntryClass_Members[] =
	{
		{ "object", &hkReferencedObjectClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "key", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "flags", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkRefCountedPropertiesEntryClass(
		"hkRefCountedPropertiesEntry",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkRefCountedProperties_EntryClass_Members),
		HK_COUNT_OF(hkRefCountedProperties_EntryClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkRefCountedPropertiesClass_Members[] =
	{
		{ "entries", &hkRefCountedPropertiesEntryClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkRefCountedPropertiesClass(
		"hkRefCountedProperties",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkRefCountedPropertiesClass_Members),
		HK_COUNT_OF(hkRefCountedPropertiesClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkContactPointMaterialFlagEnumEnumItems[] =
	{
		{1, "CONTACT_IS_NEW"},
		{2, "CONTACT_USES_SOLVER_PATH2"},
		{4, "CONTACT_BREAKOFF_OBJECT_ID"},
		{8, "CONTACT_IS_DISABLED"},
	};
	static const hkInternalClassEnum hkContactPointMaterialEnums[] = {
		{"FlagEnum", hkContactPointMaterialFlagEnumEnumItems, 4, HK_NULL, 0 }
	};
	const hkClassEnum* hkContactPointMaterialFlagEnumEnum = reinterpret_cast<const hkClassEnum*>(&hkContactPointMaterialEnums[0]);
	static hkInternalClassMember hkContactPointMaterialClass_Members[] =
	{
		{ "userData", HK_NULL, HK_NULL, hkClassMember::TYPE_ULONG, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "friction", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "restitution", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxImpulse", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "flags", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkContactPointMaterial_DefaultStruct
		{
			int s_defaultOffsets[5];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
		};
		const hkContactPointMaterial_DefaultStruct hkContactPointMaterial_Default =
		{
			{hkClassMember::HK_CLASS_ZERO_DEFAULT,-1,-1,-1,-1},
		};
	}
	hkClass hkContactPointMaterialClass(
		"hkContactPointMaterial",
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkContactPointMaterialEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkContactPointMaterialClass_Members),
		HK_COUNT_OF(hkContactPointMaterialClass_Members),
		&hkContactPointMaterial_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkContactPointClass_Members[] =
	{
		{ "position", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "separatingNormal", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkContactPointClass(
		"hkContactPoint",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkContactPointClass_Members),
		HK_COUNT_OF(hkContactPointClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkSphereClass_Members[] =
	{
		{ "pos", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkSphereClass(
		"hkSphere",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkSphereClass_Members),
		HK_COUNT_OF(hkSphereClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkPackedVector3Class_Members[] =
	{
		{ "values", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 4, 0|hkClassMember::ALIGN_8, 0, HK_NULL }
	};
	hkClass hkPackedVector3Class(
		"hkPackedVector3",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkPackedVector3Class_Members),
		HK_COUNT_OF(hkPackedVector3Class_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkMotionStateClass_Members[] =
	{
		{ "transform", HK_NULL, HK_NULL, hkClassMember::TYPE_TRANSFORM, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "sweptTransform", &hkSweptTransformClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "deltaAngle", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "objectRadius", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "linearDamping", HK_NULL, HK_NULL, hkClassMember::TYPE_HALF, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "angularDamping", HK_NULL, HK_NULL, hkClassMember::TYPE_HALF, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "timeFactor", HK_NULL, HK_NULL, hkClassMember::TYPE_HALF, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxLinearVelocity", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxAngularVelocity", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "deactivationClass", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkMotionStateClass(
		"hkMotionState",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkMotionStateClass_Members),
		HK_COUNT_OF(hkMotionStateClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkCustomAttributes_AttributeClass_Members[] =
	{
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_CSTRING, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "value", HK_NULL, HK_NULL, hkClassMember::TYPE_VARIANT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkCustomAttributesAttributeClass(
		"hkCustomAttributesAttribute",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkCustomAttributes_AttributeClass_Members),
		HK_COUNT_OF(hkCustomAttributes_AttributeClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkCustomAttributesClass_Members[] =
	{
		{ "attributes", &hkCustomAttributesAttributeClass, HK_NULL, hkClassMember::TYPE_SIMPLEARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkCustomAttributesClass(
		"hkCustomAttributes",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkCustomAttributesClass_Members),
		HK_COUNT_OF(hkCustomAttributesClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkFloat16TransformClass_Members[] =
	{
		{ "elements", &hkFloat16Class, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 12, 0, 0, HK_NULL }
	};
	hkClass hkFloat16TransformClass(
		"hkFloat16Transform",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkFloat16TransformClass_Members),
		HK_COUNT_OF(hkFloat16TransformClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkClassSignatureFlagsEnumItems[] =
	{
		{1, "SIGNATURE_LOCAL"},
	};
	static const hkInternalClassEnumItem hkClassFlagValuesEnumItems[] =
	{
		{0, "FLAGS_NONE"},
		{1, "FLAGS_NOT_SERIALIZABLE"},
	};
	static const hkInternalClassEnum hkClassEnums[] = {
		{"SignatureFlags", hkClassSignatureFlagsEnumItems, 1, HK_NULL, 0 },
		{"FlagValues", hkClassFlagValuesEnumItems, 2, HK_NULL, 0 }
	};
	const hkClassEnum* hkClassSignatureFlagsEnum = reinterpret_cast<const hkClassEnum*>(&hkClassEnums[0]);
	const hkClassEnum* hkClassFlagValuesEnum = reinterpret_cast<const hkClassEnum*>(&hkClassEnums[1]);
	static hkInternalClassMember hkClassClass_Members[] =
	{
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_CSTRING, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "parent", &hkClassClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "objectSize", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "numImplementedInterfaces", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "declaredEnums", &hkClassEnumClass, HK_NULL, hkClassMember::TYPE_SIMPLEARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "declaredMembers", &hkClassMemberClass, HK_NULL, hkClassMember::TYPE_SIMPLEARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "defaults", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "attributes", &hkCustomAttributesClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "flags", HK_NULL, hkClassFlagValuesEnum, hkClassMember::TYPE_FLAGS, hkClassMember::TYPE_UINT32, 0, 0, 0, HK_NULL },
		{ "describedVersion", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkClassClass(
		"hkClass",
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkClassEnums),
		2,
		reinterpret_cast<const hkClassMember*>(hkClassClass_Members),
		HK_COUNT_OF(hkClassClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkFourTransposedPointsClass_Members[] =
	{
		{ "vertices", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 3, 0, 0, HK_NULL }
	};
	hkClass hkFourTransposedPointsClass(
		"hkFourTransposedPoints",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkFourTransposedPointsClass_Members),
		HK_COUNT_OF(hkFourTransposedPointsClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hkBaseObjectClass(
		"hkBaseObject",
		HK_NULL,
		0,
		HK_NULL,
		1,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkReferencedObjectClass_Members[] =
	{
		{ "memSizeAndFlags", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "referenceCount", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hkReferencedObjectClass(
		"hkReferencedObject",
		&hkBaseObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkReferencedObjectClass_Members),
		HK_COUNT_OF(hkReferencedObjectClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkMonitorStreamStringMap_StringMapClass_Members[] =
	{
		{ "id", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT64, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::ALIGN_8, 0, HK_NULL },
		{ "string", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkMonitorStreamStringMapStringMapClass(
		"hkMonitorStreamStringMapStringMap",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkMonitorStreamStringMap_StringMapClass_Members),
		HK_COUNT_OF(hkMonitorStreamStringMap_StringMapClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkMonitorStreamStringMapClass_Members[] =
	{
		{ "map", &hkMonitorStreamStringMapStringMapClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkMonitorStreamStringMapClass(
		"hkMonitorStreamStringMap",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkMonitorStreamStringMapClass_Members),
		HK_COUNT_OF(hkMonitorStreamStringMapClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkMonitorStreamFrameInfoAbsoluteTimeCounterEnumItems[] =
	{
		{0, "ABSOLUTE_TIME_TIMER_0"},
		{1, "ABSOLUTE_TIME_TIMER_1"},
		{-1, "ABSOLUTE_TIME_NOT_TIMED"},
	};
	static const hkInternalClassEnum hkMonitorStreamFrameInfoEnums[] = {
		{"AbsoluteTimeCounter", hkMonitorStreamFrameInfoAbsoluteTimeCounterEnumItems, 3, HK_NULL, 0 }
	};
	const hkClassEnum* hkMonitorStreamFrameInfoAbsoluteTimeCounterEnum = reinterpret_cast<const hkClassEnum*>(&hkMonitorStreamFrameInfoEnums[0]);
	static hkInternalClassMember hkMonitorStreamFrameInfoClass_Members[] =
	{
		{ "heading", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "indexOfTimer0", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "indexOfTimer1", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "absoluteTimeCounter", HK_NULL, hkMonitorStreamFrameInfoAbsoluteTimeCounterEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT32, 0, 0, 0, HK_NULL },
		{ "timerFactor0", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "timerFactor1", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "threadId", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "frameStreamStart", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "frameStreamEnd", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkMonitorStreamFrameInfoClass(
		"hkMonitorStreamFrameInfo",
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkMonitorStreamFrameInfoEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkMonitorStreamFrameInfoClass_Members),
		HK_COUNT_OF(hkMonitorStreamFrameInfoClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkMonitorStreamColorTable_ColorPairClass_Members[] =
	{
		{ "colorName", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "color", HK_NULL, hkColorExtendedColorsEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT32, 0, 0, 0, HK_NULL }
	};
	hkClass hkMonitorStreamColorTableColorPairClass(
		"hkMonitorStreamColorTableColorPair",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkMonitorStreamColorTable_ColorPairClass_Members),
		HK_COUNT_OF(hkMonitorStreamColorTable_ColorPairClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkMonitorStreamColorTableClass_Members[] =
	{
		{ "colorPairs", &hkMonitorStreamColorTableColorPairClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "defaultColor", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkMonitorStreamColorTableClass(
		"hkMonitorStreamColorTable",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkMonitorStreamColorTableClass_Members),
		HK_COUNT_OF(hkMonitorStreamColorTableClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkClassEnumFlagValuesEnumItems[] =
	{
		{0, "FLAGS_NONE"},
	};
	static const hkInternalClassEnum hkClassEnumEnums[] = {
		{"FlagValues", hkClassEnumFlagValuesEnumItems, 1, HK_NULL, 0 }
	};
	const hkClassEnum* hkClassEnumFlagValuesEnum = reinterpret_cast<const hkClassEnum*>(&hkClassEnumEnums[0]);
	static hkInternalClassMember hkClassEnum_ItemClass_Members[] =
	{
		{ "value", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_CSTRING, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkClassEnumItemClass(
		"hkClassEnumItem",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkClassEnum_ItemClass_Members),
		HK_COUNT_OF(hkClassEnum_ItemClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkClassEnumClass_Members[] =
	{
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_CSTRING, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "items", &hkClassEnumItemClass, HK_NULL, hkClassMember::TYPE_SIMPLEARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "attributes", &hkCustomAttributesClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "flags", HK_NULL, hkClassEnumFlagValuesEnum, hkClassMember::TYPE_FLAGS, hkClassMember::TYPE_UINT32, 0, 0, 0, HK_NULL }
	};
	hkClass hkClassEnumClass(
		"hkClassEnum",
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkClassEnumEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkClassEnumClass_Members),
		HK_COUNT_OF(hkClassEnumClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkBitFieldClass_Members[] =
	{
		{ "words", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT32, 0, 0, 0, HK_NULL },
		{ "numBits", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkBitFieldClass(
		"hkBitField",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkBitFieldClass_Members),
		HK_COUNT_OF(hkBitFieldClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkRangeRealAttributeClass_Members[] =
	{
		{ "absmin", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "absmax", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "softmin", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "softmax", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkRangeRealAttributeClass(
		"hkRangeRealAttribute",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkRangeRealAttributeClass_Members),
		HK_COUNT_OF(hkRangeRealAttributeClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkRangeInt32AttributeClass_Members[] =
	{
		{ "absmin", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "absmax", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "softmin", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "softmax", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkRangeInt32AttributeClass(
		"hkRangeInt32Attribute",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkRangeInt32AttributeClass_Members),
		HK_COUNT_OF(hkRangeInt32AttributeClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkUiAttributeHideInModelerEnumItems[] =
	{
		{0, "NONE"},
		{1, "MAX"},
		{2, "MAYA"},
	};
	static const hkInternalClassEnum hkUiAttributeEnums[] = {
		{"HideInModeler", hkUiAttributeHideInModelerEnumItems, 3, HK_NULL, 0 }
	};
	const hkClassEnum* hkUiAttributeHideInModelerEnum = reinterpret_cast<const hkClassEnum*>(&hkUiAttributeEnums[0]);
	static hkInternalClassMember hkUiAttributeClass_Members[] =
	{
		{ "visible", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "hideInModeler", HK_NULL, hkUiAttributeHideInModelerEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL },
		{ "label", HK_NULL, HK_NULL, hkClassMember::TYPE_CSTRING, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "group", HK_NULL, HK_NULL, hkClassMember::TYPE_CSTRING, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "hideBaseClassMembers", HK_NULL, HK_NULL, hkClassMember::TYPE_CSTRING, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "endGroup", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "endGroup2", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "advanced", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkUiAttributeClass(
		"hkUiAttribute",
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkUiAttributeEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkUiAttributeClass_Members),
		HK_COUNT_OF(hkUiAttributeClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(2)
		);
	static const hkInternalClassEnumItem hkGizmoAttributeGizmoTypeEnumItems[] =
	{
		{0, "POINT"},
		{1, "SPHERE"},
		{2, "PLANE"},
		{3, "ARROW"},
	};
	static const hkInternalClassEnum hkGizmoAttributeEnums[] = {
		{"GizmoType", hkGizmoAttributeGizmoTypeEnumItems, 4, HK_NULL, 0 }
	};
	const hkClassEnum* hkGizmoAttributeGizmoTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkGizmoAttributeEnums[0]);
	static hkInternalClassMember hkGizmoAttributeClass_Members[] =
	{
		{ "visible", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "label", HK_NULL, HK_NULL, hkClassMember::TYPE_CSTRING, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "type", HK_NULL, hkGizmoAttributeGizmoTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL }
	};
	hkClass hkGizmoAttributeClass(
		"hkGizmoAttribute",
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkGizmoAttributeEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkGizmoAttributeClass_Members),
		HK_COUNT_OF(hkGizmoAttributeClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkModelerNodeTypeAttributeModelerTypeEnumItems[] =
	{
		{0, "DEFAULT"},
		{1, "LOCATOR"},
	};
	static const hkInternalClassEnum hkModelerNodeTypeAttributeEnums[] = {
		{"ModelerType", hkModelerNodeTypeAttributeModelerTypeEnumItems, 2, HK_NULL, 0 }
	};
	const hkClassEnum* hkModelerNodeTypeAttributeModelerTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkModelerNodeTypeAttributeEnums[0]);
	static hkInternalClassMember hkModelerNodeTypeAttributeClass_Members[] =
	{
		{ "type", HK_NULL, hkModelerNodeTypeAttributeModelerTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL }
	};
	hkClass hkModelerNodeTypeAttributeClass(
		"hkModelerNodeTypeAttribute",
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkModelerNodeTypeAttributeEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkModelerNodeTypeAttributeClass_Members),
		HK_COUNT_OF(hkModelerNodeTypeAttributeClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkLinkAttributeLinkEnumItems[] =
	{
		{0, "NONE"},
		{1, "DIRECT_LINK"},
		{2, "CHILD"},
		{3, "MESH"},
		{4, "PARENT_NAME"},
	};
	static const hkInternalClassEnum hkLinkAttributeEnums[] = {
		{"Link", hkLinkAttributeLinkEnumItems, 5, HK_NULL, 0 }
	};
	const hkClassEnum* hkLinkAttributeLinkEnum = reinterpret_cast<const hkClassEnum*>(&hkLinkAttributeEnums[0]);
	static hkInternalClassMember hkLinkAttributeClass_Members[] =
	{
		{ "type", HK_NULL, hkLinkAttributeLinkEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL }
	};
	hkClass hkLinkAttributeClass(
		"hkLinkAttribute",
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkLinkAttributeEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkLinkAttributeClass_Members),
		HK_COUNT_OF(hkLinkAttributeClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkSemanticsAttributeSemanticsEnumItems[] =
	{
		{0, "UNKNOWN"},
		{1, "DISTANCE"},
		{2, "ANGLE"},
		{3, "NORMAL"},
		{4, "POSITION"},
		{5, "COSINE_ANGLE"},
	};
	static const hkInternalClassEnum hkSemanticsAttributeEnums[] = {
		{"Semantics", hkSemanticsAttributeSemanticsEnumItems, 6, HK_NULL, 0 }
	};
	const hkClassEnum* hkSemanticsAttributeSemanticsEnum = reinterpret_cast<const hkClassEnum*>(&hkSemanticsAttributeEnums[0]);
	static hkInternalClassMember hkSemanticsAttributeClass_Members[] =
	{
		{ "type", HK_NULL, hkSemanticsAttributeSemanticsEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL }
	};
	hkClass hkSemanticsAttributeClass(
		"hkSemanticsAttribute",
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkSemanticsAttributeEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkSemanticsAttributeClass_Members),
		HK_COUNT_OF(hkSemanticsAttributeClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkDescriptionAttributeClass_Members[] =
	{
		{ "string", HK_NULL, HK_NULL, hkClassMember::TYPE_CSTRING, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkDescriptionAttributeClass(
		"hkDescriptionAttribute",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkDescriptionAttributeClass_Members),
		HK_COUNT_OF(hkDescriptionAttributeClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkArrayTypeAttributeArrayTypeEnumItems[] =
	{
		{0, "NONE"},
		{1, "POINTSOUP"},
		{2, "ENTITIES"},
	};
	static const hkInternalClassEnum hkArrayTypeAttributeEnums[] = {
		{"ArrayType", hkArrayTypeAttributeArrayTypeEnumItems, 3, HK_NULL, 0 }
	};
	const hkClassEnum* hkArrayTypeAttributeArrayTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkArrayTypeAttributeEnums[0]);
	static hkInternalClassMember hkArrayTypeAttributeClass_Members[] =
	{
		{ "type", HK_NULL, hkArrayTypeAttributeArrayTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL }
	};
	hkClass hkArrayTypeAttributeClass(
		"hkArrayTypeAttribute",
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkArrayTypeAttributeEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkArrayTypeAttributeClass_Members),
		HK_COUNT_OF(hkArrayTypeAttributeClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkDataObjectTypeAttributeClass_Members[] =
	{
		{ "typeName", HK_NULL, HK_NULL, hkClassMember::TYPE_CSTRING, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkDataObjectTypeAttributeClass(
		"hkDataObjectTypeAttribute",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkDataObjectTypeAttributeClass_Members),
		HK_COUNT_OF(hkDataObjectTypeAttributeClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkDocumentationAttributeClass_Members[] =
	{
		{ "docsSectionTag", HK_NULL, HK_NULL, hkClassMember::TYPE_CSTRING, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkDocumentationAttributeClass(
		"hkDocumentationAttribute",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkDocumentationAttributeClass_Members),
		HK_COUNT_OF(hkDocumentationAttributeClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkPostFinishAttributeClass_Members[] =
	{
		{ "postFinishFunction", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hkPostFinishAttributeClass(
		"hkPostFinishAttribute",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkPostFinishAttributeClass_Members),
		HK_COUNT_OF(hkPostFinishAttributeClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkAabbHalfClass_Members[] =
	{
		{ "data", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 6, 0, 0, HK_NULL },
		{ "extras", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 2, 0, 0, HK_NULL }
	};
	hkClass hkAabbHalfClass(
		"hkAabbHalf",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkAabbHalfClass_Members),
		HK_COUNT_OF(hkAabbHalfClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hkMeshMaterialClass(
		"hkMeshMaterial",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkMeshSectionMeshSectionIndexTypeEnumItems[] =
	{
		{0, "INDEX_TYPE_NONE"},
		{1, "INDEX_TYPE_UINT16"},
		{2, "INDEX_TYPE_UINT32"},
	};
	static const hkInternalClassEnumItem hkMeshSectionPrimitiveTypeEnumItems[] =
	{
		{0, "PRIMITIVE_TYPE_UNKNOWN"},
		{1, "PRIMITIVE_TYPE_POINT_LIST"},
		{2, "PRIMITIVE_TYPE_LINE_LIST"},
		{3, "PRIMITIVE_TYPE_TRIANGLE_LIST"},
		{4, "PRIMITIVE_TYPE_TRIANGLE_STRIP"},
	};
	static const hkInternalClassEnum hkMeshSectionEnums[] = {
		{"MeshSectionIndexType", hkMeshSectionMeshSectionIndexTypeEnumItems, 3, HK_NULL, 0 },
		{"PrimitiveType", hkMeshSectionPrimitiveTypeEnumItems, 5, HK_NULL, 0 }
	};
	const hkClassEnum* hkMeshSectionMeshSectionIndexTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkMeshSectionEnums[0]);
	const hkClassEnum* hkMeshSectionPrimitiveTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkMeshSectionEnums[1]);
	static hkInternalClassMember hkMeshSectionClass_Members[] =
	{
		{ "primitiveType", HK_NULL, hkMeshSectionPrimitiveTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "numPrimitives", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "numIndices", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "vertexStartIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "transformIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "indexType", HK_NULL, hkMeshSectionMeshSectionIndexTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "indices", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "vertexBuffer", &hkMeshVertexBufferClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "material", &hkMeshMaterialClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "sectionIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkMeshSectionClass(
		"hkMeshSection",
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkMeshSectionEnums),
		2,
		reinterpret_cast<const hkClassMember*>(hkMeshSectionClass_Members),
		HK_COUNT_OF(hkMeshSectionClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkMeshSectionCinfoClass_Members[] =
	{
		{ "vertexBuffer", &hkMeshVertexBufferClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "material", &hkMeshMaterialClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "primitiveType", HK_NULL, hkMeshSectionPrimitiveTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "numPrimitives", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "indexType", HK_NULL, hkMeshSectionMeshSectionIndexTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "indices", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "vertexStartIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "transformIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkMeshSectionCinfoClass(
		"hkMeshSectionCinfo",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkMeshSectionCinfoClass_Members),
		HK_COUNT_OF(hkMeshSectionCinfoClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static const hkInternalClassEnumItem hkMeshShapeAccessFlagsEnumItems[] =
	{
		{1, "ACCESS_INDICES"},
		{2, "ACCESS_VERTEX_BUFFER"},
	};
	static const hkInternalClassEnum hkMeshShapeEnums[] = {
		{"AccessFlags", hkMeshShapeAccessFlagsEnumItems, 2, HK_NULL, 0 }
	};
	const hkClassEnum* hkMeshShapeAccessFlagsEnum = reinterpret_cast<const hkClassEnum*>(&hkMeshShapeEnums[0]);
	hkClass hkMeshShapeClass(
		"hkMeshShape",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkMeshShapeEnums),
		1,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkMeshBodyPickDataIdentifierEnumItems[] =
	{
		{1, "PICK_RIGID_BODY_WITH_BREAKABLE_BODY"},
		{4096, "PICK_USER"},
	};
	static const hkInternalClassEnum hkMeshBodyEnums[] = {
		{"PickDataIdentifier", hkMeshBodyPickDataIdentifierEnumItems, 2, HK_NULL, 0 }
	};
	const hkClassEnum* hkMeshBodyPickDataIdentifierEnum = reinterpret_cast<const hkClassEnum*>(&hkMeshBodyEnums[0]);
	hkClass hkMeshBodyClass(
		"hkMeshBody",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkMeshBodyEnums),
		1,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkMemoryMeshVertexBufferClass_Members[] =
	{
		{ "format", &hkVertexFormatClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "elementOffsets", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 32, 0, 0, HK_NULL },
		{ "memory", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "vertexStride", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "locked", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "numVertices", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "isBigEndian", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "isSharable", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkMemoryMeshVertexBufferClass(
		"hkMemoryMeshVertexBuffer",
		&hkMeshVertexBufferClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkMemoryMeshVertexBufferClass_Members),
		HK_COUNT_OF(hkMemoryMeshVertexBufferClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkpMassPropertiesClass_Members[] =
	{
		{ "volume", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "mass", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "centerOfMass", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "inertiaTensor", HK_NULL, HK_NULL, hkClassMember::TYPE_MATRIX3, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpMassPropertiesClass(
		"hkpMassProperties",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpMassPropertiesClass_Members),
		HK_COUNT_OF(hkpMassPropertiesClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkMeshTextureFormatEnumItems[] =
	{
		{0, "Unknown"},
		{1, "PNG"},
		{2, "TGA"},
		{3, "BMP"},
		{4, "DDS"},
	};
	static const hkInternalClassEnumItem hkMeshTextureFilterModeEnumItems[] =
	{
		{0, "POINT"},
		{1, "LINEAR"},
		{2, "ANISOTROPIC"},
	};
	static const hkInternalClassEnumItem hkMeshTextureTextureUsageTypeEnumItems[] =
	{
		{0, "UNKNOWN"},
		{1, "DIFFUSE"},
		{2, "REFLECTION"},
		{3, "BUMP"},
		{4, "NORMAL"},
		{5, "DISPLACEMENT"},
		{6, "SPECULAR"},
		{7, "SPECULARANDGLOSS"},
		{8, "OPACITY"},
		{9, "EMISSIVE"},
		{10, "REFRACTION"},
		{11, "GLOSS"},
		{12, "NOTEXPORTED"},
	};
	static const hkInternalClassEnum hkMeshTextureEnums[] = {
		{"Format", hkMeshTextureFormatEnumItems, 5, HK_NULL, 0 },
		{"FilterMode", hkMeshTextureFilterModeEnumItems, 3, HK_NULL, 0 },
		{"TextureUsageType", hkMeshTextureTextureUsageTypeEnumItems, 13, HK_NULL, 0 }
	};
	const hkClassEnum* hkMeshTextureFormatEnum = reinterpret_cast<const hkClassEnum*>(&hkMeshTextureEnums[0]);
	const hkClassEnum* hkMeshTextureFilterModeEnum = reinterpret_cast<const hkClassEnum*>(&hkMeshTextureEnums[1]);
	const hkClassEnum* hkMeshTextureTextureUsageTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkMeshTextureEnums[2]);
	hkClass hkMeshTextureClass(
		"hkMeshTexture",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkMeshTextureEnums),
		3,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkMeshBoneIndexMappingClass_Members[] =
	{
		{ "mapping", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_INT16, 0, 0, 0, HK_NULL }
	};
	hkClass hkMeshBoneIndexMappingClass(
		"hkMeshBoneIndexMapping",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkMeshBoneIndexMappingClass_Members),
		HK_COUNT_OF(hkMeshBoneIndexMappingClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkIndexedTransformSetClass_Members[] =
	{
		{ "matrices", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_MATRIX4, 0, 0, 0, HK_NULL },
		{ "inverseMatrices", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_MATRIX4, 0, 0, 0, HK_NULL },
		{ "matricesOrder", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_INT16, 0, 0, 0, HK_NULL },
		{ "matricesNames", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRINGPTR, 0, 0, 0, HK_NULL },
		{ "indexMappings", &hkMeshBoneIndexMappingClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "allMatricesAreAffine", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkIndexedTransformSetClass(
		"hkIndexedTransformSet",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkIndexedTransformSetClass_Members),
		HK_COUNT_OF(hkIndexedTransformSetClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(2)
		);
	static const hkInternalClassEnumItem hkVertexFormatComponentTypeEnumItems[] =
	{
		{0, "TYPE_NONE"},
		{1, "TYPE_INT8"},
		{2, "TYPE_UINT8"},
		{3, "TYPE_INT16"},
		{4, "TYPE_UINT16"},
		{5, "TYPE_INT32"},
		{6, "TYPE_UINT32"},
		{7, "TYPE_UINT8_DWORD"},
		{8, "TYPE_ARGB32"},
		{9, "TYPE_FLOAT16"},
		{10, "TYPE_FLOAT32"},
		{11, "TYPE_VECTOR4"},
		{12, "TYPE_LAST"},
	};
	static const hkInternalClassEnumItem hkVertexFormatComponentUsageEnumItems[] =
	{
		{0, "USAGE_NONE"},
		{1, "USAGE_POSITION"},
		{2, "USAGE_NORMAL"},
		{3, "USAGE_COLOR"},
		{4, "USAGE_TANGENT"},
		{5, "USAGE_BINORMAL"},
		{6, "USAGE_BLEND_MATRIX_INDEX"},
		{7, "USAGE_BLEND_WEIGHTS"},
		{8, "USAGE_BLEND_WEIGHTS_LAST_IMPLIED"},
		{9, "USAGE_TEX_COORD"},
		{10, "USAGE_POINT_SIZE"},
		{11, "USAGE_USER"},
		{12, "USAGE_LAST"},
	};
	static const hkInternalClassEnumItem hkVertexFormatHintFlagsEnumItems[] =
	{
		{1, "FLAG_READ"},
		{2, "FLAG_WRITE"},
		{4, "FLAG_DYNAMIC"},
		{8, "FLAG_NOT_SHARED"},
	};
	static const hkInternalClassEnumItem hkVertexFormatSharingTypeEnumItems[] =
	{
		{0, "SHARING_ALL_SHARED"},
		{1, "SHARING_ALL_NOT_SHARED"},
		{2, "SHARING_MIXTURE"},
	};
	static const hkInternalClassEnum hkVertexFormatEnums[] = {
		{"ComponentType", hkVertexFormatComponentTypeEnumItems, 13, HK_NULL, 0 },
		{"ComponentUsage", hkVertexFormatComponentUsageEnumItems, 13, HK_NULL, 0 },
		{"HintFlags", hkVertexFormatHintFlagsEnumItems, 4, HK_NULL, 0 },
		{"SharingType", hkVertexFormatSharingTypeEnumItems, 3, HK_NULL, 0 }
	};
	const hkClassEnum* hkVertexFormatComponentTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkVertexFormatEnums[0]);
	const hkClassEnum* hkVertexFormatComponentUsageEnum = reinterpret_cast<const hkClassEnum*>(&hkVertexFormatEnums[1]);
	const hkClassEnum* hkVertexFormatHintFlagsEnum = reinterpret_cast<const hkClassEnum*>(&hkVertexFormatEnums[2]);
	const hkClassEnum* hkVertexFormatSharingTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkVertexFormatEnums[3]);
	static hkInternalClassMember hkVertexFormat_ElementClass_Members[] =
	{
		{ "dataType", HK_NULL, hkVertexFormatComponentTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "numValues", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "usage", HK_NULL, hkVertexFormatComponentUsageEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "subUsage", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "flags", HK_NULL, hkVertexFormatHintFlagsEnum, hkClassMember::TYPE_FLAGS, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "pad", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 3, 0, 0, HK_NULL }
	};
	hkClass hkVertexFormatElementClass(
		"hkVertexFormatElement",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkVertexFormat_ElementClass_Members),
		HK_COUNT_OF(hkVertexFormat_ElementClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkVertexFormatClass_Members[] =
	{
		{ "elements", &hkVertexFormatElementClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 32, 0, 0, HK_NULL },
		{ "numElements", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkVertexFormatClass(
		"hkVertexFormat",
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkVertexFormatEnums),
		4,
		reinterpret_cast<const hkClassMember*>(hkVertexFormatClass_Members),
		HK_COUNT_OF(hkVertexFormatClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkMeshVertexBufferFlagsEnumItems[] =
	{
		{1, "ACCESS_READ"},
		{2, "ACCESS_WRITE"},
		{3, "ACCESS_READ_WRITE"},
		{4, "ACCESS_WRITE_DISCARD"},
		{8, "ACCESS_ELEMENT_ARRAY"},
	};
	static const hkInternalClassEnumItem hkMeshVertexBufferLockResultEnumItems[] =
	{
		{0, "RESULT_FAILURE"},
		{1, "RESULT_SUCCESS"},
		{2, "RESULT_IN_USE"},
	};
	static const hkInternalClassEnum hkMeshVertexBufferEnums[] = {
		{"Flags", hkMeshVertexBufferFlagsEnumItems, 5, HK_NULL, 0 },
		{"LockResult", hkMeshVertexBufferLockResultEnumItems, 3, HK_NULL, 0 }
	};
	const hkClassEnum* hkMeshVertexBufferFlagsEnum = reinterpret_cast<const hkClassEnum*>(&hkMeshVertexBufferEnums[0]);
	const hkClassEnum* hkMeshVertexBufferLockResultEnum = reinterpret_cast<const hkClassEnum*>(&hkMeshVertexBufferEnums[1]);
	hkClass hkMeshVertexBufferClass(
		"hkMeshVertexBuffer",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkMeshVertexBufferEnums),
		2,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkMultipleVertexBuffer_VertexBufferInfoClass_Members[] =
	{
		{ "vertexBuffer", &hkMeshVertexBufferClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "lockedVertices", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "isLocked", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkMultipleVertexBufferVertexBufferInfoClass(
		"hkMultipleVertexBufferVertexBufferInfo",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkMultipleVertexBuffer_VertexBufferInfoClass_Members),
		HK_COUNT_OF(hkMultipleVertexBuffer_VertexBufferInfoClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkMultipleVertexBuffer_ElementInfoClass_Members[] =
	{
		{ "vertexBufferIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "elementIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkMultipleVertexBufferElementInfoClass(
		"hkMultipleVertexBufferElementInfo",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkMultipleVertexBuffer_ElementInfoClass_Members),
		HK_COUNT_OF(hkMultipleVertexBuffer_ElementInfoClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkMultipleVertexBuffer_LockedElementClass_Members[] =
	{
		{ "vertexBufferIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "elementIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "lockedBufferIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "vertexFormatIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "lockFlags", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "outputBufferIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "emulatedIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkMultipleVertexBufferLockedElementClass(
		"hkMultipleVertexBufferLockedElement",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkMultipleVertexBuffer_LockedElementClass_Members),
		HK_COUNT_OF(hkMultipleVertexBuffer_LockedElementClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkMultipleVertexBufferClass_Members[] =
	{
		{ "vertexFormat", &hkVertexFormatClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "lockedElements", &hkMultipleVertexBufferLockedElementClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "lockedBuffer", &hkMemoryMeshVertexBufferClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "elementInfos", &hkMultipleVertexBufferElementInfoClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "vertexBufferInfos", &hkMultipleVertexBufferVertexBufferInfoClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "numVertices", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "isLocked", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "updateCount", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "writeLock", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "isSharable", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "constructionComplete", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkMultipleVertexBufferClass(
		"hkMultipleVertexBuffer",
		&hkMeshVertexBufferClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkMultipleVertexBufferClass_Members),
		HK_COUNT_OF(hkMultipleVertexBufferClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkMemoryMeshTextureClass_Members[] =
	{
		{ "filename", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "data", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "format", HK_NULL, hkMeshTextureFormatEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL },
		{ "hasMipMaps", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "filterMode", HK_NULL, hkMeshTextureFilterModeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL },
		{ "usageHint", HK_NULL, hkMeshTextureTextureUsageTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL },
		{ "textureCoordChannel", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkMemoryMeshTextureClass(
		"hkMemoryMeshTexture",
		&hkMeshTextureClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkMemoryMeshTextureClass_Members),
		HK_COUNT_OF(hkMemoryMeshTextureClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(2)
		);
	static hkInternalClassMember hkMemoryMeshShapeClass_Members[] =
	{
		{ "sections", &hkMeshSectionCinfoClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "indices16", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT16, 0, 0, 0, HK_NULL },
		{ "indices32", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT32, 0, 0, 0, HK_NULL },
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkMemoryMeshShapeClass(
		"hkMemoryMeshShape",
		&hkMeshShapeClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkMemoryMeshShapeClass_Members),
		HK_COUNT_OF(hkMemoryMeshShapeClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkMemoryMeshMaterialClass_Members[] =
	{
		{ "materialName", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "textures", &hkMeshTextureClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "diffuseColor", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "ambientColor", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "specularColor", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "emissiveColor", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkMemoryMeshMaterialClass(
		"hkMemoryMeshMaterial",
		&hkMeshMaterialClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkMemoryMeshMaterialClass_Members),
		HK_COUNT_OF(hkMemoryMeshMaterialClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkMemoryMeshBodyClass_Members[] =
	{
		{ "transform", HK_NULL, HK_NULL, hkClassMember::TYPE_MATRIX4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "transformSet", &hkIndexedTransformSetClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "shape", &hkMeshShapeClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "vertexBuffers", &hkMeshVertexBufferClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkMemoryMeshBodyClass(
		"hkMemoryMeshBody",
		&hkMeshBodyClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkMemoryMeshBodyClass_Members),
		HK_COUNT_OF(hkMemoryMeshBodyClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkxMesh_UserChannelInfoClass_Members[] =
	{
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "className", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkxMeshUserChannelInfoClass(
		"hkxMeshUserChannelInfo",
		&hkxAttributeHolderClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkxMesh_UserChannelInfoClass_Members),
		HK_COUNT_OF(hkxMesh_UserChannelInfoClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkxMeshClass_Members[] =
	{
		{ "sections", &hkxMeshSectionClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "userChannelInfos", &hkxMeshUserChannelInfoClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL }
	};
	hkClass hkxMeshClass(
		"hkxMesh",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkxMeshClass_Members),
		HK_COUNT_OF(hkxMeshClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkxAnimatedFloatClass_Members[] =
	{
		{ "floats", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_REAL, 0, 0, 0, HK_NULL },
		{ "hint", HK_NULL, hkxAttributeHintEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL }
	};
	hkClass hkxAnimatedFloatClass(
		"hkxAnimatedFloat",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkxAnimatedFloatClass_Members),
		HK_COUNT_OF(hkxAnimatedFloatClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkxSparselyAnimatedStringClass_Members[] =
	{
		{ "strings", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRINGPTR, 0, 0, 0, HK_NULL },
		{ "times", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_REAL, 0, 0, 0, HK_NULL }
	};
	hkClass hkxSparselyAnimatedStringClass(
		"hkxSparselyAnimatedString",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkxSparselyAnimatedStringClass_Members),
		HK_COUNT_OF(hkxSparselyAnimatedStringClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(2)
		);
	static hkInternalClassMember hkxVertexIntDataChannelClass_Members[] =
	{
		{ "perVertexInts", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_INT32, 0, 0, 0, HK_NULL }
	};
	hkClass hkxVertexIntDataChannelClass(
		"hkxVertexIntDataChannel",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkxVertexIntDataChannelClass_Members),
		HK_COUNT_OF(hkxVertexIntDataChannelClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static const hkInternalClassEnumItem hkxAttributeHintEnumItems[] =
	{
		{0, "HINT_NONE"},
		{1, "HINT_IGNORE"},
		{2, "HINT_TRANSFORM"},
		{4, "HINT_SCALE"},
		{6, "HINT_TRANSFORM_AND_SCALE"},
		{8, "HINT_FLIP"},
	};
	static const hkInternalClassEnum hkxAttributeEnums[] = {
		{"Hint", hkxAttributeHintEnumItems, 6, HK_NULL, 0 }
	};
	const hkClassEnum* hkxAttributeHintEnum = reinterpret_cast<const hkClassEnum*>(&hkxAttributeEnums[0]);
	static hkInternalClassMember hkxAttributeClass_Members[] =
	{
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "value", &hkReferencedObjectClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkxAttributeClass(
		"hkxAttribute",
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkxAttributeEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkxAttributeClass_Members),
		HK_COUNT_OF(hkxAttributeClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkxSceneClass_Members[] =
	{
		{ "modeller", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "asset", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "sceneLength", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "rootNode", &hkxNodeClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "selectionSets", &hkxNodeSelectionSetClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "cameras", &hkxCameraClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "lights", &hkxLightClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "meshes", &hkxMeshClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "materials", &hkxMaterialClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "inplaceTextures", &hkxTextureInplaceClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "externalTextures", &hkxTextureFileClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "skinBindings", &hkxSkinBindingClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "appliedTransform", HK_NULL, HK_NULL, hkClassMember::TYPE_MATRIX3, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkxScene_DefaultStruct
		{
			int s_defaultOffsets[13];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			_hkMatrix3 m_appliedTransform;
		};
		const hkxScene_DefaultStruct hkxScene_Default =
		{
			{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,HK_OFFSET_OF(hkxScene_DefaultStruct,m_appliedTransform)},
			{1,0,0,0,0,1,0,0,0,0,1,0}
		};
	}
	hkClass hkxSceneClass(
		"hkxScene",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkxSceneClass_Members),
		HK_COUNT_OF(hkxSceneClass_Members),
		&hkxScene_Default,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkxEnum_ItemClass_Members[] =
	{
		{ "value", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkxEnumItemClass(
		"hkxEnumItem",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkxEnum_ItemClass_Members),
		HK_COUNT_OF(hkxEnum_ItemClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkxEnumClass_Members[] =
	{
		{ "items", &hkxEnumItemClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkxEnumClass(
		"hkxEnum",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkxEnumClass_Members),
		HK_COUNT_OF(hkxEnumClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkxSparselyAnimatedEnumClass_Members[] =
	{
		{ "enum", &hkxEnumClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkxSparselyAnimatedEnumClass(
		"hkxSparselyAnimatedEnum",
		&hkxSparselyAnimatedIntClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkxSparselyAnimatedEnumClass_Members),
		HK_COUNT_OF(hkxSparselyAnimatedEnumClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkxMaterialShaderSetClass_Members[] =
	{
		{ "shaders", &hkxMaterialShaderClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL }
	};
	hkClass hkxMaterialShaderSetClass(
		"hkxMaterialShaderSet",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkxMaterialShaderSetClass_Members),
		HK_COUNT_OF(hkxMaterialShaderSetClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkxSkinBindingClass_Members[] =
	{
		{ "mesh", &hkxMeshClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "nodeNames", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRINGPTR, 0, 0, 0, HK_NULL },
		{ "bindPose", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_MATRIX4, 0, 0, 0, HK_NULL },
		{ "initSkinTransform", HK_NULL, HK_NULL, hkClassMember::TYPE_MATRIX4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkxSkinBindingClass(
		"hkxSkinBinding",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkxSkinBindingClass_Members),
		HK_COUNT_OF(hkxSkinBindingClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(2)
		);
	static hkInternalClassMember hkxTextureFileClass_Members[] =
	{
		{ "filename", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "originalFilename", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkxTextureFileClass(
		"hkxTextureFile",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkxTextureFileClass_Members),
		HK_COUNT_OF(hkxTextureFileClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static const hkInternalClassEnumItem hkxMaterialTextureTypeEnumItems[] =
	{
		{0, "TEX_UNKNOWN"},
		{1, "TEX_DIFFUSE"},
		{2, "TEX_REFLECTION"},
		{3, "TEX_BUMP"},
		{4, "TEX_NORMAL"},
		{5, "TEX_DISPLACEMENT"},
		{6, "TEX_SPECULAR"},
		{7, "TEX_SPECULARANDGLOSS"},
		{8, "TEX_OPACITY"},
		{9, "TEX_EMISSIVE"},
		{10, "TEX_REFRACTION"},
		{11, "TEX_GLOSS"},
		{12, "TEX_NOTEXPORTED"},
	};
	static const hkInternalClassEnumItem hkxMaterialPropertyKeyEnumItems[] =
	{
		{1, "PROPERTY_MTL_TYPE_BLEND"},
		{256, "PROPERTY_MTL_UV_ID_STAGE0"},
		{257, "PROPERTY_MTL_UV_ID_STAGE1"},
		{258, "PROPERTY_MTL_UV_ID_STAGE2"},
		{259, "PROPERTY_MTL_UV_ID_STAGE3"},
		{260, "PROPERTY_MTL_UV_ID_STAGE4"},
		{261, "PROPERTY_MTL_UV_ID_STAGE5"},
		{262, "PROPERTY_MTL_UV_ID_STAGE6"},
		{263, "PROPERTY_MTL_UV_ID_STAGE7"},
		{264, "PROPERTY_MTL_UV_ID_STAGE8"},
		{265, "PROPERTY_MTL_UV_ID_STAGE9"},
		{266, "PROPERTY_MTL_UV_ID_STAGE10"},
		{267, "PROPERTY_MTL_UV_ID_STAGE11"},
		{268, "PROPERTY_MTL_UV_ID_STAGE12"},
		{269, "PROPERTY_MTL_UV_ID_STAGE13"},
		{270, "PROPERTY_MTL_UV_ID_STAGE14"},
		{271, "PROPERTY_MTL_UV_ID_STAGE15"},
		{272, "PROPERTY_MTL_UV_ID_STAGE_MAX"},
	};
	static const hkInternalClassEnum hkxMaterialEnums[] = {
		{"TextureType", hkxMaterialTextureTypeEnumItems, 13, HK_NULL, 0 },
		{"PropertyKey", hkxMaterialPropertyKeyEnumItems, 18, HK_NULL, 0 }
	};
	const hkClassEnum* hkxMaterialTextureTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkxMaterialEnums[0]);
	const hkClassEnum* hkxMaterialPropertyKeyEnum = reinterpret_cast<const hkClassEnum*>(&hkxMaterialEnums[1]);
	static hkInternalClassMember hkxMaterial_TextureStageClass_Members[] =
	{
		{ "texture", &hkReferencedObjectClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "usageHint", HK_NULL, hkxMaterialTextureTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT32, 0, 0, 0, HK_NULL },
		{ "tcoordChannel", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkxMaterialTextureStage_DefaultStruct
		{
			int s_defaultOffsets[3];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkInt32 m_tcoordChannel;
		};
		const hkxMaterialTextureStage_DefaultStruct hkxMaterialTextureStage_Default =
		{
			{-1,-1,HK_OFFSET_OF(hkxMaterialTextureStage_DefaultStruct,m_tcoordChannel)},
			-1
		};
	}
	hkClass hkxMaterialTextureStageClass(
		"hkxMaterialTextureStage",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkxMaterial_TextureStageClass_Members),
		HK_COUNT_OF(hkxMaterial_TextureStageClass_Members),
		&hkxMaterialTextureStage_Default,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkxMaterial_PropertyClass_Members[] =
	{
		{ "key", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "value", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkxMaterialPropertyClass(
		"hkxMaterialProperty",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkxMaterial_PropertyClass_Members),
		HK_COUNT_OF(hkxMaterial_PropertyClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkxMaterialClass_Members[] =
	{
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "stages", &hkxMaterialTextureStageClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "diffuseColor", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "ambientColor", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "specularColor", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "emissiveColor", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "subMaterials", &hkxMaterialClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "extraData", &hkReferencedObjectClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "properties", &hkxMaterialPropertyClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkxMaterialClass(
		"hkxMaterial",
		&hkxAttributeHolderClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkxMaterialEnums),
		2,
		reinterpret_cast<const hkClassMember*>(hkxMaterialClass_Members),
		HK_COUNT_OF(hkxMaterialClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(2)
		);
	static const hkInternalClassEnumItem hkxVertexDescriptionDataTypeEnumItems[] =
	{
		{0, "HKX_DT_NONE"},
		{1, "HKX_DT_UINT8"},
		{2, "HKX_DT_INT16"},
		{3, "HKX_DT_UINT32"},
		{4, "HKX_DT_FLOAT"},
	};
	static const hkInternalClassEnumItem hkxVertexDescriptionDataUsageEnumItems[] =
	{
		{0, "HKX_DU_NONE"},
		{1, "HKX_DU_POSITION"},
		{2, "HKX_DU_COLOR"},
		{4, "HKX_DU_NORMAL"},
		{8, "HKX_DU_TANGENT"},
		{16, "HKX_DU_BINORMAL"},
		{32, "HKX_DU_TEXCOORD"},
		{64, "HKX_DU_BLENDWEIGHTS"},
		{128, "HKX_DU_BLENDINDICES"},
		{256, "HKX_DU_USERDATA"},
	};
	static const hkInternalClassEnum hkxVertexDescriptionEnums[] = {
		{"DataType", hkxVertexDescriptionDataTypeEnumItems, 5, HK_NULL, 0 },
		{"DataUsage", hkxVertexDescriptionDataUsageEnumItems, 10, HK_NULL, 0 }
	};
	const hkClassEnum* hkxVertexDescriptionDataTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkxVertexDescriptionEnums[0]);
	const hkClassEnum* hkxVertexDescriptionDataUsageEnum = reinterpret_cast<const hkClassEnum*>(&hkxVertexDescriptionEnums[1]);
	static hkInternalClassMember hkxVertexDescription_ElementDeclClass_Members[] =
	{
		{ "byteOffset", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "type", HK_NULL, hkxVertexDescriptionDataTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT16, 0, 0, 0, HK_NULL },
		{ "usage", HK_NULL, hkxVertexDescriptionDataUsageEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT16, 0, 0, 0, HK_NULL },
		{ "byteStride", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "numElements", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkxVertexDescriptionElementDeclClass(
		"hkxVertexDescriptionElementDecl",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkxVertexDescription_ElementDeclClass_Members),
		HK_COUNT_OF(hkxVertexDescription_ElementDeclClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(2)
		);
	static hkInternalClassMember hkxVertexDescriptionClass_Members[] =
	{
		{ "decls", &hkxVertexDescriptionElementDeclClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkxVertexDescriptionClass(
		"hkxVertexDescription",
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkxVertexDescriptionEnums),
		2,
		reinterpret_cast<const hkClassMember*>(hkxVertexDescriptionClass_Members),
		HK_COUNT_OF(hkxVertexDescriptionClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkxSparselyAnimatedIntClass_Members[] =
	{
		{ "ints", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_INT32, 0, 0, 0, HK_NULL },
		{ "times", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_REAL, 0, 0, 0, HK_NULL }
	};
	hkClass hkxSparselyAnimatedIntClass(
		"hkxSparselyAnimatedInt",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkxSparselyAnimatedIntClass_Members),
		HK_COUNT_OF(hkxSparselyAnimatedIntClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkxAnimatedVectorClass_Members[] =
	{
		{ "vectors", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VECTOR4, 0, 0, 0, HK_NULL },
		{ "hint", HK_NULL, hkxAttributeHintEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL }
	};
	hkClass hkxAnimatedVectorClass(
		"hkxAnimatedVector",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkxAnimatedVectorClass_Members),
		HK_COUNT_OF(hkxAnimatedVectorClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkxNodeSelectionSetClass_Members[] =
	{
		{ "selectedNodes", &hkxNodeClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkxNodeSelectionSetClass(
		"hkxNodeSelectionSet",
		&hkxAttributeHolderClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkxNodeSelectionSetClass_Members),
		HK_COUNT_OF(hkxNodeSelectionSetClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkxTriangleSelectionChannelClass_Members[] =
	{
		{ "selectedTriangles", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_INT32, 0, 0, 0, HK_NULL }
	};
	hkClass hkxTriangleSelectionChannelClass(
		"hkxTriangleSelectionChannel",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkxTriangleSelectionChannelClass_Members),
		HK_COUNT_OF(hkxTriangleSelectionChannelClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkxAttributeGroupClass_Members[] =
	{
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "attributes", &hkxAttributeClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkxAttributeGroupClass(
		"hkxAttributeGroup",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkxAttributeGroupClass_Members),
		HK_COUNT_OF(hkxAttributeGroupClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkxNode_AnnotationDataClass_Members[] =
	{
		{ "time", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "description", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkxNodeAnnotationDataClass(
		"hkxNodeAnnotationData",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkxNode_AnnotationDataClass_Members),
		HK_COUNT_OF(hkxNode_AnnotationDataClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkxNodeClass_Members[] =
	{
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "object", &hkReferencedObjectClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "keyFrames", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_MATRIX4, 0, 0, 0, HK_NULL },
		{ "children", &hkxNodeClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "annotations", &hkxNodeAnnotationDataClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "userProperties", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "selected", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkxNodeClass(
		"hkxNode",
		&hkxAttributeHolderClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkxNodeClass_Members),
		HK_COUNT_OF(hkxNodeClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(2)
		);
	static hkInternalClassMember hkxAnimatedQuaternionClass_Members[] =
	{
		{ "quaternions", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_QUATERNION, 0, 0, 0, HK_NULL }
	};
	hkClass hkxAnimatedQuaternionClass(
		"hkxAnimatedQuaternion",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkxAnimatedQuaternionClass_Members),
		HK_COUNT_OF(hkxAnimatedQuaternionClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkxVertexBuffer_VertexDataClass_Members[] =
	{
		{ "vectorData", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VECTOR4, 0, 0, 0, HK_NULL },
		{ "floatData", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_REAL, 0, 0, 0, HK_NULL },
		{ "uint32Data", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT32, 0, 0, 0, HK_NULL },
		{ "uint16Data", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT16, 0, 0, 0, HK_NULL },
		{ "uint8Data", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "numVerts", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "vectorStride", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "floatStride", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "uint32Stride", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "uint16Stride", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "uint8Stride", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkxVertexBufferVertexDataClass(
		"hkxVertexBufferVertexData",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkxVertexBuffer_VertexDataClass_Members),
		HK_COUNT_OF(hkxVertexBuffer_VertexDataClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkxVertexBufferClass_Members[] =
	{
		{ "data", &hkxVertexBufferVertexDataClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "desc", &hkxVertexDescriptionClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkxVertexBufferClass(
		"hkxVertexBuffer",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkxVertexBufferClass_Members),
		HK_COUNT_OF(hkxVertexBufferClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkxCameraClass_Members[] =
	{
		{ "from", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "focus", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "up", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "fov", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "far", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "near", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "leftHanded", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkxCameraClass(
		"hkxCamera",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkxCameraClass_Members),
		HK_COUNT_OF(hkxCameraClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static const hkInternalClassEnumItem hkxMaterialEffectEffectTypeEnumItems[] =
	{
		{0, "EFFECT_TYPE_INVALID"},
		{1, "EFFECT_TYPE_UNKNOWN"},
		{2, "EFFECT_TYPE_HLSL_FX_INLINE"},
		{3, "EFFECT_TYPE_CG_FX_INLINE"},
		{4, "EFFECT_TYPE_HLSL_FX_FILENAME"},
		{5, "EFFECT_TYPE_CG_FX_FILENAME"},
		{6, "EFFECT_TYPE_MAX_ID"},
	};
	static const hkInternalClassEnum hkxMaterialEffectEnums[] = {
		{"EffectType", hkxMaterialEffectEffectTypeEnumItems, 7, HK_NULL, 0 }
	};
	const hkClassEnum* hkxMaterialEffectEffectTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkxMaterialEffectEnums[0]);
	static hkInternalClassMember hkxMaterialEffectClass_Members[] =
	{
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "type", HK_NULL, hkxMaterialEffectEffectTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "data", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL }
	};
	hkClass hkxMaterialEffectClass(
		"hkxMaterialEffect",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkxMaterialEffectEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkxMaterialEffectClass_Members),
		HK_COUNT_OF(hkxMaterialEffectClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkxMeshSectionClass_Members[] =
	{
		{ "vertexBuffer", &hkxVertexBufferClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "indexBuffers", &hkxIndexBufferClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "material", &hkxMaterialClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "userChannels", &hkReferencedObjectClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL }
	};
	hkClass hkxMeshSectionClass(
		"hkxMeshSection",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkxMeshSectionClass_Members),
		HK_COUNT_OF(hkxMeshSectionClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(2)
		);
	static hkInternalClassMember hkAlignSceneToNodeOptionsClass_Members[] =
	{
		{ "invert", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "transformPositionX", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "transformPositionY", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "transformPositionZ", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "transformRotation", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "transformScale", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "transformSkew", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "keyframe", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "nodeName", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkAlignSceneToNodeOptionsClass(
		"hkAlignSceneToNodeOptions",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkAlignSceneToNodeOptionsClass_Members),
		HK_COUNT_OF(hkAlignSceneToNodeOptionsClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(2)
		);
	static hkInternalClassMember hkxEdgeSelectionChannelClass_Members[] =
	{
		{ "selectedEdges", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_INT32, 0, 0, 0, HK_NULL }
	};
	hkClass hkxEdgeSelectionChannelClass(
		"hkxEdgeSelectionChannel",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkxEdgeSelectionChannelClass_Members),
		HK_COUNT_OF(hkxEdgeSelectionChannelClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static const hkInternalClassEnumItem hkxVertexFloatDataChannelVertexFloatDimensionsEnumItems[] =
	{
		{0, "FLOAT"},
		{1, "DISTANCE"},
		{2, "ANGLE"},
	};
	static const hkInternalClassEnum hkxVertexFloatDataChannelEnums[] = {
		{"VertexFloatDimensions", hkxVertexFloatDataChannelVertexFloatDimensionsEnumItems, 3, HK_NULL, 0 }
	};
	const hkClassEnum* hkxVertexFloatDataChannelVertexFloatDimensionsEnum = reinterpret_cast<const hkClassEnum*>(&hkxVertexFloatDataChannelEnums[0]);
	static hkInternalClassMember hkxVertexFloatDataChannelClass_Members[] =
	{
		{ "perVertexFloats", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_REAL, 0, 0, 0, HK_NULL },
		{ "dimensions", HK_NULL, hkxVertexFloatDataChannelVertexFloatDimensionsEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL }
	};
	hkClass hkxVertexFloatDataChannelClass(
		"hkxVertexFloatDataChannel",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkxVertexFloatDataChannelEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkxVertexFloatDataChannelClass_Members),
		HK_COUNT_OF(hkxVertexFloatDataChannelClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkxSparselyAnimatedBoolClass_Members[] =
	{
		{ "bools", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_BOOL, 0, 0, 0, HK_NULL },
		{ "times", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_REAL, 0, 0, 0, HK_NULL }
	};
	hkClass hkxSparselyAnimatedBoolClass(
		"hkxSparselyAnimatedBool",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkxSparselyAnimatedBoolClass_Members),
		HK_COUNT_OF(hkxSparselyAnimatedBoolClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static const hkInternalClassEnumItem hkxIndexBufferIndexTypeEnumItems[] =
	{
		{0, "INDEX_TYPE_INVALID"},
		{1, "INDEX_TYPE_TRI_LIST"},
		{2, "INDEX_TYPE_TRI_STRIP"},
		{3, "INDEX_TYPE_TRI_FAN"},
		{4, "INDEX_TYPE_MAX_ID"},
	};
	static const hkInternalClassEnum hkxIndexBufferEnums[] = {
		{"IndexType", hkxIndexBufferIndexTypeEnumItems, 5, HK_NULL, 0 }
	};
	const hkClassEnum* hkxIndexBufferIndexTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkxIndexBufferEnums[0]);
	static hkInternalClassMember hkxIndexBufferClass_Members[] =
	{
		{ "indexType", HK_NULL, hkxIndexBufferIndexTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL },
		{ "indices16", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT16, 0, 0, 0, HK_NULL },
		{ "indices32", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT32, 0, 0, 0, HK_NULL },
		{ "vertexBaseOffset", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "length", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkxIndexBufferClass(
		"hkxIndexBuffer",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkxIndexBufferEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkxIndexBufferClass_Members),
		HK_COUNT_OF(hkxIndexBufferClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkxVertexVectorDataChannelClass_Members[] =
	{
		{ "perVertexVectors", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VECTOR4, 0, 0, 0, HK_NULL }
	};
	hkClass hkxVertexVectorDataChannelClass(
		"hkxVertexVectorDataChannel",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkxVertexVectorDataChannelClass_Members),
		HK_COUNT_OF(hkxVertexVectorDataChannelClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkxAnimatedMatrixClass_Members[] =
	{
		{ "matrices", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_MATRIX4, 0, 0, 0, HK_NULL },
		{ "hint", HK_NULL, hkxAttributeHintEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL }
	};
	hkClass hkxAnimatedMatrixClass(
		"hkxAnimatedMatrix",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkxAnimatedMatrixClass_Members),
		HK_COUNT_OF(hkxAnimatedMatrixClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkxVertexSelectionChannelClass_Members[] =
	{
		{ "selectedVertices", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_INT32, 0, 0, 0, HK_NULL }
	};
	hkClass hkxVertexSelectionChannelClass(
		"hkxVertexSelectionChannel",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkxVertexSelectionChannelClass_Members),
		HK_COUNT_OF(hkxVertexSelectionChannelClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static const hkInternalClassEnumItem hkxMaterialShaderShaderTypeEnumItems[] =
	{
		{0, "EFFECT_TYPE_INVALID"},
		{1, "EFFECT_TYPE_UNKNOWN"},
		{2, "EFFECT_TYPE_HLSL_INLINE"},
		{3, "EFFECT_TYPE_CG_INLINE"},
		{4, "EFFECT_TYPE_HLSL_FILENAME"},
		{5, "EFFECT_TYPE_CG_FILENAME"},
		{6, "EFFECT_TYPE_MAX_ID"},
	};
	static const hkInternalClassEnum hkxMaterialShaderEnums[] = {
		{"ShaderType", hkxMaterialShaderShaderTypeEnumItems, 7, HK_NULL, 0 }
	};
	const hkClassEnum* hkxMaterialShaderShaderTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkxMaterialShaderEnums[0]);
	static hkInternalClassMember hkxMaterialShaderClass_Members[] =
	{
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "type", HK_NULL, hkxMaterialShaderShaderTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "vertexEntryName", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "geomEntryName", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "pixelEntryName", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "data", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL }
	};
	hkClass hkxMaterialShaderClass(
		"hkxMaterialShader",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkxMaterialShaderEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkxMaterialShaderClass_Members),
		HK_COUNT_OF(hkxMaterialShaderClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkxAttributeHolderClass_Members[] =
	{
		{ "attributeGroups", &hkxAttributeGroupClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkxAttributeHolderClass(
		"hkxAttributeHolder",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkxAttributeHolderClass_Members),
		HK_COUNT_OF(hkxAttributeHolderClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(2)
		);
	static const hkInternalClassEnumItem hkxLightLightTypeEnumItems[] =
	{
		{0, "POINT_LIGHT"},
		{1, "DIRECTIONAL_LIGHT"},
		{2, "SPOT_LIGHT"},
	};
	static const hkInternalClassEnum hkxLightEnums[] = {
		{"LightType", hkxLightLightTypeEnumItems, 3, HK_NULL, 0 }
	};
	const hkClassEnum* hkxLightLightTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkxLightEnums[0]);
	static hkInternalClassMember hkxLightClass_Members[] =
	{
		{ "type", HK_NULL, hkxLightLightTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL },
		{ "position", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "direction", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "color", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "angle", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkxLightClass(
		"hkxLight",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkxLightEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkxLightClass_Members),
		HK_COUNT_OF(hkxLightClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkxTextureInplaceClass_Members[] =
	{
		{ "fileType", HK_NULL, HK_NULL, hkClassMember::TYPE_CHAR, hkClassMember::TYPE_VOID, 4, 0, 0, HK_NULL },
		{ "data", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "originalFilename", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkxTextureInplaceClass(
		"hkxTextureInplace",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkxTextureInplaceClass_Members),
		HK_COUNT_OF(hkxTextureInplaceClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkxEnvironment_VariableClass_Members[] =
	{
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "value", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkxEnvironmentVariableClass(
		"hkxEnvironmentVariable",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkxEnvironment_VariableClass_Members),
		HK_COUNT_OF(hkxEnvironment_VariableClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkxEnvironmentClass_Members[] =
	{
		{ "variables", &hkxEnvironmentVariableClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkxEnvironmentClass(
		"hkxEnvironment",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkxEnvironmentClass_Members),
		HK_COUNT_OF(hkxEnvironmentClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static const hkInternalClassEnumItem hkResourceBaseTypeEnumItems[] =
	{
		{0, "TYPE_RESOURCE"},
		{1, "TYPE_CONTAINER"},
	};
	static const hkInternalClassEnum hkResourceBaseEnums[] = {
		{"Type", hkResourceBaseTypeEnumItems, 2, HK_NULL, 0 }
	};
	const hkClassEnum* hkResourceBaseTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkResourceBaseEnums[0]);
	hkClass hkResourceBaseClass(
		"hkResourceBase",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkResourceBaseEnums),
		1,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hkResourceHandleClass(
		"hkResourceHandle",
		&hkResourceBaseClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hkResourceContainerClass(
		"hkResourceContainer",
		&hkResourceBaseClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkMemoryResourceHandle_ExternalLinkClass_Members[] =
	{
		{ "memberName", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "externalId", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkMemoryResourceHandleExternalLinkClass(
		"hkMemoryResourceHandleExternalLink",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkMemoryResourceHandle_ExternalLinkClass_Members),
		HK_COUNT_OF(hkMemoryResourceHandle_ExternalLinkClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkMemoryResourceHandleClass_Members[] =
	{
		{ "variant", &hkReferencedObjectClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "references", &hkMemoryResourceHandleExternalLinkClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkMemoryResourceHandleClass(
		"hkMemoryResourceHandle",
		&hkResourceHandleClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkMemoryResourceHandleClass_Members),
		HK_COUNT_OF(hkMemoryResourceHandleClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(3)
		);
	static hkInternalClassMember hkMemoryResourceContainerClass_Members[] =
	{
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "parent", &hkMemoryResourceContainerClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "resourceHandles", &hkMemoryResourceHandleClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "children", &hkMemoryResourceContainerClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL }
	};
	hkClass hkMemoryResourceContainerClass(
		"hkMemoryResourceContainer",
		&hkResourceContainerClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkMemoryResourceContainerClass_Members),
		HK_COUNT_OF(hkMemoryResourceContainerClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkPackfileHeaderClass_Members[] =
	{
		{ "magic", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 2, 0, 0, HK_NULL },
		{ "userTag", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "fileVersion", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "layoutRules", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 4, 0, 0, HK_NULL },
		{ "numSections", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "contentsSectionIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "contentsSectionOffset", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "contentsClassNameSectionIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "contentsClassNameSectionOffset", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "contentsVersion", HK_NULL, HK_NULL, hkClassMember::TYPE_CHAR, hkClassMember::TYPE_VOID, 16, 0, 0, HK_NULL },
		{ "flags", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "pad", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 1, 0, 0, HK_NULL }
	};
	hkClass hkPackfileHeaderClass(
		"hkPackfileHeader",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkPackfileHeaderClass_Members),
		HK_COUNT_OF(hkPackfileHeaderClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkPackfileSectionHeaderClass_Members[] =
	{
		{ "sectionTag", HK_NULL, HK_NULL, hkClassMember::TYPE_CHAR, hkClassMember::TYPE_VOID, 19, 0, 0, HK_NULL },
		{ "nullByte", HK_NULL, HK_NULL, hkClassMember::TYPE_CHAR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "absoluteDataStart", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "localFixupsOffset", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "globalFixupsOffset", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "virtualFixupsOffset", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "exportsOffset", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "importsOffset", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "endOffset", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkPackfileSectionHeaderClass(
		"hkPackfileSectionHeader",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkPackfileSectionHeaderClass_Members),
		HK_COUNT_OF(hkPackfileSectionHeaderClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkRootLevelContainer_NamedVariantClass_Members[] =
	{
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "className", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "variant", &hkReferencedObjectClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkRootLevelContainerNamedVariantClass(
		"hkRootLevelContainerNamedVariant",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkRootLevelContainer_NamedVariantClass_Members),
		HK_COUNT_OF(hkRootLevelContainer_NamedVariantClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkRootLevelContainerClass_Members[] =
	{
		{ "namedVariants", &hkRootLevelContainerNamedVariantClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkRootLevelContainerClass(
		"hkRootLevelContainer",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkRootLevelContainerClass_Members),
		HK_COUNT_OF(hkRootLevelContainerClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkdMeshSimplifierActionClass_Members[] =
	{
		{ "maxNumberOfTriangles", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "preferChildSimplification", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "minNumberOfTrianglesPerShape", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "allowRemovingShapes", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "avoidGaps", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "allowRootShapeSimplification", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "enableCoplanarMerge", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxCoplanarError", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkdMeshSimplifierAction_DefaultStruct
		{
			int s_defaultOffsets[8];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkInt32 m_maxNumberOfTriangles;
			hkInt32 m_minNumberOfTrianglesPerShape;
			_hkBool m_avoidGaps;
			hkReal m_maxCoplanarError;
		};
		const hkdMeshSimplifierAction_DefaultStruct hkdMeshSimplifierAction_Default =
		{
			{HK_OFFSET_OF(hkdMeshSimplifierAction_DefaultStruct,m_maxNumberOfTriangles),hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkdMeshSimplifierAction_DefaultStruct,m_minNumberOfTrianglesPerShape),hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkdMeshSimplifierAction_DefaultStruct,m_avoidGaps),hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkdMeshSimplifierAction_DefaultStruct,m_maxCoplanarError)},
			1000,4,true,1e-6f
		};
	}
	hkClass hkdMeshSimplifierActionClass(
		"hkdMeshSimplifierAction",
		&hkdActionClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkdMeshSimplifierActionClass_Members),
		HK_COUNT_OF(hkdMeshSimplifierActionClass_Members),
		&hkdMeshSimplifierAction_Default,
		HK_NULL,
		0,
		hkUint32(3)
		);
	static const hkInternalClassEnumItem hkdShockWaveActionTriggerTypeEnumItems[] =
	{
		{0, "INTERSECTING_COMS"},
		{1, "INTERSECTING_BODIES"},
	};
	static const hkInternalClassEnum hkdShockWaveActionEnums[] = {
		{"TriggerType", hkdShockWaveActionTriggerTypeEnumItems, 2, HK_NULL, 0 }
	};
	const hkClassEnum* hkdShockWaveActionTriggerTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkdShockWaveActionEnums[0]);
	static hkInternalClassMember hkdShockWaveActionClass_Members[] =
	{
		{ "phantom", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "world", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "center", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "initialRadius", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxRadius", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "thickness", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "triggerType", HK_NULL, hkdShockWaveActionTriggerTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "expandingVelocity", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "damageMultiplier", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "pad0", HK_NULL, HK_NULL, hkClassMember::TYPE_CHAR, hkClassMember::TYPE_VOID, 8, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	namespace
	{
		struct hkdShockWaveAction_DefaultStruct
		{
			int s_defaultOffsets[10];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkReal m_initialRadius;
			hkReal m_maxRadius;
			hkReal m_thickness;
			hkUint8 /* hkEnum< enum hkdShockWaveAction::TriggerType, hkUint8 > */ m_triggerType;
			hkReal m_expandingVelocity;
			hkReal m_damageMultiplier;
		};
		const hkdShockWaveAction_DefaultStruct hkdShockWaveAction_Default =
		{
			{-1,-1,-1,HK_OFFSET_OF(hkdShockWaveAction_DefaultStruct,m_initialRadius),HK_OFFSET_OF(hkdShockWaveAction_DefaultStruct,m_maxRadius),HK_OFFSET_OF(hkdShockWaveAction_DefaultStruct,m_thickness),HK_OFFSET_OF(hkdShockWaveAction_DefaultStruct,m_triggerType),HK_OFFSET_OF(hkdShockWaveAction_DefaultStruct,m_expandingVelocity),HK_OFFSET_OF(hkdShockWaveAction_DefaultStruct,m_damageMultiplier),-1},
			1.0f,100.f,10.f,hkdShockWaveAction::INTERSECTING_COMS,30.f,1.0f
		};
	}
	hkClass hkdShockWaveActionClass(
		"hkdShockWaveAction",
		&hkdActionClass,
		0,
		HK_NULL,
		2,
		reinterpret_cast<const hkClassEnum*>(hkdShockWaveActionEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkdShockWaveActionClass_Members),
		HK_COUNT_OF(hkdShockWaveActionClass_Members),
		&hkdShockWaveAction_Default,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkdSimpleShockWaveActionClass_Members[] =
	{
		{ "virtualMass", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "appliedVelocity", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "forceFallOff", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "relCounterForce", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkdSimpleShockWaveAction_DefaultStruct
		{
			int s_defaultOffsets[4];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkReal m_virtualMass;
			hkReal m_appliedVelocity;
			hkReal m_forceFallOff;
			hkReal m_relCounterForce;
		};
		const hkdSimpleShockWaveAction_DefaultStruct hkdSimpleShockWaveAction_Default =
		{
			{HK_OFFSET_OF(hkdSimpleShockWaveAction_DefaultStruct,m_virtualMass),HK_OFFSET_OF(hkdSimpleShockWaveAction_DefaultStruct,m_appliedVelocity),HK_OFFSET_OF(hkdSimpleShockWaveAction_DefaultStruct,m_forceFallOff),HK_OFFSET_OF(hkdSimpleShockWaveAction_DefaultStruct,m_relCounterForce)},
			100000.0f,100.0f,1.4f,0.5f
		};
	}
	hkClass hkdSimpleShockWaveActionClass(
		"hkdSimpleShockWaveAction",
		&hkdShockWaveActionClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkdSimpleShockWaveActionClass_Members),
		HK_COUNT_OF(hkdSimpleShockWaveActionClass_Members),
		&hkdSimpleShockWaveAction_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkdGeometryInvalidUserIdentEnumItems[] =
	{
		{65535, "INVALID_USER_IDENT"},
	};
	static const hkInternalClassEnum hkdGeometryEnums[] = {
		{"InvalidUserIdent", hkdGeometryInvalidUserIdentEnumItems, 1, HK_NULL, 0 }
	};
	const hkClassEnum* hkdGeometryInvalidUserIdentEnum = reinterpret_cast<const hkClassEnum*>(&hkdGeometryEnums[0]);
	static hkInternalClassMember hkdGeometry_FaceIdentifierClass_Members[] =
	{
		{ "userData", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 4, 0, 0, HK_NULL }
	};
	hkClass hkdGeometryFaceIdentifierClass(
		"hkdGeometryFaceIdentifier",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkdGeometry_FaceIdentifierClass_Members),
		HK_COUNT_OF(hkdGeometry_FaceIdentifierClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkdGeometry_FaceClass_Members[] =
	{
		{ "support", &hkdGeometryFaceIdentifierClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "startTriangleIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "numTriangles", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "objectIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "parentFaceIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkdGeometryFaceClass(
		"hkdGeometryFace",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkdGeometry_FaceClass_Members),
		HK_COUNT_OF(hkdGeometry_FaceClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkdGeometryTriangleEdgeMarkerEnumItems[] =
	{
		{65535, "UNCONNECTED_EDGE"},
	};
	static const hkInternalClassEnum hkdGeometryTriangleEnums[] = {
		{"EdgeMarker", hkdGeometryTriangleEdgeMarkerEnumItems, 1, HK_NULL, 0 }
	};
	const hkClassEnum* hkdGeometryTriangleEdgeMarkerEnum = reinterpret_cast<const hkClassEnum*>(&hkdGeometryTriangleEnums[0]);
	static hkInternalClassMember hkdGeometry_TriangleClass_Members[] =
	{
		{ "vertexIndices", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 3, 0, 0, HK_NULL },
		{ "neighbouringFaces", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 3, 0, 0, HK_NULL }
	};
	hkClass hkdGeometryTriangleClass(
		"hkdGeometryTriangle",
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkdGeometryTriangleEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkdGeometry_TriangleClass_Members),
		HK_COUNT_OF(hkdGeometry_TriangleClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkdGeometry_ObjectIdentifierClass_Members[] =
	{
		{ "transform", HK_NULL, HK_NULL, hkClassMember::TYPE_MATRIX4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "isInverted", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkdGeometryObjectIdentifierClass(
		"hkdGeometryObjectIdentifier",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkdGeometry_ObjectIdentifierClass_Members),
		HK_COUNT_OF(hkdGeometry_ObjectIdentifierClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkdGeometryClass_Members[] =
	{
		{ "faces", &hkdGeometryFaceClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "triangles", &hkdGeometryTriangleClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "vertices", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VECTOR4, 0, 0, 0, HK_NULL },
		{ "objectIds", &hkdGeometryObjectIdentifierClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "parent", &hkdGeometryClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hkdGeometryClass(
		"hkdGeometry",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkdGeometryEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkdGeometryClass_Members),
		HK_COUNT_OF(hkdGeometryClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static const hkInternalClassEnumItem hkdFractureTypeEnumItems[] =
	{
		{0, "TYPE_INVALID"},
		{1, "TYPE_SPLITINHALF"},
		{2, "TYPE_WOOD"},
		{3, "TYPE_RANDOMSPLIT"},
		{4, "TYPE_SLICE"},
		{5, "TYPE_PIE"},
		{6, "TYPE_VORONOI"},
		{7, "TYPE_DEBRIS"},
		{8, "TYPE_CUTOUT"},
		{9, "TYPE_DECOMPOSE"},
		{10, "TYPE_RESERVED1"},
		{11, "TYPE_RESERVED2"},
		{12, "TYPE_NUM_TYPES"},
	};
	static const hkInternalClassEnumItem hkdFractureConnectivityTypeEnumItems[] =
	{
		{0, "CONNECTIVITY_NONE"},
		{1, "CONNECTIVITY_PARTIAL"},
		{2, "CONNECTIVITY_FULL"},
	};
	static const hkInternalClassEnumItem hkdFractureRefitPhysicsTypeEnumItems[] =
	{
		{0, "REFIT_NONE"},
		{1, "REFIT_CONVEX_HULL"},
		{2, "REFIT_SHRINK_TO_CONVEX_HULL"},
	};
	static const hkInternalClassEnum hkdFractureEnums[] = {
		{"Type", hkdFractureTypeEnumItems, 13, HK_NULL, 0 },
		{"ConnectivityType", hkdFractureConnectivityTypeEnumItems, 3, HK_NULL, 0 },
		{"RefitPhysicsType", hkdFractureRefitPhysicsTypeEnumItems, 3, HK_NULL, 0 }
	};
	const hkClassEnum* hkdFractureTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkdFractureEnums[0]);
	const hkClassEnum* hkdFractureConnectivityTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkdFractureEnums[1]);
	const hkClassEnum* hkdFractureRefitPhysicsTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkdFractureEnums[2]);
	static hkInternalClassMember hkdFractureClass_Members[] =
	{
		{ "rootToLeafRatio", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "minimumSize", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxDistanceForConnection", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "type", HK_NULL, HK_NULL, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "refitPhysicsShapes", HK_NULL, hkdFractureRefitPhysicsTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "flattenHierarchy", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "childFracture", &hkdFractureClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkdFracture_DefaultStruct
		{
			int s_defaultOffsets[7];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkReal m_rootToLeafRatio;
			hkReal m_maxDistanceForConnection;
			hkUint8 /* hkEnum< enum hkdFracture::RefitPhysicsType, hkUint8 > */ m_refitPhysicsShapes;
		};
		const hkdFracture_DefaultStruct hkdFracture_Default =
		{
			{HK_OFFSET_OF(hkdFracture_DefaultStruct,m_rootToLeafRatio),hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkdFracture_DefaultStruct,m_maxDistanceForConnection),-1,HK_OFFSET_OF(hkdFracture_DefaultStruct,m_refitPhysicsShapes),hkClassMember::HK_CLASS_ZERO_DEFAULT,-1},
			1e6f,0.1f,hkdFracture::REFIT_CONVEX_HULL
		};
	}
	hkClass hkdFractureClass(
		"hkdFracture",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkdFractureEnums),
		3,
		reinterpret_cast<const hkClassMember*>(hkdFractureClass_Members),
		HK_COUNT_OF(hkdFractureClass_Members),
		&hkdFracture_Default,
		HK_NULL,
		0,
		hkUint32(2)
		);
	static hkInternalClassMember hkdShareVerticesActionClass_Members[] =
	{
		{ "maxNumVerticesPerBuffer", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkdShareVerticesAction_DefaultStruct
		{
			int s_defaultOffsets[1];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkInt32 m_maxNumVerticesPerBuffer;
		};
		const hkdShareVerticesAction_DefaultStruct hkdShareVerticesAction_Default =
		{
			{HK_OFFSET_OF(hkdShareVerticesAction_DefaultStruct,m_maxNumVerticesPerBuffer)},
			0xffff
		};
	}
	hkClass hkdShareVerticesActionClass(
		"hkdShareVerticesAction",
		&hkdActionClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkdShareVerticesActionClass_Members),
		HK_COUNT_OF(hkdShareVerticesActionClass_Members),
		&hkdShareVerticesAction_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkdDecorateFractureFaceActionDecorationPivotEnumItems[] =
	{
		{0, "GEOMETRY_PIVOT"},
		{1, "AABB_CENTER"},
	};
	static const hkInternalClassEnumItem hkdDecorateFractureFaceActionDecorateWhatEnumItems[] =
	{
		{0, "DECORATE_NEIGHBOR"},
		{1, "DECORATE_SELF"},
		{2, "DECORATE_BOTH"},
		{3, "DECORATE_CHILDREN"},
	};
	static const hkInternalClassEnumItem hkdDecorateFractureFaceActionAlignmentEnumItems[] =
	{
		{0, "X_WITH_FACE_NORMAL"},
		{1, "X_WITH_CLOSEST_AXIS"},
		{2, "X_WITH_HORIZON"},
	};
	static const hkInternalClassEnumItem hkdDecorateFractureFaceActionProtrusionTestEnumItems[] =
	{
		{0, "FAST"},
		{1, "ACCURATE"},
		{2, "DISABLED"},
	};
	static const hkInternalClassEnumItem hkdDecorateFractureFaceActionPlacementCompressionTypesEnumItems[] =
	{
		{0, "FLOAT_32"},
		{1, "QUANTIZED"},
		{2, "FLOAT_16"},
	};
	static const hkInternalClassEnum hkdDecorateFractureFaceActionEnums[] = {
		{"DecorationPivot", hkdDecorateFractureFaceActionDecorationPivotEnumItems, 2, HK_NULL, 0 },
		{"DecorateWhat", hkdDecorateFractureFaceActionDecorateWhatEnumItems, 4, HK_NULL, 0 },
		{"Alignment", hkdDecorateFractureFaceActionAlignmentEnumItems, 3, HK_NULL, 0 },
		{"ProtrusionTest", hkdDecorateFractureFaceActionProtrusionTestEnumItems, 3, HK_NULL, 0 },
		{"PlacementCompressionTypes", hkdDecorateFractureFaceActionPlacementCompressionTypesEnumItems, 3, HK_NULL, 0 }
	};
	const hkClassEnum* hkdDecorateFractureFaceActionDecorationPivotEnum = reinterpret_cast<const hkClassEnum*>(&hkdDecorateFractureFaceActionEnums[0]);
	const hkClassEnum* hkdDecorateFractureFaceActionDecorateWhatEnum = reinterpret_cast<const hkClassEnum*>(&hkdDecorateFractureFaceActionEnums[1]);
	const hkClassEnum* hkdDecorateFractureFaceActionAlignmentEnum = reinterpret_cast<const hkClassEnum*>(&hkdDecorateFractureFaceActionEnums[2]);
	const hkClassEnum* hkdDecorateFractureFaceActionProtrusionTestEnum = reinterpret_cast<const hkClassEnum*>(&hkdDecorateFractureFaceActionEnums[3]);
	const hkClassEnum* hkdDecorateFractureFaceActionPlacementCompressionTypesEnum = reinterpret_cast<const hkClassEnum*>(&hkdDecorateFractureFaceActionEnums[4]);
	static hkInternalClassMember hkdDecorateFractureFaceAction_CompressedDecorationPlacementClass_Members[] =
	{
		{ "boundingBoxIdx", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "pos", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "rot", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkdDecorateFractureFaceActionCompressedDecorationPlacementClass(
		"hkdDecorateFractureFaceActionCompressedDecorationPlacement",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkdDecorateFractureFaceAction_CompressedDecorationPlacementClass_Members),
		HK_COUNT_OF(hkdDecorateFractureFaceAction_CompressedDecorationPlacementClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkdDecorateFractureFaceAction_GlobalDecorationDataClass_Members[] =
	{
		{ "templates", &hkdBreakableShapeClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "boundingBoxes", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VECTOR4, 0, 0, 0, HK_NULL },
		{ "rawTransforms", &hkQTransformClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "halfTransforms", &hkFloat16TransformClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "compressedPlacements", &hkdDecorateFractureFaceActionCompressedDecorationPlacementClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "indexBuffer", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT16, 0, 0, 0, HK_NULL },
		{ "graphicsRanges", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT16, 0, 0, 0, HK_NULL }
	};
	hkClass hkdDecorateFractureFaceActionGlobalDecorationDataClass(
		"hkdDecorateFractureFaceActionGlobalDecorationData",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkdDecorateFractureFaceAction_GlobalDecorationDataClass_Members),
		HK_COUNT_OF(hkdDecorateFractureFaceAction_GlobalDecorationDataClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(2)
		);
	static hkInternalClassMember hkdDecorateFractureFaceAction_ConnectionDecorationInfoClass_Members[] =
	{
		{ "owningAction", &hkdActionClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "otherShape", &hkdBreakableShapeClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "startIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "numDecorations", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkdDecorateFractureFaceActionConnectionDecorationInfoClass(
		"hkdDecorateFractureFaceActionConnectionDecorationInfo",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkdDecorateFractureFaceAction_ConnectionDecorationInfoClass_Members),
		HK_COUNT_OF(hkdDecorateFractureFaceAction_ConnectionDecorationInfoClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(2)
		);
	static hkInternalClassMember hkdDecorateFractureFaceAction_ShapeDecorationInfoClass_Members[] =
	{
		{ "connectionDecorations", &hkdDecorateFractureFaceActionConnectionDecorationInfoClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "sharedData", &hkdDecorateFractureFaceActionGlobalDecorationDataClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkdDecorateFractureFaceActionShapeDecorationInfoClass(
		"hkdDecorateFractureFaceActionShapeDecorationInfo",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkdDecorateFractureFaceAction_ShapeDecorationInfoClass_Members),
		HK_COUNT_OF(hkdDecorateFractureFaceAction_ShapeDecorationInfoClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(2)
		);
	static hkInternalClassMember hkdDecorateFractureFaceAction_FractureFaceInfoClass_Members[] =
	{
		{ "decorations", &hkdBreakableShapeClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "density", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "gap", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "spinAngle", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "randomSpinAngle", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "allowRandomFlipX", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "xShift", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "xRandomShift", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkdDecorateFractureFaceActionFractureFaceInfo_DefaultStruct
		{
			int s_defaultOffsets[8];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkReal m_density;
		};
		const hkdDecorateFractureFaceActionFractureFaceInfo_DefaultStruct hkdDecorateFractureFaceActionFractureFaceInfo_Default =
		{
			{-1,HK_OFFSET_OF(hkdDecorateFractureFaceActionFractureFaceInfo_DefaultStruct,m_density),hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT},
			1.0f
		};
	}
	hkClass hkdDecorateFractureFaceActionFractureFaceInfoClass(
		"hkdDecorateFractureFaceActionFractureFaceInfo",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkdDecorateFractureFaceAction_FractureFaceInfoClass_Members),
		HK_COUNT_OF(hkdDecorateFractureFaceAction_FractureFaceInfoClass_Members),
		&hkdDecorateFractureFaceActionFractureFaceInfo_Default,
		HK_NULL,
		0,
		hkUint32(3)
		);
	hkClass hkdDecorateFractureFaceActionFractureFaceInfo2Class(
		"hkdDecorateFractureFaceActionFractureFaceInfo2",
		&hkdDecorateFractureFaceActionFractureFaceInfoClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkdDecorateFractureFaceAction_CornerDecorationInfoClass_Members[] =
	{
		{ "decorations", &hkdBreakableShapeClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "density", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "minimumDistance", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maximumVerticalShift", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkdDecorateFractureFaceActionCornerDecorationInfo_DefaultStruct
		{
			int s_defaultOffsets[4];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkReal m_density;
			hkReal m_maximumVerticalShift;
		};
		const hkdDecorateFractureFaceActionCornerDecorationInfo_DefaultStruct hkdDecorateFractureFaceActionCornerDecorationInfo_Default =
		{
			{-1,HK_OFFSET_OF(hkdDecorateFractureFaceActionCornerDecorationInfo_DefaultStruct,m_density),hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkdDecorateFractureFaceActionCornerDecorationInfo_DefaultStruct,m_maximumVerticalShift)},
			1.0f,1.0e-5f
		};
	}
	hkClass hkdDecorateFractureFaceActionCornerDecorationInfoClass(
		"hkdDecorateFractureFaceActionCornerDecorationInfo",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkdDecorateFractureFaceAction_CornerDecorationInfoClass_Members),
		HK_COUNT_OF(hkdDecorateFractureFaceAction_CornerDecorationInfoClass_Members),
		&hkdDecorateFractureFaceActionCornerDecorationInfo_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkdDecorateFractureFaceActionClass_Members[] =
	{
		{ "decorateWhat", HK_NULL, hkdDecorateFractureFaceActionDecorateWhatEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "decorationPivot", HK_NULL, hkdDecorateFractureFaceActionDecorationPivotEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "upDir", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "alignDecorations", HK_NULL, hkdDecorateFractureFaceActionAlignmentEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "controlShapes", &hkdBreakableShapeClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "controlShapesTransform", HK_NULL, HK_NULL, hkClassMember::TYPE_TRANSFORM, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "minFractureLength", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "linearTolerance", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "angularTolerance", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "decorationsStorage", HK_NULL, hkdDecorateFractureFaceActionPlacementCompressionTypesEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "keepFixedDecorations", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "protrusionTest", HK_NULL, hkdDecorateFractureFaceActionProtrusionTestEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "maxProtrusion", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "fixupDistance", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "equalizeGaps", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "vertGridDist", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "vertGridOffset", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "horGridDist", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "horGridOffset", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "top", &hkdDecorateFractureFaceActionFractureFaceInfo2Class, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "bottom", &hkdDecorateFractureFaceActionFractureFaceInfo2Class, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "side", &hkdDecorateFractureFaceActionFractureFaceInfoClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "flat", &hkdDecorateFractureFaceActionFractureFaceInfoClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "corner", &hkdDecorateFractureFaceActionCornerDecorationInfoClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "actionCornerInfos", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "numCornerDecorationAttempts", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "borderOverlap", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "forceBorderOnEdges", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxAngleBetweenEdges", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkdDecorateFractureFaceAction_DefaultStruct
		{
			int s_defaultOffsets[29];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkUint8 /* hkEnum< enum hkdDecorateFractureFaceAction::DecorateWhat, hkUint8 > */ m_decorateWhat;
			hkUint8 /* hkEnum< enum hkdDecorateFractureFaceAction::DecorationPivot, hkUint8 > */ m_decorationPivot;
			_hkVector4 m_upDir;
			hkUint8 /* hkEnum< enum hkdDecorateFractureFaceAction::Alignment, hkUint8 > */ m_alignDecorations;
			hkReal m_minFractureLength;
			hkReal m_linearTolerance;
			hkReal m_angularTolerance;
			hkUint8 /* hkEnum< enum hkdDecorateFractureFaceAction::PlacementCompressionTypes, hkUint8 > */ m_decorationsStorage;
			_hkBool m_keepFixedDecorations;
			hkUint8 /* hkEnum< enum hkdDecorateFractureFaceAction::ProtrusionTest, hkUint8 > */ m_protrusionTest;
			_hkBool m_equalizeGaps;
			hkInt32 m_numCornerDecorationAttempts;
			hkReal m_maxAngleBetweenEdges;
		};
		const hkdDecorateFractureFaceAction_DefaultStruct hkdDecorateFractureFaceAction_Default =
		{
			{HK_OFFSET_OF(hkdDecorateFractureFaceAction_DefaultStruct,m_decorateWhat),HK_OFFSET_OF(hkdDecorateFractureFaceAction_DefaultStruct,m_decorationPivot),HK_OFFSET_OF(hkdDecorateFractureFaceAction_DefaultStruct,m_upDir),HK_OFFSET_OF(hkdDecorateFractureFaceAction_DefaultStruct,m_alignDecorations),-1,-1,HK_OFFSET_OF(hkdDecorateFractureFaceAction_DefaultStruct,m_minFractureLength),HK_OFFSET_OF(hkdDecorateFractureFaceAction_DefaultStruct,m_linearTolerance),HK_OFFSET_OF(hkdDecorateFractureFaceAction_DefaultStruct,m_angularTolerance),HK_OFFSET_OF(hkdDecorateFractureFaceAction_DefaultStruct,m_decorationsStorage),HK_OFFSET_OF(hkdDecorateFractureFaceAction_DefaultStruct,m_keepFixedDecorations),HK_OFFSET_OF(hkdDecorateFractureFaceAction_DefaultStruct,m_protrusionTest),hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkdDecorateFractureFaceAction_DefaultStruct,m_equalizeGaps),hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,-1,-1,-1,-1,-1,-1,HK_OFFSET_OF(hkdDecorateFractureFaceAction_DefaultStruct,m_numCornerDecorationAttempts),hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkdDecorateFractureFaceAction_DefaultStruct,m_maxAngleBetweenEdges)},
		hkdDecorateFractureFaceAction::DECORATE_NEIGHBOR,hkdDecorateFractureFaceAction::AABB_CENTER,	{0.0f,1.0f,0.0f},hkdDecorateFractureFaceAction::X_WITH_FACE_NORMAL,0.1f,0.0001f,0.0001f,hkdDecorateFractureFaceAction::FLOAT_32,true,hkdDecorateFractureFaceAction::FAST,true,-1,6.28318530717958f
		};
	}
	hkClass hkdDecorateFractureFaceActionClass(
		"hkdDecorateFractureFaceAction",
		&hkdActionClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkdDecorateFractureFaceActionEnums),
		5,
		reinterpret_cast<const hkClassMember*>(hkdDecorateFractureFaceActionClass_Members),
		HK_COUNT_OF(hkdDecorateFractureFaceActionClass_Members),
		&hkdDecorateFractureFaceAction_Default,
		HK_NULL,
		0,
		hkUint32(8)
		);
	static hkInternalClassMember hkdDecorateFractureFaceActionForwarderClass_Members[] =
	{
		{ "child", &hkdDecorateFractureFaceActionClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkdDecorateFractureFaceActionForwarderClass(
		"hkdDecorateFractureFaceActionForwarder",
		&hkdActionClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkdDecorateFractureFaceActionForwarderClass_Members),
		HK_COUNT_OF(hkdDecorateFractureFaceActionForwarderClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkdBreakableBodyMementoInvalidBodyIdEnumItems[] =
	{
		{65535, "INVALID_BODY_ID"},
	};
	static const hkInternalClassEnum hkdBreakableBodyMementoEnums[] = {
		{"InvalidBodyId", hkdBreakableBodyMementoInvalidBodyIdEnumItems, 1, HK_NULL, 0 }
	};
	const hkClassEnum* hkdBreakableBodyMementoInvalidBodyIdEnum = reinterpret_cast<const hkClassEnum*>(&hkdBreakableBodyMementoEnums[0]);
	static hkInternalClassMember hkdBreakableBodyMementoClass_Members[] =
	{
		{ "bodyId", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "rotation", HK_NULL, HK_NULL, hkClassMember::TYPE_QUATERNION, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "translation", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "linearVelocity", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "angularVelocity", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkdBreakableBodyMemento_DefaultStruct
		{
			int s_defaultOffsets[5];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkUint16 m_bodyId;
			_hkQuaternion m_rotation;
			_hkVector4 m_translation;
			_hkVector4 m_linearVelocity;
			_hkVector4 m_angularVelocity;
		};
		const hkdBreakableBodyMemento_DefaultStruct hkdBreakableBodyMemento_Default =
		{
			{HK_OFFSET_OF(hkdBreakableBodyMemento_DefaultStruct,m_bodyId),HK_OFFSET_OF(hkdBreakableBodyMemento_DefaultStruct,m_rotation),HK_OFFSET_OF(hkdBreakableBodyMemento_DefaultStruct,m_translation),HK_OFFSET_OF(hkdBreakableBodyMemento_DefaultStruct,m_linearVelocity),HK_OFFSET_OF(hkdBreakableBodyMemento_DefaultStruct,m_angularVelocity)},
	hkdBreakableBodyMemento::INVALID_BODY_ID,	{0.0f,0.0f,0.0f,1.0f},	{0.0f,0.0f,0.0f},	{0.0f,0.0f,0.0f},	{0.0f,0.0f,0.0f}
		};
	}
	hkClass hkdBreakableBodyMementoClass(
		"hkdBreakableBodyMemento",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkdBreakableBodyMementoEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkdBreakableBodyMementoClass_Members),
		HK_COUNT_OF(hkdBreakableBodyMementoClass_Members),
		&hkdBreakableBodyMemento_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkdSimpleBreakableBodyMementoClass_Members[] =
	{
		{ "path", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT16, 0, 0, 0, HK_NULL }
	};
	hkClass hkdSimpleBreakableBodyMementoClass(
		"hkdSimpleBreakableBodyMemento",
		&hkdBreakableBodyMementoClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkdSimpleBreakableBodyMementoClass_Members),
		HK_COUNT_OF(hkdSimpleBreakableBodyMementoClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkdCompoundBreakableBodyMementoClass_Members[] =
	{
		{ "paths", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT16, 0, 0, 0, HK_NULL },
		{ "transforms", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_TRANSFORM, 0, 0, 0, HK_NULL }
	};
	hkClass hkdCompoundBreakableBodyMementoClass(
		"hkdCompoundBreakableBodyMemento",
		&hkdBreakableBodyMementoClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkdCompoundBreakableBodyMementoClass_Members),
		HK_COUNT_OF(hkdCompoundBreakableBodyMementoClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkdDeformableBreakableBodyMementoClass_Members[] =
	{
		{ "transforms", &hkQTransformClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkdDeformableBreakableBodyMementoClass(
		"hkdDeformableBreakableBodyMemento",
		&hkdBreakableBodyMementoClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkdDeformableBreakableBodyMementoClass_Members),
		HK_COUNT_OF(hkdDeformableBreakableBodyMementoClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkdDecomposeFractureClass_Members[] =
	{
		{ "splittingGeometry", &hkdGeometryClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "shiftToSmallerCrossSection", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "clipZoneWidth", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkdDecomposeFracture_DefaultStruct
		{
			int s_defaultOffsets[3];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkReal m_shiftToSmallerCrossSection;
			hkReal m_clipZoneWidth;
		};
		const hkdDecomposeFracture_DefaultStruct hkdDecomposeFracture_Default =
		{
			{-1,HK_OFFSET_OF(hkdDecomposeFracture_DefaultStruct,m_shiftToSmallerCrossSection),HK_OFFSET_OF(hkdDecomposeFracture_DefaultStruct,m_clipZoneWidth)},
			0.1f,0.3f
		};
	}
	hkClass hkdDecomposeFractureClass(
		"hkdDecomposeFracture",
		&hkdFractureClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkdDecomposeFractureClass_Members),
		HK_COUNT_OF(hkdDecomposeFractureClass_Members),
		&hkdDecomposeFracture_Default,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkdSetRigidBodyPropertiesActionClass_Members[] =
	{
		{ "setCollisionFilter", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "collisionFilterInfo", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "gravityFactor", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "inertiaFactor", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "setDamping", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "linearDamping", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "angularDamping", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "setMass", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "mass", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "setFriction", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "friction", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "setRestitution", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "restitution", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "setDeactivation", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "enableDeactivation", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkdSetRigidBodyPropertiesAction_DefaultStruct
		{
			int s_defaultOffsets[15];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkReal m_gravityFactor;
			hkReal m_inertiaFactor;
			hkReal m_angularDamping;
			hkReal m_friction;
			_hkBool m_enableDeactivation;
		};
		const hkdSetRigidBodyPropertiesAction_DefaultStruct hkdSetRigidBodyPropertiesAction_Default =
		{
			{hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkdSetRigidBodyPropertiesAction_DefaultStruct,m_gravityFactor),HK_OFFSET_OF(hkdSetRigidBodyPropertiesAction_DefaultStruct,m_inertiaFactor),hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkdSetRigidBodyPropertiesAction_DefaultStruct,m_angularDamping),hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkdSetRigidBodyPropertiesAction_DefaultStruct,m_friction),hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkdSetRigidBodyPropertiesAction_DefaultStruct,m_enableDeactivation)},
			1.0f,1.0f,0.5f,1.0f,true
		};
	}
	hkClass hkdSetRigidBodyPropertiesActionClass(
		"hkdSetRigidBodyPropertiesAction",
		&hkdActionClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkdSetRigidBodyPropertiesActionClass_Members),
		HK_COUNT_OF(hkdSetRigidBodyPropertiesActionClass_Members),
		&hkdSetRigidBodyPropertiesAction_Default,
		HK_NULL,
		0,
		hkUint32(2)
		);
	static const hkInternalClassEnumItem hkdControllerControllerTypeEnumItems[] =
	{
		{0, "CONTROLLER_TYPE_INVALID"},
		{1, "CONTROLLER_TYPE_CONTACTREGION"},
		{2, "CONTROLLER_TYPE_DEFORMATION"},
		{3, "CONTROLLER_TYPE_SPLITINHALF"},
		{4, "CONTROLLER_TYPE_WOOD"},
		{5, "CONTROLLER_TYPE_FLEXIBLE_JOINT"},
		{6, "CONTROLLER_TYPE_USER"},
		{7, "CONTROLLER_TYPE_BUILDING"},
		{8, "CONTROLLER_TYPE_NUM_TYPES"},
	};
	static const hkInternalClassEnumItem hkdControllerConstrainToTypeEnumItems[] =
	{
		{0, "CONSTRAIN_TO_NONE"},
		{1, "CONSTRAIN_TO_FIXED_UNBREAKABLE"},
		{2, "CONSTRAIN_TO_FIXED"},
		{3, "CONSTRAIN_TO_UNBREAKABLE"},
		{4, "CONSTRAIN_TO_ALL"},
	};
	static const hkInternalClassEnumItem hkdControllerShapeDecisionResultEnumItems[] =
	{
		{0, "PROCESSING_ERROR"},
		{1, "INTERSECTING_FOUND"},
		{2, "OUTSIDE_FOUND"},
		{4, "DYNAMIC_CREATED"},
		{8, "FIXED_FORCED_OUTSIDE"},
		{16, "WEAK_FORCED_OUTSIDE"},
		{32, "USER_FORCED_OUTSIDE"},
		{64, "USER_FORCED_INSIDE"},
	};
	static const hkInternalClassEnum hkdControllerEnums[] = {
		{"ControllerType", hkdControllerControllerTypeEnumItems, 9, HK_NULL, 0 },
		{"ConstrainToType", hkdControllerConstrainToTypeEnumItems, 5, HK_NULL, 0 },
		{"ShapeDecisionResult", hkdControllerShapeDecisionResultEnumItems, 8, HK_NULL, 0 }
	};
	const hkClassEnum* hkdControllerControllerTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkdControllerEnums[0]);
	const hkClassEnum* hkdControllerConstrainToTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkdControllerEnums[1]);
	const hkClassEnum* hkdControllerShapeDecisionResultEnum = reinterpret_cast<const hkClassEnum*>(&hkdControllerEnums[2]);
	static hkInternalClassMember hkdController_SmallArraySerializeOverrideTypeClass_Members[] =
	{
		{ "data", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "size", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "capacityAndFlags", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkdControllerSmallArraySerializeOverrideTypeClass(
		"hkdControllerSmallArraySerializeOverrideType",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkdController_SmallArraySerializeOverrideTypeClass_Members),
		HK_COUNT_OF(hkdController_SmallArraySerializeOverrideTypeClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkdControllerClass_Members[] =
	{
		{ "type", HK_NULL, HK_NULL, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "insideDecisionFunctor", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "listeners", &hkdControllerSmallArraySerializeOverrideTypeClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "dynamicFractureBridge", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hkdControllerClass(
		"hkdController",
		&hkpBreakableBodyControllerClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkdControllerEnums),
		3,
		reinterpret_cast<const hkClassMember*>(hkdControllerClass_Members),
		HK_COUNT_OF(hkdControllerClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkdPropertiesClass_Members[] =
	{
		{ "properties", &hkpPropertyClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkdPropertiesClass(
		"hkdProperties",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkdPropertiesClass_Members),
		HK_COUNT_OF(hkdPropertiesClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkdObjectProperties_PropertyClass_Members[] =
	{
		{ "key", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "object", &hkReferencedObjectClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkdObjectPropertiesPropertyClass(
		"hkdObjectPropertiesProperty",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkdObjectProperties_PropertyClass_Members),
		HK_COUNT_OF(hkdObjectProperties_PropertyClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkdObjectPropertiesClass_Members[] =
	{
		{ "properties", &hkdObjectPropertiesPropertyClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkdObjectPropertiesClass(
		"hkdObjectProperties",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkdObjectPropertiesClass_Members),
		HK_COUNT_OF(hkdObjectPropertiesClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkdStringObjectClass_Members[] =
	{
		{ "string", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkdStringObjectClass(
		"hkdStringObject",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkdStringObjectClass_Members),
		HK_COUNT_OF(hkdStringObjectClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkdPropertyFlagSetClass_Members[] =
	{
		{ "properties", &hkdPropertiesClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkdPropertyFlagSetClass(
		"hkdPropertyFlagSet",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkdPropertyFlagSetClass_Members),
		HK_COUNT_OF(hkdPropertyFlagSetClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkdDebugLines_DebugLineClass_Members[] =
	{
		{ "start", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "end", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "color", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkdDebugLinesDebugLineClass(
		"hkdDebugLinesDebugLine",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkdDebugLines_DebugLineClass_Members),
		HK_COUNT_OF(hkdDebugLines_DebugLineClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkdDebugLines_DebugTextClass_Members[] =
	{
		{ "pos", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "string", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "color", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkdDebugLinesDebugTextClass(
		"hkdDebugLinesDebugText",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkdDebugLines_DebugTextClass_Members),
		HK_COUNT_OF(hkdDebugLines_DebugTextClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkdDebugLinesClass_Members[] =
	{
		{ "texts", &hkdDebugLinesDebugTextClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "lines", &hkdDebugLinesDebugLineClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkdDebugLinesClass(
		"hkdDebugLines",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkdDebugLinesClass_Members),
		HK_COUNT_OF(hkdDebugLinesClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkdTransformObjectClass_Members[] =
	{
		{ "transform", HK_NULL, HK_NULL, hkClassMember::TYPE_TRANSFORM, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkdTransformObjectClass(
		"hkdTransformObject",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkdTransformObjectClass_Members),
		HK_COUNT_OF(hkdTransformObjectClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkdShapeConnectivityEnumItems[] =
	{
		{0, "CONNECTIVITY_INHERITED"},
		{1, "CONNECTIVITY_PARTIAL"},
		{2, "CONNECTIVITY_FULL"},
		{3, "CONNECTIVITY_NONE"},
		{4, "CONNECTIVITY_ROOT_ONLY"},
	};
	static const hkInternalClassEnumItem hkdShapeFlexibleJointTypeEnumItems[] =
	{
		{0, "FLEXJOINT_SELF"},
		{1, "FLEXJOINT_CHILDREN"},
		{2, "FLEXJOINT_FIXED"},
	};
	static const hkInternalClassEnumItem hkdShapeBodyQualityTypeEnumItems[] =
	{
		{0, "QUALITY_INHERITED"},
		{1, "QUALITY_FIXED"},
		{2, "QUALITY_DEBRIS"},
		{3, "QUALITY_DEBRIS_SIMPLE_TOI"},
		{4, "QUALITY_MOVING"},
		{5, "QUALITY_CRITICAL"},
	};
	static const hkInternalClassEnum hkdShapeEnums[] = {
		{"Connectivity", hkdShapeConnectivityEnumItems, 5, HK_NULL, 0 },
		{"FlexibleJointType", hkdShapeFlexibleJointTypeEnumItems, 3, HK_NULL, 0 },
		{"BodyQualityType", hkdShapeBodyQualityTypeEnumItems, 6, HK_NULL, 0 }
	};
	const hkClassEnum* hkdShapeConnectivityEnum = reinterpret_cast<const hkClassEnum*>(&hkdShapeEnums[0]);
	const hkClassEnum* hkdShapeFlexibleJointTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkdShapeEnums[1]);
	const hkClassEnum* hkdShapeBodyQualityTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkdShapeEnums[2]);
	static hkInternalClassMember hkdShapeClass_Members[] =
	{
		{ "parentName", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "fracture", &hkdFractureClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "mergeCoplanarTriangles", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "connectivity", HK_NULL, hkdShapeConnectivityEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "flattenChildCompounds", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "dynamicFracture", &hkdFractureClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "strength", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "relativeSubpieceStrength", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "breakingPropagationRate", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "destructionRadius", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "bodyQualityType", HK_NULL, hkdShapeBodyQualityTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "flexibleJointType", HK_NULL, hkdShapeFlexibleJointTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "attributes", &hkxAttributeClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkdShape_DefaultStruct
		{
			int s_defaultOffsets[13];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			_hkBool m_mergeCoplanarTriangles;
			hkUint8 /* hkEnum< enum hkdShape::Connectivity, hkUint8 > */ m_connectivity;
			_hkBool m_flattenChildCompounds;
			hkReal m_relativeSubpieceStrength;
			hkReal m_breakingPropagationRate;
			hkUint8 /* hkEnum< enum hkdShape::BodyQualityType, hkUint8 > */ m_bodyQualityType;
			hkUint8 /* hkEnum< enum hkdShape::FlexibleJointType, hkUint8 > */ m_flexibleJointType;
		};
		const hkdShape_DefaultStruct hkdShape_Default =
		{
			{-1,-1,HK_OFFSET_OF(hkdShape_DefaultStruct,m_mergeCoplanarTriangles),HK_OFFSET_OF(hkdShape_DefaultStruct,m_connectivity),HK_OFFSET_OF(hkdShape_DefaultStruct,m_flattenChildCompounds),-1,hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkdShape_DefaultStruct,m_relativeSubpieceStrength),HK_OFFSET_OF(hkdShape_DefaultStruct,m_breakingPropagationRate),hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkdShape_DefaultStruct,m_bodyQualityType),HK_OFFSET_OF(hkdShape_DefaultStruct,m_flexibleJointType),-1},
			true,hkdShape::CONNECTIVITY_INHERITED,true,1.0f,0.1f,hkdShape::QUALITY_INHERITED,hkdShape::FLEXJOINT_SELF
		};
	}
	hkClass hkdShapeClass(
		"hkdShape",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkdShapeEnums),
		3,
		reinterpret_cast<const hkClassMember*>(hkdShapeClass_Members),
		HK_COUNT_OF(hkdShapeClass_Members),
		&hkdShape_Default,
		HK_NULL,
		0,
		hkUint32(3)
		);
	static hkInternalClassMember hkdContactRegionControllerClass_Members[] =
	{
		{ "maxRecursionLevels", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkdContactRegionController_DefaultStruct
		{
			int s_defaultOffsets[1];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkInt32 m_maxRecursionLevels;
		};
		const hkdContactRegionController_DefaultStruct hkdContactRegionController_Default =
		{
			{HK_OFFSET_OF(hkdContactRegionController_DefaultStruct,m_maxRecursionLevels)},
			1000
		};
	}
	hkClass hkdContactRegionControllerClass(
		"hkdContactRegionController",
		&hkdControllerClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkdContactRegionControllerClass_Members),
		HK_COUNT_OF(hkdContactRegionControllerClass_Members),
		&hkdContactRegionController_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkdBreakableShapeTypeAndFlagsEnumItems[] =
	{
		{0, "SHAPE_TYPE_OR_FLAG_INVALID"},
		{1, "SHAPE_TYPE_SIMPLE"},
		{2, "SHAPE_TYPE_COMPOUND"},
		{4, "SHAPE_TYPE_DEFORMABLE"},
		{7, "SHAPE_TYPE_MASK"},
		{8, "SHAPE_FLAG_DO_NOT_FLATTEN_RECURSIVE_COMPOUNDS"},
		{16, "SHAPE_FLAG_CONTAINS_FIXED_CHILDREN"},
		{128, "SHAPE_FLAG_FRACTURE_HELPER"},
	};
	static const hkInternalClassEnumItem hkdBreakableShapeRefitTypeEnumItems[] =
	{
		{0, "REFIT_CONVEX_HULL"},
		{1, "REFIT_SHRINK_TO_CONVEX_HULL"},
	};
	static const hkInternalClassEnumItem hkdBreakableShapeRecalcChildrenEnumItems[] =
	{
		{1, "RECALC_CHILDREN_BREAKING_THRESHOLDS"},
		{0, "DO_NOT_RECALC_CHILDREN_BREAKING_THRESHOLDS"},
	};
	static const hkInternalClassEnum hkdBreakableShapeEnums[] = {
		{"TypeAndFlags", hkdBreakableShapeTypeAndFlagsEnumItems, 8, HK_NULL, 0 },
		{"RefitType", hkdBreakableShapeRefitTypeEnumItems, 2, HK_NULL, 0 },
		{"RecalcChildren", hkdBreakableShapeRecalcChildrenEnumItems, 2, HK_NULL, 0 }
	};
	const hkClassEnum* hkdBreakableShapeTypeAndFlagsEnum = reinterpret_cast<const hkClassEnum*>(&hkdBreakableShapeEnums[0]);
	const hkClassEnum* hkdBreakableShapeRefitTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkdBreakableShapeEnums[1]);
	const hkClassEnum* hkdBreakableShapeRecalcChildrenEnum = reinterpret_cast<const hkClassEnum*>(&hkdBreakableShapeEnums[2]);
	static hkInternalClassMember hkdBreakableShape_ContactAreaClass_Members[] =
	{
		{ "vertices", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VECTOR4, 0, 0, 0, HK_NULL }
	};
	hkClass hkdBreakableShapeContactAreaClass(
		"hkdBreakableShapeContactArea",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkdBreakableShape_ContactAreaClass_Members),
		HK_COUNT_OF(hkdBreakableShape_ContactAreaClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkdBreakableShape_ConnectionClass_Members[] =
	{
		{ "pivotA", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "pivotB", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "separatingNormal", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "contactArea", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "a", &hkdBreakableShapeClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "b", &hkdBreakableShapeClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "contactAreaDetails", &hkdBreakableShapeContactAreaClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkdBreakableShapeConnectionClass(
		"hkdBreakableShapeConnection",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkdBreakableShape_ConnectionClass_Members),
		HK_COUNT_OF(hkdBreakableShape_ConnectionClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkdBreakableShape_ConnectionListClass_Members[] =
	{
		{ "connections", &hkdBreakableShapeConnectionClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkdBreakableShapeConnectionListClass(
		"hkdBreakableShapeConnectionList",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkdBreakableShape_ConnectionListClass_Members),
		HK_COUNT_OF(hkdBreakableShape_ConnectionListClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkdBreakableShape_ActionListClass_Members[] =
	{
		{ "actions", &hkdActionClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL }
	};
	hkClass hkdBreakableShapeActionListClass(
		"hkdBreakableShapeActionList",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkdBreakableShape_ActionListClass_Members),
		HK_COUNT_OF(hkdBreakableShape_ActionListClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkdBreakableShapeClass_Members[] =
	{
		{ "typeAndFlags", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "connectivityType", HK_NULL, hkdShapeConnectivityEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "flexibleJointType", HK_NULL, hkdShapeFlexibleJointTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "qualityType", HK_NULL, hkdShapeBodyQualityTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "parent", &hkdBreakableShapeClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "majorAxisSpace", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "geometry", &hkdGeometryClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "comAndMass", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "inertiaAndValues", HK_NULL, HK_NULL, hkClassMember::TYPE_HALF, hkClassMember::TYPE_VOID, 8, 0, 0, HK_NULL },
		{ "children", &hkdShapeInstanceInfoClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "graphicsShape", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "objectProperties", &hkdObjectPropertiesClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "userData", HK_NULL, HK_NULL, hkClassMember::TYPE_ULONG, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkdBreakableShape_DefaultStruct
		{
			int s_defaultOffsets[13];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkUint8 /* hkEnum< enum hkdShape::Connectivity, hkUint8 > */ m_connectivityType;
			hkUint8 /* hkEnum< enum hkdShape::FlexibleJointType, hkUint8 > */ m_flexibleJointType;
			hkUint8 /* hkEnum< enum hkdShape::BodyQualityType, hkUint8 > */ m_qualityType;
			_hkVector4 m_comAndMass;
		};
		const hkdBreakableShape_DefaultStruct hkdBreakableShape_Default =
		{
			{hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkdBreakableShape_DefaultStruct,m_connectivityType),HK_OFFSET_OF(hkdBreakableShape_DefaultStruct,m_flexibleJointType),HK_OFFSET_OF(hkdBreakableShape_DefaultStruct,m_qualityType),-1,-1,-1,HK_OFFSET_OF(hkdBreakableShape_DefaultStruct,m_comAndMass),-1,-1,-1,-1,hkClassMember::HK_CLASS_ZERO_DEFAULT},
		hkdShape::CONNECTIVITY_INHERITED,hkdShape::FLEXJOINT_SELF,hkdShape::QUALITY_INHERITED,	{0.0f,0.0f,0.0f,1.0f}
		};
	}
	hkClass hkdBreakableShapeClass(
		"hkdBreakableShape",
		&hkpBreakableShapeClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkdBreakableShapeEnums),
		3,
		reinterpret_cast<const hkClassMember*>(hkdBreakableShapeClass_Members),
		HK_COUNT_OF(hkdBreakableShapeClass_Members),
		&hkdBreakableShape_Default,
		HK_NULL,
		0,
		hkUint32(6)
		);
	static const hkInternalClassEnumItem hkdShapeInstanceInfoFlagsEnumItems[] =
	{
		{1, "FLAG_IS_DEBRIS_PIECE"},
	};
	static const hkInternalClassEnum hkdShapeInstanceInfoEnums[] = {
		{"Flags", hkdShapeInstanceInfoFlagsEnumItems, 1, HK_NULL, 0 }
	};
	const hkClassEnum* hkdShapeInstanceInfoFlagsEnum = reinterpret_cast<const hkClassEnum*>(&hkdShapeInstanceInfoEnums[0]);
	static hkInternalClassMember hkdShapeInstanceInfo_RuntimeInfoClass_Members[] =
	{
		{ "distanceToDestructionPoint", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "forceFixed", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "parentUid", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkdShapeInstanceInfoRuntimeInfoClass(
		"hkdShapeInstanceInfoRuntimeInfo",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkdShapeInstanceInfo_RuntimeInfoClass_Members),
		HK_COUNT_OF(hkdShapeInstanceInfo_RuntimeInfoClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(2)
		);
	static hkInternalClassMember hkdShapeInstanceInfoClass_Members[] =
	{
		{ "transform", &hkQTransformClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "shape", &hkdBreakableShapeClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "damage", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "flags", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "tempControllerData", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "runtimeInfo", &hkdShapeInstanceInfoRuntimeInfoClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hkdShapeInstanceInfoClass(
		"hkdShapeInstanceInfo",
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkdShapeInstanceInfoEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkdShapeInstanceInfoClass_Members),
		HK_COUNT_OF(hkdShapeInstanceInfoClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(4)
		);
	static hkInternalClassMember hkdDebrisFractureInfo_TemplateInfoClass_Members[] =
	{
		{ "templateDebris", &hkdBreakableShapeClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "density", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkdDebrisFractureInfoTemplateInfo_DefaultStruct
		{
			int s_defaultOffsets[2];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkReal m_density;
		};
		const hkdDebrisFractureInfoTemplateInfo_DefaultStruct hkdDebrisFractureInfoTemplateInfo_Default =
		{
			{-1,HK_OFFSET_OF(hkdDebrisFractureInfoTemplateInfo_DefaultStruct,m_density)},
			1.0f
		};
	}
	hkClass hkdDebrisFractureInfoTemplateInfoClass(
		"hkdDebrisFractureInfoTemplateInfo",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkdDebrisFractureInfo_TemplateInfoClass_Members),
		HK_COUNT_OF(hkdDebrisFractureInfo_TemplateInfoClass_Members),
		&hkdDebrisFractureInfoTemplateInfo_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkdDebrisFractureInfoClass_Members[] =
	{
		{ "info0", &hkdDebrisFractureInfoTemplateInfoClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "info1", &hkdDebrisFractureInfoTemplateInfoClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "info2", &hkdDebrisFractureInfoTemplateInfoClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkdDebrisFractureInfoClass(
		"hkdDebrisFractureInfo",
		&hkdInfoClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkdDebrisFractureInfoClass_Members),
		HK_COUNT_OF(hkdDebrisFractureInfoClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkdDebrisFractureInsertTypeEnumItems[] =
	{
		{0, "INSERT_USE_DEBRIS_PIVOT"},
		{1, "INSERT_RND_POSITION"},
		{2, "INSERT_RND_TRANSFORM"},
	};
	static const hkInternalClassEnumItem hkdDebrisFracturePositionSourceEnumItems[] =
	{
		{0, "SRC_CONTROL_SHAPE"},
		{1, "SRC_INTERSECTION"},
		{2, "SRC_BREAKABLE_SHAPE"},
	};
	static const hkInternalClassEnum hkdDebrisFractureEnums[] = {
		{"InsertType", hkdDebrisFractureInsertTypeEnumItems, 3, HK_NULL, 0 },
		{"PositionSource", hkdDebrisFracturePositionSourceEnumItems, 3, HK_NULL, 0 }
	};
	const hkClassEnum* hkdDebrisFractureInsertTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkdDebrisFractureEnums[0]);
	const hkClassEnum* hkdDebrisFracturePositionSourceEnum = reinterpret_cast<const hkClassEnum*>(&hkdDebrisFractureEnums[1]);
	static hkInternalClassMember hkdDebrisFractureClass_Members[] =
	{
		{ "templateDebris", &hkdBreakableShapeClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "maxNumPieces", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "insertType", HK_NULL, hkdDebrisFractureInsertTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "controlShapes", &hkdBreakableShapeClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "controlShapesTransform", HK_NULL, HK_NULL, hkClassMember::TYPE_TRANSFORM, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "positionSource", HK_NULL, hkdDebrisFracturePositionSourceEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "gap", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "density", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkdDebrisFracture_DefaultStruct
		{
			int s_defaultOffsets[8];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkUint32 m_maxNumPieces;
			hkUint8 /* hkEnum< enum hkdDebrisFracture::InsertType, hkUint8 > */ m_insertType;
			hkUint8 /* hkEnum< enum hkdDebrisFracture::PositionSource, hkUint8 > */ m_positionSource;
			hkReal m_density;
		};
		const hkdDebrisFracture_DefaultStruct hkdDebrisFracture_Default =
		{
			{-1,HK_OFFSET_OF(hkdDebrisFracture_DefaultStruct,m_maxNumPieces),HK_OFFSET_OF(hkdDebrisFracture_DefaultStruct,m_insertType),-1,-1,HK_OFFSET_OF(hkdDebrisFracture_DefaultStruct,m_positionSource),hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkdDebrisFracture_DefaultStruct,m_density)},
			100,hkdDebrisFracture::INSERT_RND_TRANSFORM,hkdDebrisFracture::SRC_INTERSECTION,1.0f
		};
	}
	hkClass hkdDebrisFractureClass(
		"hkdDebrisFracture",
		&hkdFractureClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkdDebrisFractureEnums),
		2,
		reinterpret_cast<const hkClassMember*>(hkdDebrisFractureClass_Members),
		HK_COUNT_OF(hkdDebrisFractureClass_Members),
		&hkdDebrisFracture_Default,
		HK_NULL,
		0,
		hkUint32(2)
		);
	static hkInternalClassMember hkdSplitShapeClass_Members[] =
	{
		{ "graphicsShape", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "geometry", &hkdGeometryClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkdSplitShapeClass(
		"hkdSplitShape",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkdSplitShapeClass_Members),
		HK_COUNT_OF(hkdSplitShapeClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkdRemoveDebrisActionClass_Members[] =
	{
		{ "removeInSeconds", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "removeOnTimeout", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkdRemoveDebrisAction_DefaultStruct
		{
			int s_defaultOffsets[2];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkReal m_removeInSeconds;
		};
		const hkdRemoveDebrisAction_DefaultStruct hkdRemoveDebrisAction_Default =
		{
			{HK_OFFSET_OF(hkdRemoveDebrisAction_DefaultStruct,m_removeInSeconds),hkClassMember::HK_CLASS_ZERO_DEFAULT},
			10.0f
		};
	}
	hkClass hkdRemoveDebrisActionClass(
		"hkdRemoveDebrisAction",
		&hkdActionClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkdRemoveDebrisActionClass_Members),
		HK_COUNT_OF(hkdRemoveDebrisActionClass_Members),
		&hkdRemoveDebrisAction_Default,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static const hkInternalClassEnumItem hkdDecalMapActionDecalMapTypeEnumItems[] =
	{
		{0, "DECAL_MAP_EMPTY"},
		{1, "DECAL_MAP_DECAL"},
		{2, "DECAL_MAP_DECORATION"},
		{3, "DECAL_MAP_DECORATION_BASE"},
	};
	static const hkInternalClassEnum hkdDecalMapActionEnums[] = {
		{"DecalMapType", hkdDecalMapActionDecalMapTypeEnumItems, 4, HK_NULL, 0 }
	};
	const hkClassEnum* hkdDecalMapActionDecalMapTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkdDecalMapActionEnums[0]);
	static hkInternalClassMember hkdDecalMapAction_DecalMapClass_Members[] =
	{
		{ "textureW", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "textureH", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "type", HK_NULL, hkdDecalMapActionDecalMapTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "data", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL }
	};
	hkClass hkdDecalMapActionDecalMapClass(
		"hkdDecalMapActionDecalMap",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkdDecalMapAction_DecalMapClass_Members),
		HK_COUNT_OF(hkdDecalMapAction_DecalMapClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkdDecalMapAction_DecorMapInfoClass_Members[] =
	{
		{ "intersectingMaps", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT16, 0, 0, 0, HK_NULL }
	};
	hkClass hkdDecalMapActionDecorMapInfoClass(
		"hkdDecalMapActionDecorMapInfo",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkdDecalMapAction_DecorMapInfoClass_Members),
		HK_COUNT_OF(hkdDecalMapAction_DecorMapInfoClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkdDecalMapAction_DecalMapDataClass_Members[] =
	{
		{ "decals", &hkdDecalMapActionDecalMapClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "decors", &hkdDecalMapActionDecalMapClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "decorInfo", &hkdDecalMapActionDecorMapInfoClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "decorMapBaseIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkdDecalMapActionDecalMapDataClass(
		"hkdDecalMapActionDecalMapData",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkdDecalMapAction_DecalMapDataClass_Members),
		HK_COUNT_OF(hkdDecalMapAction_DecalMapDataClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkdDecalMapActionClass_Members[] =
	{
		{ "xResolution", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "yResolution", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "uvChannel", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "extraRadius", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "softRadius", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "decorationShape", &hkdBreakableShapeClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "decorationShapeTransform", HK_NULL, HK_NULL, hkClassMember::TYPE_TRANSFORM, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "xResolutionDecoration", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "yResolutionDecoration", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "uvChannelDecoration", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "extraRadiusDecoration", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "softRadiusDecoration", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "enableDebugBitmapGeneration", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkdDecalMapAction_DefaultStruct
		{
			int s_defaultOffsets[13];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkInt32 m_xResolution;
			hkInt32 m_yResolution;
			hkReal m_softRadius;
			hkInt32 m_xResolutionDecoration;
			hkInt32 m_yResolutionDecoration;
			hkReal m_softRadiusDecoration;
			_hkBool m_enableDebugBitmapGeneration;
		};
		const hkdDecalMapAction_DefaultStruct hkdDecalMapAction_Default =
		{
			{HK_OFFSET_OF(hkdDecalMapAction_DefaultStruct,m_xResolution),HK_OFFSET_OF(hkdDecalMapAction_DefaultStruct,m_yResolution),hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkdDecalMapAction_DefaultStruct,m_softRadius),-1,-1,HK_OFFSET_OF(hkdDecalMapAction_DefaultStruct,m_xResolutionDecoration),HK_OFFSET_OF(hkdDecalMapAction_DefaultStruct,m_yResolutionDecoration),hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkdDecalMapAction_DefaultStruct,m_softRadiusDecoration),HK_OFFSET_OF(hkdDecalMapAction_DefaultStruct,m_enableDebugBitmapGeneration)},
			64,64,1.0f,64,64,1.0f,true
		};
	}
	hkClass hkdDecalMapActionClass(
		"hkdDecalMapAction",
		&hkdActionClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkdDecalMapActionEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkdDecalMapActionClass_Members),
		HK_COUNT_OF(hkdDecalMapActionClass_Members),
		&hkdDecalMapAction_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkdDecorateFractureFaceInfoClass_Members[] =
	{
		{ "enableDecorations", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "priority", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "decorations", &hkdDecorateFractureFaceActionFractureFaceInfoClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkdDecorateFractureFaceInfo_DefaultStruct
		{
			int s_defaultOffsets[3];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			_hkBool m_enableDecorations;
			hkUint32 m_priority;
		};
		const hkdDecorateFractureFaceInfo_DefaultStruct hkdDecorateFractureFaceInfo_Default =
		{
			{HK_OFFSET_OF(hkdDecorateFractureFaceInfo_DefaultStruct,m_enableDecorations),HK_OFFSET_OF(hkdDecorateFractureFaceInfo_DefaultStruct,m_priority),-1},
			true,1
		};
	}
	hkClass hkdDecorateFractureFaceInfoClass(
		"hkdDecorateFractureFaceInfo",
		&hkdInfoClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkdDecorateFractureFaceInfoClass_Members),
		HK_COUNT_OF(hkdDecorateFractureFaceInfoClass_Members),
		&hkdDecorateFractureFaceInfo_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkdStickyGunClass_Members[] =
	{
		{ "explosions", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hkdStickyGunClass(
		"hkdStickyGun",
		&hkpProjectileGunClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkdStickyGunClass_Members),
		HK_COUNT_OF(hkdStickyGunClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkdFlexibleJointControllerConstraintRemovedReasonEnumItems[] =
	{
		{0, "PLANE_IMPULSE_EXCEEDED"},
		{1, "CONE_IMPULSE_EXCEEDED"},
		{2, "TWIST_IMPULSE_EXCEEDED"},
		{3, "PULLING_IMPULSE_EXCEEDED"},
	};
	static const hkInternalClassEnum hkdFlexibleJointControllerEnums[] = {
		{"ConstraintRemovedReason", hkdFlexibleJointControllerConstraintRemovedReasonEnumItems, 4, HK_NULL, 0 }
	};
	const hkClassEnum* hkdFlexibleJointControllerConstraintRemovedReasonEnum = reinterpret_cast<const hkClassEnum*>(&hkdFlexibleJointControllerEnums[0]);
	static hkInternalClassMember hkdFlexibleJointController_JointDefClass_Members[] =
	{
		{ "coneAngle", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "twistAngle", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "planeAngle", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "relBendingStrength", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "limitStiffness", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "relBreakingStrength", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "relPullingStrength", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "dropConstraintOnBreakage", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkdFlexibleJointControllerJointDef_DefaultStruct
		{
			int s_defaultOffsets[8];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkReal m_coneAngle;
			hkReal m_twistAngle;
			hkReal m_planeAngle;
			hkReal m_relBendingStrength;
			hkReal m_limitStiffness;
			hkReal m_relBreakingStrength;
			hkReal m_relPullingStrength;
		};
		const hkdFlexibleJointControllerJointDef_DefaultStruct hkdFlexibleJointControllerJointDef_Default =
		{
			{HK_OFFSET_OF(hkdFlexibleJointControllerJointDef_DefaultStruct,m_coneAngle),HK_OFFSET_OF(hkdFlexibleJointControllerJointDef_DefaultStruct,m_twistAngle),HK_OFFSET_OF(hkdFlexibleJointControllerJointDef_DefaultStruct,m_planeAngle),HK_OFFSET_OF(hkdFlexibleJointControllerJointDef_DefaultStruct,m_relBendingStrength),HK_OFFSET_OF(hkdFlexibleJointControllerJointDef_DefaultStruct,m_limitStiffness),HK_OFFSET_OF(hkdFlexibleJointControllerJointDef_DefaultStruct,m_relBreakingStrength),HK_OFFSET_OF(hkdFlexibleJointControllerJointDef_DefaultStruct,m_relPullingStrength),hkClassMember::HK_CLASS_ZERO_DEFAULT},
			20.0f,20.0f, 3.0f,20.0f, 1.0f,10.0f,1000.f
		};
	}
	hkClass hkdFlexibleJointControllerJointDefClass(
		"hkdFlexibleJointControllerJointDef",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkdFlexibleJointController_JointDefClass_Members),
		HK_COUNT_OF(hkdFlexibleJointController_JointDefClass_Members),
		&hkdFlexibleJointControllerJointDef_Default,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkdFlexibleJointControllerClass_Members[] =
	{
		{ "activationStrength", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "inertiaMultiplier", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxInertiaRatio", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "connectToType", HK_NULL, hkdControllerConstrainToTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "supportJoints", &hkdFlexibleJointControllerJointDefClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkdFlexibleJointController_DefaultStruct
		{
			int s_defaultOffsets[5];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkReal m_inertiaMultiplier;
			hkReal m_maxInertiaRatio;
			hkUint8 /* hkEnum< enum hkdController::ConstrainToType, hkUint8 > */ m_connectToType;
		};
		const hkdFlexibleJointController_DefaultStruct hkdFlexibleJointController_Default =
		{
			{hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkdFlexibleJointController_DefaultStruct,m_inertiaMultiplier),HK_OFFSET_OF(hkdFlexibleJointController_DefaultStruct,m_maxInertiaRatio),HK_OFFSET_OF(hkdFlexibleJointController_DefaultStruct,m_connectToType),-1},
			1.0f,10.0f,hkdController::CONSTRAIN_TO_FIXED_UNBREAKABLE
		};
	}
	hkClass hkdFlexibleJointControllerClass(
		"hkdFlexibleJointController",
		&hkdControllerClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkdFlexibleJointControllerEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkdFlexibleJointControllerClass_Members),
		HK_COUNT_OF(hkdFlexibleJointControllerClass_Members),
		&hkdFlexibleJointController_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkdFlexibleJointControllerWatchConstraintActionClass_Members[] =
	{
		{ "instance", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "impulseCone", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "impulsePlane", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "pullingImpulse", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hkdFlexibleJointControllerWatchConstraintActionClass(
		"hkdFlexibleJointControllerWatchConstraintAction",
		&hkpBinaryActionClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkdFlexibleJointControllerWatchConstraintActionClass_Members),
		HK_COUNT_OF(hkdFlexibleJointControllerWatchConstraintActionClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkdRaycastGunClass_Members[] =
	{
		{ "destructionRadius", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "beamRadius", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "mass", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "velocity", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "angImpulseFactor", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkdRaycastGun_DefaultStruct
		{
			int s_defaultOffsets[5];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkReal m_destructionRadius;
			hkReal m_beamRadius;
			hkReal m_mass;
			hkReal m_velocity;
			hkReal m_angImpulseFactor;
		};
		const hkdRaycastGun_DefaultStruct hkdRaycastGun_Default =
		{
			{HK_OFFSET_OF(hkdRaycastGun_DefaultStruct,m_destructionRadius),HK_OFFSET_OF(hkdRaycastGun_DefaultStruct,m_beamRadius),HK_OFFSET_OF(hkdRaycastGun_DefaultStruct,m_mass),HK_OFFSET_OF(hkdRaycastGun_DefaultStruct,m_velocity),HK_OFFSET_OF(hkdRaycastGun_DefaultStruct,m_angImpulseFactor)},
			0.6f,0.1f,1000.0f,20.0f,0.4f
		};
	}
	hkClass hkdRaycastGunClass(
		"hkdRaycastGun",
		&hkpFirstPersonGunClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkdRaycastGunClass_Members),
		HK_COUNT_OF(hkdRaycastGunClass_Members),
		&hkdRaycastGun_Default,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static const hkInternalClassEnumItem hkdBuildingControllerShapeTypeEnumItems[] =
	{
		{0, "EXTENDED_MESH_SHAPE"},
		{1, "STATIC_COMPOUND_SHAPE"},
	};
	static const hkInternalClassEnum hkdBuildingControllerEnums[] = {
		{"ShapeType", hkdBuildingControllerShapeTypeEnumItems, 2, HK_NULL, 0 }
	};
	const hkClassEnum* hkdBuildingControllerShapeTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkdBuildingControllerEnums[0]);
	static hkInternalClassMember hkdBuildingControllerClass_Members[] =
	{
		{ "physicsShapeType", HK_NULL, hkdBuildingControllerShapeTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkdBuildingController_DefaultStruct
		{
			int s_defaultOffsets[1];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkUint8 /* hkEnum< enum hkdBuildingController::ShapeType, hkUint8 > */ m_physicsShapeType;
		};
		const hkdBuildingController_DefaultStruct hkdBuildingController_Default =
		{
			{HK_OFFSET_OF(hkdBuildingController_DefaultStruct,m_physicsShapeType)},
			hkdBuildingController::EXTENDED_MESH_SHAPE
		};
	}
	hkClass hkdBuildingControllerClass(
		"hkdBuildingController",
		&hkdControllerClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkdBuildingControllerEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkdBuildingControllerClass_Members),
		HK_COUNT_OF(hkdBuildingControllerClass_Members),
		&hkdBuildingController_Default,
		HK_NULL,
		0,
		hkUint32(1)
		);
	hkClass hkdSplitInHalfControllerClass(
		"hkdSplitInHalfController",
		&hkdControllerClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkdDeformableBreakableShape_SkinShapeSectionClass_Members[] =
	{
		{ "indexBuffer", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT16, 0, 0, 0, HK_NULL },
		{ "boneIndices", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_INT16, 0, 0, 0, HK_NULL }
	};
	hkClass hkdDeformableBreakableShapeSkinShapeSectionClass(
		"hkdDeformableBreakableShapeSkinShapeSection",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkdDeformableBreakableShape_SkinShapeSectionClass_Members),
		HK_COUNT_OF(hkdDeformableBreakableShape_SkinShapeSectionClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkdDeformableBreakableShape_BoneDeformationDataClass_Members[] =
	{
		{ "weight", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "index", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkdDeformableBreakableShapeBoneDeformationDataClass(
		"hkdDeformableBreakableShapeBoneDeformationData",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkdDeformableBreakableShape_BoneDeformationDataClass_Members),
		HK_COUNT_OF(hkdDeformableBreakableShape_BoneDeformationDataClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkdDeformableBreakableShape_BoneInfoClass_Members[] =
	{
		{ "modelSpaceBindPoseTransform", &hkQTransformClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "comAndSoftness", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkdDeformableBreakableShapeBoneInfoClass(
		"hkdDeformableBreakableShapeBoneInfo",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkdDeformableBreakableShape_BoneInfoClass_Members),
		HK_COUNT_OF(hkdDeformableBreakableShape_BoneInfoClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkdDeformableBreakableShape_PhysicsSkinShapeClass_Members[] =
	{
		{ "bones", &hkdDeformableBreakableShapeBoneInfoClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "vertices", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VECTOR4, 0, 0, 0, HK_NULL },
		{ "deformationData", &hkdDeformableBreakableShapeBoneDeformationDataClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "sections", &hkdDeformableBreakableShapeSkinShapeSectionClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "physicsToGraphicsBonesMap", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "physicsToGraphicsBonesTransforms", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hkdDeformableBreakableShapePhysicsSkinShapeClass(
		"hkdDeformableBreakableShapePhysicsSkinShape",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkdDeformableBreakableShape_PhysicsSkinShapeClass_Members),
		HK_COUNT_OF(hkdDeformableBreakableShape_PhysicsSkinShapeClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkdDeformableBreakableShape_PhysicsSkinInstanceClass_Members[] =
	{
		{ "modelSpaceBoneTransforms", &hkQTransformClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "skinShape", &hkdDeformableBreakableShapePhysicsSkinShapeClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "vertices", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VECTOR4, 0, 0, 0, HK_NULL }
	};
	hkClass hkdDeformableBreakableShapePhysicsSkinInstanceClass(
		"hkdDeformableBreakableShapePhysicsSkinInstance",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkdDeformableBreakableShape_PhysicsSkinInstanceClass_Members),
		HK_COUNT_OF(hkdDeformableBreakableShape_PhysicsSkinInstanceClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(2)
		);
	static hkInternalClassMember hkdDeformableBreakableShape_DeformationPropertyClass_Members[] =
	{
		{ "sectionIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "deformableShape", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "dynamicShape", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hkdDeformableBreakableShapeDeformationPropertyClass(
		"hkdDeformableBreakableShapeDeformationProperty",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkdDeformableBreakableShape_DeformationPropertyClass_Members),
		HK_COUNT_OF(hkdDeformableBreakableShape_DeformationPropertyClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkdDeformableBreakableShapeClass_Members[] =
	{
		{ "physicsSkinInstance", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "physicsSkinShape", &hkdDeformableBreakableShapePhysicsSkinShapeClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkdDeformableBreakableShapeClass(
		"hkdDeformableBreakableShape",
		&hkdCompoundBreakableShapeClass,
		0,
		HK_NULL,
		1,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkdDeformableBreakableShapeClass_Members),
		HK_COUNT_OF(hkdDeformableBreakableShapeClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(3)
		);
	static hkInternalClassMember hkdMissileGunClass_Members[] =
	{
		{ "explosions", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hkdMissileGunClass(
		"hkdMissileGun",
		&hkpProjectileGunClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkdMissileGunClass_Members),
		HK_COUNT_OF(hkdMissileGunClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkdGrenadeGunClass_Members[] =
	{
		{ "explosions", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hkdGrenadeGunClass(
		"hkdGrenadeGun",
		&hkpProjectileGunClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkdGrenadeGunClass_Members),
		HK_COUNT_OF(hkdGrenadeGunClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkdRemoveWeakConnectionsActionClass_Members[] =
	{
		{ "minRelativeArea", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkdRemoveWeakConnectionsAction_DefaultStruct
		{
			int s_defaultOffsets[1];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkReal m_minRelativeArea;
		};
		const hkdRemoveWeakConnectionsAction_DefaultStruct hkdRemoveWeakConnectionsAction_Default =
		{
			{HK_OFFSET_OF(hkdRemoveWeakConnectionsAction_DefaultStruct,m_minRelativeArea)},
			0.1f
		};
	}
	hkClass hkdRemoveWeakConnectionsActionClass(
		"hkdRemoveWeakConnectionsAction",
		&hkdActionClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkdRemoveWeakConnectionsActionClass_Members),
		HK_COUNT_OF(hkdRemoveWeakConnectionsActionClass_Members),
		&hkdRemoveWeakConnectionsAction_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkdDecorateCornerInfoClass_Members[] =
	{
		{ "enableCornerDecorations", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "cornerTemplates", &hkdDecorateFractureFaceActionCornerDecorationInfoClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkdDecorateCornerInfo_DefaultStruct
		{
			int s_defaultOffsets[2];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			_hkBool m_enableCornerDecorations;
		};
		const hkdDecorateCornerInfo_DefaultStruct hkdDecorateCornerInfo_Default =
		{
			{HK_OFFSET_OF(hkdDecorateCornerInfo_DefaultStruct,m_enableCornerDecorations),-1},
			true
		};
	}
	hkClass hkdDecorateCornerInfoClass(
		"hkdDecorateCornerInfo",
		&hkdInfoClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkdDecorateCornerInfoClass_Members),
		HK_COUNT_OF(hkdDecorateCornerInfoClass_Members),
		&hkdDecorateCornerInfo_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkdDecorateCornerInfoContainerClass_Members[] =
	{
		{ "infos", &hkdDecorateCornerInfoClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL }
	};
	hkClass hkdDecorateCornerInfoContainerClass(
		"hkdDecorateCornerInfoContainer",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkdDecorateCornerInfoContainerClass_Members),
		HK_COUNT_OF(hkdDecorateCornerInfoContainerClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkdSphereGunClass_Members[] =
	{
		{ "sphereGeometry", &hkdGeometryClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkdSphereGunClass(
		"hkdSphereGun",
		&hkpProjectileGunClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkdSphereGunClass_Members),
		HK_COUNT_OF(hkdSphereGunClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkdDeformationControllerSkinningTypeEnumItems[] =
	{
		{0, "USER_DEFINED"},
		{1, "DISTANCE_TO_CENTER"},
		{2, "DISTANCE_TO_SURFACE"},
	};
	static const hkInternalClassEnum hkdDeformationControllerEnums[] = {
		{"SkinningType", hkdDeformationControllerSkinningTypeEnumItems, 3, HK_NULL, 0 }
	};
	const hkClassEnum* hkdDeformationControllerSkinningTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkdDeformationControllerEnums[0]);
	static hkInternalClassMember hkdDeformationControllerClass_Members[] =
	{
		{ "numSmoothingSteps", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "smoothingRadius", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "deformationRadius", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "deformationStrength", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "constraintStrength", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "constraintBreakingLimit", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "softness", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxDeformationDistance", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxDeformationAngle", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "deformationTau", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "skiningType", HK_NULL, hkdDeformationControllerSkinningTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "skinningSmoothing", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "hullTolerance", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "shapeWeldingTolerance", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkdDeformationController_DefaultStruct
		{
			int s_defaultOffsets[14];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkUint8 m_numSmoothingSteps;
			hkUint8 m_smoothingRadius;
			hkReal m_deformationRadius;
			hkReal m_softness;
			hkReal m_maxDeformationDistance;
			hkReal m_maxDeformationAngle;
			hkReal m_deformationTau;
			hkUint8 /* hkEnum< enum hkdDeformationController::SkinningType, hkUint8 > */ m_skiningType;
			hkReal m_skinningSmoothing;
			hkReal m_hullTolerance;
			hkReal m_shapeWeldingTolerance;
		};
		const hkdDeformationController_DefaultStruct hkdDeformationController_Default =
		{
			{HK_OFFSET_OF(hkdDeformationController_DefaultStruct,m_numSmoothingSteps),HK_OFFSET_OF(hkdDeformationController_DefaultStruct,m_smoothingRadius),HK_OFFSET_OF(hkdDeformationController_DefaultStruct,m_deformationRadius),hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkdDeformationController_DefaultStruct,m_softness),HK_OFFSET_OF(hkdDeformationController_DefaultStruct,m_maxDeformationDistance),HK_OFFSET_OF(hkdDeformationController_DefaultStruct,m_maxDeformationAngle),HK_OFFSET_OF(hkdDeformationController_DefaultStruct,m_deformationTau),HK_OFFSET_OF(hkdDeformationController_DefaultStruct,m_skiningType),HK_OFFSET_OF(hkdDeformationController_DefaultStruct,m_skinningSmoothing),HK_OFFSET_OF(hkdDeformationController_DefaultStruct,m_hullTolerance),HK_OFFSET_OF(hkdDeformationController_DefaultStruct,m_shapeWeldingTolerance)},
			1,2,1.0f,0.6f,10.0f,90.0f,1.0f,hkdDeformationController::DISTANCE_TO_SURFACE,0.3f,0.001f,0.01f
		};
	}
	hkClass hkdDeformationControllerClass(
		"hkdDeformationController",
		&hkdControllerClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkdDeformationControllerEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkdDeformationControllerClass_Members),
		HK_COUNT_OF(hkdDeformationControllerClass_Members),
		&hkdDeformationController_Default,
		HK_NULL,
		0,
		hkUint32(5)
		);
	static const hkInternalClassEnumItem hkdWoodFractureSplittingDataSplittingPlaneRotationEnumItems[] =
	{
		{0, "AUTO_ROTATE"},
		{1, "NO_ROTATION"},
		{2, "ROTATE_90"},
	};
	static const hkInternalClassEnum hkdWoodFractureSplittingDataEnums[] = {
		{"SplittingPlaneRotation", hkdWoodFractureSplittingDataSplittingPlaneRotationEnumItems, 3, HK_NULL, 0 }
	};
	const hkClassEnum* hkdWoodFractureSplittingDataSplittingPlaneRotationEnum = reinterpret_cast<const hkClassEnum*>(&hkdWoodFractureSplittingDataEnums[0]);
	static hkInternalClassMember hkdWoodFracture_SplittingDataClass_Members[] =
	{
		{ "splitGeom", &hkdGeometryClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "splittingAxis", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "rotateSplitGeom", HK_NULL, hkdWoodFractureSplittingDataSplittingPlaneRotationEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "numSubparts", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "widthRange", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "scale", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "scaleRange", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "splitGeomShiftRangeY", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "splitGeomShiftRangeZ", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "surfaceNormalShearingRange", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "fractureLineShearingRange", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "fractureNormalShearingRange", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkdWoodFractureSplittingData_DefaultStruct
		{
			int s_defaultOffsets[12];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			_hkVector4 m_splittingAxis;
			hkUint8 /* hkEnum< enum hkdWoodFracture::SplittingData::SplittingPlaneRotation, hkUint8 > */ m_rotateSplitGeom;
			hkReal m_numSubparts;
			_hkVector4 m_scale;
			_hkVector4 m_scaleRange;
		};
		const hkdWoodFractureSplittingData_DefaultStruct hkdWoodFractureSplittingData_Default =
		{
			{-1,HK_OFFSET_OF(hkdWoodFractureSplittingData_DefaultStruct,m_splittingAxis),HK_OFFSET_OF(hkdWoodFractureSplittingData_DefaultStruct,m_rotateSplitGeom),HK_OFFSET_OF(hkdWoodFractureSplittingData_DefaultStruct,m_numSubparts),hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkdWoodFractureSplittingData_DefaultStruct,m_scale),HK_OFFSET_OF(hkdWoodFractureSplittingData_DefaultStruct,m_scaleRange),hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT},
		{0.0f,0.0f,0.0f},hkdWoodFracture::SplittingData::AUTO_ROTATE,3.0f,	{1.0f,1.0f,1.0f},	{0.0f,0.0f,0.0f}
		};
	}
	hkClass hkdWoodFractureSplittingDataClass(
		"hkdWoodFractureSplittingData",
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkdWoodFractureSplittingDataEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkdWoodFracture_SplittingDataClass_Members),
		HK_COUNT_OF(hkdWoodFracture_SplittingDataClass_Members),
		&hkdWoodFractureSplittingData_Default,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkdWoodFractureClass_Members[] =
	{
		{ "randomSeed", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "boardData", &hkdWoodFractureSplittingDataClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "splinterData", &hkdWoodFractureSplittingDataClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkdWoodFracture_DefaultStruct
		{
			int s_defaultOffsets[3];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkInt32 m_randomSeed;
		};
		const hkdWoodFracture_DefaultStruct hkdWoodFracture_Default =
		{
			{HK_OFFSET_OF(hkdWoodFracture_DefaultStruct,m_randomSeed),-1,-1},
			187
		};
	}
	hkClass hkdWoodFractureClass(
		"hkdWoodFracture",
		&hkdFractureClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkdWoodFractureClass_Members),
		HK_COUNT_OF(hkdWoodFractureClass_Members),
		&hkdWoodFracture_Default,
		HK_NULL,
		0,
		hkUint32(2)
		);
	static hkInternalClassMember hkdVoronoiFractureClass_Members[] =
	{
		{ "splitPlaneGeometry", &hkdGeometryClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "graphicsOverlap", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "fixupOverlaps", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "voronoiSiteShapes", &hkdBreakableShapeClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "voronoiSiteShapesTransform", HK_NULL, HK_NULL, hkClassMember::TYPE_TRANSFORM, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "copyDataFromSites", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "numSitesToGenerate", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "numIterations", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "seed", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkdVoronoiFracture_DefaultStruct
		{
			int s_defaultOffsets[9];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			_hkBool m_copyDataFromSites;
			hkInt32 m_seed;
		};
		const hkdVoronoiFracture_DefaultStruct hkdVoronoiFracture_Default =
		{
			{-1,hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,-1,-1,HK_OFFSET_OF(hkdVoronoiFracture_DefaultStruct,m_copyDataFromSites),hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkdVoronoiFracture_DefaultStruct,m_seed)},
			true,180673
		};
	}
	hkClass hkdVoronoiFractureClass(
		"hkdVoronoiFracture",
		&hkdFractureClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkdVoronoiFractureClass_Members),
		HK_COUNT_OF(hkdVoronoiFractureClass_Members),
		&hkdVoronoiFracture_Default,
		HK_NULL,
		0,
		hkUint32(4)
		);
	static const hkInternalClassEnumItem hkdExplosionForceActionExplosionCenterSpaceEnumItems[] =
	{
		{0, "SHAPE_SPACE"},
		{1, "BODY_SPACE"},
		{2, "WORLD_SPACE"},
	};
	static const hkInternalClassEnum hkdExplosionForceActionEnums[] = {
		{"ExplosionCenterSpace", hkdExplosionForceActionExplosionCenterSpaceEnumItems, 3, HK_NULL, 0 }
	};
	const hkClassEnum* hkdExplosionForceActionExplosionCenterSpaceEnum = reinterpret_cast<const hkClassEnum*>(&hkdExplosionForceActionEnums[0]);
	static hkInternalClassMember hkdExplosionForceActionClass_Members[] =
	{
		{ "explosionCenter", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "explosionCenterSpace", HK_NULL, hkdExplosionForceActionExplosionCenterSpaceEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "velocity", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "expandingVelocity", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "virtMass", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "angularImpulseFactor", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkdExplosionForceAction_DefaultStruct
		{
			int s_defaultOffsets[6];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			_hkVector4 m_explosionCenter;
			hkUint8 /* hkEnum< enum hkdExplosionForceAction::ExplosionCenterSpace, hkUint8 > */ m_explosionCenterSpace;
			_hkVector4 m_velocity;
			hkReal m_expandingVelocity;
			hkReal m_virtMass;
			hkReal m_angularImpulseFactor;
		};
		const hkdExplosionForceAction_DefaultStruct hkdExplosionForceAction_Default =
		{
			{HK_OFFSET_OF(hkdExplosionForceAction_DefaultStruct,m_explosionCenter),HK_OFFSET_OF(hkdExplosionForceAction_DefaultStruct,m_explosionCenterSpace),HK_OFFSET_OF(hkdExplosionForceAction_DefaultStruct,m_velocity),HK_OFFSET_OF(hkdExplosionForceAction_DefaultStruct,m_expandingVelocity),HK_OFFSET_OF(hkdExplosionForceAction_DefaultStruct,m_virtMass),HK_OFFSET_OF(hkdExplosionForceAction_DefaultStruct,m_angularImpulseFactor)},
		{0.0f,0.0f,0.0f},hkdExplosionForceAction::SHAPE_SPACE,	{0.0f,0.0f,0.0f},20.0f,1000.0f,0.2f
		};
	}
	hkClass hkdExplosionForceActionClass(
		"hkdExplosionForceAction",
		&hkdActionClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkdExplosionForceActionEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkdExplosionForceActionClass_Members),
		HK_COUNT_OF(hkdExplosionForceActionClass_Members),
		&hkdExplosionForceAction_Default,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static const hkInternalClassEnumItem hkdSliceFractureSnapTypeEnumItems[] =
	{
		{0, "SNAP_TO_PIVOT"},
		{1, "SNAP_TO_AABB"},
	};
	static const hkInternalClassEnum hkdSliceFractureEnums[] = {
		{"SnapType", hkdSliceFractureSnapTypeEnumItems, 2, HK_NULL, 0 }
	};
	const hkClassEnum* hkdSliceFractureSnapTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkdSliceFractureEnums[0]);
	static hkInternalClassMember hkdSliceFractureClass_Members[] =
	{
		{ "splitGeometry", &hkdGeometryClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "splitGeometryScale", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "splittingPlaneNormal", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "numSubparts", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "snap", HK_NULL, hkdSliceFractureSnapTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "splittingPlaneConvexRadius", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkdSliceFracture_DefaultStruct
		{
			int s_defaultOffsets[6];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			_hkVector4 m_splitGeometryScale;
			_hkVector4 m_splittingPlaneNormal;
			hkReal m_numSubparts;
			hkUint8 /* hkEnum< enum hkdSliceFracture::SnapType, hkUint8 > */ m_snap;
		};
		const hkdSliceFracture_DefaultStruct hkdSliceFracture_Default =
		{
			{-1,HK_OFFSET_OF(hkdSliceFracture_DefaultStruct,m_splitGeometryScale),HK_OFFSET_OF(hkdSliceFracture_DefaultStruct,m_splittingPlaneNormal),HK_OFFSET_OF(hkdSliceFracture_DefaultStruct,m_numSubparts),HK_OFFSET_OF(hkdSliceFracture_DefaultStruct,m_snap),hkClassMember::HK_CLASS_ZERO_DEFAULT},
		{1.0f,1.0f,1.0f},	{0.0f,1.0f,0.0f},2.0f,hkdSliceFracture::SNAP_TO_PIVOT
		};
	}
	hkClass hkdSliceFractureClass(
		"hkdSliceFracture",
		&hkdFractureClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkdSliceFractureEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkdSliceFractureClass_Members),
		HK_COUNT_OF(hkdSliceFractureClass_Members),
		&hkdSliceFracture_Default,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkdPieFractureClass_Members[] =
	{
		{ "splitGeometry", &hkdGeometryClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "splitGeometryScale", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "splitCentralAxis", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "splitCenter", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "numParts", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "splittingPlaneConvexRadius", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkdPieFracture_DefaultStruct
		{
			int s_defaultOffsets[6];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			_hkVector4 m_splitGeometryScale;
			_hkVector4 m_splitCentralAxis;
			_hkVector4 m_splitCenter;
			hkInt32 m_numParts;
		};
		const hkdPieFracture_DefaultStruct hkdPieFracture_Default =
		{
			{-1,HK_OFFSET_OF(hkdPieFracture_DefaultStruct,m_splitGeometryScale),HK_OFFSET_OF(hkdPieFracture_DefaultStruct,m_splitCentralAxis),HK_OFFSET_OF(hkdPieFracture_DefaultStruct,m_splitCenter),HK_OFFSET_OF(hkdPieFracture_DefaultStruct,m_numParts),hkClassMember::HK_CLASS_ZERO_DEFAULT},
		{1.0f,1.0f,1.0f},	{0.0f,1.0f,0.0f},	{0.0f,0.0f,0.0f},8
		};
	}
	hkClass hkdPieFractureClass(
		"hkdPieFracture",
		&hkdFractureClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkdPieFractureClass_Members),
		HK_COUNT_OF(hkdPieFractureClass_Members),
		&hkdPieFracture_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkdRandomSplitFractureClass_Members[] =
	{
		{ "splitLargestVolumesFirst", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "splitPlaneGeometry", &hkdGeometryClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "splitGeometryScale", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "numObjectsOnLevel1", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "numObjectsOnLevel2", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "numObjectsOnLevel3", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "numObjectsOnLevel4", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "randomSeed1", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "randomSeed2", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "randomSeed3", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "randomSeed4", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "randomRange", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkdRandomSplitFracture_DefaultStruct
		{
			int s_defaultOffsets[12];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			_hkBool m_splitLargestVolumesFirst;
			_hkVector4 m_splitGeometryScale;
			hkInt32 m_numObjectsOnLevel1;
			hkInt32 m_randomSeed1;
			hkInt32 m_randomSeed2;
			hkInt32 m_randomSeed3;
			hkInt32 m_randomSeed4;
			hkReal m_randomRange;
		};
		const hkdRandomSplitFracture_DefaultStruct hkdRandomSplitFracture_Default =
		{
			{HK_OFFSET_OF(hkdRandomSplitFracture_DefaultStruct,m_splitLargestVolumesFirst),-1,HK_OFFSET_OF(hkdRandomSplitFracture_DefaultStruct,m_splitGeometryScale),HK_OFFSET_OF(hkdRandomSplitFracture_DefaultStruct,m_numObjectsOnLevel1),hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkdRandomSplitFracture_DefaultStruct,m_randomSeed1),HK_OFFSET_OF(hkdRandomSplitFracture_DefaultStruct,m_randomSeed2),HK_OFFSET_OF(hkdRandomSplitFracture_DefaultStruct,m_randomSeed3),HK_OFFSET_OF(hkdRandomSplitFracture_DefaultStruct,m_randomSeed4),HK_OFFSET_OF(hkdRandomSplitFracture_DefaultStruct,m_randomRange)},
		true,	{1.0f,1.0f,1.0f},2,123,456,789,101112,1.0f
		};
	}
	hkClass hkdRandomSplitFractureClass(
		"hkdRandomSplitFracture",
		&hkdFractureClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkdRandomSplitFractureClass_Members),
		HK_COUNT_OF(hkdRandomSplitFractureClass_Members),
		&hkdRandomSplitFracture_Default,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkdGlueFixedPiecesActionClass_Members[] =
	{
		{ "allowedVolumeIncrease", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "minEdgeLength", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkdGlueFixedPiecesAction_DefaultStruct
		{
			int s_defaultOffsets[2];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkReal m_allowedVolumeIncrease;
			hkReal m_minEdgeLength;
		};
		const hkdGlueFixedPiecesAction_DefaultStruct hkdGlueFixedPiecesAction_Default =
		{
			{HK_OFFSET_OF(hkdGlueFixedPiecesAction_DefaultStruct,m_allowedVolumeIncrease),HK_OFFSET_OF(hkdGlueFixedPiecesAction_DefaultStruct,m_minEdgeLength)},
			0.05f,0.005f
		};
	}
	hkClass hkdGlueFixedPiecesActionClass(
		"hkdGlueFixedPiecesAction",
		&hkdActionClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkdGlueFixedPiecesActionClass_Members),
		HK_COUNT_OF(hkdGlueFixedPiecesActionClass_Members),
		&hkdGlueFixedPiecesAction_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkdBreakableBodyTypesAndFlagsEnumItems[] =
	{
		{0, "BODY_TYPE_OR_FLAG_INVALID"},
		{1, "BODY_TYPE_SIMPLE"},
		{2, "BODY_TYPE_EMBEDDED"},
		{4, "BODY_TYPE_TEMPLATE"},
		{8, "BODY_FLAG_ATTACH_TO_NEARBY_OBJECTS"},
		{16, "BODY_TYPE_EMBEDDED_COMPOUND"},
	};
	static const hkInternalClassEnum hkdBreakableBodyEnums[] = {
		{"TypesAndFlags", hkdBreakableBodyTypesAndFlagsEnumItems, 6, HK_NULL, 0 }
	};
	const hkClassEnum* hkdBreakableBodyTypesAndFlagsEnum = reinterpret_cast<const hkClassEnum*>(&hkdBreakableBodyEnums[0]);
	static hkInternalClassMember hkdBreakableBody_SmallArraySerializeOverrideTypeClass_Members[] =
	{
		{ "data", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "size", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "capacityAndFlags", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkdBreakableBodySmallArraySerializeOverrideTypeClass(
		"hkdBreakableBodySmallArraySerializeOverrideType",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkdBreakableBody_SmallArraySerializeOverrideTypeClass_Members),
		HK_COUNT_OF(hkdBreakableBody_SmallArraySerializeOverrideTypeClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkdBreakableBodyClass_Members[] =
	{
		{ "destructionWorld", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "physicsBody", &hkpRigidBodyClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "graphicsBody", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "objectProperties", &hkdObjectPropertiesClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "listeners", &hkdBreakableBodySmallArraySerializeOverrideTypeClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "fixedConnectivity", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "decorations", &hkdBreakableBodySmallArraySerializeOverrideTypeClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hkdBreakableBodyClass(
		"hkdBreakableBody",
		&hkpBreakableBodyClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkdBreakableBodyEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkdBreakableBodyClass_Members),
		HK_COUNT_OF(hkdBreakableBodyClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(7)
		);
	static hkInternalClassMember hkdDestructionDemoConfigClass_Members[] =
	{
		{ "useData", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "initialCharacterPosition", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "initialCharacterDirection", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "lightSourcePosition", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "lightSourceDirection", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "lightSourceColor", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "lightFillColor", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "lightRimColor", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "ambientLightColor", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxNumTimeoutDebrisPieces", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "minNumTimeoutDebrisPieces", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "clearColor", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "enableSSAO", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "enableBloom", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "fogDensity", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "addFloor", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "skyBoxName", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "createSharedVertexBuffer", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "simplyfierPercentToRemove", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "enableInstancing", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkdDestructionDemoConfig_DefaultStruct
		{
			int s_defaultOffsets[20];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			_hkBool m_useData;
			_hkVector4 m_initialCharacterPosition;
			_hkVector4 m_initialCharacterDirection;
			_hkVector4 m_lightSourcePosition;
			_hkVector4 m_lightSourceDirection;
			_hkVector4 m_lightSourceColor;
			_hkVector4 m_lightFillColor;
			_hkVector4 m_lightRimColor;
			_hkVector4 m_ambientLightColor;
			hkUint32 m_maxNumTimeoutDebrisPieces;
			_hkVector4 m_clearColor;
			_hkBool m_createSharedVertexBuffer;
		};
		const hkdDestructionDemoConfig_DefaultStruct hkdDestructionDemoConfig_Default =
		{
			{HK_OFFSET_OF(hkdDestructionDemoConfig_DefaultStruct,m_useData),HK_OFFSET_OF(hkdDestructionDemoConfig_DefaultStruct,m_initialCharacterPosition),HK_OFFSET_OF(hkdDestructionDemoConfig_DefaultStruct,m_initialCharacterDirection),HK_OFFSET_OF(hkdDestructionDemoConfig_DefaultStruct,m_lightSourcePosition),HK_OFFSET_OF(hkdDestructionDemoConfig_DefaultStruct,m_lightSourceDirection),HK_OFFSET_OF(hkdDestructionDemoConfig_DefaultStruct,m_lightSourceColor),HK_OFFSET_OF(hkdDestructionDemoConfig_DefaultStruct,m_lightFillColor),HK_OFFSET_OF(hkdDestructionDemoConfig_DefaultStruct,m_lightRimColor),HK_OFFSET_OF(hkdDestructionDemoConfig_DefaultStruct,m_ambientLightColor),HK_OFFSET_OF(hkdDestructionDemoConfig_DefaultStruct,m_maxNumTimeoutDebrisPieces),hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkdDestructionDemoConfig_DefaultStruct,m_clearColor),hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkdDestructionDemoConfig_DefaultStruct,m_createSharedVertexBuffer),hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT},
	true,	{0.0f,1.0f,10.0f},	{0.0f,0.0f,1.0f},	{0.0f,0.0f,0.0f},	{0.0f,-3.0f,-1.0f},	{1.0f,1.0f,1.0f,1.0f},	{0.3f,0.3f,0.3f,1.0f},	{0.2f,0.2f,0.2f,1.0f},	{0.1f,0.1f,0.1f,1.0f},1000000,	{0.53f,0.55f,0.61f,1.0f},true
		};
	}
	hkClass hkdDestructionDemoConfigClass(
		"hkdDestructionDemoConfig",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkdDestructionDemoConfigClass_Members),
		HK_COUNT_OF(hkdDestructionDemoConfigClass_Members),
		&hkdDestructionDemoConfig_Default,
		HK_NULL,
		0,
		hkUint32(5)
		);
	static hkInternalClassMember hkdIntegrityAnalyzerActionClass_Members[] =
	{
		{ "breakingLength", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "fracturePosition", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "destructionRadius", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "delay", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "refineRadius", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkdIntegrityAnalyzerAction_DefaultStruct
		{
			int s_defaultOffsets[5];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkReal m_breakingLength;
			hkReal m_fracturePosition;
		};
		const hkdIntegrityAnalyzerAction_DefaultStruct hkdIntegrityAnalyzerAction_Default =
		{
			{HK_OFFSET_OF(hkdIntegrityAnalyzerAction_DefaultStruct,m_breakingLength),HK_OFFSET_OF(hkdIntegrityAnalyzerAction_DefaultStruct,m_fracturePosition),hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT},
			8.0f,0.4f
		};
	}
	hkClass hkdIntegrityAnalyzerActionClass(
		"hkdIntegrityAnalyzerAction",
		&hkdActionClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkdIntegrityAnalyzerActionClass_Members),
		HK_COUNT_OF(hkdIntegrityAnalyzerActionClass_Members),
		&hkdIntegrityAnalyzerAction_Default,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static const hkInternalClassEnumItem hkdConvexDecompositionActionDecompositionMethodEnumItems[] =
	{
		{0, "SURFACE"},
		{1, "SOLID"},
	};
	static const hkInternalClassEnumItem hkdConvexDecompositionActionHollowMethodEnumItems[] =
	{
		{0, "HOLLOW_KEEP"},
		{1, "HOLLOW_MERGE"},
		{2, "HOLLOW_DISCARD"},
	};
	static const hkInternalClassEnumItem hkdConvexDecompositionActionReduceMethodEnumItems[] =
	{
		{0, "REDUCE_GLOBAL"},
		{1, "REDUCE_LOCAL"},
		{2, "REDUCE_DISABLE"},
	};
	static const hkInternalClassEnumItem hkdConvexDecompositionActionRefineLevelEnumItems[] =
	{
		{0, "REFINE_NONE"},
		{2, "REFINE_LOW"},
		{4, "REFINE_MED"},
		{8, "REFINE_HIGH"},
	};
	static const hkInternalClassEnum hkdConvexDecompositionActionEnums[] = {
		{"DecompositionMethod", hkdConvexDecompositionActionDecompositionMethodEnumItems, 2, HK_NULL, 0 },
		{"HollowMethod", hkdConvexDecompositionActionHollowMethodEnumItems, 3, HK_NULL, 0 },
		{"ReduceMethod", hkdConvexDecompositionActionReduceMethodEnumItems, 3, HK_NULL, 0 },
		{"RefineLevel", hkdConvexDecompositionActionRefineLevelEnumItems, 4, HK_NULL, 0 }
	};
	const hkClassEnum* hkdConvexDecompositionActionDecompositionMethodEnum = reinterpret_cast<const hkClassEnum*>(&hkdConvexDecompositionActionEnums[0]);
	const hkClassEnum* hkdConvexDecompositionActionHollowMethodEnum = reinterpret_cast<const hkClassEnum*>(&hkdConvexDecompositionActionEnums[1]);
	const hkClassEnum* hkdConvexDecompositionActionReduceMethodEnum = reinterpret_cast<const hkClassEnum*>(&hkdConvexDecompositionActionEnums[2]);
	const hkClassEnum* hkdConvexDecompositionActionRefineLevelEnum = reinterpret_cast<const hkClassEnum*>(&hkdConvexDecompositionActionEnums[3]);
	static hkInternalClassMember hkdConvexDecompositionActionClass_Members[] =
	{
		{ "tolerance", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "method", HK_NULL, hkdConvexDecompositionActionDecompositionMethodEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "reduce", HK_NULL, hkdConvexDecompositionActionReduceMethodEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "refine", HK_NULL, hkdConvexDecompositionActionRefineLevelEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "self", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "recurse", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "hollow", HK_NULL, hkdConvexDecompositionActionHollowMethodEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "moppThreshold", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkdConvexDecompositionAction_DefaultStruct
		{
			int s_defaultOffsets[8];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkReal m_tolerance;
			hkUint8 /* hkEnum< enum hkdConvexDecompositionAction::DecompositionMethod, hkUint8 > */ m_method;
			hkUint8 /* hkEnum< enum hkdConvexDecompositionAction::ReduceMethod, hkUint8 > */ m_reduce;
			hkUint8 /* hkEnum< enum hkdConvexDecompositionAction::RefineLevel, hkUint8 > */ m_refine;
			_hkBool m_self;
			_hkBool m_recurse;
			hkUint8 /* hkEnum< enum hkdConvexDecompositionAction::HollowMethod, hkUint8 > */ m_hollow;
		};
		const hkdConvexDecompositionAction_DefaultStruct hkdConvexDecompositionAction_Default =
		{
			{HK_OFFSET_OF(hkdConvexDecompositionAction_DefaultStruct,m_tolerance),HK_OFFSET_OF(hkdConvexDecompositionAction_DefaultStruct,m_method),HK_OFFSET_OF(hkdConvexDecompositionAction_DefaultStruct,m_reduce),HK_OFFSET_OF(hkdConvexDecompositionAction_DefaultStruct,m_refine),HK_OFFSET_OF(hkdConvexDecompositionAction_DefaultStruct,m_self),HK_OFFSET_OF(hkdConvexDecompositionAction_DefaultStruct,m_recurse),HK_OFFSET_OF(hkdConvexDecompositionAction_DefaultStruct,m_hollow),hkClassMember::HK_CLASS_ZERO_DEFAULT},
			0.01f,hkdConvexDecompositionAction::SURFACE,hkdConvexDecompositionAction::REDUCE_GLOBAL,hkdConvexDecompositionAction::REFINE_NONE,true,true,hkdConvexDecompositionAction::HOLLOW_KEEP
		};
	}
	hkClass hkdConvexDecompositionActionClass(
		"hkdConvexDecompositionAction",
		&hkdActionClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkdConvexDecompositionActionEnums),
		4,
		reinterpret_cast<const hkClassMember*>(hkdConvexDecompositionActionClass_Members),
		HK_COUNT_OF(hkdConvexDecompositionActionClass_Members),
		&hkdConvexDecompositionAction_Default,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static const hkInternalClassEnumItem hkdCutOutFractureSplitTypeEnumItems[] =
	{
		{0, "USE_PHYSICS_WITH_SPLIT_GEOMETRY"},
		{1, "USE_CUT_OUT_GEOMETRY"},
	};
	static const hkInternalClassEnum hkdCutOutFractureEnums[] = {
		{"SplitType", hkdCutOutFractureSplitTypeEnumItems, 2, HK_NULL, 0 }
	};
	const hkClassEnum* hkdCutOutFractureSplitTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkdCutOutFractureEnums[0]);
	static hkInternalClassMember hkdCutOutFractureClass_Members[] =
	{
		{ "setFrameShapeFixed", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "minPhysicsThickness", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "minimumOverlap", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "expandShape", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "cutoutShapes", &hkdBreakableShapeClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "cutoutShapesTransform", HK_NULL, HK_NULL, hkClassMember::TYPE_TRANSFORM, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "copyDataFromCutouts", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "splitType", HK_NULL, hkdCutOutFractureSplitTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "splitPlaneGeometry", &hkdGeometryClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkdCutOutFracture_DefaultStruct
		{
			int s_defaultOffsets[9];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			_hkBool m_setFrameShapeFixed;
			hkReal m_minPhysicsThickness;
			hkReal m_minimumOverlap;
			hkReal m_expandShape;
			_hkBool m_copyDataFromCutouts;
			hkUint8 /* hkEnum< enum hkdCutOutFracture::SplitType, hkUint8 > */ m_splitType;
		};
		const hkdCutOutFracture_DefaultStruct hkdCutOutFracture_Default =
		{
			{HK_OFFSET_OF(hkdCutOutFracture_DefaultStruct,m_setFrameShapeFixed),HK_OFFSET_OF(hkdCutOutFracture_DefaultStruct,m_minPhysicsThickness),HK_OFFSET_OF(hkdCutOutFracture_DefaultStruct,m_minimumOverlap),HK_OFFSET_OF(hkdCutOutFracture_DefaultStruct,m_expandShape),-1,-1,HK_OFFSET_OF(hkdCutOutFracture_DefaultStruct,m_copyDataFromCutouts),HK_OFFSET_OF(hkdCutOutFracture_DefaultStruct,m_splitType),-1},
			true,0.01f,0.05f,0.001f,true, hkdCutOutFracture::USE_PHYSICS_WITH_SPLIT_GEOMETRY 
		};
	}
	hkClass hkdCutOutFractureClass(
		"hkdCutOutFracture",
		&hkdFractureClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkdCutOutFractureEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkdCutOutFractureClass_Members),
		HK_COUNT_OF(hkdCutOutFractureClass_Members),
		&hkdCutOutFracture_Default,
		HK_NULL,
		0,
		hkUint32(2)
		);
	static const hkInternalClassEnumItem hkdCompoundBreakableShapeConstructorFlagsEnumItems[] =
	{
		{0, "CTR_FLAGS_NORMAL"},
		{1, "CTR_FLAGS_ADD_EXTRA_PCONVEX_TRANSFORM_SHAPE"},
		{2, "CTR_FLAGS_SET_CHILD_PARENT"},
		{4, "CTR_FLAGS_FLATTEN_LIST_SHAPES"},
		{8, "CTR_FLAGS_ALLOW_EXTENDED_MESH_SHAPE"},
		{16, "CTR_FLAGS_ALLOW_STATIC_COMPOUND_SHAPE"},
		{32, "CTR_FLAGS_FORCE_COMPOUND_MATERIAL"},
		{64, "CTR_FLAGS_CREATE_INVERSE_MATERIAL_MAPPING"},
	};
	static const hkInternalClassEnum hkdCompoundBreakableShapeEnums[] = {
		{"ConstructorFlags", hkdCompoundBreakableShapeConstructorFlagsEnumItems, 8, HK_NULL, 0 }
	};
	const hkClassEnum* hkdCompoundBreakableShapeConstructorFlagsEnum = reinterpret_cast<const hkClassEnum*>(&hkdCompoundBreakableShapeEnums[0]);
	static hkInternalClassMember hkdCompoundBreakableShapeClass_Members[] =
	{
		{ "rootBreakableShape", &hkdBreakableShapeClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "useChildrenBreakableThreshold", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "enabledChildren", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "unusedPaddingCompound", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hkdCompoundBreakableShapeClass(
		"hkdCompoundBreakableShape",
		&hkdBreakableShapeClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkdCompoundBreakableShapeEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkdCompoundBreakableShapeClass_Members),
		HK_COUNT_OF(hkdCompoundBreakableShapeClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static const hkInternalClassEnumItem hkdSplitInHalfFractureNumChildrenEnumItems[] =
	{
		{0, "CHILDREN_2"},
		{1, "CHILDREN_4"},
		{2, "CHILDREN_8"},
		{3, "CHILDREN_16"},
		{4, "CHILDREN_32"},
		{5, "CHILDREN_64"},
		{6, "CHILDREN_128"},
		{7, "CHILDREN_256"},
	};
	static const hkInternalClassEnum hkdSplitInHalfFractureEnums[] = {
		{"NumChildren", hkdSplitInHalfFractureNumChildrenEnumItems, 8, HK_NULL, 0 }
	};
	const hkClassEnum* hkdSplitInHalfFractureNumChildrenEnum = reinterpret_cast<const hkClassEnum*>(&hkdSplitInHalfFractureEnums[0]);
	static hkInternalClassMember hkdSplitInHalfFractureClass_Members[] =
	{
		{ "splitPlaneGeometry", &hkdGeometryClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "splitGeometryScale", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "numChildren", HK_NULL, hkdSplitInHalfFractureNumChildrenEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkdSplitInHalfFracture_DefaultStruct
		{
			int s_defaultOffsets[3];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			_hkVector4 m_splitGeometryScale;
			hkUint8 /* hkEnum< enum hkdSplitInHalfFracture::NumChildren, hkUint8 > */ m_numChildren;
		};
		const hkdSplitInHalfFracture_DefaultStruct hkdSplitInHalfFracture_Default =
		{
			{-1,HK_OFFSET_OF(hkdSplitInHalfFracture_DefaultStruct,m_splitGeometryScale),HK_OFFSET_OF(hkdSplitInHalfFracture_DefaultStruct,m_numChildren)},
			{1.0f,1.0f,1.0f},hkdSplitInHalfFracture::CHILDREN_32
		};
	}
	hkClass hkdSplitInHalfFractureClass(
		"hkdSplitInHalfFracture",
		&hkdFractureClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkdSplitInHalfFractureEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkdSplitInHalfFractureClass_Members),
		HK_COUNT_OF(hkdSplitInHalfFractureClass_Members),
		&hkdSplitInHalfFracture_Default,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static const hkInternalClassEnumItem hkdActionReplaceTypeEnumItems[] =
	{
		{0, "SHAPE_BROKEN"},
		{1, "SHAPE_ADDED"},
		{2, "COMPOUND_CHILD_ADDED"},
		{3, "COMPOUND_SHAPE_ADDED"},
		{4, "CHILD_ADDED"},
		{5, "DESCENDANT_ADDED"},
	};
	static const hkInternalClassEnumItem hkdActionInheritanceTypeEnumItems[] =
	{
		{0, "INHERITE_NEVER"},
		{1, "INHERIT_TO_STATIC_CHILDREN"},
		{2, "INHERIT_TO_DYNAMIC_CHILDREN"},
		{3, "INHERIT_TO_CHILDREN"},
		{4, "INHERIT_SELF"},
		{5, "INHERIT_SELF_AND_STATIC_CHILDREN"},
		{6, "INHERIT_SELF_AND_DYNAMIC_CHILDREN"},
		{7, "INHERIT_SELF_AND_CHILDREN"},
	};
	static const hkInternalClassEnumItem hkdActionExecutionTypeEnumItems[] =
	{
		{0, "EXECUTE_NEVER"},
		{1, "EXECUTE_ON_ADD"},
		{2, "EXECUTE_ON_ADD_COMPOUND"},
		{3, "EXECUTE_ON_ADD_ALWAYS"},
		{4, "EXECUTE_ON_BREAKAGE"},
		{7, "EXECUTE_ALWAYS"},
	};
	static const hkInternalClassEnumItem hkdActionFilterPipelinePriorityEnumItems[] =
	{
		{100, "PRIORITY_DEFAULT"},
		{60, "PRIORITY_REMOVE_WEAK_CONNECTIONS"},
		{50, "PRIORITY_GLUE_FIXED_PIECES"},
		{40, "PRIORITY_CREATE_DECAL_MAP"},
		{30, "PRIORITY_MESH_SIMPLIFIER"},
		{20, "PRIORITY_SHARE_VERTICES"},
		{10, "PRIORITY_CONVEX_DECOMPOSITION"},
		{5, "PRIORITY_DECORATE_FRACTURE_FACE"},
	};
	static const hkInternalClassEnum hkdActionEnums[] = {
		{"ReplaceType", hkdActionReplaceTypeEnumItems, 6, HK_NULL, 0 },
		{"InheritanceType", hkdActionInheritanceTypeEnumItems, 8, HK_NULL, 0 },
		{"ExecutionType", hkdActionExecutionTypeEnumItems, 6, HK_NULL, 0 },
		{"FilterPipelinePriority", hkdActionFilterPipelinePriorityEnumItems, 8, HK_NULL, 0 }
	};
	const hkClassEnum* hkdActionReplaceTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkdActionEnums[0]);
	const hkClassEnum* hkdActionInheritanceTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkdActionEnums[1]);
	const hkClassEnum* hkdActionExecutionTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkdActionEnums[2]);
	const hkClassEnum* hkdActionFilterPipelinePriorityEnum = reinterpret_cast<const hkClassEnum*>(&hkdActionEnums[3]);
	static hkInternalClassMember hkdActionClass_Members[] =
	{
		{ "inheritanceType", HK_NULL, HK_NULL, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "executionType", HK_NULL, HK_NULL, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "padding", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 2, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	namespace
	{
		struct hkdAction_DefaultStruct
		{
			int s_defaultOffsets[3];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkUint8 /* hkEnum< enum hkdAction::InheritanceType, hkUint8 > */ m_inheritanceType;
			hkUint8 /* hkEnum< enum hkdAction::ExecutionType, hkUint8 > */ m_executionType;
		};
		const hkdAction_DefaultStruct hkdAction_Default =
		{
			{HK_OFFSET_OF(hkdAction_DefaultStruct,m_inheritanceType),HK_OFFSET_OF(hkdAction_DefaultStruct,m_executionType),-1},
			 hkdAction::INHERIT_SELF_AND_CHILDREN , hkdAction::EXECUTE_ON_ADD 
		};
	}
	hkClass hkdActionClass(
		"hkdAction",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkdActionEnums),
		4,
		reinterpret_cast<const hkClassMember*>(hkdActionClass_Members),
		HK_COUNT_OF(hkdActionClass_Members),
		&hkdAction_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hkdInfoClass(
		"hkdInfo",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkdWoodControllerClass_Members[] =
	{
		{ "deformationFriction", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "deformationStrength", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxDeformationDistance", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "applyDeformationOnAllObjects", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "numSmoothingSteps", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "smoothingRadius", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkdWoodController_DefaultStruct
		{
			int s_defaultOffsets[6];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkReal m_deformationFriction;
			hkReal m_deformationStrength;
			hkReal m_maxDeformationDistance;
			hkUint8 m_numSmoothingSteps;
			hkUint8 m_smoothingRadius;
		};
		const hkdWoodController_DefaultStruct hkdWoodController_Default =
		{
			{HK_OFFSET_OF(hkdWoodController_DefaultStruct,m_deformationFriction),HK_OFFSET_OF(hkdWoodController_DefaultStruct,m_deformationStrength),HK_OFFSET_OF(hkdWoodController_DefaultStruct,m_maxDeformationDistance),hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkdWoodController_DefaultStruct,m_numSmoothingSteps),HK_OFFSET_OF(hkdWoodController_DefaultStruct,m_smoothingRadius)},
			0.5f,10.0f,10.0f,1,2
		};
	}
	hkClass hkdWoodControllerClass(
		"hkdWoodController",
		&hkdControllerClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkdWoodControllerClass_Members),
		HK_COUNT_OF(hkdWoodControllerClass_Members),
		&hkdWoodController_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkdGraphicsShapeGraphicsShapeTypeEnumItems[] =
	{
		{0, "TYPE_SINGLE"},
		{1, "TYPE_COMPOUND"},
		{2, "TYPE_SKINNED"},
	};
	static const hkInternalClassEnum hkdGraphicsShapeEnums[] = {
		{"GraphicsShapeType", hkdGraphicsShapeGraphicsShapeTypeEnumItems, 3, HK_NULL, 0 }
	};
	const hkClassEnum* hkdGraphicsShapeGraphicsShapeTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkdGraphicsShapeEnums[0]);
	static hkInternalClassMember hkdGraphicsShapeClass_Members[] =
	{
		{ "type", HK_NULL, hkdGraphicsShapeGraphicsShapeTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "numChildTransforms", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkdGraphicsShapeClass(
		"hkdGraphicsShape",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkdGraphicsShapeEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkdGraphicsShapeClass_Members),
		HK_COUNT_OF(hkdGraphicsShapeClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hkdGraphicsBodyClass(
		"hkdGraphicsBody",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkdBodyBodyTypeEnumItems[] =
	{
		{0, "TYPE_BODY"},
		{1, "TYPE_TEMPLATE"},
	};
	static const hkInternalClassEnum hkdBodyEnums[] = {
		{"BodyType", hkdBodyBodyTypeEnumItems, 2, HK_NULL, 0 }
	};
	const hkClassEnum* hkdBodyBodyTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkdBodyEnums[0]);
	static hkInternalClassMember hkdBodyClass_Members[] =
	{
		{ "bodyType", HK_NULL, hkdBodyBodyTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "parentName", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "controller", &hkdControllerClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "attachToNearbyObjects", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "constraintStrength", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "attributes", &hkxAttributeClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkdBody_DefaultStruct
		{
			int s_defaultOffsets[6];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkUint8 /* hkEnum< enum hkdBody::BodyType, hkUint8 > */ m_bodyType;
		};
		const hkdBody_DefaultStruct hkdBody_Default =
		{
			{HK_OFFSET_OF(hkdBody_DefaultStruct,m_bodyType),-1,-1,hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,-1},
			hkdBody::TYPE_BODY
		};
	}
	hkClass hkdBodyClass(
		"hkdBody",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkdBodyEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkdBodyClass_Members),
		HK_COUNT_OF(hkdBodyClass_Members),
		&hkdBody_Default,
		HK_NULL,
		0,
		hkUint32(3)
		);
	hkClass hkcdDynamicTreeDefaultTreePtrStorageClass(
		"hkcdDynamicTreeDefaultTreePtrStorage",
		&hkcdDynamicTreeTreehkcdDynamicTreeDynamicStoragePtrClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hkcdDynamicTreeDefaultTree48StorageClass(
		"hkcdDynamicTreeDefaultTree48Storage",
		&hkcdDynamicTreeTreehkcdDynamicTreeDynamicStorage32Class,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hkcdDynamicTreeDefaultTree32StorageClass(
		"hkcdDynamicTreeDefaultTree32Storage",
		&hkcdDynamicTreeTreehkcdDynamicTreeDynamicStorage16Class,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkcdDynamicTreeTreehkcdDynamicTreeDynamicStoragePtr_typenameClass_Members[] =
	{
		{ "numLeaves", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "path", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "root", HK_NULL, HK_NULL, hkClassMember::TYPE_ULONG, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkcdDynamicTreeTreehkcdDynamicTreeDynamicStoragePtrClass(
		"hkcdDynamicTreeTreehkcdDynamicTreeDynamicStoragePtr",
		&hkcdDynamicTreeDynamicStoragePtrClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkcdDynamicTreeTreehkcdDynamicTreeDynamicStoragePtr_typenameClass_Members),
		HK_COUNT_OF(hkcdDynamicTreeTreehkcdDynamicTreeDynamicStoragePtr_typenameClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkcdDynamicTreeTreehkcdDynamicTreeDynamicStorage32_typenameClass_Members[] =
	{
		{ "numLeaves", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "path", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "root", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkcdDynamicTreeTreehkcdDynamicTreeDynamicStorage32Class(
		"hkcdDynamicTreeTreehkcdDynamicTreeDynamicStorage32",
		&hkcdDynamicTreeDynamicStorage32Class,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkcdDynamicTreeTreehkcdDynamicTreeDynamicStorage32_typenameClass_Members),
		HK_COUNT_OF(hkcdDynamicTreeTreehkcdDynamicTreeDynamicStorage32_typenameClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkcdDynamicTreeTreehkcdDynamicTreeDynamicStorage16_typenameClass_Members[] =
	{
		{ "numLeaves", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "path", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "root", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkcdDynamicTreeTreehkcdDynamicTreeDynamicStorage16Class(
		"hkcdDynamicTreeTreehkcdDynamicTreeDynamicStorage16",
		&hkcdDynamicTreeDynamicStorage16Class,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkcdDynamicTreeTreehkcdDynamicTreeDynamicStorage16_typenameClass_Members),
		HK_COUNT_OF(hkcdDynamicTreeTreehkcdDynamicTreeDynamicStorage16_typenameClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hkcdDynamicTreeCentroidMetricClass(
		"hkcdDynamicTreeCentroidMetric",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hkcdDynamicTreeBalanceMetricClass(
		"hkcdDynamicTreeBalanceMetric",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hkcdDynamicTreeAnisotropicMetricClass(
		"hkcdDynamicTreeAnisotropicMetric",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hkcdStaticTreeDynamicStorage4Class(
		"hkcdStaticTreeDynamicStorage4",
		&hkcdStaticTreeDynamicStoragehkcdStaticTreeCodec3Axis4Class,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hkcdStaticTreeDynamicStorage5Class(
		"hkcdStaticTreeDynamicStorage5",
		&hkcdStaticTreeDynamicStoragehkcdStaticTreeCodec3Axis5Class,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hkcdStaticTreeDynamicStorage6Class(
		"hkcdStaticTreeDynamicStorage6",
		&hkcdStaticTreeDynamicStoragehkcdStaticTreeCodec3Axis6Class,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hkcdStaticTreeDynamicStorage32Class(
		"hkcdStaticTreeDynamicStorage32",
		&hkcdStaticTreeDynamicStoragehkcdStaticTreeCodecRawClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkcdStaticTreeDynamicStoragehkcdStaticTreeCodec3Axis4_typenameClass_Members[] =
	{
		{ "nodes", &hkcdStaticTreeCodec3Axis4Class, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkcdStaticTreeDynamicStoragehkcdStaticTreeCodec3Axis4Class(
		"hkcdStaticTreeDynamicStoragehkcdStaticTreeCodec3Axis4",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkcdStaticTreeDynamicStoragehkcdStaticTreeCodec3Axis4_typenameClass_Members),
		HK_COUNT_OF(hkcdStaticTreeDynamicStoragehkcdStaticTreeCodec3Axis4_typenameClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkcdStaticTreeDynamicStoragehkcdStaticTreeCodec3Axis5_typenameClass_Members[] =
	{
		{ "nodes", &hkcdStaticTreeCodec3Axis5Class, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkcdStaticTreeDynamicStoragehkcdStaticTreeCodec3Axis5Class(
		"hkcdStaticTreeDynamicStoragehkcdStaticTreeCodec3Axis5",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkcdStaticTreeDynamicStoragehkcdStaticTreeCodec3Axis5_typenameClass_Members),
		HK_COUNT_OF(hkcdStaticTreeDynamicStoragehkcdStaticTreeCodec3Axis5_typenameClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkcdStaticTreeDynamicStoragehkcdStaticTreeCodec3Axis6_typenameClass_Members[] =
	{
		{ "nodes", &hkcdStaticTreeCodec3Axis6Class, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkcdStaticTreeDynamicStoragehkcdStaticTreeCodec3Axis6Class(
		"hkcdStaticTreeDynamicStoragehkcdStaticTreeCodec3Axis6",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkcdStaticTreeDynamicStoragehkcdStaticTreeCodec3Axis6_typenameClass_Members),
		HK_COUNT_OF(hkcdStaticTreeDynamicStoragehkcdStaticTreeCodec3Axis6_typenameClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkcdStaticTreeDynamicStoragehkcdStaticTreeCodecRaw_typenameClass_Members[] =
	{
		{ "nodes", &hkcdStaticTreeCodecRawClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkcdStaticTreeDynamicStoragehkcdStaticTreeCodecRawClass(
		"hkcdStaticTreeDynamicStoragehkcdStaticTreeCodecRaw",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkcdStaticTreeDynamicStoragehkcdStaticTreeCodecRaw_typenameClass_Members),
		HK_COUNT_OF(hkcdStaticTreeDynamicStoragehkcdStaticTreeCodecRaw_typenameClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hkcdDynamicTreeDynamicStoragePtrClass(
		"hkcdDynamicTreeDynamicStoragePtr",
		&hkcdDynamicTreeDefaultDynamicStoragehkcdDynamicTreeCodecRawUlongClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hkcdDynamicTreeDynamicStorage32Class(
		"hkcdDynamicTreeDynamicStorage32",
		&hkcdDynamicTreeDefaultDynamicStoragehkcdDynamicTreeCodecRawUintClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hkcdDynamicTreeDynamicStorage16Class(
		"hkcdDynamicTreeDynamicStorage16",
		&hkcdDynamicTreeDefaultDynamicStoragehkcdDynamicTreeCodec32Class,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkcdDynamicTreeDynamicStorage0hkcdDynamicTreeAnisotropicMetrichkcdDynamicTreeCodecRawUlong_typenameClass_Members[] =
	{
		{ "nodes", &hkcdDynamicTreeCodecRawUlongClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "firstFree", HK_NULL, HK_NULL, hkClassMember::TYPE_ULONG, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkcdDynamicTreeDynamicStorage0hkcdDynamicTreeAnisotropicMetrichkcdDynamicTreeCodecRawUlongClass(
		"hkcdDynamicTreeDynamicStorage0hkcdDynamicTreeAnisotropicMetrichkcdDynamicTreeCodecRawUlong",
		&hkcdDynamicTreeAnisotropicMetricClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkcdDynamicTreeDynamicStorage0hkcdDynamicTreeAnisotropicMetrichkcdDynamicTreeCodecRawUlong_typenameClass_Members),
		HK_COUNT_OF(hkcdDynamicTreeDynamicStorage0hkcdDynamicTreeAnisotropicMetrichkcdDynamicTreeCodecRawUlong_typenameClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hkcdDynamicTreeDefaultDynamicStoragehkcdDynamicTreeCodecRawUlongClass(
		"hkcdDynamicTreeDefaultDynamicStoragehkcdDynamicTreeCodecRawUlong",
		&hkcdDynamicTreeDynamicStorage0hkcdDynamicTreeAnisotropicMetrichkcdDynamicTreeCodecRawUlongClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkcdDynamicTreeDynamicStorage0hkcdDynamicTreeAnisotropicMetrichkcdDynamicTreeCodecRawUint_typenameClass_Members[] =
	{
		{ "nodes", &hkcdDynamicTreeCodecRawUintClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "firstFree", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkcdDynamicTreeDynamicStorage0hkcdDynamicTreeAnisotropicMetrichkcdDynamicTreeCodecRawUintClass(
		"hkcdDynamicTreeDynamicStorage0hkcdDynamicTreeAnisotropicMetrichkcdDynamicTreeCodecRawUint",
		&hkcdDynamicTreeAnisotropicMetricClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkcdDynamicTreeDynamicStorage0hkcdDynamicTreeAnisotropicMetrichkcdDynamicTreeCodecRawUint_typenameClass_Members),
		HK_COUNT_OF(hkcdDynamicTreeDynamicStorage0hkcdDynamicTreeAnisotropicMetrichkcdDynamicTreeCodecRawUint_typenameClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hkcdDynamicTreeDefaultDynamicStoragehkcdDynamicTreeCodecRawUintClass(
		"hkcdDynamicTreeDefaultDynamicStoragehkcdDynamicTreeCodecRawUint",
		&hkcdDynamicTreeDynamicStorage0hkcdDynamicTreeAnisotropicMetrichkcdDynamicTreeCodecRawUintClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkcdDynamicTreeDynamicStorage0hkcdDynamicTreeAnisotropicMetrichkcdDynamicTreeCodec32_typenameClass_Members[] =
	{
		{ "nodes", &hkcdDynamicTreeCodec32Class, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "firstFree", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkcdDynamicTreeDynamicStorage0hkcdDynamicTreeAnisotropicMetrichkcdDynamicTreeCodec32Class(
		"hkcdDynamicTreeDynamicStorage0hkcdDynamicTreeAnisotropicMetrichkcdDynamicTreeCodec32",
		&hkcdDynamicTreeAnisotropicMetricClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkcdDynamicTreeDynamicStorage0hkcdDynamicTreeAnisotropicMetrichkcdDynamicTreeCodec32_typenameClass_Members),
		HK_COUNT_OF(hkcdDynamicTreeDynamicStorage0hkcdDynamicTreeAnisotropicMetrichkcdDynamicTreeCodec32_typenameClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hkcdDynamicTreeDefaultDynamicStoragehkcdDynamicTreeCodec32Class(
		"hkcdDynamicTreeDefaultDynamicStoragehkcdDynamicTreeCodec32",
		&hkcdDynamicTreeDynamicStorage0hkcdDynamicTreeAnisotropicMetrichkcdDynamicTreeCodec32Class,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hkcdStaticTreeDefaultTreeStorage4Class(
		"hkcdStaticTreeDefaultTreeStorage4",
		&hkcdStaticTreeTreehkcdStaticTreeDynamicStorage4Class,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hkcdStaticTreeDefaultTreeStorage5Class(
		"hkcdStaticTreeDefaultTreeStorage5",
		&hkcdStaticTreeTreehkcdStaticTreeDynamicStorage5Class,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hkcdStaticTreeDefaultTreeStorage6Class(
		"hkcdStaticTreeDefaultTreeStorage6",
		&hkcdStaticTreeTreehkcdStaticTreeDynamicStorage6Class,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hkcdStaticTreeDefaultTreeStorage32Class(
		"hkcdStaticTreeDefaultTreeStorage32",
		&hkcdStaticTreeTreehkcdStaticTreeDynamicStorage32Class,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkcdStaticTreeTreehkcdStaticTreeDynamicStorage4_typenameClass_Members[] =
	{
		{ "domain", &hkAabbClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkcdStaticTreeTreehkcdStaticTreeDynamicStorage4Class(
		"hkcdStaticTreeTreehkcdStaticTreeDynamicStorage4",
		&hkcdStaticTreeDynamicStorage4Class,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkcdStaticTreeTreehkcdStaticTreeDynamicStorage4_typenameClass_Members),
		HK_COUNT_OF(hkcdStaticTreeTreehkcdStaticTreeDynamicStorage4_typenameClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkcdStaticTreeTreehkcdStaticTreeDynamicStorage5_typenameClass_Members[] =
	{
		{ "domain", &hkAabbClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkcdStaticTreeTreehkcdStaticTreeDynamicStorage5Class(
		"hkcdStaticTreeTreehkcdStaticTreeDynamicStorage5",
		&hkcdStaticTreeDynamicStorage5Class,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkcdStaticTreeTreehkcdStaticTreeDynamicStorage5_typenameClass_Members),
		HK_COUNT_OF(hkcdStaticTreeTreehkcdStaticTreeDynamicStorage5_typenameClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkcdStaticTreeTreehkcdStaticTreeDynamicStorage6_typenameClass_Members[] =
	{
		{ "domain", &hkAabbClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkcdStaticTreeTreehkcdStaticTreeDynamicStorage6Class(
		"hkcdStaticTreeTreehkcdStaticTreeDynamicStorage6",
		&hkcdStaticTreeDynamicStorage6Class,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkcdStaticTreeTreehkcdStaticTreeDynamicStorage6_typenameClass_Members),
		HK_COUNT_OF(hkcdStaticTreeTreehkcdStaticTreeDynamicStorage6_typenameClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkcdStaticTreeTreehkcdStaticTreeDynamicStorage32_typenameClass_Members[] =
	{
		{ "domain", &hkAabbClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkcdStaticTreeTreehkcdStaticTreeDynamicStorage32Class(
		"hkcdStaticTreeTreehkcdStaticTreeDynamicStorage32",
		&hkcdStaticTreeDynamicStorage32Class,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkcdStaticTreeTreehkcdStaticTreeDynamicStorage32_typenameClass_Members),
		HK_COUNT_OF(hkcdStaticTreeTreehkcdStaticTreeDynamicStorage32_typenameClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkcdStaticTree_Codec3AxisClass_Members[] =
	{
		{ "xyz", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 3, 0, 0, HK_NULL }
	};
	hkClass hkcdStaticTreeCodec3AxisClass(
		"hkcdStaticTreeCodec3Axis",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkcdStaticTree_Codec3AxisClass_Members),
		HK_COUNT_OF(hkcdStaticTree_Codec3AxisClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkcdStaticTree_Codec3Axis4Class_Members[] =
	{
		{ "data", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkcdStaticTreeCodec3Axis4Class(
		"hkcdStaticTreeCodec3Axis4",
		&hkcdStaticTreeCodec3AxisClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkcdStaticTree_Codec3Axis4Class_Members),
		HK_COUNT_OF(hkcdStaticTree_Codec3Axis4Class_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkcdStaticTree_Codec3Axis5Class_Members[] =
	{
		{ "hiData", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "loData", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkcdStaticTreeCodec3Axis5Class(
		"hkcdStaticTreeCodec3Axis5",
		&hkcdStaticTreeCodec3AxisClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkcdStaticTree_Codec3Axis5Class_Members),
		HK_COUNT_OF(hkcdStaticTree_Codec3Axis5Class_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkcdStaticTree_Codec3Axis6Class_Members[] =
	{
		{ "hiData", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "loData", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkcdStaticTreeCodec3Axis6Class(
		"hkcdStaticTreeCodec3Axis6",
		&hkcdStaticTreeCodec3AxisClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkcdStaticTree_Codec3Axis6Class_Members),
		HK_COUNT_OF(hkcdStaticTree_Codec3Axis6Class_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkcdStaticTree_CodecRawClass_Members[] =
	{
		{ "aabb", &hkAabbClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkcdStaticTreeCodecRawClass(
		"hkcdStaticTreeCodecRaw",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkcdStaticTree_CodecRawClass_Members),
		HK_COUNT_OF(hkcdStaticTree_CodecRawClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkcdStaticMeshTreeBase_Section_SharedVerticesClass_Members[] =
	{
		{ "data", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkcdStaticMeshTreeBaseSectionSharedVerticesClass(
		"hkcdStaticMeshTreeBaseSectionSharedVertices",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkcdStaticMeshTreeBase_Section_SharedVerticesClass_Members),
		HK_COUNT_OF(hkcdStaticMeshTreeBase_Section_SharedVerticesClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkcdStaticMeshTreeBase_Section_PrimitivesClass_Members[] =
	{
		{ "data", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkcdStaticMeshTreeBaseSectionPrimitivesClass(
		"hkcdStaticMeshTreeBaseSectionPrimitives",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkcdStaticMeshTreeBase_Section_PrimitivesClass_Members),
		HK_COUNT_OF(hkcdStaticMeshTreeBase_Section_PrimitivesClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkcdStaticMeshTreeBase_Section_DataRunsClass_Members[] =
	{
		{ "data", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkcdStaticMeshTreeBaseSectionDataRunsClass(
		"hkcdStaticMeshTreeBaseSectionDataRuns",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkcdStaticMeshTreeBase_Section_DataRunsClass_Members),
		HK_COUNT_OF(hkcdStaticMeshTreeBase_Section_DataRunsClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkcdStaticMeshTreeBase_SectionClass_Members[] =
	{
		{ "codecParms", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 6, 0, 0, HK_NULL },
		{ "firstPackedVertex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "sharedVertices", &hkcdStaticMeshTreeBaseSectionSharedVerticesClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "primitives", &hkcdStaticMeshTreeBaseSectionPrimitivesClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "dataRuns", &hkcdStaticMeshTreeBaseSectionDataRunsClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "numPackedVertices", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "numSharedIndices", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "leafIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "page", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "unusedData", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 3, 0, 0, HK_NULL }
	};
	hkClass hkcdStaticMeshTreeBaseSectionClass(
		"hkcdStaticMeshTreeBaseSection",
		&hkcdStaticTreeTreehkcdStaticTreeDynamicStorage4Class,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkcdStaticMeshTreeBase_SectionClass_Members),
		HK_COUNT_OF(hkcdStaticMeshTreeBase_SectionClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static const hkInternalClassEnumItem hkcdStaticMeshTreeBasePrimitiveTypeEnumItems[] =
	{
		{0, "TRIANGLE"},
		{1, "QUAD"},
	};
	static const hkInternalClassEnum hkcdStaticMeshTreeBasePrimitiveEnums[] = {
		{"Type", hkcdStaticMeshTreeBasePrimitiveTypeEnumItems, 2, HK_NULL, 0 }
	};
	const hkClassEnum* hkcdStaticMeshTreeBasePrimitiveTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkcdStaticMeshTreeBasePrimitiveEnums[0]);
	static hkInternalClassMember hkcdStaticMeshTreeBase_PrimitiveClass_Members[] =
	{
		{ "indices", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 4, 0, 0, HK_NULL }
	};
	hkClass hkcdStaticMeshTreeBasePrimitiveClass(
		"hkcdStaticMeshTreeBasePrimitive",
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkcdStaticMeshTreeBasePrimitiveEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkcdStaticMeshTreeBase_PrimitiveClass_Members),
		HK_COUNT_OF(hkcdStaticMeshTreeBase_PrimitiveClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkcdStaticMeshTreeBaseClass_Members[] =
	{
		{ "numPrimitiveKeys", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "bitsPerKey", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxKeyValue", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "sections", &hkcdStaticMeshTreeBaseSectionClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "primitives", &hkcdStaticMeshTreeBasePrimitiveClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "sharedVerticesIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT16, 0, 0, 0, HK_NULL }
	};
	hkClass hkcdStaticMeshTreeBaseClass(
		"hkcdStaticMeshTreeBase",
		&hkcdStaticTreeTreehkcdStaticTreeDynamicStorage5Class,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkcdStaticMeshTreeBaseClass_Members),
		HK_COUNT_OF(hkcdStaticMeshTreeBaseClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hkcdStaticMeshTreeDefaultDataRunClass(
		"hkcdStaticMeshTreeDefaultDataRun",
		&hkcdStaticMeshTreeBasePrimitiveDataRunBaseunsignedshortClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkcdStaticMeshTreeBasePrimitiveDataRunBaseunsignedshort_typenameClass_Members[] =
	{
		{ "value", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "index", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "count", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkcdStaticMeshTreeBasePrimitiveDataRunBaseunsignedshortClass(
		"hkcdStaticMeshTreeBasePrimitiveDataRunBaseunsignedshort",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkcdStaticMeshTreeBasePrimitiveDataRunBaseunsignedshort_typenameClass_Members),
		HK_COUNT_OF(hkcdStaticMeshTreeBasePrimitiveDataRunBaseunsignedshort_typenameClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkcdDynamicTree_Codec32Class_Members[] =
	{
		{ "aabb", &hkAabbClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkcdDynamicTreeCodec32Class(
		"hkcdDynamicTreeCodec32",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkcdDynamicTree_Codec32Class_Members),
		HK_COUNT_OF(hkcdDynamicTree_Codec32Class_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkcdDynamicTree_Codec18Class_Members[] =
	{
		{ "aabb", &hkAabbHalfClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "parent", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkcdDynamicTreeCodec18Class(
		"hkcdDynamicTreeCodec18",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkcdDynamicTree_Codec18Class_Members),
		HK_COUNT_OF(hkcdDynamicTree_Codec18Class_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hkcdDynamicTreeCodecRawUlongClass(
		"hkcdDynamicTreeCodecRawUlong",
		&hkcdDynamicTreeCodecRawunsignedlongClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hkcdDynamicTreeCodecRawUintClass(
		"hkcdDynamicTreeCodecRawUint",
		&hkcdDynamicTreeCodecRawunsignedintClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkcdDynamicTreeCodecRawunsignedlong_typenameClass_Members[] =
	{
		{ "aabb", &hkAabbClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "parent", HK_NULL, HK_NULL, hkClassMember::TYPE_ULONG, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "children", HK_NULL, HK_NULL, hkClassMember::TYPE_ULONG, hkClassMember::TYPE_VOID, 2, 0, 0, HK_NULL }
	};
	hkClass hkcdDynamicTreeCodecRawunsignedlongClass(
		"hkcdDynamicTreeCodecRawunsignedlong",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkcdDynamicTreeCodecRawunsignedlong_typenameClass_Members),
		HK_COUNT_OF(hkcdDynamicTreeCodecRawunsignedlong_typenameClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkcdDynamicTreeCodecRawunsignedint_typenameClass_Members[] =
	{
		{ "aabb", &hkAabbClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "parent", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "children", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 2, 0, 0, HK_NULL }
	};
	hkClass hkcdDynamicTreeCodecRawunsignedintClass(
		"hkcdDynamicTreeCodecRawunsignedint",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkcdDynamicTreeCodecRawunsignedint_typenameClass_Members),
		HK_COUNT_OF(hkcdDynamicTreeCodecRawunsignedint_typenameClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkpWeldingUtilityWeldingTypeEnumItems[] =
	{
		{0, "WELDING_TYPE_ANTICLOCKWISE"},
		{4, "WELDING_TYPE_CLOCKWISE"},
		{5, "WELDING_TYPE_TWO_SIDED"},
		{6, "WELDING_TYPE_NONE"},
	};
	static const hkInternalClassEnumItem hkpWeldingUtilitySectorTypeEnumItems[] =
	{
		{1, "ACCEPT_0"},
		{0, "SNAP_0"},
		{2, "REJECT"},
		{4, "SNAP_1"},
		{3, "ACCEPT_1"},
	};
	static const hkInternalClassEnumItem hkpWeldingUtilityNumAnglesEnumItems[] =
	{
		{31, "NUM_ANGLES"},
	};
	static const hkInternalClassEnum hkpWeldingUtilityEnums[] = {
		{"WeldingType", hkpWeldingUtilityWeldingTypeEnumItems, 4, HK_NULL, 0 },
		{"SectorType", hkpWeldingUtilitySectorTypeEnumItems, 5, HK_NULL, 0 },
		{"NumAngles", hkpWeldingUtilityNumAnglesEnumItems, 1, HK_NULL, 0 }
	};
	const hkClassEnum* hkpWeldingUtilityWeldingTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkpWeldingUtilityEnums[0]);
	const hkClassEnum* hkpWeldingUtilitySectorTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkpWeldingUtilityEnums[1]);
	const hkClassEnum* hkpWeldingUtilityNumAnglesEnum = reinterpret_cast<const hkClassEnum*>(&hkpWeldingUtilityEnums[2]);
	hkClass hkpWeldingUtilityClass(
		"hkpWeldingUtility",
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkpWeldingUtilityEnums),
		3,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkpCollidableForceCollideOntoPpuReasonsEnumItems[] =
	{
		{1, "FORCE_PPU_USER_REQUEST"},
		{2, "FORCE_PPU_SHAPE_REQUEST"},
		{4, "FORCE_PPU_MODIFIER_REQUEST"},
		{8, "FORCE_PPU_SHAPE_UNCHECKED"},
	};
	static const hkInternalClassEnum hkpCollidableEnums[] = {
		{"ForceCollideOntoPpuReasons", hkpCollidableForceCollideOntoPpuReasonsEnumItems, 4, HK_NULL, 0 }
	};
	const hkClassEnum* hkpCollidableForceCollideOntoPpuReasonsEnum = reinterpret_cast<const hkClassEnum*>(&hkpCollidableEnums[0]);
	static hkInternalClassMember hkpCollidable_BoundingVolumeDataClass_Members[] =
	{
		{ "min", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 3, 0, 0, HK_NULL },
		{ "expansionMin", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 3, 0, 0, HK_NULL },
		{ "expansionShift", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "max", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 3, 0, 0, HK_NULL },
		{ "expansionMax", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 3, 0, 0, HK_NULL },
		{ "padding", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "numChildShapeAabbs", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "capacityChildShapeAabbs", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "childShapeAabbs", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "childShapeKeys", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hkpCollidableBoundingVolumeDataClass(
		"hkpCollidableBoundingVolumeData",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpCollidable_BoundingVolumeDataClass_Members),
		HK_COUNT_OF(hkpCollidable_BoundingVolumeDataClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpCollidableClass_Members[] =
	{
		{ "ownerOffset", HK_NULL, HK_NULL, hkClassMember::TYPE_INT8, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "forceCollideOntoPpu", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "shapeSizeOnSpu", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "broadPhaseHandle", &hkpTypedBroadPhaseHandleClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "boundingVolumeData", &hkpCollidableBoundingVolumeDataClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "allowedPenetrationDepth", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpCollidableClass(
		"hkpCollidable",
		&hkpCdBodyClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkpCollidableEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkpCollidableClass_Members),
		HK_COUNT_OF(hkpCollidableClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hkpDefaultConvexListFilterClass(
		"hkpDefaultConvexListFilter",
		&hkpConvexListFilterClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpShapeInfoClass_Members[] =
	{
		{ "shape", &hkpShapeClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "isHierarchicalCompound", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "hkdShapesCollected", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "childShapeNames", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRINGPTR, 0, 0, 0, HK_NULL },
		{ "childTransforms", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_TRANSFORM, 0, 0, 0, HK_NULL },
		{ "transform", HK_NULL, HK_NULL, hkClassMember::TYPE_TRANSFORM, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpShapeInfoClass(
		"hkpShapeInfo",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpShapeInfoClass_Members),
		HK_COUNT_OF(hkpShapeInfoClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpCompressedSampledHeightFieldShapeClass_Members[] =
	{
		{ "storage", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT16, 0, 0, 0, HK_NULL },
		{ "triangleFlip", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "offset", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "scale", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpCompressedSampledHeightFieldShapeClass(
		"hkpCompressedSampledHeightFieldShape",
		&hkpSampledHeightFieldShapeClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpCompressedSampledHeightFieldShapeClass_Members),
		HK_COUNT_OF(hkpCompressedSampledHeightFieldShapeClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hkpRayCollidableFilterClass(
		"hkpRayCollidableFilter",
		HK_NULL,
		0,
		HK_NULL,
		1,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpConvexVerticesConnectivityClass_Members[] =
	{
		{ "vertexIndices", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT16, 0, 0, 0, HK_NULL },
		{ "numVerticesPerFace", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL }
	};
	hkClass hkpConvexVerticesConnectivityClass(
		"hkpConvexVerticesConnectivity",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpConvexVerticesConnectivityClass_Members),
		HK_COUNT_OF(hkpConvexVerticesConnectivityClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkpCollisionFilterhkpFilterTypeEnumItems[] =
	{
		{0, "HK_FILTER_UNKNOWN"},
		{1, "HK_FILTER_NULL"},
		{2, "HK_FILTER_GROUP"},
		{3, "HK_FILTER_LIST"},
		{4, "HK_FILTER_CUSTOM"},
		{5, "HK_FILTER_PAIR"},
		{6, "HK_FILTER_CONSTRAINT"},
	};
	static const hkInternalClassEnum hkpCollisionFilterEnums[] = {
		{"hkpFilterType", hkpCollisionFilterhkpFilterTypeEnumItems, 7, HK_NULL, 0 }
	};
	const hkClassEnum* hkpCollisionFilterhkpFilterTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkpCollisionFilterEnums[0]);
	static hkInternalClassMember hkpCollisionFilterClass_Members[] =
	{
		{ "prepad", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 2, 0, 0, HK_NULL },
		{ "type", HK_NULL, hkpCollisionFilterhkpFilterTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT32, 0, 0, 0, HK_NULL },
		{ "postpad", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 3, 0, 0, HK_NULL }
	};
	hkClass hkpCollisionFilterClass(
		"hkpCollisionFilter",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		4,
		reinterpret_cast<const hkClassEnum*>(hkpCollisionFilterEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkpCollisionFilterClass_Members),
		HK_COUNT_OF(hkpCollisionFilterClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkpCylinderShapeVertexIdEncodingEnumItems[] =
	{
		{7, "VERTEX_ID_ENCODING_IS_BASE_A_SHIFT"},
		{6, "VERTEX_ID_ENCODING_SIN_SIGN_SHIFT"},
		{5, "VERTEX_ID_ENCODING_COS_SIGN_SHIFT"},
		{4, "VERTEX_ID_ENCODING_IS_SIN_LESSER_SHIFT"},
		{15, "VERTEX_ID_ENCODING_VALUE_MASK"},
	};
	static const hkInternalClassEnum hkpCylinderShapeEnums[] = {
		{"VertexIdEncoding", hkpCylinderShapeVertexIdEncodingEnumItems, 5, HK_NULL, 0 }
	};
	const hkClassEnum* hkpCylinderShapeVertexIdEncodingEnum = reinterpret_cast<const hkClassEnum*>(&hkpCylinderShapeEnums[0]);
	static hkInternalClassMember hkpCylinderShapeClass_Members[] =
	{
		{ "cylRadius", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "cylBaseRadiusFactorForHeightFieldCollisions", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "vertexA", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "vertexB", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "perpendicular1", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "perpendicular2", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkpCylinderShape_DefaultStruct
		{
			int s_defaultOffsets[6];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkReal m_cylBaseRadiusFactorForHeightFieldCollisions;
		};
		const hkpCylinderShape_DefaultStruct hkpCylinderShape_Default =
		{
			{-1,HK_OFFSET_OF(hkpCylinderShape_DefaultStruct,m_cylBaseRadiusFactorForHeightFieldCollisions),-1,-1,-1,-1},
			0.8f
		};
	}
	hkClass hkpCylinderShapeClass(
		"hkpCylinderShape",
		&hkpConvexShapeClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkpCylinderShapeEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkpCylinderShapeClass_Members),
		HK_COUNT_OF(hkpCylinderShapeClass_Members),
		&hkpCylinderShape_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkpBvTreeShapeBvTreeTypeEnumItems[] =
	{
		{0, "BVTREE_MOPP"},
		{1, "BVTREE_TRISAMPLED_HEIGHTFIELD"},
		{2, "BVTREE_STATIC_COMPOUND"},
		{3, "BVTREE_COMPRESSED_MESH"},
		{4, "BVTREE_USER"},
		{5, "BVTREE_MAX"},
	};
	static const hkInternalClassEnum hkpBvTreeShapeEnums[] = {
		{"BvTreeType", hkpBvTreeShapeBvTreeTypeEnumItems, 6, HK_NULL, 0 }
	};
	const hkClassEnum* hkpBvTreeShapeBvTreeTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkpBvTreeShapeEnums[0]);
	static hkInternalClassMember hkpBvTreeShapeClass_Members[] =
	{
		{ "bvTreeType", HK_NULL, hkpBvTreeShapeBvTreeTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkpBvTreeShape_DefaultStruct
		{
			int s_defaultOffsets[1];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkUint8 /* hkEnum< enum hkpBvTreeShape::BvTreeType, hkUint8 > */ m_bvTreeType;
		};
		const hkpBvTreeShape_DefaultStruct hkpBvTreeShape_Default =
		{
			{HK_OFFSET_OF(hkpBvTreeShape_DefaultStruct,m_bvTreeType)},
			hkpBvTreeShape::BVTREE_USER
		};
	}
	hkClass hkpBvTreeShapeClass(
		"hkpBvTreeShape",
		&hkpShapeClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkpBvTreeShapeEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkpBvTreeShapeClass_Members),
		HK_COUNT_OF(hkpBvTreeShapeClass_Members),
		&hkpBvTreeShape_Default,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkpBroadPhaseHandleClass_Members[] =
	{
		{ "id", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hkpBroadPhaseHandleClass(
		"hkpBroadPhaseHandle",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpBroadPhaseHandleClass_Members),
		HK_COUNT_OF(hkpBroadPhaseHandleClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpBvShapeClass_Members[] =
	{
		{ "boundingVolumeShape", &hkpShapeClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "childShape", &hkpSingleShapeContainerClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpBvShapeClass(
		"hkpBvShape",
		&hkpShapeClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpBvShapeClass_Members),
		HK_COUNT_OF(hkpBvShapeClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpConvexTransformShapeClass_Members[] =
	{
		{ "transform", HK_NULL, HK_NULL, hkClassMember::TYPE_QSTRANSFORM, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpConvexTransformShapeClass(
		"hkpConvexTransformShape",
		&hkpConvexTransformShapeBaseClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpConvexTransformShapeClass_Members),
		HK_COUNT_OF(hkpConvexTransformShapeClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkpConvexVerticesShapeClass_Members[] =
	{
		{ "aabbHalfExtents", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "aabbCenter", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "rotatedVertices", &hkFourTransposedPointsClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "numVertices", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "useSpuBuffer", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "planeEquations", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VECTOR4, 0, 0, 0, HK_NULL },
		{ "connectivity", &hkpConvexVerticesConnectivityClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkpConvexVerticesShape_DefaultStruct
		{
			int s_defaultOffsets[7];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
		};
		const hkpConvexVerticesShape_DefaultStruct hkpConvexVerticesShape_Default =
		{
			{-1,-1,-1,-1,hkClassMember::HK_CLASS_ZERO_DEFAULT,-1,-1},
		};
	}
	hkClass hkpConvexVerticesShapeClass(
		"hkpConvexVerticesShape",
		&hkpConvexShapeClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpConvexVerticesShapeClass_Members),
		HK_COUNT_OF(hkpConvexVerticesShapeClass_Members),
		&hkpConvexVerticesShape_Default,
		HK_NULL,
		0,
		hkUint32(4)
		);
	hkClass hkpPhantomCallbackShapeClass(
		"hkpPhantomCallbackShape",
		&hkpShapeClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpTriangleShapeClass_Members[] =
	{
		{ "weldingInfo", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "weldingType", HK_NULL, hkpWeldingUtilityWeldingTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "isExtruded", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "vertexA", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "vertexB", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "vertexC", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "extrusion", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkpTriangleShape_DefaultStruct
		{
			int s_defaultOffsets[7];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkUint8 /* hkEnum< enum hkpWeldingUtility::WeldingType, hkUint8 > */ m_weldingType;
		};
		const hkpTriangleShape_DefaultStruct hkpTriangleShape_Default =
		{
			{hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkpTriangleShape_DefaultStruct,m_weldingType),-1,-1,-1,-1,-1},
			hkpWeldingUtility::WELDING_TYPE_NONE
		};
	}
	hkClass hkpTriangleShapeClass(
		"hkpTriangleShape",
		&hkpConvexShapeClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpTriangleShapeClass_Members),
		HK_COUNT_OF(hkpTriangleShapeClass_Members),
		&hkpTriangleShape_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpNamedMeshMaterialClass_Members[] =
	{
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpNamedMeshMaterialClass(
		"hkpNamedMeshMaterial",
		&hkpMeshMaterialClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpNamedMeshMaterialClass_Members),
		HK_COUNT_OF(hkpNamedMeshMaterialClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkpMeshShapeMeshShapeIndexStridingTypeEnumItems[] =
	{
		{0, "INDICES_INVALID"},
		{1, "INDICES_INT16"},
		{2, "INDICES_INT32"},
		{3, "INDICES_MAX_ID"},
	};
	static const hkInternalClassEnumItem hkpMeshShapeMeshShapeMaterialIndexStridingTypeEnumItems[] =
	{
		{0, "MATERIAL_INDICES_INVALID"},
		{1, "MATERIAL_INDICES_INT8"},
		{2, "MATERIAL_INDICES_INT16"},
		{3, "MATERIAL_INDICES_MAX_ID"},
	};
	static const hkInternalClassEnum hkpMeshShapeEnums[] = {
		{"MeshShapeIndexStridingType", hkpMeshShapeMeshShapeIndexStridingTypeEnumItems, 4, HK_NULL, 0 },
		{"MeshShapeMaterialIndexStridingType", hkpMeshShapeMeshShapeMaterialIndexStridingTypeEnumItems, 4, HK_NULL, 0 }
	};
	const hkClassEnum* hkpMeshShapeMeshShapeIndexStridingTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkpMeshShapeEnums[0]);
	const hkClassEnum* hkpMeshShapeMeshShapeMaterialIndexStridingTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkpMeshShapeEnums[1]);
	static hkInternalClassMember hkpMeshShape_SubpartClass_Members[] =
	{
		{ "vertexBase", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "vertexStriding", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "numVertices", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "indexBase", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "stridingType", HK_NULL, hkpMeshShapeMeshShapeIndexStridingTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL },
		{ "materialIndexStridingType", HK_NULL, hkpMeshShapeMeshShapeMaterialIndexStridingTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL },
		{ "indexStriding", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "flipAlternateTriangles", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "numTriangles", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "materialIndexBase", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "materialIndexStriding", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "materialBase", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "materialStriding", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "numMaterials", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "triangleOffset", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkpMeshShapeSubpart_DefaultStruct
		{
			int s_defaultOffsets[15];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkInt32 m_triangleOffset;
		};
		const hkpMeshShapeSubpart_DefaultStruct hkpMeshShapeSubpart_Default =
		{
			{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,HK_OFFSET_OF(hkpMeshShapeSubpart_DefaultStruct,m_triangleOffset)},
			-1
		};
	}
	hkClass hkpMeshShapeSubpartClass(
		"hkpMeshShapeSubpart",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpMeshShape_SubpartClass_Members),
		HK_COUNT_OF(hkpMeshShape_SubpartClass_Members),
		&hkpMeshShapeSubpart_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpMeshShapeClass_Members[] =
	{
		{ "scaling", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "numBitsForSubpartIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "subparts", &hkpMeshShapeSubpartClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "weldingInfo", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT16, 0, 0, 0, HK_NULL },
		{ "weldingType", HK_NULL, hkpWeldingUtilityWeldingTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "radius", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "pad", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 3, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkpMeshShape_DefaultStruct
		{
			int s_defaultOffsets[7];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkUint8 /* hkEnum< enum hkpWeldingUtility::WeldingType, hkUint8 > */ m_weldingType;
		};
		const hkpMeshShape_DefaultStruct hkpMeshShape_Default =
		{
			{-1,-1,-1,-1,HK_OFFSET_OF(hkpMeshShape_DefaultStruct,m_weldingType),-1,-1},
			hkpWeldingUtility::WELDING_TYPE_NONE
		};
	}
	hkClass hkpMeshShapeClass(
		"hkpMeshShape",
		&hkpShapeCollectionClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkpMeshShapeEnums),
		2,
		reinterpret_cast<const hkClassMember*>(hkpMeshShapeClass_Members),
		HK_COUNT_OF(hkpMeshShapeClass_Members),
		&hkpMeshShape_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hkpShapeContainerClass(
		"hkpShapeContainer",
		HK_NULL,
		0,
		HK_NULL,
		1,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpSingleShapeContainerClass_Members[] =
	{
		{ "childShape", &hkpShapeClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkpSingleShapeContainerClass(
		"hkpSingleShapeContainer",
		&hkpShapeContainerClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpSingleShapeContainerClass_Members),
		HK_COUNT_OF(hkpSingleShapeContainerClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpPlaneShapeClass_Members[] =
	{
		{ "plane", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "aabbCenter", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "aabbHalfExtents", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpPlaneShapeClass(
		"hkpPlaneShape",
		&hkpHeightFieldShapeClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpPlaneShapeClass_Members),
		HK_COUNT_OF(hkpPlaneShapeClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hkpHeightFieldShapeClass(
		"hkpHeightFieldShape",
		&hkpShapeClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpStorageSampledHeightFieldShapeClass_Members[] =
	{
		{ "storage", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_REAL, 0, 0, 0, HK_NULL },
		{ "triangleFlip", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpStorageSampledHeightFieldShapeClass(
		"hkpStorageSampledHeightFieldShape",
		&hkpSampledHeightFieldShapeClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpStorageSampledHeightFieldShapeClass_Members),
		HK_COUNT_OF(hkpStorageSampledHeightFieldShapeClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpStorageMeshShape_SubpartStorageClass_Members[] =
	{
		{ "vertices", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_REAL, 0, 0, 0, HK_NULL },
		{ "indices16", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT16, 0, 0, 0, HK_NULL },
		{ "indices32", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT32, 0, 0, 0, HK_NULL },
		{ "materialIndices", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "materials", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT32, 0, 0, 0, HK_NULL },
		{ "materialIndices16", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT16, 0, 0, 0, HK_NULL }
	};
	hkClass hkpStorageMeshShapeSubpartStorageClass(
		"hkpStorageMeshShapeSubpartStorage",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpStorageMeshShape_SubpartStorageClass_Members),
		HK_COUNT_OF(hkpStorageMeshShape_SubpartStorageClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpStorageMeshShapeClass_Members[] =
	{
		{ "storage", &hkpStorageMeshShapeSubpartStorageClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL }
	};
	hkClass hkpStorageMeshShapeClass(
		"hkpStorageMeshShape",
		&hkpMeshShapeClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpStorageMeshShapeClass_Members),
		HK_COUNT_OF(hkpStorageMeshShapeClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpMultiRayShape_RayClass_Members[] =
	{
		{ "start", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "end", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpMultiRayShapeRayClass(
		"hkpMultiRayShapeRay",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpMultiRayShape_RayClass_Members),
		HK_COUNT_OF(hkpMultiRayShape_RayClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpMultiRayShapeClass_Members[] =
	{
		{ "rays", &hkpMultiRayShapeRayClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "rayPenetrationDistance", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpMultiRayShapeClass(
		"hkpMultiRayShape",
		&hkpShapeClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpMultiRayShapeClass_Members),
		HK_COUNT_OF(hkpMultiRayShapeClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkpCompressedMeshShapeMaterialTypeEnumItems[] =
	{
		{0, "MATERIAL_NONE"},
		{1, "MATERIAL_SINGLE_VALUE_PER_CHUNK"},
		{2, "MATERIAL_ONE_BYTE_PER_TRIANGLE"},
		{3, "MATERIAL_TWO_BYTES_PER_TRIANGLE"},
		{4, "MATERIAL_FOUR_BYTES_PER_TRIANGLE"},
	};
	static const hkInternalClassEnum hkpCompressedMeshShapeEnums[] = {
		{"MaterialType", hkpCompressedMeshShapeMaterialTypeEnumItems, 5, HK_NULL, 0 }
	};
	const hkClassEnum* hkpCompressedMeshShapeMaterialTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkpCompressedMeshShapeEnums[0]);
	static hkInternalClassMember hkpCompressedMeshShape_ChunkClass_Members[] =
	{
		{ "offset", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "vertices", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT16, 0, 0, 0, HK_NULL },
		{ "indices", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT16, 0, 0, 0, HK_NULL },
		{ "stripLengths", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT16, 0, 0, 0, HK_NULL },
		{ "weldingInfo", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT16, 0, 0, 0, HK_NULL },
		{ "materialInfo", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "reference", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "transformIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpCompressedMeshShapeChunkClass(
		"hkpCompressedMeshShapeChunk",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpCompressedMeshShape_ChunkClass_Members),
		HK_COUNT_OF(hkpCompressedMeshShape_ChunkClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(4)
		);
	static hkInternalClassMember hkpCompressedMeshShape_BigTriangleClass_Members[] =
	{
		{ "a", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "b", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "c", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "material", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "weldingInfo", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "transformIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkpCompressedMeshShapeBigTriangle_DefaultStruct
		{
			int s_defaultOffsets[6];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
		};
		const hkpCompressedMeshShapeBigTriangle_DefaultStruct hkpCompressedMeshShapeBigTriangle_Default =
		{
			{-1,-1,-1,-1,hkClassMember::HK_CLASS_ZERO_DEFAULT,-1},
		};
	}
	hkClass hkpCompressedMeshShapeBigTriangleClass(
		"hkpCompressedMeshShapeBigTriangle",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpCompressedMeshShape_BigTriangleClass_Members),
		HK_COUNT_OF(hkpCompressedMeshShape_BigTriangleClass_Members),
		&hkpCompressedMeshShapeBigTriangle_Default,
		HK_NULL,
		0,
		hkUint32(2)
		);
	static hkInternalClassMember hkpCompressedMeshShape_ConvexPieceClass_Members[] =
	{
		{ "offset", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "vertices", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT16, 0, 0, 0, HK_NULL },
		{ "reference", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "transformIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpCompressedMeshShapeConvexPieceClass(
		"hkpCompressedMeshShapeConvexPiece",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpCompressedMeshShape_ConvexPieceClass_Members),
		HK_COUNT_OF(hkpCompressedMeshShape_ConvexPieceClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(4)
		);
	static hkInternalClassMember hkpCompressedMeshShapeClass_Members[] =
	{
		{ "bitsPerIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "bitsPerWIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "wIndexMask", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "indexMask", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "radius", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "weldingType", HK_NULL, hkpWeldingUtilityWeldingTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "materialType", HK_NULL, hkpCompressedMeshShapeMaterialTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "materials", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT32, 0, 0, 0, HK_NULL },
		{ "materials16", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT16, 0, 0, 0, HK_NULL },
		{ "materials8", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "transforms", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_QSTRANSFORM, 0, 0, 0, HK_NULL },
		{ "bigVertices", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VECTOR4, 0, 0, 0, HK_NULL },
		{ "bigTriangles", &hkpCompressedMeshShapeBigTriangleClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "chunks", &hkpCompressedMeshShapeChunkClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "convexPieces", &hkpCompressedMeshShapeConvexPieceClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "error", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "bounds", &hkAabbClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "defaultCollisionFilterInfo", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "meshMaterials", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "materialStriding", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "numMaterials", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "namedMaterials", &hkpNamedMeshMaterialClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkpCompressedMeshShape_DefaultStruct
		{
			int s_defaultOffsets[22];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkUint8 /* hkEnum< enum hkpWeldingUtility::WeldingType, hkUint8 > */ m_weldingType;
		};
		const hkpCompressedMeshShape_DefaultStruct hkpCompressedMeshShape_Default =
		{
			{-1,-1,-1,-1,-1,HK_OFFSET_OF(hkpCompressedMeshShape_DefaultStruct,m_weldingType),-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,hkClassMember::HK_CLASS_ZERO_DEFAULT,-1,-1,-1},
			hkpWeldingUtility::WELDING_TYPE_NONE
		};
	}
	hkClass hkpCompressedMeshShapeClass(
		"hkpCompressedMeshShape",
		&hkpShapeCollectionClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkpCompressedMeshShapeEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkpCompressedMeshShapeClass_Members),
		HK_COUNT_OF(hkpCompressedMeshShapeClass_Members),
		&hkpCompressedMeshShape_Default,
		HK_NULL,
		0,
		hkUint32(11)
		);
	static hkInternalClassMember hkpLinkedCollidableClass_Members[] =
	{
		{ "collisionEntries", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hkpLinkedCollidableClass(
		"hkpLinkedCollidable",
		&hkpCollidableClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpLinkedCollidableClass_Members),
		HK_COUNT_OF(hkpLinkedCollidableClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpCollisionFilterListClass_Members[] =
	{
		{ "collisionFilters", &hkpCollisionFilterClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL }
	};
	hkClass hkpCollisionFilterListClass(
		"hkpCollisionFilterList",
		&hkpCollisionFilterClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpCollisionFilterListClass_Members),
		HK_COUNT_OF(hkpCollisionFilterListClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkMoppBvTreeShapeBaseClass_Members[] =
	{
		{ "code", &hkpMoppCodeClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "moppData", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "moppDataSize", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "codeInfoCopy", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hkMoppBvTreeShapeBaseClass(
		"hkMoppBvTreeShapeBase",
		&hkpBvTreeShapeClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkMoppBvTreeShapeBaseClass_Members),
		HK_COUNT_OF(hkMoppBvTreeShapeBaseClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpMoppBvTreeShapeClass_Members[] =
	{
		{ "child", &hkpSingleShapeContainerClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "childSize", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hkpMoppBvTreeShapeClass(
		"hkpMoppBvTreeShape",
		&hkMoppBvTreeShapeBaseClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpMoppBvTreeShapeClass_Members),
		HK_COUNT_OF(hkpMoppBvTreeShapeClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpTransformShapeClass_Members[] =
	{
		{ "childShape", &hkpSingleShapeContainerClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "childShapeSize", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "rotation", HK_NULL, HK_NULL, hkClassMember::TYPE_QUATERNION, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "transform", HK_NULL, HK_NULL, hkClassMember::TYPE_TRANSFORM, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpTransformShapeClass(
		"hkpTransformShape",
		&hkpShapeClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpTransformShapeClass_Members),
		HK_COUNT_OF(hkpTransformShapeClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpBoxShapeClass_Members[] =
	{
		{ "halfExtents", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpBoxShapeClass(
		"hkpBoxShape",
		&hkpConvexShapeClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpBoxShapeClass_Members),
		HK_COUNT_OF(hkpBoxShapeClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hkpCollidableCollidableFilterClass(
		"hkpCollidableCollidableFilter",
		HK_NULL,
		0,
		HK_NULL,
		1,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkpExtendedMeshShapeIndexStridingTypeEnumItems[] =
	{
		{0, "INDICES_INVALID"},
		{1, "INDICES_INT8"},
		{2, "INDICES_INT16"},
		{3, "INDICES_INT32"},
		{4, "INDICES_MAX_ID"},
	};
	static const hkInternalClassEnumItem hkpExtendedMeshShapeMaterialIndexStridingTypeEnumItems[] =
	{
		{0, "MATERIAL_INDICES_INVALID"},
		{1, "MATERIAL_INDICES_INT8"},
		{2, "MATERIAL_INDICES_INT16"},
		{3, "MATERIAL_INDICES_MAX_ID"},
	};
	static const hkInternalClassEnumItem hkpExtendedMeshShapeSubpartTypeEnumItems[] =
	{
		{0, "SUBPART_TRIANGLES"},
		{1, "SUBPART_SHAPE"},
		{2, "SUBPART_TYPE_MAX"},
	};
	static const hkInternalClassEnumItem hkpExtendedMeshShapeSubpartTypesAndFlagsEnumItems[] =
	{
		{1, "SUBPART_TYPE_MASK"},
		{6, "SUBPART_MATERIAL_INDICES_MASK"},
		{1, "SUBPART_MATERIAL_INDICES_SHIFT"},
		{65528, "SUBPART_NUM_MATERIALS_MASK"},
		{3, "SUBPART_NUM_MATERIALS_SHIFT"},
	};
	static const hkInternalClassEnum hkpExtendedMeshShapeEnums[] = {
		{"IndexStridingType", hkpExtendedMeshShapeIndexStridingTypeEnumItems, 5, HK_NULL, 0 },
		{"MaterialIndexStridingType", hkpExtendedMeshShapeMaterialIndexStridingTypeEnumItems, 4, HK_NULL, 0 },
		{"SubpartType", hkpExtendedMeshShapeSubpartTypeEnumItems, 3, HK_NULL, 0 },
		{"SubpartTypesAndFlags", hkpExtendedMeshShapeSubpartTypesAndFlagsEnumItems, 5, HK_NULL, 0 }
	};
	const hkClassEnum* hkpExtendedMeshShapeIndexStridingTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkpExtendedMeshShapeEnums[0]);
	const hkClassEnum* hkpExtendedMeshShapeMaterialIndexStridingTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkpExtendedMeshShapeEnums[1]);
	const hkClassEnum* hkpExtendedMeshShapeSubpartTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkpExtendedMeshShapeEnums[2]);
	const hkClassEnum* hkpExtendedMeshShapeSubpartTypesAndFlagsEnum = reinterpret_cast<const hkClassEnum*>(&hkpExtendedMeshShapeEnums[3]);
	static hkInternalClassMember hkpExtendedMeshShape_SubpartClass_Members[] =
	{
		{ "typeAndFlags", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "shapeInfo", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "materialStriding", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "materialIndexStriding", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "materialIndexBase", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "materialBase", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "userData", HK_NULL, HK_NULL, hkClassMember::TYPE_ULONG, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkpExtendedMeshShapeSubpart_DefaultStruct
		{
			int s_defaultOffsets[7];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
		};
		const hkpExtendedMeshShapeSubpart_DefaultStruct hkpExtendedMeshShapeSubpart_Default =
		{
			{-1,-1,-1,-1,-1,-1,hkClassMember::HK_CLASS_ZERO_DEFAULT},
		};
	}
	hkClass hkpExtendedMeshShapeSubpartClass(
		"hkpExtendedMeshShapeSubpart",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpExtendedMeshShape_SubpartClass_Members),
		HK_COUNT_OF(hkpExtendedMeshShape_SubpartClass_Members),
		&hkpExtendedMeshShapeSubpart_Default,
		HK_NULL,
		0,
		hkUint32(3)
		);
	static hkInternalClassMember hkpExtendedMeshShape_TrianglesSubpartClass_Members[] =
	{
		{ "numTriangleShapes", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "vertexBase", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "numVertices", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "indexBase", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "vertexStriding", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "triangleOffset", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "indexStriding", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "stridingType", HK_NULL, hkpExtendedMeshShapeIndexStridingTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL },
		{ "flipAlternateTriangles", HK_NULL, HK_NULL, hkClassMember::TYPE_INT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "extrusion", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "transform", HK_NULL, HK_NULL, hkClassMember::TYPE_QSTRANSFORM, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkpExtendedMeshShapeTrianglesSubpart_DefaultStruct
		{
			int s_defaultOffsets[11];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkInt32 m_triangleOffset;
		};
		const hkpExtendedMeshShapeTrianglesSubpart_DefaultStruct hkpExtendedMeshShapeTrianglesSubpart_Default =
		{
			{-1,-1,-1,-1,-1,HK_OFFSET_OF(hkpExtendedMeshShapeTrianglesSubpart_DefaultStruct,m_triangleOffset),-1,-1,-1,-1,-1},
			-1
		};
	}
	hkClass hkpExtendedMeshShapeTrianglesSubpartClass(
		"hkpExtendedMeshShapeTrianglesSubpart",
		&hkpExtendedMeshShapeSubpartClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpExtendedMeshShape_TrianglesSubpartClass_Members),
		HK_COUNT_OF(hkpExtendedMeshShape_TrianglesSubpartClass_Members),
		&hkpExtendedMeshShapeTrianglesSubpart_Default,
		HK_NULL,
		0,
		hkUint32(3)
		);
	static hkInternalClassMember hkpExtendedMeshShape_ShapesSubpartClass_Members[] =
	{
		{ "childShapes", &hkpConvexShapeClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "rotation", HK_NULL, HK_NULL, hkClassMember::TYPE_QUATERNION, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "translation", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpExtendedMeshShapeShapesSubpartClass(
		"hkpExtendedMeshShapeShapesSubpart",
		&hkpExtendedMeshShapeSubpartClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpExtendedMeshShape_ShapesSubpartClass_Members),
		HK_COUNT_OF(hkpExtendedMeshShape_ShapesSubpartClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkpExtendedMeshShapeClass_Members[] =
	{
		{ "embeddedTrianglesSubpart", &hkpExtendedMeshShapeTrianglesSubpartClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "aabbHalfExtents", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "aabbCenter", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "materialClass", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "numBitsForSubpartIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "trianglesSubparts", &hkpExtendedMeshShapeTrianglesSubpartClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "shapesSubparts", &hkpExtendedMeshShapeShapesSubpartClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "weldingInfo", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT16, 0, 0, 0, HK_NULL },
		{ "weldingType", HK_NULL, hkpWeldingUtilityWeldingTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "defaultCollisionFilterInfo", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "cachedNumChildShapes", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "triangleRadius", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "padding", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	namespace
	{
		struct hkpExtendedMeshShape_DefaultStruct
		{
			int s_defaultOffsets[13];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkUint8 /* hkEnum< enum hkpWeldingUtility::WeldingType, hkUint8 > */ m_weldingType;
			hkInt32 m_cachedNumChildShapes;
		};
		const hkpExtendedMeshShape_DefaultStruct hkpExtendedMeshShape_Default =
		{
			{-1,-1,-1,hkClassMember::HK_CLASS_ZERO_DEFAULT,-1,-1,-1,-1,HK_OFFSET_OF(hkpExtendedMeshShape_DefaultStruct,m_weldingType),-1,HK_OFFSET_OF(hkpExtendedMeshShape_DefaultStruct,m_cachedNumChildShapes),-1,-1},
			hkpWeldingUtility::WELDING_TYPE_NONE,-1
		};
	}
	hkClass hkpExtendedMeshShapeClass(
		"hkpExtendedMeshShape",
		&hkpShapeCollectionClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkpExtendedMeshShapeEnums),
		4,
		reinterpret_cast<const hkClassMember*>(hkpExtendedMeshShapeClass_Members),
		HK_COUNT_OF(hkpExtendedMeshShapeClass_Members),
		&hkpExtendedMeshShape_Default,
		HK_NULL,
		0,
		hkUint32(4)
		);
	static hkInternalClassMember hkpCdBodyClass_Members[] =
	{
		{ "shape", &hkpShapeClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "shapeKey", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "motion", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "parent", &hkpCdBodyClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hkpCdBodyClass(
		"hkpCdBody",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpCdBodyClass_Members),
		HK_COUNT_OF(hkpCdBodyClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkpConvexListShapeClass_Members[] =
	{
		{ "minDistanceToUseConvexHullForGetClosestPoints", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "aabbHalfExtents", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "aabbCenter", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "useCachedAabb", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "childShapes", &hkpConvexShapeClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkpConvexListShape_DefaultStruct
		{
			int s_defaultOffsets[5];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
		};
		const hkpConvexListShape_DefaultStruct hkpConvexListShape_Default =
		{
			{-1,-1,-1,hkClassMember::HK_CLASS_ZERO_DEFAULT,-1},
		};
	}
	hkClass hkpConvexListShapeClass(
		"hkpConvexListShape",
		&hkpConvexShapeClass,
		0,
		HK_NULL,
		1,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpConvexListShapeClass_Members),
		HK_COUNT_OF(hkpConvexListShapeClass_Members),
		&hkpConvexListShape_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hkpNullCollisionFilterClass(
		"hkpNullCollisionFilter",
		&hkpCollisionFilterClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpMultiSphereShapeClass_Members[] =
	{
		{ "numSpheres", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "spheres", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 8, 0, 0, HK_NULL }
	};
	hkClass hkpMultiSphereShapeClass(
		"hkpMultiSphereShape",
		&hkpSphereRepShapeClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpMultiSphereShapeClass_Members),
		HK_COUNT_OF(hkpMultiSphereShapeClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hkpSphereRepShapeClass(
		"hkpSphereRepShape",
		&hkpShapeClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkpListShapeListShapeFlagsEnumItems[] =
	{
		{0, "ALL_FLAGS_CLEAR"},
		{1, "DISABLE_SPU_CACHE_FOR_LIST_CHILD_INFO"},
	};
	static const hkInternalClassEnum hkpListShapeEnums[] = {
		{"ListShapeFlags", hkpListShapeListShapeFlagsEnumItems, 2, HK_NULL, 0 }
	};
	const hkClassEnum* hkpListShapeListShapeFlagsEnum = reinterpret_cast<const hkClassEnum*>(&hkpListShapeEnums[0]);
	static hkInternalClassMember hkpListShape_ChildInfoClass_Members[] =
	{
		{ "shape", &hkpShapeClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0|hkClassMember::ALIGN_16, 0, HK_NULL },
		{ "collisionFilterInfo", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "shapeInfo", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "shapeSize", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "numChildShapes", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hkpListShapeChildInfoClass(
		"hkpListShapeChildInfo",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpListShape_ChildInfoClass_Members),
		HK_COUNT_OF(hkpListShape_ChildInfoClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkpListShapeClass_Members[] =
	{
		{ "childInfo", &hkpListShapeChildInfoClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "flags", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "numDisabledChildren", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "aabbHalfExtents", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "aabbCenter", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "enabledChildren", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 8, 0, 0, HK_NULL }
	};
	hkClass hkpListShapeClass(
		"hkpListShape",
		&hkpShapeCollectionClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkpListShapeEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkpListShapeClass_Members),
		HK_COUNT_OF(hkpListShapeClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpAgent1nSectorClass_Members[] =
	{
		{ "bytesAllocated", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "pad0", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "pad1", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "pad2", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "data", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 496, 0, 0, HK_NULL }
	};
	hkClass hkpAgent1nSectorClass(
		"hkpAgent1nSector",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpAgent1nSectorClass_Members),
		HK_COUNT_OF(hkpAgent1nSectorClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpTypedBroadPhaseHandleClass_Members[] =
	{
		{ "type", HK_NULL, HK_NULL, hkClassMember::TYPE_INT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "ownerOffset", HK_NULL, HK_NULL, hkClassMember::TYPE_INT8, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "objectQualityType", HK_NULL, HK_NULL, hkClassMember::TYPE_INT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "collisionFilterInfo", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpTypedBroadPhaseHandleClass(
		"hkpTypedBroadPhaseHandle",
		&hkpBroadPhaseHandleClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpTypedBroadPhaseHandleClass_Members),
		HK_COUNT_OF(hkpTypedBroadPhaseHandleClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpShapeClass_Members[] =
	{
		{ "userData", HK_NULL, HK_NULL, hkClassMember::TYPE_ULONG, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "type", HK_NULL, HK_NULL, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT32, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hkpShapeClass(
		"hkpShape",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpShapeClass_Members),
		HK_COUNT_OF(hkpShapeClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hkpShapeCollectionFilterClass(
		"hkpShapeCollectionFilter",
		HK_NULL,
		0,
		HK_NULL,
		1,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkpShapeCollectionCollectionTypeEnumItems[] =
	{
		{0, "COLLECTION_LIST"},
		{1, "COLLECTION_EXTENDED_MESH"},
		{2, "COLLECTION_TRISAMPLED_HEIGHTFIELD"},
		{3, "COLLECTION_USER"},
		{4, "COLLECTION_SIMPLE_MESH"},
		{5, "COLLECTION_MESH_SHAPE"},
		{6, "COLLECTION_COMPRESSED_MESH"},
		{7, "COLLECTION_MAX"},
	};
	static const hkInternalClassEnum hkpShapeCollectionEnums[] = {
		{"CollectionType", hkpShapeCollectionCollectionTypeEnumItems, 8, HK_NULL, 0 }
	};
	const hkClassEnum* hkpShapeCollectionCollectionTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkpShapeCollectionEnums[0]);
	static hkInternalClassMember hkpShapeCollectionClass_Members[] =
	{
		{ "disableWelding", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "collectionType", HK_NULL, hkpShapeCollectionCollectionTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkpShapeCollection_DefaultStruct
		{
			int s_defaultOffsets[2];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkUint8 /* hkEnum< enum hkpShapeCollection::CollectionType, hkUint8 > */ m_collectionType;
		};
		const hkpShapeCollection_DefaultStruct hkpShapeCollection_Default =
		{
			{-1,HK_OFFSET_OF(hkpShapeCollection_DefaultStruct,m_collectionType)},
			hkpShapeCollection::COLLECTION_USER
		};
	}
	hkClass hkpShapeCollectionClass(
		"hkpShapeCollection",
		&hkpShapeClass,
		0,
		HK_NULL,
		1,
		reinterpret_cast<const hkClassEnum*>(hkpShapeCollectionEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkpShapeCollectionClass_Members),
		HK_COUNT_OF(hkpShapeCollectionClass_Members),
		&hkpShapeCollection_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkpSampledHeightFieldShapeHeightFieldTypeEnumItems[] =
	{
		{0, "HEIGHTFIELD_STORAGE"},
		{1, "HEIGHTFIELD_COMPRESSED"},
		{2, "HEIGHTFIELD_USER"},
		{3, "HEIGHTFIELD_MAX_ID"},
	};
	static const hkInternalClassEnum hkpSampledHeightFieldShapeEnums[] = {
		{"HeightFieldType", hkpSampledHeightFieldShapeHeightFieldTypeEnumItems, 4, HK_NULL, 0 }
	};
	const hkClassEnum* hkpSampledHeightFieldShapeHeightFieldTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkpSampledHeightFieldShapeEnums[0]);
	static hkInternalClassMember hkpSampledHeightFieldShape_CoarseMinMaxLevelClass_Members[] =
	{
		{ "minMaxData", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VECTOR4, 0, 0, 0, HK_NULL },
		{ "xRes", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "zRes", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpSampledHeightFieldShapeCoarseMinMaxLevelClass(
		"hkpSampledHeightFieldShapeCoarseMinMaxLevel",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpSampledHeightFieldShape_CoarseMinMaxLevelClass_Members),
		HK_COUNT_OF(hkpSampledHeightFieldShape_CoarseMinMaxLevelClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpSampledHeightFieldShapeClass_Members[] =
	{
		{ "coarseTreeData", &hkpSampledHeightFieldShapeCoarseMinMaxLevelClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "coarseness", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "raycastMinY", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "raycastMaxY", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "xRes", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "zRes", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "heightCenter", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "useProjectionBasedHeight", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "heightfieldType", HK_NULL, hkpSampledHeightFieldShapeHeightFieldTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "intToFloatScale", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "floatToIntScale", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "floatToIntOffsetFloorCorrected", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "extents", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkpSampledHeightFieldShape_DefaultStruct
		{
			int s_defaultOffsets[13];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkUint8 /* hkEnum< enum hkpSampledHeightFieldShape::HeightFieldType, hkUint8 > */ m_heightfieldType;
		};
		const hkpSampledHeightFieldShape_DefaultStruct hkpSampledHeightFieldShape_Default =
		{
			{-1,-1,-1,-1,-1,-1,-1,-1,HK_OFFSET_OF(hkpSampledHeightFieldShape_DefaultStruct,m_heightfieldType),-1,-1,-1,-1},
			hkpSampledHeightFieldShape::HEIGHTFIELD_USER
		};
	}
	hkClass hkpSampledHeightFieldShapeClass(
		"hkpSampledHeightFieldShape",
		&hkpHeightFieldShapeClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkpSampledHeightFieldShapeEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkpSampledHeightFieldShapeClass_Members),
		HK_COUNT_OF(hkpSampledHeightFieldShapeClass_Members),
		&hkpSampledHeightFieldShape_Default,
		HK_NULL,
		0,
		hkUint32(1)
		);
	hkClass hkpFastMeshShapeClass(
		"hkpFastMeshShape",
		&hkpMeshShapeClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpTriSampledHeightFieldBvTreeShapeClass_Members[] =
	{
		{ "childContainer", &hkpSingleShapeContainerClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "childSize", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "wantAabbRejectionTest", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "padding", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 12, 0, 0, HK_NULL }
	};
	hkClass hkpTriSampledHeightFieldBvTreeShapeClass(
		"hkpTriSampledHeightFieldBvTreeShape",
		&hkpBvTreeShapeClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpTriSampledHeightFieldBvTreeShapeClass_Members),
		HK_COUNT_OF(hkpTriSampledHeightFieldBvTreeShapeClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpStorageExtendedMeshShape_MaterialClass_Members[] =
	{
		{ "restitution", HK_NULL, HK_NULL, hkClassMember::TYPE_HALF, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "friction", HK_NULL, HK_NULL, hkClassMember::TYPE_HALF, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "userData", HK_NULL, HK_NULL, hkClassMember::TYPE_ULONG, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpStorageExtendedMeshShapeMaterialClass(
		"hkpStorageExtendedMeshShapeMaterial",
		&hkpMeshMaterialClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpStorageExtendedMeshShape_MaterialClass_Members),
		HK_COUNT_OF(hkpStorageExtendedMeshShape_MaterialClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkpStorageExtendedMeshShape_MeshSubpartStorageClass_Members[] =
	{
		{ "vertices", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VECTOR4, 0, 0, 0, HK_NULL },
		{ "indices8", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "indices16", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT16, 0, 0, 0, HK_NULL },
		{ "indices32", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT32, 0, 0, 0, HK_NULL },
		{ "materialIndices", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "materials", &hkpStorageExtendedMeshShapeMaterialClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "namedMaterials", &hkpNamedMeshMaterialClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "materialIndices16", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT16, 0, 0, 0, HK_NULL }
	};
	hkClass hkpStorageExtendedMeshShapeMeshSubpartStorageClass(
		"hkpStorageExtendedMeshShapeMeshSubpartStorage",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpStorageExtendedMeshShape_MeshSubpartStorageClass_Members),
		HK_COUNT_OF(hkpStorageExtendedMeshShape_MeshSubpartStorageClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(3)
		);
	static hkInternalClassMember hkpStorageExtendedMeshShape_ShapeSubpartStorageClass_Members[] =
	{
		{ "materialIndices", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "materials", &hkpStorageExtendedMeshShapeMaterialClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "materialIndices16", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT16, 0, 0, 0, HK_NULL }
	};
	hkClass hkpStorageExtendedMeshShapeShapeSubpartStorageClass(
		"hkpStorageExtendedMeshShapeShapeSubpartStorage",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpStorageExtendedMeshShape_ShapeSubpartStorageClass_Members),
		HK_COUNT_OF(hkpStorageExtendedMeshShape_ShapeSubpartStorageClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(2)
		);
	static hkInternalClassMember hkpStorageExtendedMeshShapeClass_Members[] =
	{
		{ "meshstorage", &hkpStorageExtendedMeshShapeMeshSubpartStorageClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "shapestorage", &hkpStorageExtendedMeshShapeShapeSubpartStorageClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL }
	};
	hkClass hkpStorageExtendedMeshShapeClass(
		"hkpStorageExtendedMeshShape",
		&hkpExtendedMeshShapeClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpStorageExtendedMeshShapeClass_Members),
		HK_COUNT_OF(hkpStorageExtendedMeshShapeClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpGroupFilterClass_Members[] =
	{
		{ "nextFreeSystemGroup", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "collisionLookupTable", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 32, 0, 0, HK_NULL },
		{ "pad256", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 4, 0, 0, HK_NULL }
	};
	hkClass hkpGroupFilterClass(
		"hkpGroupFilter",
		&hkpCollisionFilterClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpGroupFilterClass_Members),
		HK_COUNT_OF(hkpGroupFilterClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpSimpleMeshShape_TriangleClass_Members[] =
	{
		{ "a", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "b", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "c", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "weldingInfo", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkpSimpleMeshShapeTriangle_DefaultStruct
		{
			int s_defaultOffsets[4];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
		};
		const hkpSimpleMeshShapeTriangle_DefaultStruct hkpSimpleMeshShapeTriangle_Default =
		{
			{-1,-1,-1,hkClassMember::HK_CLASS_ZERO_DEFAULT},
		};
	}
	hkClass hkpSimpleMeshShapeTriangleClass(
		"hkpSimpleMeshShapeTriangle",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpSimpleMeshShape_TriangleClass_Members),
		HK_COUNT_OF(hkpSimpleMeshShape_TriangleClass_Members),
		&hkpSimpleMeshShapeTriangle_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpSimpleMeshShapeClass_Members[] =
	{
		{ "vertices", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VECTOR4, 0, 0, 0, HK_NULL },
		{ "triangles", &hkpSimpleMeshShapeTriangleClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "materialIndices", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "radius", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "weldingType", HK_NULL, hkpWeldingUtilityWeldingTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkpSimpleMeshShape_DefaultStruct
		{
			int s_defaultOffsets[5];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkUint8 /* hkEnum< enum hkpWeldingUtility::WeldingType, hkUint8 > */ m_weldingType;
		};
		const hkpSimpleMeshShape_DefaultStruct hkpSimpleMeshShape_Default =
		{
			{-1,-1,-1,-1,HK_OFFSET_OF(hkpSimpleMeshShape_DefaultStruct,m_weldingType)},
			hkpWeldingUtility::WELDING_TYPE_NONE
		};
	}
	hkClass hkpSimpleMeshShapeClass(
		"hkpSimpleMeshShape",
		&hkpShapeCollectionClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpSimpleMeshShapeClass_Members),
		HK_COUNT_OF(hkpSimpleMeshShapeClass_Members),
		&hkpSimpleMeshShape_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpTriSampledHeightFieldCollectionClass_Members[] =
	{
		{ "heightfield", &hkpSampledHeightFieldShapeClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "childSize", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "radius", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "weldingInfo", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT16, 0, 0, 0, HK_NULL },
		{ "triangleExtrusion", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpTriSampledHeightFieldCollectionClass(
		"hkpTriSampledHeightFieldCollection",
		&hkpShapeCollectionClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpTriSampledHeightFieldCollectionClass_Members),
		HK_COUNT_OF(hkpTriSampledHeightFieldCollectionClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkpConvexShapeWeldResultEnumItems[] =
	{
		{0, "WELD_RESULT_REJECT_CONTACT_POINT"},
		{1, "WELD_RESULT_ACCEPT_CONTACT_POINT_MODIFIED"},
		{2, "WELD_RESULT_ACCEPT_CONTACT_POINT_UNMODIFIED"},
	};
	static const hkInternalClassEnum hkpConvexShapeEnums[] = {
		{"WeldResult", hkpConvexShapeWeldResultEnumItems, 3, HK_NULL, 0 }
	};
	const hkClassEnum* hkpConvexShapeWeldResultEnum = reinterpret_cast<const hkClassEnum*>(&hkpConvexShapeEnums[0]);
	static hkInternalClassMember hkpConvexShapeClass_Members[] =
	{
		{ "radius", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpConvexShapeClass(
		"hkpConvexShape",
		&hkpSphereRepShapeClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkpConvexShapeEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkpConvexShapeClass_Members),
		HK_COUNT_OF(hkpConvexShapeClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpConvexTransformShapeBaseClass_Members[] =
	{
		{ "childShape", &hkpSingleShapeContainerClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "childShapeSize", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hkpConvexTransformShapeBaseClass(
		"hkpConvexTransformShapeBase",
		&hkpConvexShapeClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpConvexTransformShapeBaseClass_Members),
		HK_COUNT_OF(hkpConvexTransformShapeBaseClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkpConvexListFilterConvexListCollisionTypeEnumItems[] =
	{
		{0, "TREAT_CONVEX_LIST_AS_NORMAL"},
		{1, "TREAT_CONVEX_LIST_AS_LIST"},
		{2, "TREAT_CONVEX_LIST_AS_CONVEX"},
	};
	static const hkInternalClassEnum hkpConvexListFilterEnums[] = {
		{"ConvexListCollisionType", hkpConvexListFilterConvexListCollisionTypeEnumItems, 3, HK_NULL, 0 }
	};
	const hkClassEnum* hkpConvexListFilterConvexListCollisionTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkpConvexListFilterEnums[0]);
	hkClass hkpConvexListFilterClass(
		"hkpConvexListFilter",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkpConvexListFilterEnums),
		1,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkpCapsuleShapeRayHitTypeEnumItems[] =
	{
		{0, "HIT_CAP0"},
		{1, "HIT_CAP1"},
		{2, "HIT_BODY"},
	};
	static const hkInternalClassEnum hkpCapsuleShapeEnums[] = {
		{"RayHitType", hkpCapsuleShapeRayHitTypeEnumItems, 3, HK_NULL, 0 }
	};
	const hkClassEnum* hkpCapsuleShapeRayHitTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkpCapsuleShapeEnums[0]);
	static hkInternalClassMember hkpCapsuleShapeClass_Members[] =
	{
		{ "vertexA", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "vertexB", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpCapsuleShapeClass(
		"hkpCapsuleShape",
		&hkpConvexShapeClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkpCapsuleShapeEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkpCapsuleShapeClass_Members),
		HK_COUNT_OF(hkpCapsuleShapeClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hkpRayShapeCollectionFilterClass(
		"hkpRayShapeCollectionFilter",
		HK_NULL,
		0,
		HK_NULL,
		1,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpConvexPieceMeshShapeClass_Members[] =
	{
		{ "convexPieceStream", &hkpConvexPieceStreamDataClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "displayMesh", &hkpShapeCollectionClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "radius", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpConvexPieceMeshShapeClass(
		"hkpConvexPieceMeshShape",
		&hkpShapeCollectionClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpConvexPieceMeshShapeClass_Members),
		HK_COUNT_OF(hkpConvexPieceMeshShapeClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpSphereShapeClass_Members[] =
	{
		{ "pad16", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 3, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hkpSphereShapeClass(
		"hkpSphereShape",
		&hkpConvexShapeClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpSphereShapeClass_Members),
		HK_COUNT_OF(hkpSphereShapeClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpMeshMaterialClass_Members[] =
	{
		{ "filterInfo", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpMeshMaterialClass(
		"hkpMeshMaterial",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpMeshMaterialClass_Members),
		HK_COUNT_OF(hkpMeshMaterialClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpRemoveTerminalsMoppModifierClass_Members[] =
	{
		{ "removeInfo", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT32, 0, 0, 0, HK_NULL },
		{ "tempShapesToRemove", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hkpRemoveTerminalsMoppModifierClass(
		"hkpRemoveTerminalsMoppModifier",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		1,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpRemoveTerminalsMoppModifierClass_Members),
		HK_COUNT_OF(hkpRemoveTerminalsMoppModifierClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpConvexTranslateShapeClass_Members[] =
	{
		{ "translation", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpConvexTranslateShapeClass(
		"hkpConvexTranslateShape",
		&hkpConvexTransformShapeBaseClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpConvexTranslateShapeClass_Members),
		HK_COUNT_OF(hkpConvexTranslateShapeClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpBridgeConstraintAtomClass_Members[] =
	{
		{ "buildJacobianFunc", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "constraintData", &hkpConstraintDataClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0|hkClassMember::NOT_OWNED, 0, HK_NULL }
	};
	hkClass hkpBridgeConstraintAtomClass(
		"hkpBridgeConstraintAtom",
		&hkpConstraintAtomClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpBridgeConstraintAtomClass_Members),
		HK_COUNT_OF(hkpBridgeConstraintAtomClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpBridgeAtomsClass_Members[] =
	{
		{ "bridgeAtom", &hkpBridgeConstraintAtomClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpBridgeAtomsClass(
		"hkpBridgeAtoms",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpBridgeAtomsClass_Members),
		HK_COUNT_OF(hkpBridgeAtomsClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpSimpleContactConstraintAtomClass_Members[] =
	{
		{ "sizeOfAllAtoms", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "numContactPoints", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "numReservedContactPoints", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "numUserDatasForBodyA", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "numUserDatasForBodyB", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "contactPointPropertiesStriding", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxNumContactPoints", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "info", &hkpSimpleContactConstraintDataInfoClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::ALIGN_16, 0, HK_NULL }
	};
	hkClass hkpSimpleContactConstraintAtomClass(
		"hkpSimpleContactConstraintAtom",
		&hkpConstraintAtomClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpSimpleContactConstraintAtomClass_Members),
		HK_COUNT_OF(hkpSimpleContactConstraintAtomClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpSoftContactModifierConstraintAtomClass_Members[] =
	{
		{ "tau", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxAcceleration", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpSoftContactModifierConstraintAtomClass(
		"hkpSoftContactModifierConstraintAtom",
		&hkpModifierConstraintAtomClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpSoftContactModifierConstraintAtomClass_Members),
		HK_COUNT_OF(hkpSoftContactModifierConstraintAtomClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hkpViscousSurfaceModifierConstraintAtomClass(
		"hkpViscousSurfaceModifierConstraintAtom",
		&hkpModifierConstraintAtomClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpMovingSurfaceModifierConstraintAtomClass_Members[] =
	{
		{ "velocity", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpMovingSurfaceModifierConstraintAtomClass(
		"hkpMovingSurfaceModifierConstraintAtom",
		&hkpModifierConstraintAtomClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpMovingSurfaceModifierConstraintAtomClass_Members),
		HK_COUNT_OF(hkpMovingSurfaceModifierConstraintAtomClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hkpIgnoreModifierConstraintAtomClass(
		"hkpIgnoreModifierConstraintAtom",
		&hkpModifierConstraintAtomClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpSimpleContactConstraintDataInfoClass_Members[] =
	{
		{ "flags", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::ALIGN_16, 0, HK_NULL },
		{ "biNormalAxis", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "rollingFrictionMultiplier", HK_NULL, HK_NULL, hkClassMember::TYPE_HALF, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "internalData1", HK_NULL, HK_NULL, hkClassMember::TYPE_HALF, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "rhsRolling", HK_NULL, HK_NULL, hkClassMember::TYPE_HALF, hkClassMember::TYPE_VOID, 2, 0, 0, HK_NULL },
		{ "contactRadius", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "data", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 4, 0, 0, HK_NULL }
	};
	hkClass hkpSimpleContactConstraintDataInfoClass(
		"hkpSimpleContactConstraintDataInfo",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpSimpleContactConstraintDataInfoClass_Members),
		HK_COUNT_OF(hkpSimpleContactConstraintDataInfoClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(2)
		);
	static const hkInternalClassEnumItem hkpConstraintAtomAtomTypeEnumItems[] =
	{
		{0, "TYPE_INVALID"},
		{1, "TYPE_BRIDGE"},
		{2, "TYPE_SET_LOCAL_TRANSFORMS"},
		{3, "TYPE_SET_LOCAL_TRANSLATIONS"},
		{4, "TYPE_SET_LOCAL_ROTATIONS"},
		{5, "TYPE_BALL_SOCKET"},
		{6, "TYPE_STIFF_SPRING"},
		{7, "TYPE_LIN"},
		{8, "TYPE_LIN_SOFT"},
		{9, "TYPE_LIN_LIMIT"},
		{10, "TYPE_LIN_FRICTION"},
		{11, "TYPE_LIN_MOTOR"},
		{12, "TYPE_2D_ANG"},
		{13, "TYPE_ANG"},
		{14, "TYPE_ANG_LIMIT"},
		{15, "TYPE_TWIST_LIMIT"},
		{16, "TYPE_CONE_LIMIT"},
		{17, "TYPE_ANG_FRICTION"},
		{18, "TYPE_ANG_MOTOR"},
		{19, "TYPE_RAGDOLL_MOTOR"},
		{20, "TYPE_PULLEY"},
		{21, "TYPE_RACK_AND_PINION"},
		{22, "TYPE_COG_WHEEL"},
		{23, "TYPE_SETUP_STABILIZATION"},
		{24, "TYPE_OVERWRITE_PIVOT"},
		{25, "TYPE_CONTACT"},
		{26, "TYPE_MODIFIER_SOFT_CONTACT"},
		{27, "TYPE_MODIFIER_MASS_CHANGER"},
		{28, "TYPE_MODIFIER_VISCOUS_SURFACE"},
		{29, "TYPE_MODIFIER_MOVING_SURFACE"},
		{30, "TYPE_MODIFIER_IGNORE_CONSTRAINT"},
		{31, "TYPE_MODIFIER_CENTER_OF_MASS_CHANGER"},
		{32, "TYPE_MAX"},
	};
	static const hkInternalClassEnumItem hkpConstraintAtomCallbackRequestEnumItems[] =
	{
		{0, "CALLBACK_REQUEST_NONE"},
		{1, "CALLBACK_REQUEST_NEW_CONTACT_POINT"},
		{2, "CALLBACK_REQUEST_SETUP_PPU_ONLY"},
		{4, "CALLBACK_REQUEST_SETUP_CALLBACK"},
		{8, "CALLBACK_REQUEST_CONTACT_POINT_CALLBACK"},
	};
	static const hkInternalClassEnumItem hkpConstraintAtomSolvingMethodEnumItems[] =
	{
		{0, "METHOD_STABILIZED"},
		{1, "METHOD_OLD"},
	};
	static const hkInternalClassEnum hkpConstraintAtomEnums[] = {
		{"AtomType", hkpConstraintAtomAtomTypeEnumItems, 33, HK_NULL, 0 },
		{"CallbackRequest", hkpConstraintAtomCallbackRequestEnumItems, 5, HK_NULL, 0 },
		{"SolvingMethod", hkpConstraintAtomSolvingMethodEnumItems, 2, HK_NULL, 0 }
	};
	const hkClassEnum* hkpConstraintAtomAtomTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkpConstraintAtomEnums[0]);
	const hkClassEnum* hkpConstraintAtomCallbackRequestEnum = reinterpret_cast<const hkClassEnum*>(&hkpConstraintAtomEnums[1]);
	const hkClassEnum* hkpConstraintAtomSolvingMethodEnum = reinterpret_cast<const hkClassEnum*>(&hkpConstraintAtomEnums[2]);
	static hkInternalClassMember hkpConstraintAtomClass_Members[] =
	{
		{ "type", HK_NULL, hkpConstraintAtomAtomTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT16, 0, 0, 0, HK_NULL }
	};
	hkClass hkpConstraintAtomClass(
		"hkpConstraintAtom",
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkpConstraintAtomEnums),
		3,
		reinterpret_cast<const hkClassMember*>(hkpConstraintAtomClass_Members),
		HK_COUNT_OF(hkpConstraintAtomClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpSetupStabilizationAtomClass_Members[] =
	{
		{ "enabled", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "padding", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 8, 0, 0, HK_NULL },
		{ "maxAngle", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkpSetupStabilizationAtom_DefaultStruct
		{
			int s_defaultOffsets[3];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkReal m_maxAngle;
		};
		const hkpSetupStabilizationAtom_DefaultStruct hkpSetupStabilizationAtom_Default =
		{
			{hkClassMember::HK_CLASS_ZERO_DEFAULT,-1,HK_OFFSET_OF(hkpSetupStabilizationAtom_DefaultStruct,m_maxAngle)},
			HK_REAL_HIGH
		};
	}
	hkClass hkpSetupStabilizationAtomClass(
		"hkpSetupStabilizationAtom",
		&hkpConstraintAtomClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpSetupStabilizationAtomClass_Members),
		HK_COUNT_OF(hkpSetupStabilizationAtomClass_Members),
		&hkpSetupStabilizationAtom_Default,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkpBallSocketConstraintAtomClass_Members[] =
	{
		{ "solvingMethod", HK_NULL, hkpConstraintAtomSolvingMethodEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "bodiesToNotify", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "velocityStabilizationFactor", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxImpulse", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "inertiaStabilizationFactor", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkpBallSocketConstraintAtom_DefaultStruct
		{
			int s_defaultOffsets[5];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkUint8 /* hkEnum< enum hkpConstraintAtom::SolvingMethod, hkUint8 > */ m_solvingMethod;
			hkUFloat8 m_velocityStabilizationFactor;
			hkReal m_maxImpulse;
		};
		const hkpBallSocketConstraintAtom_DefaultStruct hkpBallSocketConstraintAtom_Default =
		{
			{HK_OFFSET_OF(hkpBallSocketConstraintAtom_DefaultStruct,m_solvingMethod),hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkpBallSocketConstraintAtom_DefaultStruct,m_velocityStabilizationFactor),HK_OFFSET_OF(hkpBallSocketConstraintAtom_DefaultStruct,m_maxImpulse),hkClassMember::HK_CLASS_ZERO_DEFAULT},
			hkpConstraintAtom::METHOD_OLD,1.0f,1e38f
		};
	}
	hkClass hkpBallSocketConstraintAtomClass(
		"hkpBallSocketConstraintAtom",
		&hkpConstraintAtomClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpBallSocketConstraintAtomClass_Members),
		HK_COUNT_OF(hkpBallSocketConstraintAtomClass_Members),
		&hkpBallSocketConstraintAtom_Default,
		HK_NULL,
		0,
		hkUint32(3)
		);
	static hkInternalClassMember hkpStiffSpringConstraintAtomClass_Members[] =
	{
		{ "length", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpStiffSpringConstraintAtomClass(
		"hkpStiffSpringConstraintAtom",
		&hkpConstraintAtomClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpStiffSpringConstraintAtomClass_Members),
		HK_COUNT_OF(hkpStiffSpringConstraintAtomClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpSetLocalTransformsConstraintAtomClass_Members[] =
	{
		{ "transformA", HK_NULL, HK_NULL, hkClassMember::TYPE_TRANSFORM, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "transformB", HK_NULL, HK_NULL, hkClassMember::TYPE_TRANSFORM, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpSetLocalTransformsConstraintAtomClass(
		"hkpSetLocalTransformsConstraintAtom",
		&hkpConstraintAtomClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpSetLocalTransformsConstraintAtomClass_Members),
		HK_COUNT_OF(hkpSetLocalTransformsConstraintAtomClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpSetLocalTranslationsConstraintAtomClass_Members[] =
	{
		{ "translationA", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "translationB", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpSetLocalTranslationsConstraintAtomClass(
		"hkpSetLocalTranslationsConstraintAtom",
		&hkpConstraintAtomClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpSetLocalTranslationsConstraintAtomClass_Members),
		HK_COUNT_OF(hkpSetLocalTranslationsConstraintAtomClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpSetLocalRotationsConstraintAtomClass_Members[] =
	{
		{ "rotationA", HK_NULL, HK_NULL, hkClassMember::TYPE_ROTATION, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "rotationB", HK_NULL, HK_NULL, hkClassMember::TYPE_ROTATION, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpSetLocalRotationsConstraintAtomClass(
		"hkpSetLocalRotationsConstraintAtom",
		&hkpConstraintAtomClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpSetLocalRotationsConstraintAtomClass_Members),
		HK_COUNT_OF(hkpSetLocalRotationsConstraintAtomClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpOverwritePivotConstraintAtomClass_Members[] =
	{
		{ "copyToPivotBFromPivotA", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpOverwritePivotConstraintAtomClass(
		"hkpOverwritePivotConstraintAtom",
		&hkpConstraintAtomClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpOverwritePivotConstraintAtomClass_Members),
		HK_COUNT_OF(hkpOverwritePivotConstraintAtomClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpLinConstraintAtomClass_Members[] =
	{
		{ "axisIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpLinConstraintAtomClass(
		"hkpLinConstraintAtom",
		&hkpConstraintAtomClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpLinConstraintAtomClass_Members),
		HK_COUNT_OF(hkpLinConstraintAtomClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpLinSoftConstraintAtomClass_Members[] =
	{
		{ "axisIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "tau", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "damping", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpLinSoftConstraintAtomClass(
		"hkpLinSoftConstraintAtom",
		&hkpConstraintAtomClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpLinSoftConstraintAtomClass_Members),
		HK_COUNT_OF(hkpLinSoftConstraintAtomClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpLinLimitConstraintAtomClass_Members[] =
	{
		{ "axisIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "min", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "max", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpLinLimitConstraintAtomClass(
		"hkpLinLimitConstraintAtom",
		&hkpConstraintAtomClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpLinLimitConstraintAtomClass_Members),
		HK_COUNT_OF(hkpLinLimitConstraintAtomClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkp2dAngConstraintAtomClass_Members[] =
	{
		{ "freeRotationAxis", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkp2dAngConstraintAtomClass(
		"hkp2dAngConstraintAtom",
		&hkpConstraintAtomClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkp2dAngConstraintAtomClass_Members),
		HK_COUNT_OF(hkp2dAngConstraintAtomClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpAngConstraintAtomClass_Members[] =
	{
		{ "firstConstrainedAxis", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "numConstrainedAxes", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpAngConstraintAtomClass(
		"hkpAngConstraintAtom",
		&hkpConstraintAtomClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpAngConstraintAtomClass_Members),
		HK_COUNT_OF(hkpAngConstraintAtomClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpAngLimitConstraintAtomClass_Members[] =
	{
		{ "isEnabled", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "limitAxis", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "minAngle", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxAngle", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "angularLimitsTauFactor", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkpAngLimitConstraintAtom_DefaultStruct
		{
			int s_defaultOffsets[5];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkReal m_angularLimitsTauFactor;
		};
		const hkpAngLimitConstraintAtom_DefaultStruct hkpAngLimitConstraintAtom_Default =
		{
			{-1,-1,-1,-1,HK_OFFSET_OF(hkpAngLimitConstraintAtom_DefaultStruct,m_angularLimitsTauFactor)},
			1.0
		};
	}
	hkClass hkpAngLimitConstraintAtomClass(
		"hkpAngLimitConstraintAtom",
		&hkpConstraintAtomClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpAngLimitConstraintAtomClass_Members),
		HK_COUNT_OF(hkpAngLimitConstraintAtomClass_Members),
		&hkpAngLimitConstraintAtom_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpTwistLimitConstraintAtomClass_Members[] =
	{
		{ "isEnabled", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "twistAxis", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "refAxis", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "minAngle", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxAngle", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "angularLimitsTauFactor", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkpTwistLimitConstraintAtom_DefaultStruct
		{
			int s_defaultOffsets[6];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkReal m_angularLimitsTauFactor;
		};
		const hkpTwistLimitConstraintAtom_DefaultStruct hkpTwistLimitConstraintAtom_Default =
		{
			{-1,-1,-1,-1,-1,HK_OFFSET_OF(hkpTwistLimitConstraintAtom_DefaultStruct,m_angularLimitsTauFactor)},
			1.0
		};
	}
	hkClass hkpTwistLimitConstraintAtomClass(
		"hkpTwistLimitConstraintAtom",
		&hkpConstraintAtomClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpTwistLimitConstraintAtomClass_Members),
		HK_COUNT_OF(hkpTwistLimitConstraintAtomClass_Members),
		&hkpTwistLimitConstraintAtom_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkpConeLimitConstraintAtomMeasurementModeEnumItems[] =
	{
		{0, "ZERO_WHEN_VECTORS_ALIGNED"},
		{1, "ZERO_WHEN_VECTORS_PERPENDICULAR"},
	};
	static const hkInternalClassEnum hkpConeLimitConstraintAtomEnums[] = {
		{"MeasurementMode", hkpConeLimitConstraintAtomMeasurementModeEnumItems, 2, HK_NULL, 0 }
	};
	const hkClassEnum* hkpConeLimitConstraintAtomMeasurementModeEnum = reinterpret_cast<const hkClassEnum*>(&hkpConeLimitConstraintAtomEnums[0]);
	static hkInternalClassMember hkpConeLimitConstraintAtomClass_Members[] =
	{
		{ "isEnabled", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "twistAxisInA", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "refAxisInB", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "angleMeasurementMode", HK_NULL, hkpConeLimitConstraintAtomMeasurementModeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "memOffsetToAngleOffset", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "minAngle", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxAngle", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "angularLimitsTauFactor", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkpConeLimitConstraintAtom_DefaultStruct
		{
			int s_defaultOffsets[8];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkUint8 m_memOffsetToAngleOffset;
			hkReal m_angularLimitsTauFactor;
		};
		const hkpConeLimitConstraintAtom_DefaultStruct hkpConeLimitConstraintAtom_Default =
		{
			{-1,-1,-1,-1,HK_OFFSET_OF(hkpConeLimitConstraintAtom_DefaultStruct,m_memOffsetToAngleOffset),-1,-1,HK_OFFSET_OF(hkpConeLimitConstraintAtom_DefaultStruct,m_angularLimitsTauFactor)},
			1,1.0
		};
	}
	hkClass hkpConeLimitConstraintAtomClass(
		"hkpConeLimitConstraintAtom",
		&hkpConstraintAtomClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkpConeLimitConstraintAtomEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkpConeLimitConstraintAtomClass_Members),
		HK_COUNT_OF(hkpConeLimitConstraintAtomClass_Members),
		&hkpConeLimitConstraintAtom_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpAngFrictionConstraintAtomClass_Members[] =
	{
		{ "isEnabled", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "firstFrictionAxis", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "numFrictionAxes", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxFrictionTorque", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpAngFrictionConstraintAtomClass(
		"hkpAngFrictionConstraintAtom",
		&hkpConstraintAtomClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpAngFrictionConstraintAtomClass_Members),
		HK_COUNT_OF(hkpAngFrictionConstraintAtomClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpAngMotorConstraintAtomClass_Members[] =
	{
		{ "isEnabled", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "motorAxis", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "initializedOffset", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "previousTargetAngleOffset", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "correspondingAngLimitSolverResultOffset", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "targetAngle", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "motor", &hkpConstraintMotorClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkpAngMotorConstraintAtomClass(
		"hkpAngMotorConstraintAtom",
		&hkpConstraintAtomClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpAngMotorConstraintAtomClass_Members),
		HK_COUNT_OF(hkpAngMotorConstraintAtomClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpRagdollMotorConstraintAtomClass_Members[] =
	{
		{ "isEnabled", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "initializedOffset", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "previousTargetAnglesOffset", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "target_bRca", HK_NULL, HK_NULL, hkClassMember::TYPE_MATRIX3, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "motors", &hkpConstraintMotorClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 3, 0, 0, HK_NULL }
	};
	hkClass hkpRagdollMotorConstraintAtomClass(
		"hkpRagdollMotorConstraintAtom",
		&hkpConstraintAtomClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpRagdollMotorConstraintAtomClass_Members),
		HK_COUNT_OF(hkpRagdollMotorConstraintAtomClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpLinFrictionConstraintAtomClass_Members[] =
	{
		{ "isEnabled", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "frictionAxis", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxFrictionForce", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpLinFrictionConstraintAtomClass(
		"hkpLinFrictionConstraintAtom",
		&hkpConstraintAtomClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpLinFrictionConstraintAtomClass_Members),
		HK_COUNT_OF(hkpLinFrictionConstraintAtomClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpLinMotorConstraintAtomClass_Members[] =
	{
		{ "isEnabled", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "motorAxis", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "initializedOffset", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "previousTargetPositionOffset", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "targetPosition", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "motor", &hkpConstraintMotorClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkpLinMotorConstraintAtomClass(
		"hkpLinMotorConstraintAtom",
		&hkpConstraintAtomClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpLinMotorConstraintAtomClass_Members),
		HK_COUNT_OF(hkpLinMotorConstraintAtomClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpPulleyConstraintAtomClass_Members[] =
	{
		{ "fixedPivotAinWorld", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "fixedPivotBinWorld", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "ropeLength", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "leverageOnBodyB", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpPulleyConstraintAtomClass(
		"hkpPulleyConstraintAtom",
		&hkpConstraintAtomClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpPulleyConstraintAtomClass_Members),
		HK_COUNT_OF(hkpPulleyConstraintAtomClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpRackAndPinionConstraintAtomClass_Members[] =
	{
		{ "pinionRadiusOrScrewPitch", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "isScrew", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "memOffsetToInitialAngleOffset", HK_NULL, HK_NULL, hkClassMember::TYPE_INT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "memOffsetToPrevAngle", HK_NULL, HK_NULL, hkClassMember::TYPE_INT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "memOffsetToRevolutionCounter", HK_NULL, HK_NULL, hkClassMember::TYPE_INT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpRackAndPinionConstraintAtomClass(
		"hkpRackAndPinionConstraintAtom",
		&hkpConstraintAtomClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpRackAndPinionConstraintAtomClass_Members),
		HK_COUNT_OF(hkpRackAndPinionConstraintAtomClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpCogWheelConstraintAtomClass_Members[] =
	{
		{ "cogWheelRadiusA", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "cogWheelRadiusB", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "isScrew", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "memOffsetToInitialAngleOffset", HK_NULL, HK_NULL, hkClassMember::TYPE_INT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "memOffsetToPrevAngle", HK_NULL, HK_NULL, hkClassMember::TYPE_INT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "memOffsetToRevolutionCounter", HK_NULL, HK_NULL, hkClassMember::TYPE_INT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpCogWheelConstraintAtomClass(
		"hkpCogWheelConstraintAtom",
		&hkpConstraintAtomClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpCogWheelConstraintAtomClass_Members),
		HK_COUNT_OF(hkpCogWheelConstraintAtomClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpModifierConstraintAtomClass_Members[] =
	{
		{ "modifierAtomSize", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::ALIGN_16, 0, HK_NULL },
		{ "childSize", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "child", &hkpConstraintAtomClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "pad", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 2, 0, 0, HK_NULL }
	};
	hkClass hkpModifierConstraintAtomClass(
		"hkpModifierConstraintAtom",
		&hkpConstraintAtomClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpModifierConstraintAtomClass_Members),
		HK_COUNT_OF(hkpModifierConstraintAtomClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpMassChangerModifierConstraintAtomClass_Members[] =
	{
		{ "factorA", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "factorB", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpMassChangerModifierConstraintAtomClass(
		"hkpMassChangerModifierConstraintAtom",
		&hkpModifierConstraintAtomClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpMassChangerModifierConstraintAtomClass_Members),
		HK_COUNT_OF(hkpMassChangerModifierConstraintAtomClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkpCenterOfMassChangerModifierConstraintAtomClass_Members[] =
	{
		{ "displacementA", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "displacementB", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpCenterOfMassChangerModifierConstraintAtomClass(
		"hkpCenterOfMassChangerModifierConstraintAtom",
		&hkpModifierConstraintAtomClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpCenterOfMassChangerModifierConstraintAtomClass_Members),
		HK_COUNT_OF(hkpCenterOfMassChangerModifierConstraintAtomClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkpConstraintMotorMotorTypeEnumItems[] =
	{
		{0, "TYPE_INVALID"},
		{1, "TYPE_POSITION"},
		{2, "TYPE_VELOCITY"},
		{3, "TYPE_SPRING_DAMPER"},
		{4, "TYPE_CALLBACK"},
		{5, "TYPE_MAX"},
	};
	static const hkInternalClassEnum hkpConstraintMotorEnums[] = {
		{"MotorType", hkpConstraintMotorMotorTypeEnumItems, 6, HK_NULL, 0 }
	};
	const hkClassEnum* hkpConstraintMotorMotorTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkpConstraintMotorEnums[0]);
	static hkInternalClassMember hkpConstraintMotorClass_Members[] =
	{
		{ "type", HK_NULL, hkpConstraintMotorMotorTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL }
	};
	hkClass hkpConstraintMotorClass(
		"hkpConstraintMotor",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkpConstraintMotorEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkpConstraintMotorClass_Members),
		HK_COUNT_OF(hkpConstraintMotorClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkpPointToPathConstraintDataOrientationConstraintTypeEnumItems[] =
	{
		{0, "CONSTRAIN_ORIENTATION_INVALID"},
		{1, "CONSTRAIN_ORIENTATION_NONE"},
		{2, "CONSTRAIN_ORIENTATION_ALLOW_SPIN"},
		{3, "CONSTRAIN_ORIENTATION_TO_PATH"},
		{4, "CONSTRAIN_ORIENTATION_MAX_ID"},
	};
	static const hkInternalClassEnum hkpPointToPathConstraintDataEnums[] = {
		{"OrientationConstraintType", hkpPointToPathConstraintDataOrientationConstraintTypeEnumItems, 5, HK_NULL, 0 }
	};
	const hkClassEnum* hkpPointToPathConstraintDataOrientationConstraintTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkpPointToPathConstraintDataEnums[0]);
	static hkInternalClassMember hkpPointToPathConstraintDataClass_Members[] =
	{
		{ "atoms", &hkpBridgeAtomsClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "path", &hkpParametricCurveClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "maxFrictionForce", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "angularConstrainedDOF", HK_NULL, hkpPointToPathConstraintDataOrientationConstraintTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL },
		{ "transform_OS_KS", HK_NULL, HK_NULL, hkClassMember::TYPE_TRANSFORM, hkClassMember::TYPE_VOID, 2, 0, 0, HK_NULL }
	};
	hkClass hkpPointToPathConstraintDataClass(
		"hkpPointToPathConstraintData",
		&hkpConstraintDataClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkpPointToPathConstraintDataEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkpPointToPathConstraintDataClass_Members),
		HK_COUNT_OF(hkpPointToPathConstraintDataClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hkpCharacterMotionClass(
		"hkpCharacterMotion",
		&hkpMotionClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpConstraintChainInstanceActionClass_Members[] =
	{
		{ "constraintInstance", &hkpConstraintChainInstanceClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0|hkClassMember::NOT_OWNED, 0, HK_NULL }
	};
	hkClass hkpConstraintChainInstanceActionClass(
		"hkpConstraintChainInstanceAction",
		&hkpActionClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpConstraintChainInstanceActionClass_Members),
		HK_COUNT_OF(hkpConstraintChainInstanceActionClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpGenericConstraintDataClass_Members[] =
	{
		{ "atoms", &hkpBridgeAtomsClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "scheme", &hkpGenericConstraintDataSchemeClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpGenericConstraintDataClass(
		"hkpGenericConstraintData",
		&hkpConstraintDataClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpGenericConstraintDataClass_Members),
		HK_COUNT_OF(hkpGenericConstraintDataClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hkWorldMemoryAvailableWatchDogClass(
		"hkWorldMemoryAvailableWatchDog",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkpRotationalConstraintData_AtomsClass_Members[] =
	{
		{ "rotations", &hkpSetLocalRotationsConstraintAtomClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "ang", &hkpAngConstraintAtomClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpRotationalConstraintDataAtomsClass(
		"hkpRotationalConstraintDataAtoms",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpRotationalConstraintData_AtomsClass_Members),
		HK_COUNT_OF(hkpRotationalConstraintData_AtomsClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpRotationalConstraintDataClass_Members[] =
	{
		{ "atoms", &hkpRotationalConstraintDataAtomsClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::ALIGN_16, 0, HK_NULL }
	};
	hkClass hkpRotationalConstraintDataClass(
		"hkpRotationalConstraintData",
		&hkpConstraintDataClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpRotationalConstraintDataClass_Members),
		HK_COUNT_OF(hkpRotationalConstraintDataClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hkpStaticCompoundShapeBreakableMaterialClass(
		"hkpStaticCompoundShapeBreakableMaterial",
		&hkpBreakableMultiMaterialClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpGenericConstraintDataScheme_ConstraintInfoClass_Members[] =
	{
		{ "maxSizeOfSchema", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "sizeOfSchemas", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "numSolverResults", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "numSolverElemTemps", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpGenericConstraintDataSchemeConstraintInfoClass(
		"hkpGenericConstraintDataSchemeConstraintInfo",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpGenericConstraintDataScheme_ConstraintInfoClass_Members),
		HK_COUNT_OF(hkpGenericConstraintDataScheme_ConstraintInfoClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpGenericConstraintDataSchemeClass_Members[] =
	{
		{ "info", &hkpGenericConstraintDataSchemeConstraintInfoClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "data", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VECTOR4, 0, 0, 0, HK_NULL },
		{ "commands", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_INT32, 0, 0, 0, HK_NULL },
		{ "modifiers", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "motors", &hkpConstraintMotorClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL }
	};
	hkClass hkpGenericConstraintDataSchemeClass(
		"hkpGenericConstraintDataScheme",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpGenericConstraintDataSchemeClass_Members),
		HK_COUNT_OF(hkpGenericConstraintDataSchemeClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hkpParametricCurveClass(
		"hkpParametricCurve",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hkpThinBoxMotionClass(
		"hkpThinBoxMotion",
		&hkpBoxMotionClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkpConstraintInstanceConstraintPriorityEnumItems[] =
	{
		{0, "PRIORITY_INVALID"},
		{1, "PRIORITY_PSI"},
		{2, "PRIORITY_SIMPLIFIED_TOI_UNUSED"},
		{3, "PRIORITY_TOI"},
		{4, "PRIORITY_TOI_HIGHER"},
		{5, "PRIORITY_TOI_FORCED"},
		{6, "NUM_PRIORITIES"},
	};
	static const hkInternalClassEnumItem hkpConstraintInstanceInstanceTypeEnumItems[] =
	{
		{0, "TYPE_NORMAL"},
		{1, "TYPE_CHAIN"},
	};
	static const hkInternalClassEnumItem hkpConstraintInstanceAddReferencesEnumItems[] =
	{
		{0, "DO_NOT_ADD_REFERENCES"},
		{1, "DO_ADD_REFERENCES"},
	};
	static const hkInternalClassEnumItem hkpConstraintInstanceCloningModeEnumItems[] =
	{
		{0, "CLONE_SHALLOW_IF_NOT_CONSTRAINED_TO_WORLD"},
		{1, "CLONE_DATAS_WITH_MOTORS"},
		{2, "CLONE_FORCE_SHALLOW"},
	};
	static const hkInternalClassEnumItem hkpConstraintInstanceOnDestructionRemapInfoEnumItems[] =
	{
		{0, "ON_DESTRUCTION_REMAP"},
		{1, "ON_DESTRUCTION_REMOVE"},
		{2, "ON_DESTRUCTION_RESET_REMOVE"},
	};
	static const hkInternalClassEnum hkpConstraintInstanceEnums[] = {
		{"ConstraintPriority", hkpConstraintInstanceConstraintPriorityEnumItems, 7, HK_NULL, 0 },
		{"InstanceType", hkpConstraintInstanceInstanceTypeEnumItems, 2, HK_NULL, 0 },
		{"AddReferences", hkpConstraintInstanceAddReferencesEnumItems, 2, HK_NULL, 0 },
		{"CloningMode", hkpConstraintInstanceCloningModeEnumItems, 3, HK_NULL, 0 },
		{"OnDestructionRemapInfo", hkpConstraintInstanceOnDestructionRemapInfoEnumItems, 3, HK_NULL, 0 }
	};
	const hkClassEnum* hkpConstraintInstanceConstraintPriorityEnum = reinterpret_cast<const hkClassEnum*>(&hkpConstraintInstanceEnums[0]);
	const hkClassEnum* hkpConstraintInstanceInstanceTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkpConstraintInstanceEnums[1]);
	const hkClassEnum* hkpConstraintInstanceAddReferencesEnum = reinterpret_cast<const hkClassEnum*>(&hkpConstraintInstanceEnums[2]);
	const hkClassEnum* hkpConstraintInstanceCloningModeEnum = reinterpret_cast<const hkClassEnum*>(&hkpConstraintInstanceEnums[3]);
	const hkClassEnum* hkpConstraintInstanceOnDestructionRemapInfoEnum = reinterpret_cast<const hkClassEnum*>(&hkpConstraintInstanceEnums[4]);
	static hkInternalClassMember hkpConstraintInstance_SmallArraySerializeOverrideTypeClass_Members[] =
	{
		{ "data", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "size", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "capacityAndFlags", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpConstraintInstanceSmallArraySerializeOverrideTypeClass(
		"hkpConstraintInstanceSmallArraySerializeOverrideType",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpConstraintInstance_SmallArraySerializeOverrideTypeClass_Members),
		HK_COUNT_OF(hkpConstraintInstance_SmallArraySerializeOverrideTypeClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkpConstraintInstanceClass_Members[] =
	{
		{ "owner", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "data", &hkpConstraintDataClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "constraintModifiers", &hkpModifierConstraintAtomClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "entities", &hkpEntityClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 2, 0, 0, HK_NULL },
		{ "priority", HK_NULL, hkpConstraintInstanceConstraintPriorityEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "wantRuntime", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "destructionRemapInfo", HK_NULL, hkpConstraintInstanceOnDestructionRemapInfoEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "listeners", &hkpConstraintInstanceSmallArraySerializeOverrideTypeClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "userData", HK_NULL, HK_NULL, hkClassMember::TYPE_ULONG, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "internal", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "uid", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	namespace
	{
		struct hkpConstraintInstance_DefaultStruct
		{
			int s_defaultOffsets[12];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
		};
		const hkpConstraintInstance_DefaultStruct hkpConstraintInstance_Default =
		{
			{-1,-1,-1,-1,-1,-1,-1,-1,-1,hkClassMember::HK_CLASS_ZERO_DEFAULT,-1,-1},
		};
	}
	hkClass hkpConstraintInstanceClass(
		"hkpConstraintInstance",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkpConstraintInstanceEnums),
		5,
		reinterpret_cast<const hkClassMember*>(hkpConstraintInstanceClass_Members),
		HK_COUNT_OF(hkpConstraintInstanceClass_Members),
		&hkpConstraintInstance_Default,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static const hkInternalClassEnumItem hkpWheelConstraintDataAtomsAxisEnumItems[] =
	{
		{0, "AXIS_SUSPENSION"},
		{1, "AXIS_PERP_SUSPENSION"},
		{0, "AXIS_AXLE"},
		{1, "AXIS_STEERING"},
	};
	static const hkInternalClassEnum hkpWheelConstraintDataAtomsEnums[] = {
		{"Axis", hkpWheelConstraintDataAtomsAxisEnumItems, 4, HK_NULL, 0 }
	};
	const hkClassEnum* hkpWheelConstraintDataAtomsAxisEnum = reinterpret_cast<const hkClassEnum*>(&hkpWheelConstraintDataAtomsEnums[0]);
	static hkInternalClassMember hkpWheelConstraintData_AtomsClass_Members[] =
	{
		{ "suspensionBase", &hkpSetLocalTransformsConstraintAtomClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "lin0Limit", &hkpLinLimitConstraintAtomClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "lin0Soft", &hkpLinSoftConstraintAtomClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "lin1", &hkpLinConstraintAtomClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "lin2", &hkpLinConstraintAtomClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "steeringBase", &hkpSetLocalRotationsConstraintAtomClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "2dAng", &hkp2dAngConstraintAtomClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpWheelConstraintDataAtomsClass(
		"hkpWheelConstraintDataAtoms",
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkpWheelConstraintDataAtomsEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkpWheelConstraintData_AtomsClass_Members),
		HK_COUNT_OF(hkpWheelConstraintData_AtomsClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpWheelConstraintDataClass_Members[] =
	{
		{ "atoms", &hkpWheelConstraintDataAtomsClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::ALIGN_16, 0, HK_NULL },
		{ "initialAxleInB", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "initialSteeringAxisInB", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpWheelConstraintDataClass(
		"hkpWheelConstraintData",
		&hkpConstraintDataClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpWheelConstraintDataClass_Members),
		HK_COUNT_OF(hkpWheelConstraintDataClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpBreakableShapeClass_Members[] =
	{
		{ "physicsShape", &hkpShapeClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "material", &hkpBreakableMaterialClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkpBreakableShapeClass(
		"hkpBreakableShape",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpBreakableShapeClass_Members),
		HK_COUNT_OF(hkpBreakableShapeClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpBinaryActionClass_Members[] =
	{
		{ "entityA", &hkpEntityClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "entityB", &hkpEntityClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkpBinaryActionClass(
		"hkpBinaryAction",
		&hkpActionClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpBinaryActionClass_Members),
		HK_COUNT_OF(hkpBinaryActionClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpCachingShapePhantomClass_Members[] =
	{
		{ "collisionDetails", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "orderDirty", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hkpCachingShapePhantomClass(
		"hkpCachingShapePhantom",
		&hkpShapePhantomClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpCachingShapePhantomClass_Members),
		HK_COUNT_OF(hkpCachingShapePhantomClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpPairCollisionFilter_MapPairFilterKeyOverrideTypeClass_Members[] =
	{
		{ "elem", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "numElems", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "hashMod", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpPairCollisionFilterMapPairFilterKeyOverrideTypeClass(
		"hkpPairCollisionFilterMapPairFilterKeyOverrideType",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpPairCollisionFilter_MapPairFilterKeyOverrideTypeClass_Members),
		HK_COUNT_OF(hkpPairCollisionFilter_MapPairFilterKeyOverrideTypeClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpPairCollisionFilterClass_Members[] =
	{
		{ "disabledPairs", &hkpPairCollisionFilterMapPairFilterKeyOverrideTypeClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "childFilter", &hkpCollisionFilterClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkpPairCollisionFilterClass(
		"hkpPairCollisionFilter",
		&hkpCollisionFilterClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpPairCollisionFilterClass_Members),
		HK_COUNT_OF(hkpPairCollisionFilterClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkpConstraintDataConstraintTypeEnumItems[] =
	{
		{0, "CONSTRAINT_TYPE_BALLANDSOCKET"},
		{1, "CONSTRAINT_TYPE_HINGE"},
		{2, "CONSTRAINT_TYPE_LIMITEDHINGE"},
		{3, "CONSTRAINT_TYPE_POINTTOPATH"},
		{6, "CONSTRAINT_TYPE_PRISMATIC"},
		{7, "CONSTRAINT_TYPE_RAGDOLL"},
		{8, "CONSTRAINT_TYPE_STIFFSPRING"},
		{9, "CONSTRAINT_TYPE_WHEEL"},
		{10, "CONSTRAINT_TYPE_GENERIC"},
		{11, "CONSTRAINT_TYPE_CONTACT"},
		{12, "CONSTRAINT_TYPE_BREAKABLE"},
		{13, "CONSTRAINT_TYPE_MALLEABLE"},
		{14, "CONSTRAINT_TYPE_POINTTOPLANE"},
		{15, "CONSTRAINT_TYPE_PULLEY"},
		{16, "CONSTRAINT_TYPE_ROTATIONAL"},
		{18, "CONSTRAINT_TYPE_HINGE_LIMITS"},
		{19, "CONSTRAINT_TYPE_RAGDOLL_LIMITS"},
		{20, "CONSTRAINT_TYPE_CUSTOM"},
		{21, "CONSTRAINT_TYPE_RACK_AND_PINION"},
		{22, "CONSTRAINT_TYPE_COG_WHEEL"},
		{100, "BEGIN_CONSTRAINT_CHAIN_TYPES"},
		{100, "CONSTRAINT_TYPE_STIFF_SPRING_CHAIN"},
		{101, "CONSTRAINT_TYPE_BALL_SOCKET_CHAIN"},
		{102, "CONSTRAINT_TYPE_POWERED_CHAIN"},
	};
	static const hkInternalClassEnum hkpConstraintDataEnums[] = {
		{"ConstraintType", hkpConstraintDataConstraintTypeEnumItems, 24, HK_NULL, 0 }
	};
	const hkClassEnum* hkpConstraintDataConstraintTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkpConstraintDataEnums[0]);
	static hkInternalClassMember hkpConstraintDataClass_Members[] =
	{
		{ "userData", HK_NULL, HK_NULL, hkClassMember::TYPE_ULONG, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkpConstraintData_DefaultStruct
		{
			int s_defaultOffsets[1];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
		};
		const hkpConstraintData_DefaultStruct hkpConstraintData_Default =
		{
			{hkClassMember::HK_CLASS_ZERO_DEFAULT},
		};
	}
	hkClass hkpConstraintDataClass(
		"hkpConstraintData",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkpConstraintDataEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkpConstraintDataClass_Members),
		HK_COUNT_OF(hkpConstraintDataClass_Members),
		&hkpConstraintData_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpPoweredChainData_ConstraintInfoClass_Members[] =
	{
		{ "pivotInA", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "pivotInB", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "aTc", HK_NULL, HK_NULL, hkClassMember::TYPE_QUATERNION, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "bTc", HK_NULL, HK_NULL, hkClassMember::TYPE_QUATERNION, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "motors", &hkpConstraintMotorClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 3, 0, 0, HK_NULL },
		{ "switchBodies", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpPoweredChainDataConstraintInfoClass(
		"hkpPoweredChainDataConstraintInfo",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpPoweredChainData_ConstraintInfoClass_Members),
		HK_COUNT_OF(hkpPoweredChainData_ConstraintInfoClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpPoweredChainDataClass_Members[] =
	{
		{ "atoms", &hkpBridgeAtomsClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "infos", &hkpPoweredChainDataConstraintInfoClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "tau", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "damping", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "cfmLinAdd", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "cfmLinMul", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "cfmAngAdd", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "cfmAngMul", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxErrorDistance", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkpPoweredChainData_DefaultStruct
		{
			int s_defaultOffsets[9];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkReal m_cfmLinAdd;
			hkReal m_cfmLinMul;
			hkReal m_cfmAngAdd;
			hkReal m_cfmAngMul;
		};
		const hkpPoweredChainData_DefaultStruct hkpPoweredChainData_Default =
		{
			{-1,-1,-1,-1,HK_OFFSET_OF(hkpPoweredChainData_DefaultStruct,m_cfmLinAdd),HK_OFFSET_OF(hkpPoweredChainData_DefaultStruct,m_cfmLinMul),HK_OFFSET_OF(hkpPoweredChainData_DefaultStruct,m_cfmAngAdd),HK_OFFSET_OF(hkpPoweredChainData_DefaultStruct,m_cfmAngMul),-1},
			0.1f*1.19209290e-07f,1.0f,0.1f*1.19209290e-07F,1.0f
		};
	}
	hkClass hkpPoweredChainDataClass(
		"hkpPoweredChainData",
		&hkpConstraintChainDataClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpPoweredChainDataClass_Members),
		HK_COUNT_OF(hkpPoweredChainDataClass_Members),
		&hkpPoweredChainData_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpVelocityConstraintMotorClass_Members[] =
	{
		{ "tau", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "velocityTarget", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "useVelocityTargetFromConstraintTargets", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpVelocityConstraintMotorClass(
		"hkpVelocityConstraintMotor",
		&hkpLimitedForceConstraintMotorClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpVelocityConstraintMotorClass_Members),
		HK_COUNT_OF(hkpVelocityConstraintMotorClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkpRackAndPinionConstraintDataTypeEnumItems[] =
	{
		{0, "TYPE_RACK_AND_PINION"},
		{1, "TYPE_SCREW"},
	};
	static const hkInternalClassEnum hkpRackAndPinionConstraintDataEnums[] = {
		{"Type", hkpRackAndPinionConstraintDataTypeEnumItems, 2, HK_NULL, 0 }
	};
	const hkClassEnum* hkpRackAndPinionConstraintDataTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkpRackAndPinionConstraintDataEnums[0]);
	static hkInternalClassMember hkpRackAndPinionConstraintData_AtomsClass_Members[] =
	{
		{ "transforms", &hkpSetLocalTransformsConstraintAtomClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "rackAndPinion", &hkpRackAndPinionConstraintAtomClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpRackAndPinionConstraintDataAtomsClass(
		"hkpRackAndPinionConstraintDataAtoms",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpRackAndPinionConstraintData_AtomsClass_Members),
		HK_COUNT_OF(hkpRackAndPinionConstraintData_AtomsClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpRackAndPinionConstraintDataClass_Members[] =
	{
		{ "atoms", &hkpRackAndPinionConstraintDataAtomsClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::ALIGN_16, 0, HK_NULL }
	};
	hkClass hkpRackAndPinionConstraintDataClass(
		"hkpRackAndPinionConstraintData",
		&hkpConstraintDataClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkpRackAndPinionConstraintDataEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkpRackAndPinionConstraintDataClass_Members),
		HK_COUNT_OF(hkpRackAndPinionConstraintDataClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkpWorldObjectMtChecksEnumItems[] =
	{
		{0, "MULTI_THREADING_CHECKS_ENABLE"},
		{1, "MULTI_THREADING_CHECKS_IGNORE"},
	};
	static const hkInternalClassEnumItem hkpWorldObjectBroadPhaseTypeEnumItems[] =
	{
		{0, "BROAD_PHASE_INVALID"},
		{1, "BROAD_PHASE_ENTITY"},
		{2, "BROAD_PHASE_PHANTOM"},
		{3, "BROAD_PHASE_BORDER"},
		{4, "BROAD_PHASE_MAX_ID"},
	};
	static const hkInternalClassEnum hkpWorldObjectEnums[] = {
		{"MtChecks", hkpWorldObjectMtChecksEnumItems, 2, HK_NULL, 0 },
		{"BroadPhaseType", hkpWorldObjectBroadPhaseTypeEnumItems, 5, HK_NULL, 0 }
	};
	const hkClassEnum* hkpWorldObjectMtChecksEnum = reinterpret_cast<const hkClassEnum*>(&hkpWorldObjectEnums[0]);
	const hkClassEnum* hkpWorldObjectBroadPhaseTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkpWorldObjectEnums[1]);
	static hkInternalClassMember hkpWorldObjectClass_Members[] =
	{
		{ "world", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "userData", HK_NULL, HK_NULL, hkClassMember::TYPE_ULONG, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "collidable", &hkpLinkedCollidableClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "multiThreadCheck", &hkMultiThreadCheckClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "properties", &hkpPropertyClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkpWorldObject_DefaultStruct
		{
			int s_defaultOffsets[6];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
		};
		const hkpWorldObject_DefaultStruct hkpWorldObject_Default =
		{
			{-1,hkClassMember::HK_CLASS_ZERO_DEFAULT,-1,-1,-1,-1},
		};
	}
	hkClass hkpWorldObjectClass(
		"hkpWorldObject",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkpWorldObjectEnums),
		2,
		reinterpret_cast<const hkClassMember*>(hkpWorldObjectClass_Members),
		HK_COUNT_OF(hkpWorldObjectClass_Members),
		&hkpWorldObject_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpConstraintChainInstanceClass_Members[] =
	{
		{ "chainedEntities", &hkpEntityClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "action", &hkpConstraintChainInstanceActionClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkpConstraintChainInstanceClass(
		"hkpConstraintChainInstance",
		&hkpConstraintInstanceClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpConstraintChainInstanceClass_Members),
		HK_COUNT_OF(hkpConstraintChainInstanceClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpPhysicsSystemClass_Members[] =
	{
		{ "rigidBodies", &hkpRigidBodyClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "constraints", &hkpConstraintInstanceClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "actions", &hkpActionClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "phantoms", &hkpPhantomClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "userData", HK_NULL, HK_NULL, hkClassMember::TYPE_ULONG, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "active", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkpPhysicsSystem_DefaultStruct
		{
			int s_defaultOffsets[7];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			_hkBool m_active;
		};
		const hkpPhysicsSystem_DefaultStruct hkpPhysicsSystem_Default =
		{
			{-1,-1,-1,-1,-1,hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkpPhysicsSystem_DefaultStruct,m_active)},
			true
		};
	}
	hkClass hkpPhysicsSystemClass(
		"hkpPhysicsSystem",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpPhysicsSystemClass_Members),
		HK_COUNT_OF(hkpPhysicsSystemClass_Members),
		&hkpPhysicsSystem_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpMalleableConstraintDataClass_Members[] =
	{
		{ "constraintData", &hkpConstraintDataClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "atoms", &hkpBridgeAtomsClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "strength", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpMalleableConstraintDataClass(
		"hkpMalleableConstraintData",
		&hkpConstraintDataClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpMalleableConstraintDataClass_Members),
		HK_COUNT_OF(hkpMalleableConstraintDataClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hkpRigidBodyClass(
		"hkpRigidBody",
		&hkpEntityClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkpCallbackConstraintMotorCallbackTypeEnumItems[] =
	{
		{0, "CALLBACK_MOTOR_TYPE_HAVOK_DEMO_SPRING_DAMPER"},
		{1, "CALLBACK_MOTOR_TYPE_USER_0"},
		{2, "CALLBACK_MOTOR_TYPE_USER_1"},
		{3, "CALLBACK_MOTOR_TYPE_USER_2"},
		{4, "CALLBACK_MOTOR_TYPE_USER_3"},
	};
	static const hkInternalClassEnum hkpCallbackConstraintMotorEnums[] = {
		{"CallbackType", hkpCallbackConstraintMotorCallbackTypeEnumItems, 5, HK_NULL, 0 }
	};
	const hkClassEnum* hkpCallbackConstraintMotorCallbackTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkpCallbackConstraintMotorEnums[0]);
	static hkInternalClassMember hkpCallbackConstraintMotorClass_Members[] =
	{
		{ "callbackFunc", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "callbackType", HK_NULL, hkpCallbackConstraintMotorCallbackTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT32, 0, 0, 0, HK_NULL },
		{ "userData0", HK_NULL, HK_NULL, hkClassMember::TYPE_ULONG, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "userData1", HK_NULL, HK_NULL, hkClassMember::TYPE_ULONG, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "userData2", HK_NULL, HK_NULL, hkClassMember::TYPE_ULONG, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkpCallbackConstraintMotor_DefaultStruct
		{
			int s_defaultOffsets[5];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
		};
		const hkpCallbackConstraintMotor_DefaultStruct hkpCallbackConstraintMotor_Default =
		{
			{-1,-1,hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT},
		};
	}
	hkClass hkpCallbackConstraintMotorClass(
		"hkpCallbackConstraintMotor",
		&hkpLimitedForceConstraintMotorClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkpCallbackConstraintMotorEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkpCallbackConstraintMotorClass_Members),
		HK_COUNT_OF(hkpCallbackConstraintMotorClass_Members),
		&hkpCallbackConstraintMotor_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkpHingeConstraintDataAtomsAxisEnumItems[] =
	{
		{0, "AXIS_AXLE"},
	};
	static const hkInternalClassEnum hkpHingeConstraintDataAtomsEnums[] = {
		{"Axis", hkpHingeConstraintDataAtomsAxisEnumItems, 1, HK_NULL, 0 }
	};
	const hkClassEnum* hkpHingeConstraintDataAtomsAxisEnum = reinterpret_cast<const hkClassEnum*>(&hkpHingeConstraintDataAtomsEnums[0]);
	static hkInternalClassMember hkpHingeConstraintData_AtomsClass_Members[] =
	{
		{ "transforms", &hkpSetLocalTransformsConstraintAtomClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "setupStabilization", &hkpSetupStabilizationAtomClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "2dAng", &hkp2dAngConstraintAtomClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "ballSocket", &hkpBallSocketConstraintAtomClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpHingeConstraintDataAtomsClass(
		"hkpHingeConstraintDataAtoms",
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkpHingeConstraintDataAtomsEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkpHingeConstraintData_AtomsClass_Members),
		HK_COUNT_OF(hkpHingeConstraintData_AtomsClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkpHingeConstraintDataClass_Members[] =
	{
		{ "atoms", &hkpHingeConstraintDataAtomsClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::ALIGN_16, 0, HK_NULL }
	};
	hkClass hkpHingeConstraintDataClass(
		"hkpHingeConstraintData",
		&hkpConstraintDataClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpHingeConstraintDataClass_Members),
		HK_COUNT_OF(hkpHingeConstraintDataClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpPulleyConstraintData_AtomsClass_Members[] =
	{
		{ "translations", &hkpSetLocalTranslationsConstraintAtomClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "pulley", &hkpPulleyConstraintAtomClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpPulleyConstraintDataAtomsClass(
		"hkpPulleyConstraintDataAtoms",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpPulleyConstraintData_AtomsClass_Members),
		HK_COUNT_OF(hkpPulleyConstraintData_AtomsClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpPulleyConstraintDataClass_Members[] =
	{
		{ "atoms", &hkpPulleyConstraintDataAtomsClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::ALIGN_16, 0, HK_NULL }
	};
	hkClass hkpPulleyConstraintDataClass(
		"hkpPulleyConstraintData",
		&hkpConstraintDataClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpPulleyConstraintDataClass_Members),
		HK_COUNT_OF(hkpPulleyConstraintDataClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpShapePhantomClass_Members[] =
	{
		{ "motionState", &hkMotionStateClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpShapePhantomClass(
		"hkpShapePhantom",
		&hkpPhantomClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpShapePhantomClass_Members),
		HK_COUNT_OF(hkpShapePhantomClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpUnaryActionClass_Members[] =
	{
		{ "entity", &hkpEntityClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkpUnaryActionClass(
		"hkpUnaryAction",
		&hkpActionClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpUnaryActionClass_Members),
		HK_COUNT_OF(hkpUnaryActionClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpArrayActionClass_Members[] =
	{
		{ "entities", &hkpEntityClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL }
	};
	hkClass hkpArrayActionClass(
		"hkpArrayAction",
		&hkpActionClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpArrayActionClass_Members),
		HK_COUNT_OF(hkpArrayActionClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkpEntitySpuCollisionCallbackEventFilterEnumItems[] =
	{
		{0, "SPU_SEND_NONE"},
		{1, "SPU_SEND_CONTACT_POINT_ADDED"},
		{2, "SPU_SEND_CONTACT_POINT_PROCESS"},
		{4, "SPU_SEND_CONTACT_POINT_REMOVED"},
		{3, "SPU_SEND_CONTACT_POINT_ADDED_OR_PROCESS"},
	};
	static const hkInternalClassEnum hkpEntityEnums[] = {
		{"SpuCollisionCallbackEventFilter", hkpEntitySpuCollisionCallbackEventFilterEnumItems, 5, HK_NULL, 0 }
	};
	const hkClassEnum* hkpEntitySpuCollisionCallbackEventFilterEnum = reinterpret_cast<const hkClassEnum*>(&hkpEntityEnums[0]);
	static hkInternalClassMember hkpEntity_SmallArraySerializeOverrideTypeClass_Members[] =
	{
		{ "data", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "size", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "capacityAndFlags", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpEntitySmallArraySerializeOverrideTypeClass(
		"hkpEntitySmallArraySerializeOverrideType",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpEntity_SmallArraySerializeOverrideTypeClass_Members),
		HK_COUNT_OF(hkpEntity_SmallArraySerializeOverrideTypeClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkpEntity_SpuCollisionCallbackClass_Members[] =
	{
		{ "util", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "capacity", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "eventFilter", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "userFilter", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpEntitySpuCollisionCallbackClass(
		"hkpEntitySpuCollisionCallback",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpEntity_SpuCollisionCallbackClass_Members),
		HK_COUNT_OF(hkpEntity_SpuCollisionCallbackClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpEntity_ExtendedListenersClass_Members[] =
	{
		{ "activationListeners", &hkpEntitySmallArraySerializeOverrideTypeClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "entityListeners", &hkpEntitySmallArraySerializeOverrideTypeClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hkpEntityExtendedListenersClass(
		"hkpEntityExtendedListeners",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpEntity_ExtendedListenersClass_Members),
		HK_COUNT_OF(hkpEntity_ExtendedListenersClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpEntityClass_Members[] =
	{
		{ "material", &hkpMaterialClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "limitContactImpulseUtilAndFlag", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "damageMultiplier", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "breakableBody", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "solverData", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "storageIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "contactPointCallbackDelay", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "constraintsMaster", &hkpEntitySmallArraySerializeOverrideTypeClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "constraintsSlave", &hkpConstraintInstanceClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0|hkClassMember::NOT_OWNED|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "constraintRuntime", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT8, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "simulationIsland", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "autoRemoveLevel", HK_NULL, HK_NULL, hkClassMember::TYPE_INT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "numShapeKeysInContactPointProperties", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "responseModifierFlags", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "uid", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "spuCollisionCallback", &hkpEntitySpuCollisionCallbackClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "motion", &hkpMaxSizeMotionClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "contactListeners", &hkpEntitySmallArraySerializeOverrideTypeClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "actions", &hkpEntitySmallArraySerializeOverrideTypeClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "localFrame", &hkLocalFrameClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "extendedListeners", &hkpEntityExtendedListenersClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "npData", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkpEntity_DefaultStruct
		{
			int s_defaultOffsets[22];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkReal m_damageMultiplier;
			hkUint32 m_uid;
		};
		const hkpEntity_DefaultStruct hkpEntity_Default =
		{
			{-1,-1,HK_OFFSET_OF(hkpEntity_DefaultStruct,m_damageMultiplier),-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,HK_OFFSET_OF(hkpEntity_DefaultStruct,m_uid),-1,-1,-1,-1,-1,-1,-1},
			1,0xffffffff
		};
	}
	hkClass hkpEntityClass(
		"hkpEntity",
		&hkpWorldObjectClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkpEntityEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkpEntityClass_Members),
		HK_COUNT_OF(hkpEntityClass_Members),
		&hkpEntity_Default,
		HK_NULL,
		0,
		hkUint32(3)
		);
	static const hkInternalClassEnumItem hkpRagdollConstraintDataMotorIndexEnumItems[] =
	{
		{0, "MOTOR_TWIST"},
		{1, "MOTOR_PLANE"},
		{2, "MOTOR_CONE"},
	};
	static const hkInternalClassEnum hkpRagdollConstraintDataEnums[] = {
		{"MotorIndex", hkpRagdollConstraintDataMotorIndexEnumItems, 3, HK_NULL, 0 }
	};
	const hkClassEnum* hkpRagdollConstraintDataMotorIndexEnum = reinterpret_cast<const hkClassEnum*>(&hkpRagdollConstraintDataEnums[0]);
	static const hkInternalClassEnumItem hkpRagdollConstraintDataAtomsAxisEnumItems[] =
	{
		{0, "AXIS_TWIST"},
		{1, "AXIS_PLANES"},
		{2, "AXIS_CROSS_PRODUCT"},
	};
	static const hkInternalClassEnum hkpRagdollConstraintDataAtomsEnums[] = {
		{"Axis", hkpRagdollConstraintDataAtomsAxisEnumItems, 3, HK_NULL, 0 }
	};
	const hkClassEnum* hkpRagdollConstraintDataAtomsAxisEnum = reinterpret_cast<const hkClassEnum*>(&hkpRagdollConstraintDataAtomsEnums[0]);
	static hkInternalClassMember hkpRagdollConstraintData_AtomsClass_Members[] =
	{
		{ "transforms", &hkpSetLocalTransformsConstraintAtomClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "setupStabilization", &hkpSetupStabilizationAtomClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "ragdollMotors", &hkpRagdollMotorConstraintAtomClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "angFriction", &hkpAngFrictionConstraintAtomClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "twistLimit", &hkpTwistLimitConstraintAtomClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "coneLimit", &hkpConeLimitConstraintAtomClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "planesLimit", &hkpConeLimitConstraintAtomClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "ballSocket", &hkpBallSocketConstraintAtomClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpRagdollConstraintDataAtomsClass(
		"hkpRagdollConstraintDataAtoms",
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkpRagdollConstraintDataAtomsEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkpRagdollConstraintData_AtomsClass_Members),
		HK_COUNT_OF(hkpRagdollConstraintData_AtomsClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkpRagdollConstraintDataClass_Members[] =
	{
		{ "atoms", &hkpRagdollConstraintDataAtomsClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::ALIGN_16, 0, HK_NULL }
	};
	hkClass hkpRagdollConstraintDataClass(
		"hkpRagdollConstraintData",
		&hkpConstraintDataClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkpRagdollConstraintDataEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkpRagdollConstraintDataClass_Members),
		HK_COUNT_OF(hkpRagdollConstraintDataClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hkpSphereMotionClass(
		"hkpSphereMotion",
		&hkpMotionClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hkpConstraintChainDataClass(
		"hkpConstraintChainData",
		&hkpConstraintDataClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpPropertyValueClass_Members[] =
	{
		{ "data", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT64, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpPropertyValueClass(
		"hkpPropertyValue",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpPropertyValueClass_Members),
		HK_COUNT_OF(hkpPropertyValueClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpPropertyClass_Members[] =
	{
		{ "key", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "alignmentPadding", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "value", &hkpPropertyValueClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpPropertyClass(
		"hkpProperty",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpPropertyClass_Members),
		HK_COUNT_OF(hkpPropertyClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	hkClass hkpExtendedMeshShapeBreakableMaterialClass(
		"hkpExtendedMeshShapeBreakableMaterial",
		&hkpBreakableMultiMaterialClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpPhantomClass_Members[] =
	{
		{ "overlapListeners", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "phantomListeners", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hkpPhantomClass(
		"hkpPhantom",
		&hkpWorldObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpPhantomClass_Members),
		HK_COUNT_OF(hkpPhantomClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkpWorldCinfoSolverTypeEnumItems[] =
	{
		{0, "SOLVER_TYPE_INVALID"},
		{1, "SOLVER_TYPE_2ITERS_SOFT"},
		{2, "SOLVER_TYPE_2ITERS_MEDIUM"},
		{3, "SOLVER_TYPE_2ITERS_HARD"},
		{4, "SOLVER_TYPE_4ITERS_SOFT"},
		{5, "SOLVER_TYPE_4ITERS_MEDIUM"},
		{6, "SOLVER_TYPE_4ITERS_HARD"},
		{7, "SOLVER_TYPE_8ITERS_SOFT"},
		{8, "SOLVER_TYPE_8ITERS_MEDIUM"},
		{9, "SOLVER_TYPE_8ITERS_HARD"},
		{10, "SOLVER_TYPE_MAX_ID"},
	};
	static const hkInternalClassEnumItem hkpWorldCinfoSimulationTypeEnumItems[] =
	{
		{0, "SIMULATION_TYPE_INVALID"},
		{1, "SIMULATION_TYPE_DISCRETE"},
		{2, "SIMULATION_TYPE_CONTINUOUS"},
		{3, "SIMULATION_TYPE_MULTITHREADED"},
	};
	static const hkInternalClassEnumItem hkpWorldCinfoContactPointGenerationEnumItems[] =
	{
		{0, "CONTACT_POINT_ACCEPT_ALWAYS"},
		{1, "CONTACT_POINT_REJECT_DUBIOUS"},
		{2, "CONTACT_POINT_REJECT_MANY"},
	};
	static const hkInternalClassEnumItem hkpWorldCinfoBroadPhaseTypeEnumItems[] =
	{
		{0, "BROADPHASE_TYPE_SAP"},
		{1, "BROADPHASE_TYPE_TREE"},
		{2, "BROADPHASE_TYPE_HYBRID"},
		{3, "BROADPHASE_TYPE_SAP_AND_KD_TREE_DEPRECATED"},
	};
	static const hkInternalClassEnumItem hkpWorldCinfoBroadPhaseBorderBehaviourEnumItems[] =
	{
		{0, "BROADPHASE_BORDER_ASSERT"},
		{1, "BROADPHASE_BORDER_FIX_ENTITY"},
		{2, "BROADPHASE_BORDER_REMOVE_ENTITY"},
		{3, "BROADPHASE_BORDER_DO_NOTHING"},
	};
	static const hkInternalClassEnum hkpWorldCinfoEnums[] = {
		{"SolverType", hkpWorldCinfoSolverTypeEnumItems, 11, HK_NULL, 0 },
		{"SimulationType", hkpWorldCinfoSimulationTypeEnumItems, 4, HK_NULL, 0 },
		{"ContactPointGeneration", hkpWorldCinfoContactPointGenerationEnumItems, 3, HK_NULL, 0 },
		{"BroadPhaseType", hkpWorldCinfoBroadPhaseTypeEnumItems, 4, HK_NULL, 0 },
		{"BroadPhaseBorderBehaviour", hkpWorldCinfoBroadPhaseBorderBehaviourEnumItems, 4, HK_NULL, 0 }
	};
	const hkClassEnum* hkpWorldCinfoSolverTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkpWorldCinfoEnums[0]);
	const hkClassEnum* hkpWorldCinfoSimulationTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkpWorldCinfoEnums[1]);
	const hkClassEnum* hkpWorldCinfoContactPointGenerationEnum = reinterpret_cast<const hkClassEnum*>(&hkpWorldCinfoEnums[2]);
	const hkClassEnum* hkpWorldCinfoBroadPhaseTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkpWorldCinfoEnums[3]);
	const hkClassEnum* hkpWorldCinfoBroadPhaseBorderBehaviourEnum = reinterpret_cast<const hkClassEnum*>(&hkpWorldCinfoEnums[4]);
	static hkInternalClassMember hkpWorldCinfoClass_Members[] =
	{
		{ "gravity", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "broadPhaseQuerySize", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "contactRestingVelocity", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "broadPhaseType", HK_NULL, hkpWorldCinfoBroadPhaseTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL },
		{ "broadPhaseBorderBehaviour", HK_NULL, hkpWorldCinfoBroadPhaseBorderBehaviourEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL },
		{ "mtPostponeAndSortBroadPhaseBorderCallbacks", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "broadPhaseWorldAabb", &hkAabbClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "autoUpdateKdTree", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "collisionTolerance", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "collisionFilter", &hkpCollisionFilterClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "convexListFilter", &hkpConvexListFilterClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "expectedMaxLinearVelocity", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "sizeOfToiEventQueue", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "expectedMinPsiDeltaTime", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "memoryWatchDog", &hkWorldMemoryAvailableWatchDogClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "broadPhaseNumMarkers", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "contactPointGeneration", HK_NULL, hkpWorldCinfoContactPointGenerationEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL },
		{ "allowToSkipConfirmedCallbacks", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "solverTau", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "solverDamp", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "solverIterations", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "solverMicrosteps", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxConstraintViolation", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "forceCoherentConstraintOrderingInSolver", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "snapCollisionToConvexEdgeThreshold", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "snapCollisionToConcaveEdgeThreshold", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "enableToiWeldRejection", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "enableDeprecatedWelding", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "iterativeLinearCastEarlyOutDistance", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "iterativeLinearCastMaxIterations", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "deactivationNumInactiveFramesSelectFlag0", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "deactivationNumInactiveFramesSelectFlag1", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "deactivationIntegrateCounter", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "shouldActivateOnRigidBodyTransformChange", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "deactivationReferenceDistance", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "toiCollisionResponseRotateNormal", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "BETA_useCompoundSpuElf", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxSectorsPerMidphaseCollideTask", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxSectorsPerNarrowphaseCollideTask", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "processToisMultithreaded", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxEntriesPerToiMidphaseCollideTask", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxEntriesPerToiNarrowphaseCollideTask", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxNumToiCollisionPairsSinglethreaded", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "numToisTillAllowedPenetrationSimplifiedToi", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "numToisTillAllowedPenetrationToi", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "numToisTillAllowedPenetrationToiHigher", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "numToisTillAllowedPenetrationToiForced", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "enableDeactivation", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "simulationType", HK_NULL, hkpWorldCinfoSimulationTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL },
		{ "enableSimulationIslands", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "minDesiredIslandSize", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "processActionsInSingleThread", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "allowIntegrationOfIslandsWithoutConstraintsInASeparateJob", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "frameMarkerPsiSnap", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "fireCollisionCallbacks", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkpWorldCinfo_DefaultStruct
		{
			int s_defaultOffsets[55];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			_hkVector4 m_gravity;
			hkInt32 m_broadPhaseQuerySize;
			_hkBool m_autoUpdateKdTree;
			hkReal m_collisionTolerance;
			hkReal m_expectedMaxLinearVelocity;
			hkInt32 m_sizeOfToiEventQueue;
			hkReal m_expectedMinPsiDeltaTime;
			hkReal m_solverDamp;
			hkInt32 m_solverIterations;
			hkInt32 m_solverMicrosteps;
			hkReal m_maxConstraintViolation;
			hkReal m_snapCollisionToConvexEdgeThreshold;
			hkReal m_snapCollisionToConcaveEdgeThreshold;
			hkReal m_iterativeLinearCastEarlyOutDistance;
			hkInt32 m_iterativeLinearCastMaxIterations;
			_hkBool m_shouldActivateOnRigidBodyTransformChange;
			hkReal m_deactivationReferenceDistance;
			hkReal m_toiCollisionResponseRotateNormal;
			hkInt32 m_maxSectorsPerMidphaseCollideTask;
			hkInt32 m_maxSectorsPerNarrowphaseCollideTask;
			_hkBool m_processToisMultithreaded;
			hkInt32 m_maxEntriesPerToiMidphaseCollideTask;
			hkInt32 m_maxEntriesPerToiNarrowphaseCollideTask;
			hkReal m_numToisTillAllowedPenetrationSimplifiedToi;
			hkReal m_numToisTillAllowedPenetrationToi;
			hkReal m_numToisTillAllowedPenetrationToiHigher;
			hkReal m_numToisTillAllowedPenetrationToiForced;
			_hkBool m_enableDeactivation;
			_hkBool m_enableSimulationIslands;
			hkUint32 m_minDesiredIslandSize;
			_hkBool m_processActionsInSingleThread;
			hkReal m_frameMarkerPsiSnap;
		};
		const hkpWorldCinfo_DefaultStruct hkpWorldCinfo_Default =
		{
			{HK_OFFSET_OF(hkpWorldCinfo_DefaultStruct,m_gravity),HK_OFFSET_OF(hkpWorldCinfo_DefaultStruct,m_broadPhaseQuerySize),-1,-1,-1,hkClassMember::HK_CLASS_ZERO_DEFAULT,-1,HK_OFFSET_OF(hkpWorldCinfo_DefaultStruct,m_autoUpdateKdTree),HK_OFFSET_OF(hkpWorldCinfo_DefaultStruct,m_collisionTolerance),-1,-1,HK_OFFSET_OF(hkpWorldCinfo_DefaultStruct,m_expectedMaxLinearVelocity),HK_OFFSET_OF(hkpWorldCinfo_DefaultStruct,m_sizeOfToiEventQueue),HK_OFFSET_OF(hkpWorldCinfo_DefaultStruct,m_expectedMinPsiDeltaTime),-1,-1,-1,hkClassMember::HK_CLASS_ZERO_DEFAULT,-1,HK_OFFSET_OF(hkpWorldCinfo_DefaultStruct,m_solverDamp),HK_OFFSET_OF(hkpWorldCinfo_DefaultStruct,m_solverIterations),HK_OFFSET_OF(hkpWorldCinfo_DefaultStruct,m_solverMicrosteps),HK_OFFSET_OF(hkpWorldCinfo_DefaultStruct,m_maxConstraintViolation),hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkpWorldCinfo_DefaultStruct,m_snapCollisionToConvexEdgeThreshold),HK_OFFSET_OF(hkpWorldCinfo_DefaultStruct,m_snapCollisionToConcaveEdgeThreshold),hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkpWorldCinfo_DefaultStruct,m_iterativeLinearCastEarlyOutDistance),HK_OFFSET_OF(hkpWorldCinfo_DefaultStruct,m_iterativeLinearCastMaxIterations),hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkpWorldCinfo_DefaultStruct,m_shouldActivateOnRigidBodyTransformChange),HK_OFFSET_OF(hkpWorldCinfo_DefaultStruct,m_deactivationReferenceDistance),HK_OFFSET_OF(hkpWorldCinfo_DefaultStruct,m_toiCollisionResponseRotateNormal),hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkpWorldCinfo_DefaultStruct,m_maxSectorsPerMidphaseCollideTask),HK_OFFSET_OF(hkpWorldCinfo_DefaultStruct,m_maxSectorsPerNarrowphaseCollideTask),HK_OFFSET_OF(hkpWorldCinfo_DefaultStruct,m_processToisMultithreaded),HK_OFFSET_OF(hkpWorldCinfo_DefaultStruct,m_maxEntriesPerToiMidphaseCollideTask),HK_OFFSET_OF(hkpWorldCinfo_DefaultStruct,m_maxEntriesPerToiNarrowphaseCollideTask),hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkpWorldCinfo_DefaultStruct,m_numToisTillAllowedPenetrationSimplifiedToi),HK_OFFSET_OF(hkpWorldCinfo_DefaultStruct,m_numToisTillAllowedPenetrationToi),HK_OFFSET_OF(hkpWorldCinfo_DefaultStruct,m_numToisTillAllowedPenetrationToiHigher),HK_OFFSET_OF(hkpWorldCinfo_DefaultStruct,m_numToisTillAllowedPenetrationToiForced),HK_OFFSET_OF(hkpWorldCinfo_DefaultStruct,m_enableDeactivation),-1,HK_OFFSET_OF(hkpWorldCinfo_DefaultStruct,m_enableSimulationIslands),HK_OFFSET_OF(hkpWorldCinfo_DefaultStruct,m_minDesiredIslandSize),HK_OFFSET_OF(hkpWorldCinfo_DefaultStruct,m_processActionsInSingleThread),hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkpWorldCinfo_DefaultStruct,m_frameMarkerPsiSnap),hkClassMember::HK_CLASS_ZERO_DEFAULT},
			{0,-9.8f,0},1024,true,.1f,200,250,1.0f/30.0f,.6f,4,1,1.8446726e+019f,.524f,0.698f,.01f,20,true,0.02f,0.2f,2,4,true,-1,-1,3.0f,3.0f,4.0f,20.0f,true,true,64,true,.0001f
		};
	}
	hkClass hkpWorldCinfoClass(
		"hkpWorldCinfo",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkpWorldCinfoEnums),
		5,
		reinterpret_cast<const hkClassMember*>(hkpWorldCinfoClass_Members),
		HK_COUNT_OF(hkpWorldCinfoClass_Members),
		&hkpWorldCinfo_Default,
		HK_NULL,
		0,
		hkUint32(16)
		);
	static const hkInternalClassEnumItem hkpMaterialResponseTypeEnumItems[] =
	{
		{0, "RESPONSE_INVALID"},
		{1, "RESPONSE_SIMPLE_CONTACT"},
		{2, "RESPONSE_REPORTING"},
		{3, "RESPONSE_NONE"},
		{4, "RESPONSE_MAX_ID"},
	};
	static const hkInternalClassEnum hkpMaterialEnums[] = {
		{"ResponseType", hkpMaterialResponseTypeEnumItems, 5, HK_NULL, 0 }
	};
	const hkClassEnum* hkpMaterialResponseTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkpMaterialEnums[0]);
	static hkInternalClassMember hkpMaterialClass_Members[] =
	{
		{ "responseType", HK_NULL, hkpMaterialResponseTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL },
		{ "rollingFrictionMultiplier", HK_NULL, HK_NULL, hkClassMember::TYPE_HALF, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "friction", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "restitution", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkpMaterial_DefaultStruct
		{
			int s_defaultOffsets[4];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
		};
		const hkpMaterial_DefaultStruct hkpMaterial_Default =
		{
			{-1,hkClassMember::HK_CLASS_ZERO_DEFAULT,-1,-1},
		};
	}
	hkClass hkpMaterialClass(
		"hkpMaterial",
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkpMaterialEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkpMaterialClass_Members),
		HK_COUNT_OF(hkpMaterialClass_Members),
		&hkpMaterial_Default,
		HK_NULL,
		0,
		hkUint32(2)
		);
	hkClass hkpSimpleBreakableMaterialClass(
		"hkpSimpleBreakableMaterial",
		&hkpBreakableMaterialClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkpPrismaticConstraintDataAtomsAxisEnumItems[] =
	{
		{0, "AXIS_SHAFT"},
		{1, "AXIS_PERP_TO_SHAFT"},
	};
	static const hkInternalClassEnum hkpPrismaticConstraintDataAtomsEnums[] = {
		{"Axis", hkpPrismaticConstraintDataAtomsAxisEnumItems, 2, HK_NULL, 0 }
	};
	const hkClassEnum* hkpPrismaticConstraintDataAtomsAxisEnum = reinterpret_cast<const hkClassEnum*>(&hkpPrismaticConstraintDataAtomsEnums[0]);
	static hkInternalClassMember hkpPrismaticConstraintData_AtomsClass_Members[] =
	{
		{ "transforms", &hkpSetLocalTransformsConstraintAtomClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "motor", &hkpLinMotorConstraintAtomClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "friction", &hkpLinFrictionConstraintAtomClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "ang", &hkpAngConstraintAtomClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "lin0", &hkpLinConstraintAtomClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "lin1", &hkpLinConstraintAtomClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "linLimit", &hkpLinLimitConstraintAtomClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpPrismaticConstraintDataAtomsClass(
		"hkpPrismaticConstraintDataAtoms",
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkpPrismaticConstraintDataAtomsEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkpPrismaticConstraintData_AtomsClass_Members),
		HK_COUNT_OF(hkpPrismaticConstraintData_AtomsClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpPrismaticConstraintDataClass_Members[] =
	{
		{ "atoms", &hkpPrismaticConstraintDataAtomsClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::ALIGN_16, 0, HK_NULL }
	};
	hkClass hkpPrismaticConstraintDataClass(
		"hkpPrismaticConstraintData",
		&hkpConstraintDataClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpPrismaticConstraintDataClass_Members),
		HK_COUNT_OF(hkpPrismaticConstraintDataClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpPointToPlaneConstraintData_AtomsClass_Members[] =
	{
		{ "transforms", &hkpSetLocalTransformsConstraintAtomClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "lin", &hkpLinConstraintAtomClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpPointToPlaneConstraintDataAtomsClass(
		"hkpPointToPlaneConstraintDataAtoms",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpPointToPlaneConstraintData_AtomsClass_Members),
		HK_COUNT_OF(hkpPointToPlaneConstraintData_AtomsClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpPointToPlaneConstraintDataClass_Members[] =
	{
		{ "atoms", &hkpPointToPlaneConstraintDataAtomsClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::ALIGN_16, 0, HK_NULL }
	};
	hkClass hkpPointToPlaneConstraintDataClass(
		"hkpPointToPlaneConstraintData",
		&hkpConstraintDataClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpPointToPlaneConstraintDataClass_Members),
		HK_COUNT_OF(hkpPointToPlaneConstraintDataClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpBallAndSocketConstraintData_AtomsClass_Members[] =
	{
		{ "pivots", &hkpSetLocalTranslationsConstraintAtomClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "setupStabilization", &hkpSetupStabilizationAtomClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "ballSocket", &hkpBallSocketConstraintAtomClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpBallAndSocketConstraintDataAtomsClass(
		"hkpBallAndSocketConstraintDataAtoms",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpBallAndSocketConstraintData_AtomsClass_Members),
		HK_COUNT_OF(hkpBallAndSocketConstraintData_AtomsClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkpBallAndSocketConstraintDataClass_Members[] =
	{
		{ "atoms", &hkpBallAndSocketConstraintDataAtomsClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::ALIGN_16, 0, HK_NULL }
	};
	hkClass hkpBallAndSocketConstraintDataClass(
		"hkpBallAndSocketConstraintData",
		&hkpConstraintDataClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpBallAndSocketConstraintDataClass_Members),
		HK_COUNT_OF(hkpBallAndSocketConstraintDataClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpBreakableConstraintDataClass_Members[] =
	{
		{ "atoms", &hkpBridgeAtomsClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "constraintData", &hkpConstraintDataClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "childRuntimeSize", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "childNumSolverResults", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "solverResultLimit", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "removeWhenBroken", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "revertBackVelocityOnBreak", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpBreakableConstraintDataClass(
		"hkpBreakableConstraintData",
		&hkpConstraintDataClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpBreakableConstraintDataClass_Members),
		HK_COUNT_OF(hkpBreakableConstraintDataClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpActionClass_Members[] =
	{
		{ "world", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "island", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "userData", HK_NULL, HK_NULL, hkClassMember::TYPE_ULONG, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkpAction_DefaultStruct
		{
			int s_defaultOffsets[4];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
		};
		const hkpAction_DefaultStruct hkpAction_Default =
		{
			{-1,-1,hkClassMember::HK_CLASS_ZERO_DEFAULT,-1},
		};
	}
	hkClass hkpActionClass(
		"hkpAction",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpActionClass_Members),
		HK_COUNT_OF(hkpActionClass_Members),
		&hkpAction_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpSpringDamperConstraintMotorClass_Members[] =
	{
		{ "springConstant", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "springDamping", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpSpringDamperConstraintMotorClass(
		"hkpSpringDamperConstraintMotor",
		&hkpLimitedForceConstraintMotorClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpSpringDamperConstraintMotorClass_Members),
		HK_COUNT_OF(hkpSpringDamperConstraintMotorClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpLinearParametricCurveClass_Members[] =
	{
		{ "smoothingFactor", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "closedLoop", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "dirNotParallelToTangentAlongWholePath", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "points", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_VECTOR4, 0, 0, 0, HK_NULL },
		{ "distance", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_REAL, 0, 0, 0, HK_NULL }
	};
	hkClass hkpLinearParametricCurveClass(
		"hkpLinearParametricCurve",
		&hkpParametricCurveClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpLinearParametricCurveClass_Members),
		HK_COUNT_OF(hkpLinearParametricCurveClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpCogWheelConstraintData_AtomsClass_Members[] =
	{
		{ "transforms", &hkpSetLocalTransformsConstraintAtomClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "cogWheels", &hkpCogWheelConstraintAtomClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpCogWheelConstraintDataAtomsClass(
		"hkpCogWheelConstraintDataAtoms",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpCogWheelConstraintData_AtomsClass_Members),
		HK_COUNT_OF(hkpCogWheelConstraintData_AtomsClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpCogWheelConstraintDataClass_Members[] =
	{
		{ "atoms", &hkpCogWheelConstraintDataAtomsClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::ALIGN_16, 0, HK_NULL }
	};
	hkClass hkpCogWheelConstraintDataClass(
		"hkpCogWheelConstraintData",
		&hkpConstraintDataClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpCogWheelConstraintDataClass_Members),
		HK_COUNT_OF(hkpCogWheelConstraintDataClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpAabbPhantomClass_Members[] =
	{
		{ "aabb", &hkAabbClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "overlappingCollidables", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "orderDirty", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hkpAabbPhantomClass(
		"hkpAabbPhantom",
		&hkpPhantomClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpAabbPhantomClass_Members),
		HK_COUNT_OF(hkpAabbPhantomClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpDefaultWorldMemoryWatchDogClass_Members[] =
	{
		{ "freeHeapMemoryRequested", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpDefaultWorldMemoryWatchDogClass(
		"hkpDefaultWorldMemoryWatchDog",
		&hkWorldMemoryAvailableWatchDogClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpDefaultWorldMemoryWatchDogClass_Members),
		HK_COUNT_OF(hkpDefaultWorldMemoryWatchDogClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static const hkInternalClassEnumItem hkpHingeLimitsDataAtomsAxisEnumItems[] =
	{
		{0, "AXIS_AXLE"},
		{1, "AXIS_PERP_TO_AXLE_1"},
		{2, "AXIS_PERP_TO_AXLE_2"},
	};
	static const hkInternalClassEnum hkpHingeLimitsDataAtomsEnums[] = {
		{"Axis", hkpHingeLimitsDataAtomsAxisEnumItems, 3, HK_NULL, 0 }
	};
	const hkClassEnum* hkpHingeLimitsDataAtomsAxisEnum = reinterpret_cast<const hkClassEnum*>(&hkpHingeLimitsDataAtomsEnums[0]);
	static hkInternalClassMember hkpHingeLimitsData_AtomsClass_Members[] =
	{
		{ "rotations", &hkpSetLocalRotationsConstraintAtomClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "angLimit", &hkpAngLimitConstraintAtomClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "2dAng", &hkp2dAngConstraintAtomClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpHingeLimitsDataAtomsClass(
		"hkpHingeLimitsDataAtoms",
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkpHingeLimitsDataAtomsEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkpHingeLimitsData_AtomsClass_Members),
		HK_COUNT_OF(hkpHingeLimitsData_AtomsClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpHingeLimitsDataClass_Members[] =
	{
		{ "atoms", &hkpHingeLimitsDataAtomsClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::ALIGN_16, 0, HK_NULL }
	};
	hkClass hkpHingeLimitsDataClass(
		"hkpHingeLimitsData",
		&hkpConstraintDataClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpHingeLimitsDataClass_Members),
		HK_COUNT_OF(hkpHingeLimitsDataClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hkpListShapeBreakableMaterialClass(
		"hkpListShapeBreakableMaterial",
		&hkpBreakableMultiMaterialClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpBreakableMultiMaterial_InverseMappingDescriptorClass_Members[] =
	{
		{ "offset", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "numKeys", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpBreakableMultiMaterialInverseMappingDescriptorClass(
		"hkpBreakableMultiMaterialInverseMappingDescriptor",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpBreakableMultiMaterial_InverseMappingDescriptorClass_Members),
		HK_COUNT_OF(hkpBreakableMultiMaterial_InverseMappingDescriptorClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpBreakableMultiMaterial_InverseMappingClass_Members[] =
	{
		{ "descriptors", &hkpBreakableMultiMaterialInverseMappingDescriptorClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "subShapeIds", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT32, 0, 0, 0, HK_NULL }
	};
	hkClass hkpBreakableMultiMaterialInverseMappingClass(
		"hkpBreakableMultiMaterialInverseMapping",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpBreakableMultiMaterial_InverseMappingClass_Members),
		HK_COUNT_OF(hkpBreakableMultiMaterial_InverseMappingClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpBreakableMultiMaterialClass_Members[] =
	{
		{ "subMaterials", &hkpBreakableMaterialClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "inverseMapping", &hkpBreakableMultiMaterialInverseMappingClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkpBreakableMultiMaterialClass(
		"hkpBreakableMultiMaterial",
		&hkpBreakableMaterialClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpBreakableMultiMaterialClass_Members),
		HK_COUNT_OF(hkpBreakableMultiMaterialClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpLimitedForceConstraintMotorClass_Members[] =
	{
		{ "minForce", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxForce", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpLimitedForceConstraintMotorClass(
		"hkpLimitedForceConstraintMotor",
		&hkpConstraintMotorClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpLimitedForceConstraintMotorClass_Members),
		HK_COUNT_OF(hkpLimitedForceConstraintMotorClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hkpFixedRigidMotionClass(
		"hkpFixedRigidMotion",
		&hkpKeyframedRigidMotionClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpStiffSpringChainData_ConstraintInfoClass_Members[] =
	{
		{ "pivotInA", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "pivotInB", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "springLength", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpStiffSpringChainDataConstraintInfoClass(
		"hkpStiffSpringChainDataConstraintInfo",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpStiffSpringChainData_ConstraintInfoClass_Members),
		HK_COUNT_OF(hkpStiffSpringChainData_ConstraintInfoClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpStiffSpringChainDataClass_Members[] =
	{
		{ "atoms", &hkpBridgeAtomsClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "infos", &hkpStiffSpringChainDataConstraintInfoClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "tau", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "damping", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "cfm", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpStiffSpringChainDataClass(
		"hkpStiffSpringChainData",
		&hkpConstraintChainDataClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpStiffSpringChainDataClass_Members),
		HK_COUNT_OF(hkpStiffSpringChainDataClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hkpKeyframedRigidMotionClass(
		"hkpKeyframedRigidMotion",
		&hkpMotionClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hkpMaxSizeMotionClass(
		"hkpMaxSizeMotion",
		&hkpKeyframedRigidMotionClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkpRagdollLimitsDataAtomsAxisEnumItems[] =
	{
		{0, "AXIS_TWIST"},
		{1, "AXIS_PLANES"},
		{2, "AXIS_CROSS_PRODUCT"},
	};
	static const hkInternalClassEnum hkpRagdollLimitsDataAtomsEnums[] = {
		{"Axis", hkpRagdollLimitsDataAtomsAxisEnumItems, 3, HK_NULL, 0 }
	};
	const hkClassEnum* hkpRagdollLimitsDataAtomsAxisEnum = reinterpret_cast<const hkClassEnum*>(&hkpRagdollLimitsDataAtomsEnums[0]);
	static hkInternalClassMember hkpRagdollLimitsData_AtomsClass_Members[] =
	{
		{ "rotations", &hkpSetLocalRotationsConstraintAtomClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "twistLimit", &hkpTwistLimitConstraintAtomClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "coneLimit", &hkpConeLimitConstraintAtomClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "planesLimit", &hkpConeLimitConstraintAtomClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpRagdollLimitsDataAtomsClass(
		"hkpRagdollLimitsDataAtoms",
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkpRagdollLimitsDataAtomsEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkpRagdollLimitsData_AtomsClass_Members),
		HK_COUNT_OF(hkpRagdollLimitsData_AtomsClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpRagdollLimitsDataClass_Members[] =
	{
		{ "atoms", &hkpRagdollLimitsDataAtomsClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::ALIGN_16, 0, HK_NULL }
	};
	hkClass hkpRagdollLimitsDataClass(
		"hkpRagdollLimitsData",
		&hkpConstraintDataClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpRagdollLimitsDataClass_Members),
		HK_COUNT_OF(hkpRagdollLimitsDataClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpStiffSpringConstraintData_AtomsClass_Members[] =
	{
		{ "pivots", &hkpSetLocalTranslationsConstraintAtomClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "spring", &hkpStiffSpringConstraintAtomClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpStiffSpringConstraintDataAtomsClass(
		"hkpStiffSpringConstraintDataAtoms",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpStiffSpringConstraintData_AtomsClass_Members),
		HK_COUNT_OF(hkpStiffSpringConstraintData_AtomsClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpStiffSpringConstraintDataClass_Members[] =
	{
		{ "atoms", &hkpStiffSpringConstraintDataAtomsClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::ALIGN_16, 0, HK_NULL }
	};
	hkClass hkpStiffSpringConstraintDataClass(
		"hkpStiffSpringConstraintData",
		&hkpConstraintDataClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpStiffSpringConstraintDataClass_Members),
		HK_COUNT_OF(hkpStiffSpringConstraintDataClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkpMotionMotionTypeEnumItems[] =
	{
		{0, "MOTION_INVALID"},
		{1, "MOTION_DYNAMIC"},
		{2, "MOTION_SPHERE_INERTIA"},
		{3, "MOTION_BOX_INERTIA"},
		{4, "MOTION_KEYFRAMED"},
		{5, "MOTION_FIXED"},
		{6, "MOTION_THIN_BOX_INERTIA"},
		{7, "MOTION_CHARACTER"},
		{8, "MOTION_MAX_ID"},
	};
	static const hkInternalClassEnum hkpMotionEnums[] = {
		{"MotionType", hkpMotionMotionTypeEnumItems, 9, HK_NULL, 0 }
	};
	const hkClassEnum* hkpMotionMotionTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkpMotionEnums[0]);
	static hkInternalClassMember hkpMotionClass_Members[] =
	{
		{ "type", HK_NULL, hkpMotionMotionTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "deactivationIntegrateCounter", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "deactivationNumInactiveFrames", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 2, 0, 0, HK_NULL },
		{ "motionState", &hkMotionStateClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "inertiaAndMassInv", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "linearVelocity", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "angularVelocity", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "deactivationRefPosition", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 2, 0, 0, HK_NULL },
		{ "deactivationRefOrientation", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 2, 0, 0, HK_NULL },
		{ "savedMotion", &hkpMaxSizeMotionClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "savedQualityTypeIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "gravityFactor", HK_NULL, HK_NULL, hkClassMember::TYPE_HALF, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpMotionClass(
		"hkpMotion",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkpMotionEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkpMotionClass_Members),
		HK_COUNT_OF(hkpMotionClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(3)
		);
	static hkInternalClassMember hkpBreakableBody_ControllerClass_Members[] =
	{
		{ "breakingImpulse", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkpBreakableBodyController_DefaultStruct
		{
			int s_defaultOffsets[1];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkReal m_breakingImpulse;
		};
		const hkpBreakableBodyController_DefaultStruct hkpBreakableBodyController_Default =
		{
			{HK_OFFSET_OF(hkpBreakableBodyController_DefaultStruct,m_breakingImpulse)},
			-1.0f
		};
	}
	hkClass hkpBreakableBodyControllerClass(
		"hkpBreakableBodyController",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpBreakableBody_ControllerClass_Members),
		HK_COUNT_OF(hkpBreakableBody_ControllerClass_Members),
		&hkpBreakableBodyController_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpBreakableBodyClass_Members[] =
	{
		{ "controller", &hkpBreakableBodyControllerClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "breakableShape", &hkpBreakableShapeClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "bodyTypeAndFlags", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "constraintStrength", HK_NULL, HK_NULL, hkClassMember::TYPE_HALF, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkpBreakableBody_DefaultStruct
		{
			int s_defaultOffsets[4];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
		};
		const hkpBreakableBody_DefaultStruct hkpBreakableBody_Default =
		{
			{-1,-1,hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT},
		};
	}
	hkClass hkpBreakableBodyClass(
		"hkpBreakableBody",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpBreakableBodyClass_Members),
		HK_COUNT_OF(hkpBreakableBodyClass_Members),
		&hkpBreakableBody_Default,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static const hkInternalClassEnumItem hkpLimitedHingeConstraintDataAtomsAxisEnumItems[] =
	{
		{0, "AXIS_AXLE"},
		{1, "AXIS_PERP_TO_AXLE_1"},
		{2, "AXIS_PERP_TO_AXLE_2"},
	};
	static const hkInternalClassEnum hkpLimitedHingeConstraintDataAtomsEnums[] = {
		{"Axis", hkpLimitedHingeConstraintDataAtomsAxisEnumItems, 3, HK_NULL, 0 }
	};
	const hkClassEnum* hkpLimitedHingeConstraintDataAtomsAxisEnum = reinterpret_cast<const hkClassEnum*>(&hkpLimitedHingeConstraintDataAtomsEnums[0]);
	static hkInternalClassMember hkpLimitedHingeConstraintData_AtomsClass_Members[] =
	{
		{ "transforms", &hkpSetLocalTransformsConstraintAtomClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "setupStabilization", &hkpSetupStabilizationAtomClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "angMotor", &hkpAngMotorConstraintAtomClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "angFriction", &hkpAngFrictionConstraintAtomClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "angLimit", &hkpAngLimitConstraintAtomClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "2dAng", &hkp2dAngConstraintAtomClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "ballSocket", &hkpBallSocketConstraintAtomClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpLimitedHingeConstraintDataAtomsClass(
		"hkpLimitedHingeConstraintDataAtoms",
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkpLimitedHingeConstraintDataAtomsEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkpLimitedHingeConstraintData_AtomsClass_Members),
		HK_COUNT_OF(hkpLimitedHingeConstraintData_AtomsClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkpLimitedHingeConstraintDataClass_Members[] =
	{
		{ "atoms", &hkpLimitedHingeConstraintDataAtomsClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::ALIGN_16, 0, HK_NULL }
	};
	hkClass hkpLimitedHingeConstraintDataClass(
		"hkpLimitedHingeConstraintData",
		&hkpConstraintDataClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpLimitedHingeConstraintDataClass_Members),
		HK_COUNT_OF(hkpLimitedHingeConstraintDataClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpBreakableMaterialClass_Members[] =
	{
		{ "strength", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "typeAndFlags", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "properties", &hkRefCountedPropertiesClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkpBreakableMaterialClass(
		"hkpBreakableMaterial",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpBreakableMaterialClass_Members),
		HK_COUNT_OF(hkpBreakableMaterialClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpSimpleShapePhantomClass_Members[] =
	{
		{ "collisionDetails", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "orderDirty", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hkpSimpleShapePhantomClass(
		"hkpSimpleShapePhantom",
		&hkpShapePhantomClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpSimpleShapePhantomClass_Members),
		HK_COUNT_OF(hkpSimpleShapePhantomClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpBallSocketChainData_ConstraintInfoClass_Members[] =
	{
		{ "pivotInA", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "pivotInB", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpBallSocketChainDataConstraintInfoClass(
		"hkpBallSocketChainDataConstraintInfo",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpBallSocketChainData_ConstraintInfoClass_Members),
		HK_COUNT_OF(hkpBallSocketChainData_ConstraintInfoClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpBallSocketChainDataClass_Members[] =
	{
		{ "atoms", &hkpBridgeAtomsClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "infos", &hkpBallSocketChainDataConstraintInfoClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "tau", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "damping", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "cfm", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxErrorDistance", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpBallSocketChainDataClass(
		"hkpBallSocketChainData",
		&hkpConstraintChainDataClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpBallSocketChainDataClass_Members),
		HK_COUNT_OF(hkpBallSocketChainDataClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hkpConstraintCollisionFilterClass(
		"hkpConstraintCollisionFilter",
		&hkpPairCollisionFilterClass,
		0,
		HK_NULL,
		1,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hkpBoxMotionClass(
		"hkpBoxMotion",
		&hkpMotionClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpPositionConstraintMotorClass_Members[] =
	{
		{ "tau", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "damping", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "proportionalRecoveryVelocity", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "constantRecoveryVelocity", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpPositionConstraintMotorClass(
		"hkpPositionConstraintMotor",
		&hkpLimitedForceConstraintMotorClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpPositionConstraintMotorClass_Members),
		HK_COUNT_OF(hkpPositionConstraintMotorClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpMoppCodeReindexedTerminalClass_Members[] =
	{
		{ "origShapeKey", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "reindexedShapeKey", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpMoppCodeReindexedTerminalClass(
		"hkpMoppCodeReindexedTerminal",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpMoppCodeReindexedTerminalClass_Members),
		HK_COUNT_OF(hkpMoppCodeReindexedTerminalClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkpMoppCodeBuildTypeEnumItems[] =
	{
		{0, "BUILT_WITH_CHUNK_SUBDIVISION"},
		{1, "BUILT_WITHOUT_CHUNK_SUBDIVISION"},
		{2, "BUILD_NOT_SET"},
	};
	static const hkInternalClassEnum hkpMoppCodeEnums[] = {
		{"BuildType", hkpMoppCodeBuildTypeEnumItems, 3, HK_NULL, 0 }
	};
	const hkClassEnum* hkpMoppCodeBuildTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkpMoppCodeEnums[0]);
	static hkInternalClassMember hkpMoppCode_CodeInfoClass_Members[] =
	{
		{ "offset", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpMoppCodeCodeInfoClass(
		"hkpMoppCodeCodeInfo",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpMoppCode_CodeInfoClass_Members),
		HK_COUNT_OF(hkpMoppCode_CodeInfoClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpMoppCodeClass_Members[] =
	{
		{ "info", &hkpMoppCodeCodeInfoClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "data", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "buildType", HK_NULL, hkpMoppCodeBuildTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkpMoppCode_DefaultStruct
		{
			int s_defaultOffsets[3];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkInt8 /* hkEnum< enum hkpMoppCode::BuildType, hkInt8 > */ m_buildType;
		};
		const hkpMoppCode_DefaultStruct hkpMoppCode_Default =
		{
			{-1,-1,HK_OFFSET_OF(hkpMoppCode_DefaultStruct,m_buildType)},
			hkpMoppCode::BUILT_WITHOUT_CHUNK_SUBDIVISION
		};
	}
	hkClass hkpMoppCodeClass(
		"hkpMoppCode",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkpMoppCodeEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkpMoppCodeClass_Members),
		HK_COUNT_OF(hkpMoppCodeClass_Members),
		&hkpMoppCode_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpConvexPieceStreamDataClass_Members[] =
	{
		{ "convexPieceStream", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT32, 0, 0, 0, HK_NULL },
		{ "convexPieceOffsets", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT32, 0, 0, 0, HK_NULL },
		{ "convexPieceSingleTriangles", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT32, 0, 0, 0, HK_NULL }
	};
	hkClass hkpConvexPieceStreamDataClass(
		"hkpConvexPieceStreamData",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpConvexPieceStreamDataClass_Members),
		HK_COUNT_OF(hkpConvexPieceStreamDataClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkcdStaticMeshTreeBasePrimitiveDataRunBaseunsignedint_typenameClass_Members[] =
	{
		{ "value", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "index", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "count", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkcdStaticMeshTreeBasePrimitiveDataRunBaseunsignedintClass(
		"hkcdStaticMeshTreeBasePrimitiveDataRunBaseunsignedint",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkcdStaticMeshTreeBasePrimitiveDataRunBaseunsignedint_typenameClass_Members),
		HK_COUNT_OF(hkcdStaticMeshTreeBasePrimitiveDataRunBaseunsignedint_typenameClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkcdStaticMeshTreehkcdStaticMeshTreeCommonConfigunsignedintunsignedlonglong1121hkpBvCompressedMeshShapeTreeDataRun_typenameClass_Members[] =
	{
		{ "packedVertices", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT32, 0, 0, 0, HK_NULL },
		{ "sharedVertices", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT64, 0, 0, 0, HK_NULL },
		{ "primitiveDataRuns", &hkpBvCompressedMeshShapeTreeDataRunClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkcdStaticMeshTreehkcdStaticMeshTreeCommonConfigunsignedintunsignedlonglong1121hkpBvCompressedMeshShapeTreeDataRunClass(
		"hkcdStaticMeshTreehkcdStaticMeshTreeCommonConfigunsignedintunsignedlonglong1121hkpBvCompressedMeshShapeTreeDataRun",
		&hkcdStaticMeshTreeBaseClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkcdStaticMeshTreehkcdStaticMeshTreeCommonConfigunsignedintunsignedlonglong1121hkpBvCompressedMeshShapeTreeDataRun_typenameClass_Members),
		HK_COUNT_OF(hkcdStaticMeshTreehkcdStaticMeshTreeCommonConfigunsignedintunsignedlonglong1121hkpBvCompressedMeshShapeTreeDataRun_typenameClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpShapeKeyTable_BlockClass_Members[] =
	{
		{ "slots", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 63, 0|hkClassMember::ALIGN_16, 0, HK_NULL },
		{ "next", &hkpShapeKeyTableBlockClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkpShapeKeyTableBlockClass(
		"hkpShapeKeyTableBlock",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpShapeKeyTable_BlockClass_Members),
		HK_COUNT_OF(hkpShapeKeyTable_BlockClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpShapeKeyTableClass_Members[] =
	{
		{ "lists", &hkpShapeKeyTableBlockClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "occupancyBitField", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpShapeKeyTableClass(
		"hkpShapeKeyTable",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpShapeKeyTableClass_Members),
		HK_COUNT_OF(hkpShapeKeyTableClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpStaticCompoundShape_InstanceClass_Members[] =
	{
		{ "transform", HK_NULL, HK_NULL, hkClassMember::TYPE_QSTRANSFORM, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "shape", &hkpShapeClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "filterInfo", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "childFilterInfoMask", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "userData", HK_NULL, HK_NULL, hkClassMember::TYPE_ULONG, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpStaticCompoundShapeInstanceClass(
		"hkpStaticCompoundShapeInstance",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpStaticCompoundShape_InstanceClass_Members),
		HK_COUNT_OF(hkpStaticCompoundShape_InstanceClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpStaticCompoundShapeClass_Members[] =
	{
		{ "numBitsForChildShapeKey", HK_NULL, HK_NULL, hkClassMember::TYPE_INT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "childShapeKeyMask", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "instances", &hkpStaticCompoundShapeInstanceClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "instanceExtraInfos", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT16, 0, 0, 0, HK_NULL },
		{ "disabledLargeShapeKeyTable", &hkpShapeKeyTableClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "tree", &hkcdStaticTreeDefaultTreeStorage6Class, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::ALIGN_16, 0, HK_NULL }
	};
	hkClass hkpStaticCompoundShapeClass(
		"hkpStaticCompoundShape",
		&hkpBvTreeShapeClass,
		0,
		HK_NULL,
		1,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpStaticCompoundShapeClass_Members),
		HK_COUNT_OF(hkpStaticCompoundShapeClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hkpBvCompressedMeshShapeTreeDataRunClass(
		"hkpBvCompressedMeshShapeTreeDataRun",
		&hkcdStaticMeshTreeBasePrimitiveDataRunBaseunsignedintClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hkpBvCompressedMeshShapeTreeClass(
		"hkpBvCompressedMeshShapeTree",
		&hkcdStaticMeshTreehkcdStaticMeshTreeCommonConfigunsignedintunsignedlonglong1121hkpBvCompressedMeshShapeTreeDataRunClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpBvCompressedMeshShapeClass_Members[] =
	{
		{ "convexRadius", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "weldingType", HK_NULL, hkpWeldingUtilityWeldingTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "hasPerTriangleCollisionFilterInfo", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "hasPerTriangleUserData", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "collisionFilterInfoPalette", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT32, 0, 0, 0, HK_NULL },
		{ "userDataPalette", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT32, 0, 0, 0, HK_NULL },
		{ "tree", &hkpBvCompressedMeshShapeTreeClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::ALIGN_16, 0, HK_NULL }
	};
	namespace
	{
		struct hkpBvCompressedMeshShape_DefaultStruct
		{
			int s_defaultOffsets[7];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkUint8 /* hkEnum< enum hkpWeldingUtility::WeldingType, hkUint8 > */ m_weldingType;
		};
		const hkpBvCompressedMeshShape_DefaultStruct hkpBvCompressedMeshShape_Default =
		{
			{-1,HK_OFFSET_OF(hkpBvCompressedMeshShape_DefaultStruct,m_weldingType),-1,-1,-1,-1,-1},
			hkpWeldingUtility::WELDING_TYPE_NONE
		};
	}
	hkClass hkpBvCompressedMeshShapeClass(
		"hkpBvCompressedMeshShape",
		&hkpBvTreeShapeClass,
		0,
		HK_NULL,
		1,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpBvCompressedMeshShapeClass_Members),
		HK_COUNT_OF(hkpBvCompressedMeshShapeClass_Members),
		&hkpBvCompressedMeshShape_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpDisableEntityCollisionFilterClass_Members[] =
	{
		{ "disabledEntities", &hkpEntityClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL }
	};
	hkClass hkpDisableEntityCollisionFilterClass(
		"hkpDisableEntityCollisionFilter",
		&hkpCollisionFilterClass,
		0,
		HK_NULL,
		1,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpDisableEntityCollisionFilterClass_Members),
		HK_COUNT_OF(hkpDisableEntityCollisionFilterClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpSpringActionClass_Members[] =
	{
		{ "lastForce", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "positionAinA", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "positionBinB", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "restLength", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "strength", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "damping", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "onCompression", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "onExtension", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkpSpringAction_DefaultStruct
		{
			int s_defaultOffsets[8];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkReal m_restLength;
			hkReal m_strength;
			hkReal m_damping;
			_hkBool m_onCompression;
			_hkBool m_onExtension;
		};
		const hkpSpringAction_DefaultStruct hkpSpringAction_Default =
		{
			{-1,-1,-1,HK_OFFSET_OF(hkpSpringAction_DefaultStruct,m_restLength),HK_OFFSET_OF(hkpSpringAction_DefaultStruct,m_strength),HK_OFFSET_OF(hkpSpringAction_DefaultStruct,m_damping),HK_OFFSET_OF(hkpSpringAction_DefaultStruct,m_onCompression),HK_OFFSET_OF(hkpSpringAction_DefaultStruct,m_onExtension)},
			1.0f,1000.0f,0.1f,true,true
		};
	}
	hkClass hkpSpringActionClass(
		"hkpSpringAction",
		&hkpBinaryActionClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpSpringActionClass_Members),
		HK_COUNT_OF(hkpSpringActionClass_Members),
		&hkpSpringAction_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hkpCharacterControllerCinfoClass(
		"hkpCharacterControllerCinfo",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpReorientActionClass_Members[] =
	{
		{ "rotationAxis", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "upAxis", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "strength", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "damping", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpReorientActionClass(
		"hkpReorientAction",
		&hkpUnaryActionClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpReorientActionClass_Members),
		HK_COUNT_OF(hkpReorientActionClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpPhysicsDataClass_Members[] =
	{
		{ "worldCinfo", &hkpWorldCinfoClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "systems", &hkpPhysicsSystemClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL }
	};
	hkClass hkpPhysicsDataClass(
		"hkpPhysicsData",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpPhysicsDataClass_Members),
		HK_COUNT_OF(hkpPhysicsDataClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkpFirstPersonGunTypeEnumItems[] =
	{
		{0, "WEAPON_TYPE_INVALID"},
		{1, "WEAPON_TYPE_BALLGUN"},
		{2, "WEAPON_TYPE_GRENADEGUN"},
		{3, "WEAPON_TYPE_GRAVITYGUN"},
		{4, "WEAPON_TYPE_MOUNTEDBALLGUN"},
		{5, "WEAPON_TYPE_TWEAKERGUN"},
		{6, "WEAPON_TYPE_MISSILEGUN"},
		{7, "WEAPON_TYPE_RAYCASTGUN"},
		{8, "WEAPON_TYPE_SPHEREGUN"},
		{9, "WEAPON_TYPE_STICKYGUN"},
		{10, "WEAPON_TYPE_NUM_TYPES"},
	};
	static const hkInternalClassEnumItem hkpFirstPersonGunKeyboardKeyEnumItems[] =
	{
		{112, "KEY_F1"},
		{113, "KEY_F2"},
		{114, "KEY_F3"},
		{115, "KEY_F4"},
		{116, "KEY_F5"},
		{117, "KEY_F6"},
		{118, "KEY_F7"},
		{119, "KEY_F8"},
		{120, "KEY_F9"},
		{121, "KEY_F10"},
		{122, "KEY_F11"},
		{123, "KEY_F12"},
	};
	static const hkInternalClassEnum hkpFirstPersonGunEnums[] = {
		{"Type", hkpFirstPersonGunTypeEnumItems, 11, HK_NULL, 0 },
		{"KeyboardKey", hkpFirstPersonGunKeyboardKeyEnumItems, 12, HK_NULL, 0 }
	};
	const hkClassEnum* hkpFirstPersonGunTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkpFirstPersonGunEnums[0]);
	const hkClassEnum* hkpFirstPersonGunKeyboardKeyEnum = reinterpret_cast<const hkClassEnum*>(&hkpFirstPersonGunEnums[1]);
	static hkInternalClassMember hkpFirstPersonGunClass_Members[] =
	{
		{ "type", HK_NULL, HK_NULL, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "name", HK_NULL, HK_NULL, hkClassMember::TYPE_STRINGPTR, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "keyboardKey", HK_NULL, hkpFirstPersonGunKeyboardKeyEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "listeners", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	namespace
	{
		struct hkpFirstPersonGun_DefaultStruct
		{
			int s_defaultOffsets[4];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			const char* /* hkStringPtr */ m_name;
			hkUint8 /* hkEnum< enum hkpFirstPersonGun::KeyboardKey, hkUint8 > */ m_keyboardKey;
		};
		const hkpFirstPersonGun_DefaultStruct hkpFirstPersonGun_Default =
		{
			{-1,HK_OFFSET_OF(hkpFirstPersonGun_DefaultStruct,m_name),HK_OFFSET_OF(hkpFirstPersonGun_DefaultStruct,m_keyboardKey),-1},
			"",hkpFirstPersonGun::KEY_F2
		};
	}
	hkClass hkpFirstPersonGunClass(
		"hkpFirstPersonGun",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkpFirstPersonGunEnums),
		2,
		reinterpret_cast<const hkClassMember*>(hkpFirstPersonGunClass_Members),
		HK_COUNT_OF(hkpFirstPersonGunClass_Members),
		&hkpFirstPersonGun_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkpTriggerVolumeEventTypeEnumItems[] =
	{
		{1, "ENTERED_EVENT"},
		{2, "LEFT_EVENT"},
		{3, "ENTERED_AND_LEFT_EVENT"},
		{6, "TRIGGER_BODY_LEFT_EVENT"},
	};
	static const hkInternalClassEnumItem hkpTriggerVolumeOperationEnumItems[] =
	{
		{0, "ADDED_OP"},
		{1, "REMOVED_OP"},
		{2, "CONTACT_OP"},
		{3, "TOI_OP"},
	};
	static const hkInternalClassEnum hkpTriggerVolumeEnums[] = {
		{"EventType", hkpTriggerVolumeEventTypeEnumItems, 4, HK_NULL, 0 },
		{"Operation", hkpTriggerVolumeOperationEnumItems, 4, HK_NULL, 0 }
	};
	const hkClassEnum* hkpTriggerVolumeEventTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkpTriggerVolumeEnums[0]);
	const hkClassEnum* hkpTriggerVolumeOperationEnum = reinterpret_cast<const hkClassEnum*>(&hkpTriggerVolumeEnums[1]);
	static hkInternalClassMember hkpTriggerVolume_EventInfoClass_Members[] =
	{
		{ "sortValue", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT64, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "body", &hkpRigidBodyClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "operation", HK_NULL, hkpTriggerVolumeOperationEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT32, 0, 0, 0, HK_NULL }
	};
	hkClass hkpTriggerVolumeEventInfoClass(
		"hkpTriggerVolumeEventInfo",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpTriggerVolume_EventInfoClass_Members),
		HK_COUNT_OF(hkpTriggerVolume_EventInfoClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpTriggerVolumeClass_Members[] =
	{
		{ "overlappingBodies", &hkpRigidBodyClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "eventQueue", &hkpTriggerVolumeEventInfoClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "triggerBody", &hkpRigidBodyClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "sequenceNumber", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpTriggerVolumeClass(
		"hkpTriggerVolume",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		3,
		reinterpret_cast<const hkClassEnum*>(hkpTriggerVolumeEnums),
		2,
		reinterpret_cast<const hkClassMember*>(hkpTriggerVolumeClass_Members),
		HK_COUNT_OF(hkpTriggerVolumeClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpCharacterProxyCinfoClass_Members[] =
	{
		{ "position", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "velocity", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "dynamicFriction", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "staticFriction", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "keepContactTolerance", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "up", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "extraUpStaticFriction", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "extraDownStaticFriction", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "shapePhantom", &hkpShapePhantomClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "keepDistance", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "contactAngleSensitivity", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "userPlanes", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxCharacterSpeedForSolver", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "characterStrength", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "characterMass", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxSlope", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "penetrationRecoverySpeed", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxCastIterations", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "refreshManifoldInCheckSupport", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkpCharacterProxyCinfo_DefaultStruct
		{
			int s_defaultOffsets[19];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkReal m_dynamicFriction;
			hkReal m_keepContactTolerance;
			hkReal m_keepDistance;
			hkReal m_contactAngleSensitivity;
			hkUint32 m_userPlanes;
			hkReal m_maxCharacterSpeedForSolver;
			hkReal m_characterStrength;
			hkReal m_maxSlope;
			hkReal m_penetrationRecoverySpeed;
			hkInt32 m_maxCastIterations;
		};
		const hkpCharacterProxyCinfo_DefaultStruct hkpCharacterProxyCinfo_Default =
		{
			{-1,-1,HK_OFFSET_OF(hkpCharacterProxyCinfo_DefaultStruct,m_dynamicFriction),hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkpCharacterProxyCinfo_DefaultStruct,m_keepContactTolerance),-1,-1,-1,-1,HK_OFFSET_OF(hkpCharacterProxyCinfo_DefaultStruct,m_keepDistance),HK_OFFSET_OF(hkpCharacterProxyCinfo_DefaultStruct,m_contactAngleSensitivity),HK_OFFSET_OF(hkpCharacterProxyCinfo_DefaultStruct,m_userPlanes),HK_OFFSET_OF(hkpCharacterProxyCinfo_DefaultStruct,m_maxCharacterSpeedForSolver),HK_OFFSET_OF(hkpCharacterProxyCinfo_DefaultStruct,m_characterStrength),hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkpCharacterProxyCinfo_DefaultStruct,m_maxSlope),HK_OFFSET_OF(hkpCharacterProxyCinfo_DefaultStruct,m_penetrationRecoverySpeed),HK_OFFSET_OF(hkpCharacterProxyCinfo_DefaultStruct,m_maxCastIterations),hkClassMember::HK_CLASS_ZERO_DEFAULT},
			1.0f,0.1f,0.05f,10,4,10,7.9E+28f,1.57079633f,1.0f,10
		};
	}
	hkClass hkpCharacterProxyCinfoClass(
		"hkpCharacterProxyCinfo",
		&hkpCharacterControllerCinfoClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpCharacterProxyCinfoClass_Members),
		HK_COUNT_OF(hkpCharacterProxyCinfoClass_Members),
		&hkpCharacterProxyCinfo_Default,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkpAngularDashpotActionClass_Members[] =
	{
		{ "rotation", HK_NULL, HK_NULL, hkClassMember::TYPE_QUATERNION, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "strength", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "damping", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpAngularDashpotActionClass(
		"hkpAngularDashpotAction",
		&hkpBinaryActionClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpAngularDashpotActionClass_Members),
		HK_COUNT_OF(hkpAngularDashpotActionClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpMouseSpringActionClass_Members[] =
	{
		{ "positionInRbLocal", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "mousePositionInWorld", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "springDamping", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "springElasticity", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxRelativeForce", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "objectDamping", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "shapeKey", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "applyCallbacks", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hkpMouseSpringActionClass(
		"hkpMouseSpringAction",
		&hkpUnaryActionClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpMouseSpringActionClass_Members),
		HK_COUNT_OF(hkpMouseSpringActionClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpGravityGunClass_Members[] =
	{
		{ "grabbedBodies", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "maxNumObjectsPicked", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxMassOfObjectPicked", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxDistOfObjectPicked", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "impulseAppliedWhenObjectNotPicked", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "throwVelocity", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "capturedObjectPosition", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "capturedObjectsOffset", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkpGravityGun_DefaultStruct
		{
			int s_defaultOffsets[8];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkInt32 m_maxNumObjectsPicked;
			hkReal m_maxMassOfObjectPicked;
			hkReal m_maxDistOfObjectPicked;
			hkReal m_impulseAppliedWhenObjectNotPicked;
			hkReal m_throwVelocity;
			_hkVector4 m_capturedObjectPosition;
			_hkVector4 m_capturedObjectsOffset;
		};
		const hkpGravityGun_DefaultStruct hkpGravityGun_Default =
		{
			{-1,HK_OFFSET_OF(hkpGravityGun_DefaultStruct,m_maxNumObjectsPicked),HK_OFFSET_OF(hkpGravityGun_DefaultStruct,m_maxMassOfObjectPicked),HK_OFFSET_OF(hkpGravityGun_DefaultStruct,m_maxDistOfObjectPicked),HK_OFFSET_OF(hkpGravityGun_DefaultStruct,m_impulseAppliedWhenObjectNotPicked),HK_OFFSET_OF(hkpGravityGun_DefaultStruct,m_throwVelocity),HK_OFFSET_OF(hkpGravityGun_DefaultStruct,m_capturedObjectPosition),HK_OFFSET_OF(hkpGravityGun_DefaultStruct,m_capturedObjectsOffset)},
	10,200.0f,50.0f,100.0f,50.0f,	{2.5f,0.6f,0.0f},	{0.0f,1.0f,0.0f}
		};
	}
	hkClass hkpGravityGunClass(
		"hkpGravityGun",
		&hkpFirstPersonGunClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpGravityGunClass_Members),
		HK_COUNT_OF(hkpGravityGunClass_Members),
		&hkpGravityGun_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpBallGunClass_Members[] =
	{
		{ "bulletRadius", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "bulletVelocity", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "bulletMass", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "damageMultiplier", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxBulletsInWorld", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "bulletOffsetFromCenter", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "addedBodies", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	namespace
	{
		struct hkpBallGun_DefaultStruct
		{
			int s_defaultOffsets[7];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkReal m_bulletRadius;
			hkReal m_bulletVelocity;
			hkReal m_bulletMass;
			hkReal m_damageMultiplier;
			hkInt32 m_maxBulletsInWorld;
			_hkVector4 m_bulletOffsetFromCenter;
		};
		const hkpBallGun_DefaultStruct hkpBallGun_Default =
		{
			{HK_OFFSET_OF(hkpBallGun_DefaultStruct,m_bulletRadius),HK_OFFSET_OF(hkpBallGun_DefaultStruct,m_bulletVelocity),HK_OFFSET_OF(hkpBallGun_DefaultStruct,m_bulletMass),HK_OFFSET_OF(hkpBallGun_DefaultStruct,m_damageMultiplier),HK_OFFSET_OF(hkpBallGun_DefaultStruct,m_maxBulletsInWorld),HK_OFFSET_OF(hkpBallGun_DefaultStruct,m_bulletOffsetFromCenter),-1},
		0.2f,40.0f,50.0f,50.0f,100,	{0.0f,0.0f,0.0f}
		};
	}
	hkClass hkpBallGunClass(
		"hkpBallGun",
		&hkpFirstPersonGunClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpBallGunClass_Members),
		HK_COUNT_OF(hkpBallGunClass_Members),
		&hkpBallGun_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpConstrainedSystemFilterClass_Members[] =
	{
		{ "otherFilter", &hkpCollisionFilterClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkpConstrainedSystemFilterClass(
		"hkpConstrainedSystemFilter",
		&hkpCollisionFilterClass,
		0,
		HK_NULL,
		1,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpConstrainedSystemFilterClass_Members),
		HK_COUNT_OF(hkpConstrainedSystemFilterClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpSerializedTrack1nInfoClass_Members[] =
	{
		{ "sectors", &hkpAgent1nSectorClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "subTracks", &hkpSerializedSubTrack1nInfoClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL }
	};
	hkClass hkpSerializedTrack1nInfoClass(
		"hkpSerializedTrack1nInfo",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpSerializedTrack1nInfoClass_Members),
		HK_COUNT_OF(hkpSerializedTrack1nInfoClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpSerializedSubTrack1nInfoClass_Members[] =
	{
		{ "sectorIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "offsetInSector", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpSerializedSubTrack1nInfoClass(
		"hkpSerializedSubTrack1nInfo",
		&hkpSerializedTrack1nInfoClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpSerializedSubTrack1nInfoClass_Members),
		HK_COUNT_OF(hkpSerializedSubTrack1nInfoClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkpSerializedAgentNnEntrySerializedAgentTypeEnumItems[] =
	{
		{0, "INVALID_AGENT_TYPE"},
		{1, "BOX_BOX_AGENT3"},
		{2, "CAPSULE_TRIANGLE_AGENT3"},
		{3, "PRED_GSK_AGENT3"},
		{4, "PRED_GSK_CYLINDER_AGENT3"},
		{5, "CONVEX_LIST_AGENT3"},
		{6, "LIST_AGENT3"},
		{7, "BV_TREE_AGENT3"},
		{8, "COLLECTION_COLLECTION_AGENT3"},
		{9, "COLLECTION_AGENT3"},
	};
	static const hkInternalClassEnum hkpSerializedAgentNnEntryEnums[] = {
		{"SerializedAgentType", hkpSerializedAgentNnEntrySerializedAgentTypeEnumItems, 10, HK_NULL, 0 }
	};
	const hkClassEnum* hkpSerializedAgentNnEntrySerializedAgentTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkpSerializedAgentNnEntryEnums[0]);
	static hkInternalClassMember hkpSerializedAgentNnEntryClass_Members[] =
	{
		{ "bodyA", &hkpEntityClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "bodyB", &hkpEntityClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "bodyAId", HK_NULL, HK_NULL, hkClassMember::TYPE_ULONG, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "bodyBId", HK_NULL, HK_NULL, hkClassMember::TYPE_ULONG, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "useEntityIds", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "agentType", HK_NULL, hkpSerializedAgentNnEntrySerializedAgentTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL },
		{ "atom", &hkpSimpleContactConstraintAtomClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "propertiesStream", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "contactPoints", &hkContactPointClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "cpIdMgr", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_UINT8, 0, 0, 0, HK_NULL },
		{ "nnEntryData", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 160, 0, 0, HK_NULL },
		{ "trackInfo", &hkpSerializedTrack1nInfoClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "endianCheckBuffer", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 4, 0, 0, HK_NULL },
		{ "version", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpSerializedAgentNnEntryClass(
		"hkpSerializedAgentNnEntry",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkpSerializedAgentNnEntryEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkpSerializedAgentNnEntryClass_Members),
		HK_COUNT_OF(hkpSerializedAgentNnEntryClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpGroupCollisionFilterClass_Members[] =
	{
		{ "noGroupCollisionEnabled", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "collisionGroups", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 32, 0, 0, HK_NULL }
	};
	hkClass hkpGroupCollisionFilterClass(
		"hkpGroupCollisionFilter",
		&hkpCollisionFilterClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpGroupCollisionFilterClass_Members),
		HK_COUNT_OF(hkpGroupCollisionFilterClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpPoweredChainMapper_TargetClass_Members[] =
	{
		{ "chain", &hkpPoweredChainDataClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "infoIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpPoweredChainMapperTargetClass(
		"hkpPoweredChainMapperTarget",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpPoweredChainMapper_TargetClass_Members),
		HK_COUNT_OF(hkpPoweredChainMapper_TargetClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpPoweredChainMapper_LinkInfoClass_Members[] =
	{
		{ "firstTargetIdx", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "numTargets", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "limitConstraint", &hkpConstraintInstanceClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkpPoweredChainMapperLinkInfoClass(
		"hkpPoweredChainMapperLinkInfo",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpPoweredChainMapper_LinkInfoClass_Members),
		HK_COUNT_OF(hkpPoweredChainMapper_LinkInfoClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpPoweredChainMapperClass_Members[] =
	{
		{ "links", &hkpPoweredChainMapperLinkInfoClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "targets", &hkpPoweredChainMapperTargetClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "chains", &hkpConstraintChainInstanceClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL }
	};
	hkClass hkpPoweredChainMapperClass(
		"hkpPoweredChainMapper",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpPoweredChainMapperClass_Members),
		HK_COUNT_OF(hkpPoweredChainMapperClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpDashpotActionClass_Members[] =
	{
		{ "point", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 2, 0, 0, HK_NULL },
		{ "strength", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "damping", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "impulse", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpDashpotActionClass(
		"hkpDashpotAction",
		&hkpBinaryActionClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpDashpotActionClass_Members),
		HK_COUNT_OF(hkpDashpotActionClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpSerializedDisplayMarkerListClass_Members[] =
	{
		{ "markers", &hkpSerializedDisplayMarkerClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL }
	};
	hkClass hkpSerializedDisplayMarkerListClass(
		"hkpSerializedDisplayMarkerList",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpSerializedDisplayMarkerListClass_Members),
		HK_COUNT_OF(hkpSerializedDisplayMarkerListClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpCharacterRigidBodyCinfoClass_Members[] =
	{
		{ "collisionFilterInfo", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "shape", &hkpShapeClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "position", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "rotation", HK_NULL, HK_NULL, hkClassMember::TYPE_QUATERNION, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "mass", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "friction", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxLinearVelocity", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "allowedPenetrationDepth", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "up", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxSlope", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxForce", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "unweldingHeightOffsetFactor", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxSpeedForSimplexSolver", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "supportDistance", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "hardSupportDistance", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "vdbColor", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkpCharacterRigidBodyCinfo_DefaultStruct
		{
			int s_defaultOffsets[16];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkReal m_mass;
			hkReal m_maxLinearVelocity;
			hkReal m_allowedPenetrationDepth;
			hkReal m_maxSlope;
			hkReal m_maxForce;
			hkReal m_unweldingHeightOffsetFactor;
			hkReal m_maxSpeedForSimplexSolver;
			hkReal m_supportDistance;
		};
		const hkpCharacterRigidBodyCinfo_DefaultStruct hkpCharacterRigidBodyCinfo_Default =
		{
			{-1,-1,-1,-1,HK_OFFSET_OF(hkpCharacterRigidBodyCinfo_DefaultStruct,m_mass),hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkpCharacterRigidBodyCinfo_DefaultStruct,m_maxLinearVelocity),HK_OFFSET_OF(hkpCharacterRigidBodyCinfo_DefaultStruct,m_allowedPenetrationDepth),-1,HK_OFFSET_OF(hkpCharacterRigidBodyCinfo_DefaultStruct,m_maxSlope),HK_OFFSET_OF(hkpCharacterRigidBodyCinfo_DefaultStruct,m_maxForce),HK_OFFSET_OF(hkpCharacterRigidBodyCinfo_DefaultStruct,m_unweldingHeightOffsetFactor),HK_OFFSET_OF(hkpCharacterRigidBodyCinfo_DefaultStruct,m_maxSpeedForSimplexSolver),HK_OFFSET_OF(hkpCharacterRigidBodyCinfo_DefaultStruct,m_supportDistance),hkClassMember::HK_CLASS_ZERO_DEFAULT,-1},
			100.0f,20.0f,-0.1f,1.04719755f,1000.0f,0.5f,10.0f,0.1f
		};
	}
	hkClass hkpCharacterRigidBodyCinfoClass(
		"hkpCharacterRigidBodyCinfo",
		&hkpCharacterControllerCinfoClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpCharacterRigidBodyCinfoClass_Members),
		HK_COUNT_OF(hkpCharacterRigidBodyCinfoClass_Members),
		&hkpCharacterRigidBodyCinfo_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpMountedBallGunClass_Members[] =
	{
		{ "position", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkpMountedBallGun_DefaultStruct
		{
			int s_defaultOffsets[1];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			_hkVector4 m_position;
		};
		const hkpMountedBallGun_DefaultStruct hkpMountedBallGun_Default =
		{
			{HK_OFFSET_OF(hkpMountedBallGun_DefaultStruct,m_position)},
			{0.0f,100.0f,0.0f}
		};
	}
	hkClass hkpMountedBallGunClass(
		"hkpMountedBallGun",
		&hkpBallGunClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpMountedBallGunClass_Members),
		HK_COUNT_OF(hkpMountedBallGunClass_Members),
		&hkpMountedBallGun_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpSerializedDisplayMarkerClass_Members[] =
	{
		{ "transform", HK_NULL, HK_NULL, hkClassMember::TYPE_TRANSFORM, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpSerializedDisplayMarkerClass(
		"hkpSerializedDisplayMarker",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpSerializedDisplayMarkerClass_Members),
		HK_COUNT_OF(hkpSerializedDisplayMarkerClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpDisplayBindingData_RigidBodyClass_Members[] =
	{
		{ "rigidBody", &hkpRigidBodyClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "displayObjectPtr", &hkReferencedObjectClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "rigidBodyFromDisplayObjectTransform", HK_NULL, HK_NULL, hkClassMember::TYPE_MATRIX4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpDisplayBindingDataRigidBodyClass(
		"hkpDisplayBindingDataRigidBody",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpDisplayBindingData_RigidBodyClass_Members),
		HK_COUNT_OF(hkpDisplayBindingData_RigidBodyClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(2)
		);
	static hkInternalClassMember hkpDisplayBindingData_PhysicsSystemClass_Members[] =
	{
		{ "bindings", &hkpDisplayBindingDataRigidBodyClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "system", &hkpPhysicsSystemClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkpDisplayBindingDataPhysicsSystemClass(
		"hkpDisplayBindingDataPhysicsSystem",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpDisplayBindingData_PhysicsSystemClass_Members),
		HK_COUNT_OF(hkpDisplayBindingData_PhysicsSystemClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkpDisplayBindingDataClass_Members[] =
	{
		{ "rigidBodyBindings", &hkpDisplayBindingDataRigidBodyClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL },
		{ "physicsSystemBindings", &hkpDisplayBindingDataPhysicsSystemClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL }
	};
	hkClass hkpDisplayBindingDataClass(
		"hkpDisplayBindingData",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpDisplayBindingDataClass_Members),
		HK_COUNT_OF(hkpDisplayBindingDataClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkpSerializedDisplayRbTransforms_DisplayTransformPairClass_Members[] =
	{
		{ "rb", &hkpRigidBodyClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "localToDisplay", HK_NULL, HK_NULL, hkClassMember::TYPE_TRANSFORM, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpSerializedDisplayRbTransformsDisplayTransformPairClass(
		"hkpSerializedDisplayRbTransformsDisplayTransformPair",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpSerializedDisplayRbTransforms_DisplayTransformPairClass_Members),
		HK_COUNT_OF(hkpSerializedDisplayRbTransforms_DisplayTransformPairClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpSerializedDisplayRbTransformsClass_Members[] =
	{
		{ "transforms", &hkpSerializedDisplayRbTransformsDisplayTransformPairClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkpSerializedDisplayRbTransformsClass(
		"hkpSerializedDisplayRbTransforms",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpSerializedDisplayRbTransformsClass_Members),
		HK_COUNT_OF(hkpSerializedDisplayRbTransformsClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpMotorActionClass_Members[] =
	{
		{ "axis", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "spinRate", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "gain", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "active", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpMotorActionClass(
		"hkpMotorAction",
		&hkpUnaryActionClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpMotorActionClass_Members),
		HK_COUNT_OF(hkpMotorActionClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpPhysicsSystemWithContactsClass_Members[] =
	{
		{ "contacts", &hkpSerializedAgentNnEntryClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL }
	};
	hkClass hkpPhysicsSystemWithContactsClass(
		"hkpPhysicsSystemWithContacts",
		&hkpPhysicsSystemClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpPhysicsSystemWithContactsClass_Members),
		HK_COUNT_OF(hkpPhysicsSystemWithContactsClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpProjectileGunClass_Members[] =
	{
		{ "maxProjectiles", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "reloadTime", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "reload", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "projectiles", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "world", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "destructionWorld", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	namespace
	{
		struct hkpProjectileGun_DefaultStruct
		{
			int s_defaultOffsets[6];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkInt32 m_maxProjectiles;
			hkReal m_reloadTime;
		};
		const hkpProjectileGun_DefaultStruct hkpProjectileGun_Default =
		{
			{HK_OFFSET_OF(hkpProjectileGun_DefaultStruct,m_maxProjectiles),HK_OFFSET_OF(hkpProjectileGun_DefaultStruct,m_reloadTime),-1,-1,-1,-1},
			5,0.3f
		};
	}
	hkClass hkpProjectileGunClass(
		"hkpProjectileGun",
		&hkpFirstPersonGunClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpProjectileGunClass_Members),
		HK_COUNT_OF(hkpProjectileGunClass_Members),
		&hkpProjectileGun_Default,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpVehicleSuspension_SuspensionWheelParametersClass_Members[] =
	{
		{ "hardpointChassisSpace", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "directionChassisSpace", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "length", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpVehicleSuspensionSuspensionWheelParametersClass(
		"hkpVehicleSuspensionSuspensionWheelParameters",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpVehicleSuspension_SuspensionWheelParametersClass_Members),
		HK_COUNT_OF(hkpVehicleSuspension_SuspensionWheelParametersClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpVehicleSuspensionClass_Members[] =
	{
		{ "wheelParams", &hkpVehicleSuspensionSuspensionWheelParametersClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkpVehicleSuspensionClass(
		"hkpVehicleSuspension",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpVehicleSuspensionClass_Members),
		HK_COUNT_OF(hkpVehicleSuspensionClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpTyremarkPointClass_Members[] =
	{
		{ "pointLeft", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "pointRight", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpTyremarkPointClass(
		"hkpTyremarkPoint",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpTyremarkPointClass_Members),
		HK_COUNT_OF(hkpTyremarkPointClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpTyremarksWheelClass_Members[] =
	{
		{ "currentPosition", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "numPoints", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "tyremarkPoints", &hkpTyremarkPointClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkpTyremarksWheelClass(
		"hkpTyremarksWheel",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpTyremarksWheelClass_Members),
		HK_COUNT_OF(hkpTyremarksWheelClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpTyremarksInfoClass_Members[] =
	{
		{ "minTyremarkEnergy", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxTyremarkEnergy", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "tyremarksWheel", &hkpTyremarksWheelClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL }
	};
	hkClass hkpTyremarksInfoClass(
		"hkpTyremarksInfo",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpTyremarksInfoClass_Members),
		HK_COUNT_OF(hkpTyremarksInfoClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpVehicleDefaultBrake_WheelBrakingPropertiesClass_Members[] =
	{
		{ "maxBreakingTorque", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "minPedalInputToBlock", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "isConnectedToHandbrake", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpVehicleDefaultBrakeWheelBrakingPropertiesClass(
		"hkpVehicleDefaultBrakeWheelBrakingProperties",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpVehicleDefaultBrake_WheelBrakingPropertiesClass_Members),
		HK_COUNT_OF(hkpVehicleDefaultBrake_WheelBrakingPropertiesClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpVehicleDefaultBrakeClass_Members[] =
	{
		{ "wheelBrakingProperties", &hkpVehicleDefaultBrakeWheelBrakingPropertiesClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "wheelsMinTimeToBlock", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpVehicleDefaultBrakeClass(
		"hkpVehicleDefaultBrake",
		&hkpVehicleBrakeClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpVehicleDefaultBrakeClass_Members),
		HK_COUNT_OF(hkpVehicleDefaultBrakeClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpVehicleDefaultTransmissionClass_Members[] =
	{
		{ "downshiftRPM", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "upshiftRPM", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "primaryTransmissionRatio", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "clutchDelayTime", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "reverseGearRatio", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "gearsRatio", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_REAL, 0, 0, 0, HK_NULL },
		{ "wheelsTorqueRatio", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_REAL, 0, 0, 0, HK_NULL }
	};
	hkClass hkpVehicleDefaultTransmissionClass(
		"hkpVehicleDefaultTransmission",
		&hkpVehicleTransmissionClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpVehicleDefaultTransmissionClass_Members),
		HK_COUNT_OF(hkpVehicleDefaultTransmissionClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpVehicleInstance_WheelInfoClass_Members[] =
	{
		{ "contactPoint", &hkContactPointClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "contactFriction", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "contactBody", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL },
		{ "contactShapeKey", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 8, 0, 0, HK_NULL },
		{ "hardPointWs", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "rayEndPointWs", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "currentSuspensionLength", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "suspensionDirectionWs", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "spinAxisChassisSpace", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "spinAxisWs", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "steeringOrientationChassisSpace", HK_NULL, HK_NULL, hkClassMember::TYPE_QUATERNION, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "spinVelocity", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "spinAngle", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "skidEnergyDensity", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "sideForce", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "forwardSlipVelocity", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "sideSlipVelocity", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpVehicleInstanceWheelInfoClass(
		"hkpVehicleInstanceWheelInfo",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpVehicleInstance_WheelInfoClass_Members),
		HK_COUNT_OF(hkpVehicleInstance_WheelInfoClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	static hkInternalClassMember hkpVehicleInstanceClass_Members[] =
	{
		{ "data", &hkpVehicleDataClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "driverInput", &hkpVehicleDriverInputClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "steering", &hkpVehicleSteeringClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "engine", &hkpVehicleEngineClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "transmission", &hkpVehicleTransmissionClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "brake", &hkpVehicleBrakeClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "suspension", &hkpVehicleSuspensionClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "aerodynamics", &hkpVehicleAerodynamicsClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "wheelCollide", &hkpVehicleWheelCollideClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "tyreMarks", &hkpTyremarksInfoClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "velocityDamper", &hkpVehicleVelocityDamperClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "wheelsInfo", &hkpVehicleInstanceWheelInfoClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "frictionStatus", &hkpVehicleFrictionStatusClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "deviceStatus", &hkpVehicleDriverInputStatusClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "isFixed", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_BOOL, 0, 0, 0, HK_NULL },
		{ "wheelsTimeSinceMaxPedalInput", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "tryingToReverse", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "torque", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "rpm", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "mainSteeringAngle", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "wheelsSteeringAngle", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_REAL, 0, 0, 0, HK_NULL },
		{ "isReversing", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "currentGear", HK_NULL, HK_NULL, hkClassMember::TYPE_INT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "delayed", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "clutchDelayCountdown", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpVehicleInstanceClass(
		"hkpVehicleInstance",
		&hkpUnaryActionClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpVehicleInstanceClass_Members),
		HK_COUNT_OF(hkpVehicleInstanceClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hkpVehicleRayCastBatchingManagerClass(
		"hkpVehicleRayCastBatchingManager",
		&hkpVehicleCastBatchingManagerClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpVehicleRayCastWheelCollideClass_Members[] =
	{
		{ "wheelCollisionFilterInfo", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "phantom", &hkpAabbPhantomClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "rejectRayChassisListener", &hkpRejectChassisListenerClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpVehicleRayCastWheelCollideClass(
		"hkpVehicleRayCastWheelCollide",
		&hkpVehicleWheelCollideClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpVehicleRayCastWheelCollideClass_Members),
		HK_COUNT_OF(hkpVehicleRayCastWheelCollideClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);
	hkClass hkpVehicleLinearCastBatchingManagerClass(
		"hkpVehicleLinearCastBatchingManager",
		&hkpVehicleCastBatchingManagerClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpVehicleData_WheelComponentParamsClass_Members[] =
	{
		{ "radius", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "mass", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "width", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "friction", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "viscosityFriction", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxFriction", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "slipAngle", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "forceFeedbackMultiplier", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxContactBodyAcceleration", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "axle", HK_NULL, HK_NULL, hkClassMember::TYPE_INT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpVehicleDataWheelComponentParamsClass(
		"hkpVehicleDataWheelComponentParams",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpVehicleData_WheelComponentParamsClass_Members),
		HK_COUNT_OF(hkpVehicleData_WheelComponentParamsClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpVehicleDataClass_Members[] =
	{
		{ "gravity", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "numWheels", HK_NULL, HK_NULL, hkClassMember::TYPE_INT8, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "chassisOrientation", HK_NULL, HK_NULL, hkClassMember::TYPE_ROTATION, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "torqueRollFactor", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "torquePitchFactor", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "torqueYawFactor", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "extraTorqueFactor", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxVelocityForPositionalFriction", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "chassisUnitInertiaYaw", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "chassisUnitInertiaRoll", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "chassisUnitInertiaPitch", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "frictionEqualizer", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "normalClippingAngleCos", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxFrictionSolverMassRatio", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "wheelParams", &hkpVehicleDataWheelComponentParamsClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "numWheelsPerAxle", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_INT8, 0, 0, 0, HK_NULL },
		{ "frictionDescription", &hkpVehicleFrictionDescriptionClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "chassisFrictionInertiaInvDiag", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "alreadyInitialised", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	namespace
	{
		struct hkpVehicleData_DefaultStruct
		{
			int s_defaultOffsets[19];
			typedef hkInt8 _hkBool;
			typedef hkReal _hkVector4[4];
			typedef hkReal _hkQuaternion[4];
			typedef hkReal _hkMatrix3[12];
			typedef hkReal _hkRotation[12];
			typedef hkReal _hkQsTransform[12];
			typedef hkReal _hkMatrix4[16];
			typedef hkReal _hkTransform[16];
			hkReal m_maxFrictionSolverMassRatio;
		};
		const hkpVehicleData_DefaultStruct hkpVehicleData_Default =
		{
			{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,HK_OFFSET_OF(hkpVehicleData_DefaultStruct,m_maxFrictionSolverMassRatio),-1,-1,-1,-1,-1},
			30.0
		};
	}
	hkClass hkpVehicleDataClass(
		"hkpVehicleData",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpVehicleDataClass_Members),
		HK_COUNT_OF(hkpVehicleDataClass_Members),
		&hkpVehicleData_Default,
		HK_NULL,
		0,
		hkUint32(1)
		);
	hkClass hkpVehicleAerodynamicsClass(
		"hkpVehicleAerodynamics",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hkpVehicleEngineClass(
		"hkpVehicleEngine",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hkpMultithreadedVehicleManagerClass(
		"hkpMultithreadedVehicleManager",
		&hkpVehicleManagerClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpVehicleLinearCastWheelCollide_WheelStateClass_Members[] =
	{
		{ "phantom", &hkpAabbPhantomClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "shape", &hkpShapeClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "transform", HK_NULL, HK_NULL, hkClassMember::TYPE_TRANSFORM, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "to", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpVehicleLinearCastWheelCollideWheelStateClass(
		"hkpVehicleLinearCastWheelCollideWheelState",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpVehicleLinearCastWheelCollide_WheelStateClass_Members),
		HK_COUNT_OF(hkpVehicleLinearCastWheelCollide_WheelStateClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpVehicleLinearCastWheelCollideClass_Members[] =
	{
		{ "wheelCollisionFilterInfo", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "wheelStates", &hkpVehicleLinearCastWheelCollideWheelStateClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL },
		{ "rejectChassisListener", &hkpRejectChassisListenerClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxExtraPenetration", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "startPointTolerance", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpVehicleLinearCastWheelCollideClass(
		"hkpVehicleLinearCastWheelCollide",
		&hkpVehicleWheelCollideClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpVehicleLinearCastWheelCollideClass_Members),
		HK_COUNT_OF(hkpVehicleLinearCastWheelCollideClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpVehicleManagerClass_Members[] =
	{
		{ "registeredVehicles", &hkpVehicleInstanceClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_POINTER, 0, 0, 0, HK_NULL }
	};
	hkClass hkpVehicleManagerClass(
		"hkpVehicleManager",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpVehicleManagerClass_Members),
		HK_COUNT_OF(hkpVehicleManagerClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpVehicleDefaultEngineClass_Members[] =
	{
		{ "minRPM", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "optRPM", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxRPM", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxTorque", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "torqueFactorAtMinRPM", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "torqueFactorAtMaxRPM", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "resistanceFactorAtMinRPM", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "resistanceFactorAtOptRPM", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "resistanceFactorAtMaxRPM", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "clutchSlipRPM", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpVehicleDefaultEngineClass(
		"hkpVehicleDefaultEngine",
		&hkpVehicleEngineClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpVehicleDefaultEngineClass_Members),
		HK_COUNT_OF(hkpVehicleDefaultEngineClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hkpVehicleSteeringClass(
		"hkpVehicleSteering",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpVehicleFrictionDescription_AxisDescriptionClass_Members[] =
	{
		{ "frictionCircleYtab", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 16, 0, 0, HK_NULL },
		{ "xStep", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "xStart", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "wheelSurfaceInertia", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "wheelSurfaceInertiaInv", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "wheelChassisMassRatio", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "wheelRadius", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "wheelRadiusInv", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "wheelDownForceFactor", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "wheelDownForceSumFactor", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpVehicleFrictionDescriptionAxisDescriptionClass(
		"hkpVehicleFrictionDescriptionAxisDescription",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpVehicleFrictionDescription_AxisDescriptionClass_Members),
		HK_COUNT_OF(hkpVehicleFrictionDescription_AxisDescriptionClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpVehicleFrictionDescriptionClass_Members[] =
	{
		{ "wheelDistance", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "chassisMassInv", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "axleDescr", &hkpVehicleFrictionDescriptionAxisDescriptionClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 2, 0, 0, HK_NULL }
	};
	hkClass hkpVehicleFrictionDescriptionClass(
		"hkpVehicleFrictionDescription",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpVehicleFrictionDescriptionClass_Members),
		HK_COUNT_OF(hkpVehicleFrictionDescriptionClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpVehicleFrictionStatus_AxisStatusClass_Members[] =
	{
		{ "forward_slip_velocity", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "side_slip_velocity", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "skid_energy_density", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "side_force", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "delayed_forward_impulse", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "sideRhs", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "forwardRhs", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "relativeSideForce", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "relativeForwardForce", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpVehicleFrictionStatusAxisStatusClass(
		"hkpVehicleFrictionStatusAxisStatus",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpVehicleFrictionStatus_AxisStatusClass_Members),
		HK_COUNT_OF(hkpVehicleFrictionStatus_AxisStatusClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpVehicleFrictionStatusClass_Members[] =
	{
		{ "axis", &hkpVehicleFrictionStatusAxisStatusClass, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 2, 0, 0, HK_NULL }
	};
	hkClass hkpVehicleFrictionStatusClass(
		"hkpVehicleFrictionStatus",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpVehicleFrictionStatusClass_Members),
		HK_COUNT_OF(hkpVehicleFrictionStatusClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpVehicleCastBatchingManagerClass_Members[] =
	{
		{ "totalNumWheels", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT16, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpVehicleCastBatchingManagerClass(
		"hkpVehicleCastBatchingManager",
		&hkpVehicleManagerClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpVehicleCastBatchingManagerClass_Members),
		HK_COUNT_OF(hkpVehicleCastBatchingManagerClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpVehicleDefaultAerodynamicsClass_Members[] =
	{
		{ "airDensity", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "frontalArea", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "dragCoefficient", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "liftCoefficient", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "extraGravityws", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpVehicleDefaultAerodynamicsClass(
		"hkpVehicleDefaultAerodynamics",
		&hkpVehicleAerodynamicsClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpVehicleDefaultAerodynamicsClass_Members),
		HK_COUNT_OF(hkpVehicleDefaultAerodynamicsClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpVehicleDriverInputAnalogStatusClass_Members[] =
	{
		{ "positionX", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "positionY", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "handbrakeButtonPressed", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "reverseButtonPressed", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpVehicleDriverInputAnalogStatusClass(
		"hkpVehicleDriverInputAnalogStatus",
		&hkpVehicleDriverInputStatusClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpVehicleDriverInputAnalogStatusClass_Members),
		HK_COUNT_OF(hkpVehicleDriverInputAnalogStatusClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpVehicleDefaultAnalogDriverInputClass_Members[] =
	{
		{ "slopeChangePointX", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "initialSlope", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "deadZone", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "autoReverse", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpVehicleDefaultAnalogDriverInputClass(
		"hkpVehicleDefaultAnalogDriverInput",
		&hkpVehicleDriverInputClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpVehicleDefaultAnalogDriverInputClass_Members),
		HK_COUNT_OF(hkpVehicleDefaultAnalogDriverInputClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpVehicleDefaultSuspension_WheelSpringSuspensionParametersClass_Members[] =
	{
		{ "strength", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "dampingCompression", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "dampingRelaxation", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpVehicleDefaultSuspensionWheelSpringSuspensionParametersClass(
		"hkpVehicleDefaultSuspensionWheelSpringSuspensionParameters",
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpVehicleDefaultSuspension_WheelSpringSuspensionParametersClass_Members),
		HK_COUNT_OF(hkpVehicleDefaultSuspension_WheelSpringSuspensionParametersClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpVehicleDefaultSuspensionClass_Members[] =
	{
		{ "wheelSpringParams", &hkpVehicleDefaultSuspensionWheelSpringSuspensionParametersClass, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_STRUCT, 0, 0, 0, HK_NULL }
	};
	hkClass hkpVehicleDefaultSuspensionClass(
		"hkpVehicleDefaultSuspension",
		&hkpVehicleSuspensionClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpVehicleDefaultSuspensionClass_Members),
		HK_COUNT_OF(hkpVehicleDefaultSuspensionClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hkpVehicleDriverInputStatusClass(
		"hkpVehicleDriverInputStatus",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hkpVehicleDriverInputClass(
		"hkpVehicleDriverInput",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpVehicleDefaultVelocityDamperClass_Members[] =
	{
		{ "normalSpinDamping", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "collisionSpinDamping", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "collisionThreshold", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL }
	};
	hkClass hkpVehicleDefaultVelocityDamperClass(
		"hkpVehicleDefaultVelocityDamper",
		&hkpVehicleVelocityDamperClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpVehicleDefaultVelocityDamperClass_Members),
		HK_COUNT_OF(hkpVehicleDefaultVelocityDamperClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hkpVehicleTransmissionClass(
		"hkpVehicleTransmission",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static const hkInternalClassEnumItem hkpVehicleWheelCollideWheelCollideTypeEnumItems[] =
	{
		{0, "INVALID_WHEEL_COLLIDE"},
		{1, "RAY_CAST_WHEEL_COLLIDE"},
		{2, "LINEAR_CAST_WHEEL_COLLIDE"},
		{3, "USER_WHEEL_COLLIDE1"},
		{4, "USER_WHEEL_COLLIDE2"},
		{5, "USER_WHEEL_COLLIDE3"},
		{6, "USER_WHEEL_COLLIDE4"},
		{7, "USER_WHEEL_COLLIDE5"},
	};
	static const hkInternalClassEnum hkpVehicleWheelCollideEnums[] = {
		{"WheelCollideType", hkpVehicleWheelCollideWheelCollideTypeEnumItems, 8, HK_NULL, 0 }
	};
	const hkClassEnum* hkpVehicleWheelCollideWheelCollideTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkpVehicleWheelCollideEnums[0]);
	static hkInternalClassMember hkpVehicleWheelCollideClass_Members[] =
	{
		{ "alreadyUsed", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "type", HK_NULL, HK_NULL, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hkpVehicleWheelCollideClass(
		"hkpVehicleWheelCollide",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassEnum*>(hkpVehicleWheelCollideEnums),
		1,
		reinterpret_cast<const hkClassMember*>(hkpVehicleWheelCollideClass_Members),
		HK_COUNT_OF(hkpVehicleWheelCollideClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hkpVehicleBrakeClass(
		"hkpVehicleBrake",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpVehicleDefaultSteeringClass_Members[] =
	{
		{ "maxSteeringAngle", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "maxSpeedFullSteeringAngle", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, 0, HK_NULL },
		{ "doesWheelSteer", HK_NULL, HK_NULL, hkClassMember::TYPE_ARRAY, hkClassMember::TYPE_BOOL, 0, 0, 0, HK_NULL }
	};
	hkClass hkpVehicleDefaultSteeringClass(
		"hkpVehicleDefaultSteering",
		&hkpVehicleSteeringClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpVehicleDefaultSteeringClass_Members),
		HK_COUNT_OF(hkpVehicleDefaultSteeringClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	hkClass hkpVehicleVelocityDamperClass(
		"hkpVehicleVelocityDamper",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		0,
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(0)
		);
	static hkInternalClassMember hkpRejectChassisListenerClass_Members[] =
	{
		{ "chassis", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, 0, HK_NULL }
	};
	hkClass hkpRejectChassisListenerClass(
		"hkpRejectChassisListener",
		&hkReferencedObjectClass,
		0,
		HK_NULL,
		1,
		HK_NULL,
		0,
		reinterpret_cast<const hkClassMember*>(hkpRejectChassisListenerClass_Members),
		HK_COUNT_OF(hkpRejectChassisListenerClass_Members),
		HK_NULL,
		HK_NULL,
		0,
		hkUint32(1)
		);

	static hkClass* const Classes[] =
	{
		&hclActionClass,
		&hclAntiPinchConstraintSetClass,
		&hclAntiPinchConstraintSetPerParticleClass,
		&hclBendLinkConstraintSetClass,
		&hclBendLinkConstraintSetLinkClass,
		&hclBendLinkConstraintSetMxBatchClass,
		&hclBendLinkConstraintSetMxClass,
		&hclBendLinkConstraintSetMxSingleClass,
		&hclBendLinkSetupObjectClass,
		&hclBendStiffnessConstraintSetClass,
		&hclBendStiffnessConstraintSetLinkClass,
		&hclBendStiffnessConstraintSetMxBatchClass,
		&hclBendStiffnessConstraintSetMxClass,
		&hclBendStiffnessConstraintSetMxSingleClass,
		&hclBendStiffnessSetupObjectClass,
		&hclBlendSetupObjectClass,
		&hclBlendSomeVerticesOperatorBlendEntryClass,
		&hclBlendSomeVerticesOperatorClass,
		&hclBonePlanesConstraintSetBonePlaneClass,
		&hclBonePlanesConstraintSetClass,
		&hclBonePlanesSetupObjectClass,
		&hclBonePlanesSetupObjectGlobalPlaneClass,
		&hclBonePlanesSetupObjectPerParticleAngleClass,
		&hclBonePlanesSetupObjectPerParticlePlaneClass,
		&hclBoneSpaceDeformerClass,
		&hclBoneSpaceDeformerFourBlendEntryBlockClass,
		&hclBoneSpaceDeformerLocalBlockPClass,
		&hclBoneSpaceDeformerLocalBlockPNClass,
		&hclBoneSpaceDeformerLocalBlockPNTBClass,
		&hclBoneSpaceDeformerLocalBlockPNTClass,
		&hclBoneSpaceDeformerOneBlendEntryBlockClass,
		&hclBoneSpaceDeformerThreeBlendEntryBlockClass,
		&hclBoneSpaceDeformerTwoBlendEntryBlockClass,
		&hclBoneSpaceMeshMeshDeformOperatorClass,
		&hclBoneSpaceMeshMeshDeformPNOperatorClass,
		&hclBoneSpaceMeshMeshDeformPNTBOperatorClass,
		&hclBoneSpaceMeshMeshDeformPNTOperatorClass,
		&hclBoneSpaceMeshMeshDeformPOperatorClass,
		&hclBoneSpaceSkinOperatorClass,
		&hclBoneSpaceSkinPNOperatorClass,
		&hclBoneSpaceSkinPNTBOperatorClass,
		&hclBoneSpaceSkinPNTOperatorClass,
		&hclBoneSpaceSkinPOperatorClass,
		&hclBufferDefinitionClass,
		&hclBufferLayoutBufferElementClass,
		&hclBufferLayoutClass,
		&hclBufferLayoutSlotClass,
		&hclBufferSetupObjectClass,
		&hclBufferUsageClass,
		&hclCapsuleShapeClass,
		&hclClothContainerClass,
		&hclClothDataClass,
		&hclClothSetupContainerClass,
		&hclClothSetupObjectClass,
		&hclClothStateBufferAccessClass,
		&hclClothStateClass,
		&hclClothStateSetupObjectClass,
		&hclClothStateTransformSetAccessClass,
		&hclCollidableClass,
		&hclCompressibleLinkConstraintSetClass,
		&hclCompressibleLinkConstraintSetLinkClass,
		&hclCompressibleLinkConstraintSetMxBatchClass,
		&hclCompressibleLinkConstraintSetMxClass,
		&hclCompressibleLinkConstraintSetMxSingleClass,
		&hclConstraintSetClass,
		&hclConstraintSetSetupObjectClass,
		&hclConvexGeometryShapeClass,
		&hclConvexHeightFieldShapeClass,
		&hclCopyVerticesOperatorClass,
		&hclDisplayBufferSetupObjectClass,
		&hclEdgeSelectionInputClass,
		&hclGatherAllVerticesOperatorClass,
		&hclGatherSomeVerticesOperatorClass,
		&hclGatherSomeVerticesOperatorVertexPairClass,
		&hclHingeConstraintSetClass,
		&hclHingeConstraintSetHingeClass,
		&hclHingeSetupObjectClass,
		&hclInputConvertOperatorClass,
		&hclLocalRangeConstraintSetClass,
		&hclLocalRangeConstraintSetLocalConstraintClass,
		&hclLocalRangeSetupObjectClass,
		&hclMeshBoneDeformOperatorClass,
		&hclMeshBoneDeformOperatorTriangleBonePairClass,
		&hclMeshBoneDeformSetupObjectClass,
		&hclMeshMeshDeformOperatorClass,
		&hclMeshMeshDeformOperatorTriangleVertexPairClass,
		&hclMeshMeshDeformSetupObjectClass,
		&hclMoveFixedParticlesSetupObjectClass,
		&hclMoveParticlesOperatorClass,
		&hclMoveParticlesOperatorVertexParticlePairClass,
		&hclNamedSetupMeshClass,
		&hclNamedTransformSetSetupObjectClass,
		&hclObjectSpaceDeformerClass,
		&hclObjectSpaceDeformerFourBlendEntryBlockClass,
		&hclObjectSpaceDeformerLocalBlockPClass,
		&hclObjectSpaceDeformerLocalBlockPNClass,
		&hclObjectSpaceDeformerLocalBlockPNTBClass,
		&hclObjectSpaceDeformerLocalBlockPNTClass,
		&hclObjectSpaceDeformerOneBlendEntryBlockClass,
		&hclObjectSpaceDeformerThreeBlendEntryBlockClass,
		&hclObjectSpaceDeformerTwoBlendEntryBlockClass,
		&hclObjectSpaceMeshMeshDeformOperatorClass,
		&hclObjectSpaceMeshMeshDeformPNOperatorClass,
		&hclObjectSpaceMeshMeshDeformPNTBOperatorClass,
		&hclObjectSpaceMeshMeshDeformPNTOperatorClass,
		&hclObjectSpaceMeshMeshDeformPOperatorClass,
		&hclObjectSpaceSkinOperatorClass,
		&hclObjectSpaceSkinPNOperatorClass,
		&hclObjectSpaceSkinPNTBOperatorClass,
		&hclObjectSpaceSkinPNTOperatorClass,
		&hclObjectSpaceSkinPOperatorClass,
		&hclOperatorClass,
		&hclOperatorSetupObjectClass,
		&hclOutputConvertOperatorClass,
		&hclPlaneShapeClass,
		&hclRecalculateAllNormalsOperatorClass,
		&hclRecalculateNormalsSetupObjectClass,
		&hclRecalculateSomeNormalsOperatorClass,
		&hclRuntimeConversionInfoClass,
		&hclRuntimeConversionInfoElementConversionClass,
		&hclRuntimeConversionInfoSlotConversionClass,
		&hclSceneDataSetupMeshClass,
		&hclSceneDataSetupMeshSectionClass,
		&hclScratchBufferDefinitionClass,
		&hclScratchBufferSetupObjectClass,
		&hclSetupMeshClass,
		&hclSetupMeshSectionClass,
		&hclSetupMeshSectionTriangleClass,
		&hclShadowBufferDefinitionClass,
		&hclShapeClass,
		&hclSimClothBufferSetupObjectClass,
		&hclSimClothDataClass,
		&hclSimClothDataCollidablePinchingDataClass,
		&hclSimClothDataCollidableTransformMapClass,
		&hclSimClothDataLandscapeCollisionDataClass,
		&hclSimClothDataParticleDataClass,
		&hclSimClothDataSimulationInfoClass,
		&hclSimClothPoseClass,
		&hclSimClothSetupObjectClass,
		&hclSimClothSetupObjectPerInstanceCollidableClass,
		&hclSimpleMeshBoneDeformOperatorClass,
		&hclSimpleMeshBoneDeformOperatorTriangleBonePairClass,
		&hclSimpleWindActionClass,
		&hclSimulateOperatorClass,
		&hclSimulateSetupObjectClass,
		&hclSimulationSetupMeshClass,
		&hclSimulationSetupMeshMapOptionsClass,
		&hclSkeletonTransformSetSetupObjectClass,
		&hclSkinOperatorBoneInfluenceClass,
		&hclSkinOperatorClass,
		&hclSkinSetupObjectClass,
		&hclSphereShapeClass,
		&hclStandardLinkConstraintSetClass,
		&hclStandardLinkConstraintSetLinkClass,
		&hclStandardLinkConstraintSetMxBatchClass,
		&hclStandardLinkConstraintSetMxClass,
		&hclStandardLinkConstraintSetMxSingleClass,
		&hclStandardLinkSetupObjectClass,
		&hclStaticDisplayBufferSetupObjectClass,
		&hclStaticShadowBufferDefinitionClass,
		&hclStorageSetupMeshBoneClass,
		&hclStorageSetupMeshClass,
		&hclStorageSetupMeshEdgeChannelClass,
		&hclStorageSetupMeshSectionBoneInfluencesClass,
		&hclStorageSetupMeshSectionClass,
		&hclStorageSetupMeshSectionSectionEdgeSelectionChannelClass,
		&hclStorageSetupMeshSectionSectionTriangleSelectionChannelClass,
		&hclStorageSetupMeshSectionSectionVertexChannelClass,
		&hclStorageSetupMeshSectionSectionVertexFloatChannelClass,
		&hclStorageSetupMeshSectionSectionVertexSelectionChannelClass,
		&hclStorageSetupMeshTriangleChannelClass,
		&hclStorageSetupMeshVertexChannelClass,
		&hclStretchLinkConstraintSetClass,
		&hclStretchLinkConstraintSetLinkClass,
		&hclStretchLinkConstraintSetMxBatchClass,
		&hclStretchLinkConstraintSetMxClass,
		&hclStretchLinkConstraintSetMxSingleClass,
		&hclStretchLinkSetupObjectClass,
		&hclTaperedCapsuleShapeClass,
		&hclToolNamedObjectReferenceClass,
		&hclTransformSetDefinitionClass,
		&hclTransformSetSetupObjectClass,
		&hclTransformSetUsageClass,
		&hclTransitionConstraintSetClass,
		&hclTransitionConstraintSetPerParticleClass,
		&hclTransitionSetupObjectClass,
		&hclTriangleSelectionInputClass,
		&hclUpdateAllVertexFramesOperatorClass,
		&hclUpdateSomeVertexFramesOperatorClass,
		&hclUpdateSomeVertexFramesOperatorTriangleClass,
		&hclUpdateVertexFramesSetupObjectClass,
		&hclVertexCopySetupObjectClass,
		&hclVertexFloatInputClass,
		&hclVertexGatherSetupObjectClass,
		&hclVertexSelectionInputClass,
		&hclVolumeConstraintApplyDataClass,
		&hclVolumeConstraintClass,
		&hclVolumeConstraintFrameDataClass,
		&hclVolumeConstraintMxApplyBatchDataClass,
		&hclVolumeConstraintMxApplySingleDataClass,
		&hclVolumeConstraintMxClass,
		&hclVolumeConstraintMxFrameBatchDataClass,
		&hclVolumeConstraintMxFrameSingleDataClass,
		&hclVolumeConstraintSetupObjectClass,
		&hkAabbClass,
		&hkAabbHalfClass,
		&hkAabbUint32Class,
		&hkAlignSceneToNodeOptionsClass,
		&hkArrayTypeAttributeClass,
		&hkBaseObjectClass,
		&hkBitFieldClass,
		&hkClassClass,
		&hkClassEnumClass,
		&hkClassEnumItemClass,
		&hkClassMemberClass,
		&hkColorClass,
		&hkContactPointClass,
		&hkContactPointMaterialClass,
		&hkCustomAttributesAttributeClass,
		&hkCustomAttributesClass,
		&hkDataObjectTypeAttributeClass,
		&hkDescriptionAttributeClass,
		&hkDocumentationAttributeClass,
		&hkFloat16Class,
		&hkFloat16TransformClass,
		&hkFourTransposedPointsClass,
		&hkGeometryClass,
		&hkGeometryTriangleClass,
		&hkGizmoAttributeClass,
		&hkIndexedTransformSetClass,
		&hkLinkAttributeClass,
		&hkLocalFrameClass,
		&hkLocalFrameGroupClass,
		&hkMemoryMeshBodyClass,
		&hkMemoryMeshMaterialClass,
		&hkMemoryMeshShapeClass,
		&hkMemoryMeshTextureClass,
		&hkMemoryMeshVertexBufferClass,
		&hkMemoryResourceContainerClass,
		&hkMemoryResourceHandleClass,
		&hkMemoryResourceHandleExternalLinkClass,
		&hkMeshBodyClass,
		&hkMeshBoneIndexMappingClass,
		&hkMeshMaterialClass,
		&hkMeshSectionCinfoClass,
		&hkMeshSectionClass,
		&hkMeshShapeClass,
		&hkMeshTextureClass,
		&hkMeshVertexBufferClass,
		&hkModelerNodeTypeAttributeClass,
		&hkMonitorStreamColorTableClass,
		&hkMonitorStreamColorTableColorPairClass,
		&hkMonitorStreamFrameInfoClass,
		&hkMonitorStreamStringMapClass,
		&hkMonitorStreamStringMapStringMapClass,
		&hkMoppBvTreeShapeBaseClass,
		&hkMotionStateClass,
		&hkMultiThreadCheckClass,
		&hkMultipleVertexBufferClass,
		&hkMultipleVertexBufferElementInfoClass,
		&hkMultipleVertexBufferLockedElementClass,
		&hkMultipleVertexBufferVertexBufferInfoClass,
		&hkPackedVector3Class,
		&hkPackfileHeaderClass,
		&hkPackfileSectionHeaderClass,
		&hkPostFinishAttributeClass,
		&hkQTransformClass,
		&hkRangeInt32AttributeClass,
		&hkRangeRealAttributeClass,
		&hkRefCountedPropertiesClass,
		&hkRefCountedPropertiesEntryClass,
		&hkReferencedObjectClass,
		&hkResourceBaseClass,
		&hkResourceContainerClass,
		&hkResourceHandleClass,
		&hkRootLevelContainerClass,
		&hkRootLevelContainerNamedVariantClass,
		&hkSemanticsAttributeClass,
		&hkSimpleLocalFrameClass,
		&hkSphereClass,
		&hkSweptTransformClass,
		&hkUiAttributeClass,
		&hkVariableTweakingHelperBoolVariableInfoClass,
		&hkVariableTweakingHelperClass,
		&hkVariableTweakingHelperIntVariableInfoClass,
		&hkVariableTweakingHelperRealVariableInfoClass,
		&hkVariableTweakingHelperVector4VariableInfoClass,
		&hkVertexFormatClass,
		&hkVertexFormatElementClass,
		&hkWorldMemoryAvailableWatchDogClass,
		&hkaAnimatedReferenceFrameClass,
		&hkaAnimationBindingClass,
		&hkaAnimationClass,
		&hkaAnimationContainerClass,
		&hkaAnimationPreviewColorContainerClass,
		&hkaAnnotationTrackAnnotationClass,
		&hkaAnnotationTrackClass,
		&hkaBoneAttachmentClass,
		&hkaBoneClass,
		&hkaDefaultAnimatedReferenceFrameClass,
		&hkaFootstepAnalysisInfoClass,
		&hkaFootstepAnalysisInfoContainerClass,
		&hkaInterleavedUncompressedAnimationClass,
		&hkaKeyFrameHierarchyUtilityClass,
		&hkaKeyFrameHierarchyUtilityControlDataClass,
		&hkaMeshBindingClass,
		&hkaMeshBindingMappingClass,
		&hkaPredictiveCompressedAnimationClass,
		&hkaPredictiveCompressedAnimationTrackCompressionParamsClass,
		&hkaQuantizedAnimationClass,
		&hkaQuantizedAnimationTrackCompressionParamsClass,
		&hkaRagdollInstanceClass,
		&hkaSkeletonClass,
		&hkaSkeletonLocalFrameOnBoneClass,
		&hkaSkeletonMapperClass,
		&hkaSkeletonMapperDataChainMappingClass,
		&hkaSkeletonMapperDataClass,
		&hkaSkeletonMapperDataSimpleMappingClass,
		&hkaSplineCompressedAnimationAnimationCompressionParamsClass,
		&hkaSplineCompressedAnimationClass,
		&hkaSplineCompressedAnimationTrackCompressionParamsClass,
		&hkaiAgentTraversalInfoClass,
		&hkaiAstarOutputParametersClass,
		&hkaiAvoidancePairPropertiesClass,
		&hkaiAvoidancePairPropertiesPairDataClass,
		&hkaiAvoidanceSolverAvoidancePropertiesClass,
		&hkaiAvoidanceSolverMovementPropertiesClass,
		&hkaiCharacterClass,
		&hkaiDefaultNavMeshCostModifierClass,
		&hkaiDefaultNavVolumeCostModifierClass,
		&hkaiDirectedGraphExplicitCostClass,
		&hkaiDirectedGraphExplicitCostEdgeClass,
		&hkaiDirectedGraphExplicitCostExternalEdgeInfoClass,
		&hkaiDirectedGraphExplicitCostNodeClass,
		&hkaiDynamicNavMeshQueryMediatorClass,
		&hkaiEdgeGeometryClass,
		&hkaiEdgeGeometryEdgeClass,
		&hkaiEdgeGeometryFaceClass,
		&hkaiGraphPathSearchParametersClass,
		&hkaiInvertedAabbVolumeClass,
		&hkaiLocalSteeringInputClass,
		&hkaiMaterialPainterClass,
		&hkaiNavMeshClass,
		&hkaiNavMeshCostModifierClass,
		&hkaiNavMeshCutterClass,
		&hkaiNavMeshCutterMeshInfoClass,
		&hkaiNavMeshCutterSavedConnectivityClass,
		&hkaiNavMeshEdgeClass,
		&hkaiNavMeshFaceClass,
		&hkaiNavMeshGenerationSettingsClass,
		&hkaiNavMeshGenerationSettingsEdgeMatchingParametersClass,
		&hkaiNavMeshGenerationSettingsMaterialConstructionPairClass,
		&hkaiNavMeshGenerationSettingsOverrideSettingsClass,
		&hkaiNavMeshGenerationSettingsRegionPruningSettingsClass,
		&hkaiNavMeshGenerationSnapshotClass,
		&hkaiNavMeshInstanceClass,
		&hkaiNavMeshPathRequestInfoClass,
		&hkaiNavMeshPathSearchParametersClass,
		&hkaiNavMeshQueryMediatorClass,
		&hkaiNavMeshSimplificationUtilsSettingsClass,
		&hkaiNavVolumeCellClass,
		&hkaiNavVolumeClass,
		&hkaiNavVolumeCostModifierClass,
		&hkaiNavVolumeEdgeClass,
		&hkaiNavVolumeExternalEdgeInfoClass,
		&hkaiNavVolumeGenerationSettingsChunkSettingsClass,
		&hkaiNavVolumeGenerationSettingsClass,
		&hkaiNavVolumeGenerationSettingsMaterialConstructionInfoClass,
		&hkaiNavVolumeGenerationSettingsMergingSettingsClass,
		&hkaiNavVolumeGenerationSnapshotClass,
		&hkaiNavVolumePathRequestInfoClass,
		&hkaiNavVolumePathSearchParametersClass,
		&hkaiPathClass,
		&hkaiPathFollowingPropertiesClass,
		&hkaiPathPathPointClass,
		&hkaiPathfindingUtilClass,
		&hkaiPathfindingUtilFindGraphPathInputClass,
		&hkaiPathfindingUtilFindPathInputClass,
		&hkaiPathfindingUtilFindPathOutputClass,
		&hkaiPhysicsShapeVolumeClass,
		&hkaiPlaneVolumeClass,
		&hkaiReferenceFrameClass,
		&hkaiStaticTreeClass,
		&hkaiStreamingCollectionClass,
		&hkaiStreamingCollectionInstanceInfoClass,
		&hkaiStreamingManagerClass,
		&hkaiStreamingManagerSectionInfoClass,
		&hkaiUserEdgePairArrayClass,
		&hkaiUserEdgeSetupArrayClass,
		&hkaiUserEdgeUtilsClass,
		&hkaiUserEdgeUtilsObbClass,
		&hkaiUserEdgeUtilsUserEdgePairClass,
		&hkaiUserEdgeUtilsUserEdgeSetupClass,
		&hkaiVolumeClass,
		&hkaiVolumePathfindingUtilClass,
		&hkaiVolumePathfindingUtilFindPathInputClass,
		&hkaiVolumePathfindingUtilFindPathOutputClass,
		&hkaiWorldCharacterStepCallbackContextClass,
		&hkaiWorldClass,
		&hkbAlignBoneModifierClass,
		&hkbAnimatedSkeletonGeneratorClass,
		&hkbAttachmentModifierClass,
		&hkbAttachmentSetupClass,
		&hkbAttributeModifierAssignmentClass,
		&hkbAttributeModifierClass,
		&hkbAuxiliaryNodeInfoClass,
		&hkbBalanceModifierClass,
		&hkbBalanceModifierStepInfoClass,
		&hkbBalanceRadialSelectorGeneratorClass,
		&hkbBehaviorEventsInfoClass,
		&hkbBehaviorGraphClass,
		&hkbBehaviorGraphDataClass,
		&hkbBehaviorGraphInternalStateClass,
		&hkbBehaviorGraphInternalStateInfoClass,
		&hkbBehaviorGraphStringDataClass,
		&hkbBehaviorInfoClass,
		&hkbBehaviorInfoIdToNamePairClass,
		&hkbBehaviorReferenceGeneratorClass,
		&hkbBindableClass,
		&hkbBlendCurveUtilsClass,
		&hkbBlenderGeneratorChildClass,
		&hkbBlenderGeneratorChildInternalStateClass,
		&hkbBlenderGeneratorClass,
		&hkbBlendingTransitionEffectClass,
		&hkbBoneIndexArrayClass,
		&hkbBoneWeightArrayClass,
		&hkbBoolVariableSequencedDataClass,
		&hkbBoolVariableSequencedDataSampleClass,
		&hkbCameraShakeEventPayloadClass,
		&hkbCatchFallModifierClass,
		&hkbCatchFallModifierHandClass,
		&hkbCharacterAddedInfoClass,
		&hkbCharacterClass,
		&hkbCharacterControlCommandClass,
		&hkbCharacterControllerModifierClass,
		&hkbCharacterControllerModifierControlDataClass,
		&hkbCharacterDataCharacterControllerInfoClass,
		&hkbCharacterDataClass,
		&hkbCharacterInfoClass,
		&hkbCharacterSelectedInfoClass,
		&hkbCharacterSetupClass,
		&hkbCharacterSkinInfoClass,
		&hkbCharacterSteppedInfoClass,
		&hkbCharacterStringDataClass,
		&hkbCharacterStringDataFileNameMeshNamePairClass,
		&hkbCheckBalanceModifierClass,
		&hkbCheckRagdollSpeedModifierClass,
		&hkbClientCharacterStateClass,
		&hkbClipGeneratorClass,
		&hkbClipGeneratorEchoClass,
		&hkbClipTriggerArrayClass,
		&hkbClipTriggerClass,
		&hkbCombineTransformsModifierClass,
		&hkbCompiledExpressionSetClass,
		&hkbCompiledExpressionSetTokenClass,
		&hkbComputeDirectionModifierClass,
		&hkbComputeRotationFromAxisAngleModifierClass,
		&hkbComputeRotationToTargetModifierClass,
		&hkbComputeWorldFromModelModifierClass,
		&hkbConditionClass,
		&hkbConstrainRigidBodyModifierClass,
		&hkbContextClass,
		&hkbControlledReachModifierClass,
		&hkbCustomTestGeneratorClass,
		&hkbCustomTestGeneratorStruckClass,
		&hkbDampingModifierClass,
		&hkbDefaultMessageLogClass,
		&hkbDelayedModifierClass,
		&hkbDemoConfigCharacterInfoClass,
		&hkbDemoConfigClass,
		&hkbDemoConfigStickVariableInfoClass,
		&hkbDemoConfigTerrainInfoClass,
		&hkbDetectCloseToGroundModifierClass,
		&hkbDockingGeneratorClass,
		&hkbEvaluateExpressionModifierClass,
		&hkbEvaluateExpressionModifierInternalExpressionDataClass,
		&hkbEvaluateHandleModifierClass,
		&hkbEventBaseClass,
		&hkbEventClass,
		&hkbEventDrivenModifierClass,
		&hkbEventInfoClass,
		&hkbEventPayloadClass,
		&hkbEventPayloadListClass,
		&hkbEventPropertyClass,
		&hkbEventRaisedInfoClass,
		&hkbEventRangeDataArrayClass,
		&hkbEventRangeDataClass,
		&hkbEventSequencedDataClass,
		&hkbEventSequencedDataSequencedEventClass,
		&hkbEventsFromRangeModifierClass,
		&hkbExpressionConditionClass,
		&hkbExpressionDataArrayClass,
		&hkbExpressionDataClass,
		&hkbExtractRagdollPoseModifierClass,
		&hkbExtrapolatingTransitionEffectClass,
		&hkbFaceTargetModifierClass,
		&hkbFootIkControlDataClass,
		&hkbFootIkControlsModifierClass,
		&hkbFootIkControlsModifierLegClass,
		&hkbFootIkDriverInfoClass,
		&hkbFootIkDriverInfoLegClass,
		&hkbFootIkGainsClass,
		&hkbFootIkModifierClass,
		&hkbFootIkModifierInternalLegDataClass,
		&hkbFootIkModifierLegClass,
		&hkbGeneratorClass,
		&hkbGeneratorOutputListenerClass,
		&hkbGeneratorSyncInfoClass,
		&hkbGeneratorSyncInfoSyncPointClass,
		&hkbGeneratorTransitionEffectClass,
		&hkbGetHandleOnBoneModifierClass,
		&hkbGetUpModifierClass,
		&hkbGetWorldFromModelModifierClass,
		&hkbGravityModifierClass,
		&hkbHandIkControlDataClass,
		&hkbHandIkControlsModifierClass,
		&hkbHandIkControlsModifierHandClass,
		&hkbHandIkDriverInfoClass,
		&hkbHandIkDriverInfoHandClass,
		&hkbHandIkModifierClass,
		&hkbHandIkModifierHandClass,
		&hkbHandleClass,
		&hkbHoldFromBlendingTransitionEffectClass,
		&hkbIntEventPayloadClass,
		&hkbIntVariableSequencedDataClass,
		&hkbIntVariableSequencedDataSampleClass,
		&hkbJigglerGroupClass,
		&hkbJigglerModifierClass,
		&hkbKeyframeBonesModifierClass,
		&hkbKeyframeBonesModifierKeyframeInfoClass,
		&hkbLinkedSymbolInfoClass,
		&hkbLookAtModifierClass,
		&hkbManualSelectorGeneratorClass,
		&hkbMessageLogClass,
		&hkbMirrorModifierClass,
		&hkbMirroredSkeletonInfoClass,
		&hkbModifierClass,
		&hkbModifierGeneratorClass,
		&hkbModifierListClass,
		&hkbModifierWrapperClass,
		&hkbMoveBoneAttachmentModifierClass,
		&hkbMoveBoneTowardTargetModifierClass,
		&hkbMoveCharacterModifierClass,
		&hkbNamedEventPayloadClass,
		&hkbNamedIntEventPayloadClass,
		&hkbNamedRealEventPayloadClass,
		&hkbNamedStringEventPayloadClass,
		&hkbNodeClass,
		&hkbNodeInternalStateInfoClass,
		&hkbParticleSystemEventPayloadClass,
		&hkbPoseMatchingGeneratorClass,
		&hkbPoseStoringGeneratorOutputListenerClass,
		&hkbPoseStoringGeneratorOutputListenerStoredPoseClass,
		&hkbPoweredRagdollControlDataClass,
		&hkbPoweredRagdollControlsModifierClass,
		&hkbProjectDataClass,
		&hkbProjectStringDataClass,
		&hkbRadialSelectorGeneratorClass,
		&hkbRadialSelectorGeneratorGeneratorInfoClass,
		&hkbRadialSelectorGeneratorGeneratorPairClass,
		&hkbRaiseEventCommandClass,
		&hkbReachModifierClass,
		&hkbReachModifierHandClass,
		&hkbReachTowardTargetModifierClass,
		&hkbReachTowardTargetModifierHandClass,
		&hkbRealEventPayloadClass,
		&hkbRealVariableSequencedDataClass,
		&hkbRealVariableSequencedDataSampleClass,
		&hkbRebuildScriptsCommandClass,
		&hkbReferencePoseGeneratorClass,
		&hkbReferencedGeneratorSyncInfoClass,
		&hkbRigidBodyRagdollControlDataClass,
		&hkbRigidBodyRagdollControlsModifierClass,
		&hkbRoleAttributeClass,
		&hkbRotateCharacterModifierClass,
		&hkbScriptGeneratorClass,
		&hkbSenseHandleModifierClass,
		&hkbSenseHandleModifierRangeClass,
		&hkbSequenceClass,
		&hkbSequenceStringDataClass,
		&hkbSequencedDataClass,
		&hkbSetBehaviorCommandClass,
		&hkbSetLocalTimeOfClipGeneratorCommandClass,
		&hkbSetNodePropertyCommandClass,
		&hkbSetSelectedCharacterCommandClass,
		&hkbSetWordVariableCommandClass,
		&hkbSetWorldFromModelModifierClass,
		&hkbSimulationControlCommandClass,
		&hkbSimulationStateInfoClass,
		&hkbStateChooserClass,
		&hkbStateDependentModifierClass,
		&hkbStateListenerClass,
		&hkbStateMachineActiveTransitionInfoClass,
		&hkbStateMachineClass,
		&hkbStateMachineDelayedTransitionInfoClass,
		&hkbStateMachineEventPropertyArrayClass,
		&hkbStateMachineNestedStateMachineDataClass,
		&hkbStateMachineProspectiveTransitionInfoClass,
		&hkbStateMachineStateInfoClass,
		&hkbStateMachineTimeIntervalClass,
		&hkbStateMachineTransitionInfoArrayClass,
		&hkbStateMachineTransitionInfoClass,
		&hkbStateMachineTransitionInfoReferenceClass,
		&hkbStringConditionClass,
		&hkbStringEventPayloadClass,
		&hkbTargetClass,
		&hkbTargetRigidBodyModifierClass,
		&hkbTestStateChooserClass,
		&hkbTimerModifierClass,
		&hkbToolNodeTypeClass,
		&hkbTransformVectorModifierClass,
		&hkbTransitionEffectClass,
		&hkbTwistModifierClass,
		&hkbVariableBindingSetBindingClass,
		&hkbVariableBindingSetClass,
		&hkbVariableBoundsClass,
		&hkbVariableInfoClass,
		&hkbVariableValueClass,
		&hkbVariableValueSetClass,
		&hkbWorldEnumsClass,
		&hkbWorldFromModelModeDataClass,
		&hkcdDynamicTreeAnisotropicMetricClass,
		&hkcdDynamicTreeBalanceMetricClass,
		&hkcdDynamicTreeCentroidMetricClass,
		&hkcdDynamicTreeCodec18Class,
		&hkcdDynamicTreeCodec32Class,
		&hkcdDynamicTreeCodecRawUintClass,
		&hkcdDynamicTreeCodecRawUlongClass,
		&hkcdDynamicTreeCodecRawunsignedintClass,
		&hkcdDynamicTreeCodecRawunsignedlongClass,
		&hkcdDynamicTreeDefaultDynamicStoragehkcdDynamicTreeCodec32Class,
		&hkcdDynamicTreeDefaultDynamicStoragehkcdDynamicTreeCodecRawUintClass,
		&hkcdDynamicTreeDefaultDynamicStoragehkcdDynamicTreeCodecRawUlongClass,
		&hkcdDynamicTreeDefaultTree32StorageClass,
		&hkcdDynamicTreeDefaultTree48StorageClass,
		&hkcdDynamicTreeDefaultTreePtrStorageClass,
		&hkcdDynamicTreeDynamicStorage0hkcdDynamicTreeAnisotropicMetrichkcdDynamicTreeCodec32Class,
		&hkcdDynamicTreeDynamicStorage0hkcdDynamicTreeAnisotropicMetrichkcdDynamicTreeCodecRawUintClass,
		&hkcdDynamicTreeDynamicStorage0hkcdDynamicTreeAnisotropicMetrichkcdDynamicTreeCodecRawUlongClass,
		&hkcdDynamicTreeDynamicStorage16Class,
		&hkcdDynamicTreeDynamicStorage32Class,
		&hkcdDynamicTreeDynamicStoragePtrClass,
		&hkcdDynamicTreeTreehkcdDynamicTreeDynamicStorage16Class,
		&hkcdDynamicTreeTreehkcdDynamicTreeDynamicStorage32Class,
		&hkcdDynamicTreeTreehkcdDynamicTreeDynamicStoragePtrClass,
		&hkcdStaticMeshTreeBaseClass,
		&hkcdStaticMeshTreeBasePrimitiveClass,
		&hkcdStaticMeshTreeBasePrimitiveDataRunBaseunsignedintClass,
		&hkcdStaticMeshTreeBasePrimitiveDataRunBaseunsignedshortClass,
		&hkcdStaticMeshTreeBaseSectionClass,
		&hkcdStaticMeshTreeBaseSectionDataRunsClass,
		&hkcdStaticMeshTreeBaseSectionPrimitivesClass,
		&hkcdStaticMeshTreeBaseSectionSharedVerticesClass,
		&hkcdStaticMeshTreeDefaultDataRunClass,
		&hkcdStaticMeshTreehkcdStaticMeshTreeCommonConfigunsignedintunsignedlonglong1121hkpBvCompressedMeshShapeTreeDataRunClass,
		&hkcdStaticTreeCodec3Axis4Class,
		&hkcdStaticTreeCodec3Axis5Class,
		&hkcdStaticTreeCodec3Axis6Class,
		&hkcdStaticTreeCodec3AxisClass,
		&hkcdStaticTreeCodecRawClass,
		&hkcdStaticTreeDefaultTreeStorage32Class,
		&hkcdStaticTreeDefaultTreeStorage4Class,
		&hkcdStaticTreeDefaultTreeStorage5Class,
		&hkcdStaticTreeDefaultTreeStorage6Class,
		&hkcdStaticTreeDynamicStorage32Class,
		&hkcdStaticTreeDynamicStorage4Class,
		&hkcdStaticTreeDynamicStorage5Class,
		&hkcdStaticTreeDynamicStorage6Class,
		&hkcdStaticTreeDynamicStoragehkcdStaticTreeCodec3Axis4Class,
		&hkcdStaticTreeDynamicStoragehkcdStaticTreeCodec3Axis5Class,
		&hkcdStaticTreeDynamicStoragehkcdStaticTreeCodec3Axis6Class,
		&hkcdStaticTreeDynamicStoragehkcdStaticTreeCodecRawClass,
		&hkcdStaticTreeTreehkcdStaticTreeDynamicStorage32Class,
		&hkcdStaticTreeTreehkcdStaticTreeDynamicStorage4Class,
		&hkcdStaticTreeTreehkcdStaticTreeDynamicStorage5Class,
		&hkcdStaticTreeTreehkcdStaticTreeDynamicStorage6Class,
		&hkdActionClass,
		&hkdBodyClass,
		&hkdBreakableBodyClass,
		&hkdBreakableBodyMementoClass,
		&hkdBreakableBodySmallArraySerializeOverrideTypeClass,
		&hkdBreakableShapeActionListClass,
		&hkdBreakableShapeClass,
		&hkdBreakableShapeConnectionClass,
		&hkdBreakableShapeConnectionListClass,
		&hkdBreakableShapeContactAreaClass,
		&hkdBuildingControllerClass,
		&hkdCompoundBreakableBodyMementoClass,
		&hkdCompoundBreakableShapeClass,
		&hkdContactRegionControllerClass,
		&hkdControllerClass,
		&hkdControllerSmallArraySerializeOverrideTypeClass,
		&hkdConvexDecompositionActionClass,
		&hkdCutOutFractureClass,
		&hkdDebrisFractureClass,
		&hkdDebrisFractureInfoClass,
		&hkdDebrisFractureInfoTemplateInfoClass,
		&hkdDebugLinesClass,
		&hkdDebugLinesDebugLineClass,
		&hkdDebugLinesDebugTextClass,
		&hkdDecalMapActionClass,
		&hkdDecalMapActionDecalMapClass,
		&hkdDecalMapActionDecalMapDataClass,
		&hkdDecalMapActionDecorMapInfoClass,
		&hkdDecomposeFractureClass,
		&hkdDecorateCornerInfoClass,
		&hkdDecorateCornerInfoContainerClass,
		&hkdDecorateFractureFaceActionClass,
		&hkdDecorateFractureFaceActionCompressedDecorationPlacementClass,
		&hkdDecorateFractureFaceActionConnectionDecorationInfoClass,
		&hkdDecorateFractureFaceActionCornerDecorationInfoClass,
		&hkdDecorateFractureFaceActionForwarderClass,
		&hkdDecorateFractureFaceActionFractureFaceInfo2Class,
		&hkdDecorateFractureFaceActionFractureFaceInfoClass,
		&hkdDecorateFractureFaceActionGlobalDecorationDataClass,
		&hkdDecorateFractureFaceActionShapeDecorationInfoClass,
		&hkdDecorateFractureFaceInfoClass,
		&hkdDeformableBreakableBodyMementoClass,
		&hkdDeformableBreakableShapeBoneDeformationDataClass,
		&hkdDeformableBreakableShapeBoneInfoClass,
		&hkdDeformableBreakableShapeClass,
		&hkdDeformableBreakableShapeDeformationPropertyClass,
		&hkdDeformableBreakableShapePhysicsSkinInstanceClass,
		&hkdDeformableBreakableShapePhysicsSkinShapeClass,
		&hkdDeformableBreakableShapeSkinShapeSectionClass,
		&hkdDeformationControllerClass,
		&hkdDestructionDemoConfigClass,
		&hkdExplosionForceActionClass,
		&hkdFlexibleJointControllerClass,
		&hkdFlexibleJointControllerJointDefClass,
		&hkdFlexibleJointControllerWatchConstraintActionClass,
		&hkdFractureClass,
		&hkdGeometryClass,
		&hkdGeometryFaceClass,
		&hkdGeometryFaceIdentifierClass,
		&hkdGeometryObjectIdentifierClass,
		&hkdGeometryTriangleClass,
		&hkdGlueFixedPiecesActionClass,
		&hkdGraphicsBodyClass,
		&hkdGraphicsShapeClass,
		&hkdGrenadeGunClass,
		&hkdInfoClass,
		&hkdIntegrityAnalyzerActionClass,
		&hkdMeshSimplifierActionClass,
		&hkdMissileGunClass,
		&hkdObjectPropertiesClass,
		&hkdObjectPropertiesPropertyClass,
		&hkdPieFractureClass,
		&hkdPropertiesClass,
		&hkdPropertyFlagSetClass,
		&hkdRandomSplitFractureClass,
		&hkdRaycastGunClass,
		&hkdRemoveDebrisActionClass,
		&hkdRemoveWeakConnectionsActionClass,
		&hkdSetRigidBodyPropertiesActionClass,
		&hkdShapeClass,
		&hkdShapeInstanceInfoClass,
		&hkdShapeInstanceInfoRuntimeInfoClass,
		&hkdShareVerticesActionClass,
		&hkdShockWaveActionClass,
		&hkdSimpleBreakableBodyMementoClass,
		&hkdSimpleShockWaveActionClass,
		&hkdSliceFractureClass,
		&hkdSphereGunClass,
		&hkdSplitInHalfControllerClass,
		&hkdSplitInHalfFractureClass,
		&hkdSplitShapeClass,
		&hkdStickyGunClass,
		&hkdStringObjectClass,
		&hkdTransformObjectClass,
		&hkdVoronoiFractureClass,
		&hkdWoodControllerClass,
		&hkdWoodFractureClass,
		&hkdWoodFractureSplittingDataClass,
		&hkp2dAngConstraintAtomClass,
		&hkpAabbPhantomClass,
		&hkpActionClass,
		&hkpAgent1nSectorClass,
		&hkpAngConstraintAtomClass,
		&hkpAngFrictionConstraintAtomClass,
		&hkpAngLimitConstraintAtomClass,
		&hkpAngMotorConstraintAtomClass,
		&hkpAngularDashpotActionClass,
		&hkpArrayActionClass,
		&hkpBallAndSocketConstraintDataAtomsClass,
		&hkpBallAndSocketConstraintDataClass,
		&hkpBallGunClass,
		&hkpBallSocketChainDataClass,
		&hkpBallSocketChainDataConstraintInfoClass,
		&hkpBallSocketConstraintAtomClass,
		&hkpBinaryActionClass,
		&hkpBoxMotionClass,
		&hkpBoxShapeClass,
		&hkpBreakableBodyClass,
		&hkpBreakableBodyControllerClass,
		&hkpBreakableConstraintDataClass,
		&hkpBreakableMaterialClass,
		&hkpBreakableMultiMaterialClass,
		&hkpBreakableMultiMaterialInverseMappingClass,
		&hkpBreakableMultiMaterialInverseMappingDescriptorClass,
		&hkpBreakableShapeClass,
		&hkpBridgeAtomsClass,
		&hkpBridgeConstraintAtomClass,
		&hkpBroadPhaseHandleClass,
		&hkpBvCompressedMeshShapeClass,
		&hkpBvCompressedMeshShapeTreeClass,
		&hkpBvCompressedMeshShapeTreeDataRunClass,
		&hkpBvShapeClass,
		&hkpBvTreeShapeClass,
		&hkpCachingShapePhantomClass,
		&hkpCallbackConstraintMotorClass,
		&hkpCapsuleShapeClass,
		&hkpCdBodyClass,
		&hkpCenterOfMassChangerModifierConstraintAtomClass,
		&hkpCharacterControllerCinfoClass,
		&hkpCharacterMotionClass,
		&hkpCharacterProxyCinfoClass,
		&hkpCharacterRigidBodyCinfoClass,
		&hkpCogWheelConstraintAtomClass,
		&hkpCogWheelConstraintDataAtomsClass,
		&hkpCogWheelConstraintDataClass,
		&hkpCollidableBoundingVolumeDataClass,
		&hkpCollidableClass,
		&hkpCollidableCollidableFilterClass,
		&hkpCollisionFilterClass,
		&hkpCollisionFilterListClass,
		&hkpCompressedMeshShapeBigTriangleClass,
		&hkpCompressedMeshShapeChunkClass,
		&hkpCompressedMeshShapeClass,
		&hkpCompressedMeshShapeConvexPieceClass,
		&hkpCompressedSampledHeightFieldShapeClass,
		&hkpConeLimitConstraintAtomClass,
		&hkpConstrainedSystemFilterClass,
		&hkpConstraintAtomClass,
		&hkpConstraintChainDataClass,
		&hkpConstraintChainInstanceActionClass,
		&hkpConstraintChainInstanceClass,
		&hkpConstraintCollisionFilterClass,
		&hkpConstraintDataClass,
		&hkpConstraintInstanceClass,
		&hkpConstraintInstanceSmallArraySerializeOverrideTypeClass,
		&hkpConstraintMotorClass,
		&hkpConvexListFilterClass,
		&hkpConvexListShapeClass,
		&hkpConvexPieceMeshShapeClass,
		&hkpConvexPieceStreamDataClass,
		&hkpConvexShapeClass,
		&hkpConvexTransformShapeBaseClass,
		&hkpConvexTransformShapeClass,
		&hkpConvexTranslateShapeClass,
		&hkpConvexVerticesConnectivityClass,
		&hkpConvexVerticesShapeClass,
		&hkpCylinderShapeClass,
		&hkpDashpotActionClass,
		&hkpDefaultConvexListFilterClass,
		&hkpDefaultWorldMemoryWatchDogClass,
		&hkpDisableEntityCollisionFilterClass,
		&hkpDisplayBindingDataClass,
		&hkpDisplayBindingDataPhysicsSystemClass,
		&hkpDisplayBindingDataRigidBodyClass,
		&hkpEntityClass,
		&hkpEntityExtendedListenersClass,
		&hkpEntitySmallArraySerializeOverrideTypeClass,
		&hkpEntitySpuCollisionCallbackClass,
		&hkpExtendedMeshShapeBreakableMaterialClass,
		&hkpExtendedMeshShapeClass,
		&hkpExtendedMeshShapeShapesSubpartClass,
		&hkpExtendedMeshShapeSubpartClass,
		&hkpExtendedMeshShapeTrianglesSubpartClass,
		&hkpFastMeshShapeClass,
		&hkpFirstPersonGunClass,
		&hkpFixedRigidMotionClass,
		&hkpGenericConstraintDataClass,
		&hkpGenericConstraintDataSchemeClass,
		&hkpGenericConstraintDataSchemeConstraintInfoClass,
		&hkpGravityGunClass,
		&hkpGroupCollisionFilterClass,
		&hkpGroupFilterClass,
		&hkpHeightFieldShapeClass,
		&hkpHingeConstraintDataAtomsClass,
		&hkpHingeConstraintDataClass,
		&hkpHingeLimitsDataAtomsClass,
		&hkpHingeLimitsDataClass,
		&hkpIgnoreModifierConstraintAtomClass,
		&hkpKeyframedRigidMotionClass,
		&hkpLimitedForceConstraintMotorClass,
		&hkpLimitedHingeConstraintDataAtomsClass,
		&hkpLimitedHingeConstraintDataClass,
		&hkpLinConstraintAtomClass,
		&hkpLinFrictionConstraintAtomClass,
		&hkpLinLimitConstraintAtomClass,
		&hkpLinMotorConstraintAtomClass,
		&hkpLinSoftConstraintAtomClass,
		&hkpLinearParametricCurveClass,
		&hkpLinkedCollidableClass,
		&hkpListShapeBreakableMaterialClass,
		&hkpListShapeChildInfoClass,
		&hkpListShapeClass,
		&hkpMalleableConstraintDataClass,
		&hkpMassChangerModifierConstraintAtomClass,
		&hkpMassPropertiesClass,
		&hkpMaterialClass,
		&hkpMaxSizeMotionClass,
		&hkpMeshMaterialClass,
		&hkpMeshShapeClass,
		&hkpMeshShapeSubpartClass,
		&hkpModifierConstraintAtomClass,
		&hkpMoppBvTreeShapeClass,
		&hkpMoppCodeClass,
		&hkpMoppCodeCodeInfoClass,
		&hkpMoppCodeReindexedTerminalClass,
		&hkpMotionClass,
		&hkpMotorActionClass,
		&hkpMountedBallGunClass,
		&hkpMouseSpringActionClass,
		&hkpMovingSurfaceModifierConstraintAtomClass,
		&hkpMultiRayShapeClass,
		&hkpMultiRayShapeRayClass,
		&hkpMultiSphereShapeClass,
		&hkpMultithreadedVehicleManagerClass,
		&hkpNamedMeshMaterialClass,
		&hkpNullCollisionFilterClass,
		&hkpOverwritePivotConstraintAtomClass,
		&hkpPairCollisionFilterClass,
		&hkpPairCollisionFilterMapPairFilterKeyOverrideTypeClass,
		&hkpParametricCurveClass,
		&hkpPhantomCallbackShapeClass,
		&hkpPhantomClass,
		&hkpPhysicsDataClass,
		&hkpPhysicsSystemClass,
		&hkpPhysicsSystemWithContactsClass,
		&hkpPlaneShapeClass,
		&hkpPointToPathConstraintDataClass,
		&hkpPointToPlaneConstraintDataAtomsClass,
		&hkpPointToPlaneConstraintDataClass,
		&hkpPositionConstraintMotorClass,
		&hkpPoweredChainDataClass,
		&hkpPoweredChainDataConstraintInfoClass,
		&hkpPoweredChainMapperClass,
		&hkpPoweredChainMapperLinkInfoClass,
		&hkpPoweredChainMapperTargetClass,
		&hkpPrismaticConstraintDataAtomsClass,
		&hkpPrismaticConstraintDataClass,
		&hkpProjectileGunClass,
		&hkpPropertyClass,
		&hkpPropertyValueClass,
		&hkpPulleyConstraintAtomClass,
		&hkpPulleyConstraintDataAtomsClass,
		&hkpPulleyConstraintDataClass,
		&hkpRackAndPinionConstraintAtomClass,
		&hkpRackAndPinionConstraintDataAtomsClass,
		&hkpRackAndPinionConstraintDataClass,
		&hkpRagdollConstraintDataAtomsClass,
		&hkpRagdollConstraintDataClass,
		&hkpRagdollLimitsDataAtomsClass,
		&hkpRagdollLimitsDataClass,
		&hkpRagdollMotorConstraintAtomClass,
		&hkpRayCollidableFilterClass,
		&hkpRayShapeCollectionFilterClass,
		&hkpRejectChassisListenerClass,
		&hkpRemoveTerminalsMoppModifierClass,
		&hkpReorientActionClass,
		&hkpRigidBodyClass,
		&hkpRotationalConstraintDataAtomsClass,
		&hkpRotationalConstraintDataClass,
		&hkpSampledHeightFieldShapeClass,
		&hkpSampledHeightFieldShapeCoarseMinMaxLevelClass,
		&hkpSerializedAgentNnEntryClass,
		&hkpSerializedDisplayMarkerClass,
		&hkpSerializedDisplayMarkerListClass,
		&hkpSerializedDisplayRbTransformsClass,
		&hkpSerializedDisplayRbTransformsDisplayTransformPairClass,
		&hkpSerializedSubTrack1nInfoClass,
		&hkpSerializedTrack1nInfoClass,
		&hkpSetLocalRotationsConstraintAtomClass,
		&hkpSetLocalTransformsConstraintAtomClass,
		&hkpSetLocalTranslationsConstraintAtomClass,
		&hkpSetupStabilizationAtomClass,
		&hkpShapeClass,
		&hkpShapeCollectionClass,
		&hkpShapeCollectionFilterClass,
		&hkpShapeContainerClass,
		&hkpShapeInfoClass,
		&hkpShapeKeyTableBlockClass,
		&hkpShapeKeyTableClass,
		&hkpShapePhantomClass,
		&hkpSimpleBreakableMaterialClass,
		&hkpSimpleContactConstraintAtomClass,
		&hkpSimpleContactConstraintDataInfoClass,
		&hkpSimpleMeshShapeClass,
		&hkpSimpleMeshShapeTriangleClass,
		&hkpSimpleShapePhantomClass,
		&hkpSingleShapeContainerClass,
		&hkpSoftContactModifierConstraintAtomClass,
		&hkpSphereMotionClass,
		&hkpSphereRepShapeClass,
		&hkpSphereShapeClass,
		&hkpSpringActionClass,
		&hkpSpringDamperConstraintMotorClass,
		&hkpStaticCompoundShapeBreakableMaterialClass,
		&hkpStaticCompoundShapeClass,
		&hkpStaticCompoundShapeInstanceClass,
		&hkpStiffSpringChainDataClass,
		&hkpStiffSpringChainDataConstraintInfoClass,
		&hkpStiffSpringConstraintAtomClass,
		&hkpStiffSpringConstraintDataAtomsClass,
		&hkpStiffSpringConstraintDataClass,
		&hkpStorageExtendedMeshShapeClass,
		&hkpStorageExtendedMeshShapeMaterialClass,
		&hkpStorageExtendedMeshShapeMeshSubpartStorageClass,
		&hkpStorageExtendedMeshShapeShapeSubpartStorageClass,
		&hkpStorageMeshShapeClass,
		&hkpStorageMeshShapeSubpartStorageClass,
		&hkpStorageSampledHeightFieldShapeClass,
		&hkpThinBoxMotionClass,
		&hkpTransformShapeClass,
		&hkpTriSampledHeightFieldBvTreeShapeClass,
		&hkpTriSampledHeightFieldCollectionClass,
		&hkpTriangleShapeClass,
		&hkpTriggerVolumeClass,
		&hkpTriggerVolumeEventInfoClass,
		&hkpTwistLimitConstraintAtomClass,
		&hkpTypedBroadPhaseHandleClass,
		&hkpTyremarkPointClass,
		&hkpTyremarksInfoClass,
		&hkpTyremarksWheelClass,
		&hkpUnaryActionClass,
		&hkpVehicleAerodynamicsClass,
		&hkpVehicleBrakeClass,
		&hkpVehicleCastBatchingManagerClass,
		&hkpVehicleDataClass,
		&hkpVehicleDataWheelComponentParamsClass,
		&hkpVehicleDefaultAerodynamicsClass,
		&hkpVehicleDefaultAnalogDriverInputClass,
		&hkpVehicleDefaultBrakeClass,
		&hkpVehicleDefaultBrakeWheelBrakingPropertiesClass,
		&hkpVehicleDefaultEngineClass,
		&hkpVehicleDefaultSteeringClass,
		&hkpVehicleDefaultSuspensionClass,
		&hkpVehicleDefaultSuspensionWheelSpringSuspensionParametersClass,
		&hkpVehicleDefaultTransmissionClass,
		&hkpVehicleDefaultVelocityDamperClass,
		&hkpVehicleDriverInputAnalogStatusClass,
		&hkpVehicleDriverInputClass,
		&hkpVehicleDriverInputStatusClass,
		&hkpVehicleEngineClass,
		&hkpVehicleFrictionDescriptionAxisDescriptionClass,
		&hkpVehicleFrictionDescriptionClass,
		&hkpVehicleFrictionStatusAxisStatusClass,
		&hkpVehicleFrictionStatusClass,
		&hkpVehicleInstanceClass,
		&hkpVehicleInstanceWheelInfoClass,
		&hkpVehicleLinearCastBatchingManagerClass,
		&hkpVehicleLinearCastWheelCollideClass,
		&hkpVehicleLinearCastWheelCollideWheelStateClass,
		&hkpVehicleManagerClass,
		&hkpVehicleRayCastBatchingManagerClass,
		&hkpVehicleRayCastWheelCollideClass,
		&hkpVehicleSteeringClass,
		&hkpVehicleSuspensionClass,
		&hkpVehicleSuspensionSuspensionWheelParametersClass,
		&hkpVehicleTransmissionClass,
		&hkpVehicleVelocityDamperClass,
		&hkpVehicleWheelCollideClass,
		&hkpVelocityConstraintMotorClass,
		&hkpViscousSurfaceModifierConstraintAtomClass,
		&hkpWeldingUtilityClass,
		&hkpWheelConstraintDataAtomsClass,
		&hkpWheelConstraintDataClass,
		&hkpWorldCinfoClass,
		&hkpWorldObjectClass,
		&hkxAnimatedFloatClass,
		&hkxAnimatedMatrixClass,
		&hkxAnimatedQuaternionClass,
		&hkxAnimatedVectorClass,
		&hkxAttributeClass,
		&hkxAttributeGroupClass,
		&hkxAttributeHolderClass,
		&hkxCameraClass,
		&hkxEdgeSelectionChannelClass,
		&hkxEnumClass,
		&hkxEnumItemClass,
		&hkxEnvironmentClass,
		&hkxEnvironmentVariableClass,
		&hkxIndexBufferClass,
		&hkxLightClass,
		&hkxMaterialClass,
		&hkxMaterialEffectClass,
		&hkxMaterialPropertyClass,
		&hkxMaterialShaderClass,
		&hkxMaterialShaderSetClass,
		&hkxMaterialTextureStageClass,
		&hkxMeshClass,
		&hkxMeshSectionClass,
		&hkxMeshUserChannelInfoClass,
		&hkxNodeAnnotationDataClass,
		&hkxNodeClass,
		&hkxNodeSelectionSetClass,
		&hkxSceneClass,
		&hkxSkinBindingClass,
		&hkxSparselyAnimatedBoolClass,
		&hkxSparselyAnimatedEnumClass,
		&hkxSparselyAnimatedIntClass,
		&hkxSparselyAnimatedStringClass,
		&hkxTextureFileClass,
		&hkxTextureInplaceClass,
		&hkxTriangleSelectionChannelClass,
		&hkxVertexBufferClass,
		&hkxVertexBufferVertexDataClass,
		&hkxVertexDescriptionClass,
		&hkxVertexDescriptionElementDeclClass,
		&hkxVertexFloatDataChannelClass,
		&hkxVertexIntDataChannelClass,
		&hkxVertexSelectionChannelClass,
		&hkxVertexVectorDataChannelClass,
		HK_NULL
	}; 
	const hkStaticClassNameRegistry hkHavokDefaultClassRegistry
	(
		Classes,
		ClassVersion,
		VersionString
	);

} // namespace hkHavok201120r1Classes

/*
 * Havok SDK - Base file, BUILD(#20130912)
 * 
 * Confidential Information of Havok.  (C) Copyright 1999-2013
 * Telekinesys Research Limited t/a Havok. All Rights Reserved. The Havok
 * Logo, and the Havok buzzsaw logo are trademarks of Havok.  Title, ownership
 * rights, and intellectual property rights in the Havok software remain in
 * Havok and/or its suppliers.
 * 
 * Use of this software for evaluation purposes is subject to and indicates
 * acceptance of the End User licence Agreement for this product. A copy of
 * the license is included with this software and is also available from salesteam@havok.com.
 * 
 */
