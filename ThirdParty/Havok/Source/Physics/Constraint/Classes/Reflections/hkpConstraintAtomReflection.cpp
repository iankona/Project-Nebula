/*
 *
 * Confidential Information of Telekinesys Research Limited (t/a Havok). Not for disclosure or distribution without Havok's
 * prior written consent. This software contains code, techniques and know-how which is confidential and proprietary to Havok.
 * Product and Trade Secret source code contains trade secrets of Havok. Havok Software (C) Copyright 1999-2013 Telekinesys Research Limited t/a Havok. All Rights Reserved. Use of this software is subject to the terms of an end user license agreement.
 *
 */

//HK_REFLECTION_PARSER_EXCLUDE_FILE

// Autogenerated by generateReflections.py (reflectedClasses.py)
// Changes will not be lost unless:
// - The workspace is re-generated using build.py
// - The corresponding reflection database (reflection.db) is deleted
// - The --force-output or --force-rebuild option is added to the pre-build generateReflection.py execution

// Generated from 'Physics/Constraint/Atom/hkpConstraintAtom.h'
#include <Common/Base/hkBase.h>
#include <Common/Base/Reflection/hkClass.h>
#include <Common/Base/Reflection/hkInternalClassMember.h>
#include <Common/Base/Reflection/hkTypeInfo.h>
#include <Common/Base/Reflection/Attributes/hkAttributes.h>
#include <Physics/Constraint/Atom/hkpConstraintAtom.h>
#define True true
#define False false


// External pointer and enum types
extern const hkClass hkUFloat8Class;
extern const hkClass hkpConstraintMotorClass;
extern const hkClass hkpWheelFrictionConstraintAtomAxleClass;
extern const hkClassEnum* hkpConeLimitConstraintAtomMeasurementModeEnum;
extern const hkClassEnum* hkpConstraintAtomAtomTypeEnum;
extern const hkClassEnum* hkpConstraintAtomSolvingMethodEnum;

//
// Enum hkpConstraintAtom::AtomType
//
static const hkInternalClassEnumItem hkpConstraintAtomAtomTypeEnumItems[] =
{
	{0, "TYPE_INVALID"},
	{1, "TYPE_BRIDGE"},
	{2, "TYPE_SET_LOCAL_TRANSFORMS"},
	{3, "TYPE_SET_LOCAL_TRANSLATIONS"},
	{4, "TYPE_SET_LOCAL_ROTATIONS"},
	{5, "TYPE_BALL_SOCKET"},
	{6, "TYPE_STIFF_SPRING"},
	{7, "TYPE_LIN"},
	{8, "TYPE_LIN_SOFT"},
	{9, "TYPE_LIN_LIMIT"},
	{10, "TYPE_LIN_FRICTION"},
	{11, "TYPE_LIN_MOTOR"},
	{12, "TYPE_2D_ANG"},
	{13, "TYPE_ANG"},
	{14, "TYPE_ANG_LIMIT"},
	{15, "TYPE_TWIST_LIMIT"},
	{16, "TYPE_CONE_LIMIT"},
	{17, "TYPE_ANG_FRICTION"},
	{18, "TYPE_ANG_MOTOR"},
	{19, "TYPE_RAGDOLL_MOTOR"},
	{20, "TYPE_PULLEY"},
	{21, "TYPE_RACK_AND_PINION"},
	{22, "TYPE_COG_WHEEL"},
	{23, "TYPE_SETUP_STABILIZATION"},
	{24, "TYPE_3D_ANG"},
	{25, "TYPE_DEFORMABLE_3D_LIN"},
	{26, "TYPE_DEFORMABLE_3D_ANG"},
	{27, "TYPE_OVERWRITE_PIVOT"},
	{28, "TYPE_WHEEL_FRICTION"},
	{29, "TYPE_CONTACT"},
	{30, "FIRST_MODIFIER_TYPE"},
	{30, "TYPE_MODIFIER_SOFT_CONTACT"},
	{31, "TYPE_MODIFIER_MASS_CHANGER"},
	{32, "TYPE_MODIFIER_VISCOUS_SURFACE"},
	{33, "TYPE_MODIFIER_MOVING_SURFACE"},
	{34, "TYPE_MODIFIER_IGNORE_CONSTRAINT"},
	{35, "TYPE_MODIFIER_CENTER_OF_MASS_CHANGER"},
	{35, "LAST_MODIFIER_TYPE"},
	{36, "TYPE_MAX"},
};

//
// Enum hkpConstraintAtom::CallbackRequest
//
static const hkInternalClassEnumItem hkpConstraintAtomCallbackRequestEnumItems[] =
{
	{0, "CALLBACK_REQUEST_NONE"},
	{1, "CALLBACK_REQUEST_NEW_CONTACT_POINT"},
	{2, "CALLBACK_REQUEST_SETUP_PPU_ONLY"},
	{4, "CALLBACK_REQUEST_SETUP_CALLBACK"},
	{8, "CALLBACK_REQUEST_CONTACT_POINT_CALLBACK"},
};

//
// Enum hkpConstraintAtom::SolvingMethod
//
static const hkInternalClassEnumItem hkpConstraintAtomSolvingMethodEnumItems[] =
{
	{0, "METHOD_STABILIZED"},
	{1, "METHOD_OLD"},
};
static const hkInternalClassEnum hkpConstraintAtomEnums[] = {
	{"AtomType", hkpConstraintAtomAtomTypeEnumItems, 39, HK_NULL, 0 },
	{"CallbackRequest", hkpConstraintAtomCallbackRequestEnumItems, 5, HK_NULL, 0 },
	{"SolvingMethod", hkpConstraintAtomSolvingMethodEnumItems, 2, HK_NULL, 0 }
};
const hkClassEnum* hkpConstraintAtomAtomTypeEnum = reinterpret_cast<const hkClassEnum*>(&hkpConstraintAtomEnums[0]);
const hkClassEnum* hkpConstraintAtomCallbackRequestEnum = reinterpret_cast<const hkClassEnum*>(&hkpConstraintAtomEnums[1]);
const hkClassEnum* hkpConstraintAtomSolvingMethodEnum = reinterpret_cast<const hkClassEnum*>(&hkpConstraintAtomEnums[2]);

//
// Class hkpConstraintAtom
//
static const hkInternalClassMember hkpConstraintAtomClass_Members[] =
{
	{ "type", HK_NULL, hkpConstraintAtomAtomTypeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT16, 0, 0, HK_OFFSET_OF(hkpConstraintAtom,m_type), HK_NULL }
};
extern const hkClass hkpConstraintAtomClass;
const hkClass hkpConstraintAtomClass(
	"hkpConstraintAtom",
	HK_NULL, // parent
	sizeof(::hkpConstraintAtom),
	HK_NULL,
	0, // interfaces
	reinterpret_cast<const hkClassEnum*>(hkpConstraintAtomEnums),
	3, // enums
	reinterpret_cast<const hkClassMember*>(hkpConstraintAtomClass_Members),
	HK_COUNT_OF(hkpConstraintAtomClass_Members),
	HK_NULL, // defaults
	HK_NULL, // attributes
	0, // flags
	hkUint32(0) // version
	);
#ifndef HK_HKCLASS_DEFINITION_ONLY
const hkClass& HK_CALL hkpConstraintAtom::staticClass()
{
	return hkpConstraintAtomClass;
}
HK_COMPILE_TIME_ASSERT2( \
	sizeof(hkIsVirtual(static_cast<hkpConstraintAtom*>(0))) == sizeof(hkBool::CompileTimeFalseType), \
	REFLECTION_PARSER_VTABLE_DETECTION_FAILED );
static void HK_CALL finishLoadedObjecthkpConstraintAtom(void* p, int finishing = 1)
{
	hkFinishLoadedObjectFlag f;
	f.m_finishing = finishing;
	new (p) hkpConstraintAtom(f);
}
static void HK_CALL cleanupLoadedObjecthkpConstraintAtom(void* p)
{
	static_cast<hkpConstraintAtom*>(p)->~hkpConstraintAtom();
}
extern const hkTypeInfo hkpConstraintAtomTypeInfo;
const hkTypeInfo hkpConstraintAtomTypeInfo(
	"hkpConstraintAtom",
	"!hkpConstraintAtom",
	finishLoadedObjecthkpConstraintAtom,
	cleanupLoadedObjecthkpConstraintAtom,
	HK_NULL,
	sizeof(hkpConstraintAtom)
	);
#endif

//
// Class hkpSetupStabilizationAtom
//

static const hkInternalClassMember hkpSetupStabilizationAtomClass_Members[] =
{
	{ "enabled", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpSetupStabilizationAtom,m_enabled), HK_NULL },
	{ "maxLinImpulse", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpSetupStabilizationAtom,m_maxLinImpulse), HK_NULL },
	{ "maxAngImpulse", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpSetupStabilizationAtom,m_maxAngImpulse), HK_NULL },
	{ "maxAngle", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpSetupStabilizationAtom,m_maxAngle), HK_NULL }
};
namespace
{
	struct hkpSetupStabilizationAtom_DefaultStruct
	{
		int s_defaultOffsets[4];
		typedef hkInt8 _hkBool;
		typedef hkFloat32 _hkVector4[4];
		typedef hkReal _hkQuaternion[4];
		typedef hkReal _hkMatrix3[12];
		typedef hkReal _hkRotation[12];
		typedef hkReal _hkQsTransform[12];
		typedef hkReal _hkMatrix4[16];
		typedef hkReal _hkTransform[16];
		float m_maxLinImpulse;
		float m_maxAngImpulse;
		float m_maxAngle;
	};
	const hkpSetupStabilizationAtom_DefaultStruct hkpSetupStabilizationAtom_Default =
	{
		{hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkpSetupStabilizationAtom_DefaultStruct,m_maxLinImpulse),HK_OFFSET_OF(hkpSetupStabilizationAtom_DefaultStruct,m_maxAngImpulse),HK_OFFSET_OF(hkpSetupStabilizationAtom_DefaultStruct,m_maxAngle)},
		HK_REAL_MAX,HK_REAL_MAX,HK_REAL_HIGH
	};
}
extern const hkClass hkpSetupStabilizationAtomClass;
const hkClass hkpSetupStabilizationAtomClass(
	"hkpSetupStabilizationAtom",
	&hkpConstraintAtomClass, // parent
	sizeof(::hkpSetupStabilizationAtom),
	HK_NULL,
	0, // interfaces
	HK_NULL,
	0, // enums
	reinterpret_cast<const hkClassMember*>(hkpSetupStabilizationAtomClass_Members),
	HK_COUNT_OF(hkpSetupStabilizationAtomClass_Members),
	&hkpSetupStabilizationAtom_Default,
	HK_NULL, // attributes
	0, // flags
	hkUint32(2) // version
	);
#ifndef HK_HKCLASS_DEFINITION_ONLY
const hkClass& HK_CALL hkpSetupStabilizationAtom::staticClass()
{
	return hkpSetupStabilizationAtomClass;
}
HK_COMPILE_TIME_ASSERT2( \
	sizeof(hkIsVirtual(static_cast<hkpSetupStabilizationAtom*>(0))) == sizeof(hkBool::CompileTimeFalseType), \
	REFLECTION_PARSER_VTABLE_DETECTION_FAILED );
static void HK_CALL finishLoadedObjecthkpSetupStabilizationAtom(void* p, int finishing = 1)
{
	hkFinishLoadedObjectFlag f;
	f.m_finishing = finishing;
	new (p) hkpSetupStabilizationAtom(f);
}
static void HK_CALL cleanupLoadedObjecthkpSetupStabilizationAtom(void* p)
{
	static_cast<hkpSetupStabilizationAtom*>(p)->~hkpSetupStabilizationAtom();
}
extern const hkTypeInfo hkpSetupStabilizationAtomTypeInfo;
const hkTypeInfo hkpSetupStabilizationAtomTypeInfo(
	"hkpSetupStabilizationAtom",
	"!hkpSetupStabilizationAtom",
	finishLoadedObjecthkpSetupStabilizationAtom,
	cleanupLoadedObjecthkpSetupStabilizationAtom,
	HK_NULL,
	sizeof(hkpSetupStabilizationAtom)
	);
#endif

//
// Class hkp3dAngConstraintAtom
//

static const hkInternalClassMember hkp3dAngConstraintAtomClass_Members[] =
{
	{ "padding", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 14, 0|hkClassMember::SERIALIZE_IGNORED, HK_OFFSET_OF(hkp3dAngConstraintAtom,m_padding), HK_NULL }
};
extern const hkClass hkp3dAngConstraintAtomClass;
const hkClass hkp3dAngConstraintAtomClass(
	"hkp3dAngConstraintAtom",
	&hkpConstraintAtomClass, // parent
	sizeof(::hkp3dAngConstraintAtom),
	HK_NULL,
	0, // interfaces
	HK_NULL,
	0, // enums
	reinterpret_cast<const hkClassMember*>(hkp3dAngConstraintAtomClass_Members),
	HK_COUNT_OF(hkp3dAngConstraintAtomClass_Members),
	HK_NULL, // defaults
	HK_NULL, // attributes
	0, // flags
	hkUint32(1) // version
	);
#ifndef HK_HKCLASS_DEFINITION_ONLY
const hkClass& HK_CALL hkp3dAngConstraintAtom::staticClass()
{
	return hkp3dAngConstraintAtomClass;
}
HK_COMPILE_TIME_ASSERT2( \
	sizeof(hkIsVirtual(static_cast<hkp3dAngConstraintAtom*>(0))) == sizeof(hkBool::CompileTimeFalseType), \
	REFLECTION_PARSER_VTABLE_DETECTION_FAILED );
static void HK_CALL finishLoadedObjecthkp3dAngConstraintAtom(void* p, int finishing = 1)
{
	hkFinishLoadedObjectFlag f;
	f.m_finishing = finishing;
	new (p) hkp3dAngConstraintAtom(f);
}
static void HK_CALL cleanupLoadedObjecthkp3dAngConstraintAtom(void* p)
{
	static_cast<hkp3dAngConstraintAtom*>(p)->~hkp3dAngConstraintAtom();
}
extern const hkTypeInfo hkp3dAngConstraintAtomTypeInfo;
const hkTypeInfo hkp3dAngConstraintAtomTypeInfo(
	"hkp3dAngConstraintAtom",
	"!hkp3dAngConstraintAtom",
	finishLoadedObjecthkp3dAngConstraintAtom,
	cleanupLoadedObjecthkp3dAngConstraintAtom,
	HK_NULL,
	sizeof(hkp3dAngConstraintAtom)
	);
#endif

//
// Class hkpDeformableLinConstraintAtom
//

static const hkInternalClassMember hkpDeformableLinConstraintAtomClass_Members[] =
{
	{ "offset", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpDeformableLinConstraintAtom,m_offset), HK_NULL },
	{ "yieldStrengthDiag", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpDeformableLinConstraintAtom,m_yieldStrengthDiag), HK_NULL },
	{ "yieldStrengthOffDiag", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpDeformableLinConstraintAtom,m_yieldStrengthOffDiag), HK_NULL },
	{ "ultimateStrengthDiag", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpDeformableLinConstraintAtom,m_ultimateStrengthDiag), HK_NULL },
	{ "ultimateStrengthOffDiag", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpDeformableLinConstraintAtom,m_ultimateStrengthOffDiag), HK_NULL }
};
namespace
{
	struct hkpDeformableLinConstraintAtom_DefaultStruct
	{
		int s_defaultOffsets[5];
		typedef hkInt8 _hkBool;
		typedef hkFloat32 _hkVector4[4];
		typedef hkReal _hkQuaternion[4];
		typedef hkReal _hkMatrix3[12];
		typedef hkReal _hkRotation[12];
		typedef hkReal _hkQsTransform[12];
		typedef hkReal _hkMatrix4[16];
		typedef hkReal _hkTransform[16];
		_hkVector4 m_offset;
	};
	const hkpDeformableLinConstraintAtom_DefaultStruct hkpDeformableLinConstraintAtom_Default =
	{
		{HK_OFFSET_OF(hkpDeformableLinConstraintAtom_DefaultStruct,m_offset),-1,-1,-1,-1},
		{0.0f,0.0f,0.0f,0.0f}
	};
}
extern const hkClass hkpDeformableLinConstraintAtomClass;
const hkClass hkpDeformableLinConstraintAtomClass(
	"hkpDeformableLinConstraintAtom",
	&hkpConstraintAtomClass, // parent
	sizeof(::hkpDeformableLinConstraintAtom),
	HK_NULL,
	0, // interfaces
	HK_NULL,
	0, // enums
	reinterpret_cast<const hkClassMember*>(hkpDeformableLinConstraintAtomClass_Members),
	HK_COUNT_OF(hkpDeformableLinConstraintAtomClass_Members),
	&hkpDeformableLinConstraintAtom_Default,
	HK_NULL, // attributes
	0, // flags
	hkUint32(1) // version
	);
#ifndef HK_HKCLASS_DEFINITION_ONLY
const hkClass& HK_CALL hkpDeformableLinConstraintAtom::staticClass()
{
	return hkpDeformableLinConstraintAtomClass;
}
HK_COMPILE_TIME_ASSERT2( \
	sizeof(hkIsVirtual(static_cast<hkpDeformableLinConstraintAtom*>(0))) == sizeof(hkBool::CompileTimeFalseType), \
	REFLECTION_PARSER_VTABLE_DETECTION_FAILED );
static void HK_CALL finishLoadedObjecthkpDeformableLinConstraintAtom(void* p, int finishing = 1)
{
	hkFinishLoadedObjectFlag f;
	f.m_finishing = finishing;
	new (p) hkpDeformableLinConstraintAtom(f);
}
static void HK_CALL cleanupLoadedObjecthkpDeformableLinConstraintAtom(void* p)
{
	static_cast<hkpDeformableLinConstraintAtom*>(p)->~hkpDeformableLinConstraintAtom();
}
extern const hkTypeInfo hkpDeformableLinConstraintAtomTypeInfo;
const hkTypeInfo hkpDeformableLinConstraintAtomTypeInfo(
	"hkpDeformableLinConstraintAtom",
	"!hkpDeformableLinConstraintAtom",
	finishLoadedObjecthkpDeformableLinConstraintAtom,
	cleanupLoadedObjecthkpDeformableLinConstraintAtom,
	HK_NULL,
	sizeof(hkpDeformableLinConstraintAtom)
	);
#endif

//
// Class hkpDeformableAngConstraintAtom
//

static const hkInternalClassMember hkpDeformableAngConstraintAtomClass_Members[] =
{
	{ "offset", HK_NULL, HK_NULL, hkClassMember::TYPE_QUATERNION, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpDeformableAngConstraintAtom,m_offset), HK_NULL },
	{ "yieldStrengthDiag", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpDeformableAngConstraintAtom,m_yieldStrengthDiag), HK_NULL },
	{ "yieldStrengthOffDiag", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpDeformableAngConstraintAtom,m_yieldStrengthOffDiag), HK_NULL },
	{ "ultimateStrengthDiag", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpDeformableAngConstraintAtom,m_ultimateStrengthDiag), HK_NULL },
	{ "ultimateStrengthOffDiag", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpDeformableAngConstraintAtom,m_ultimateStrengthOffDiag), HK_NULL }
};
namespace
{
	struct hkpDeformableAngConstraintAtom_DefaultStruct
	{
		int s_defaultOffsets[5];
		typedef hkInt8 _hkBool;
		typedef hkFloat32 _hkVector4[4];
		typedef hkReal _hkQuaternion[4];
		typedef hkReal _hkMatrix3[12];
		typedef hkReal _hkRotation[12];
		typedef hkReal _hkQsTransform[12];
		typedef hkReal _hkMatrix4[16];
		typedef hkReal _hkTransform[16];
		_hkQuaternion m_offset;
	};
	const hkpDeformableAngConstraintAtom_DefaultStruct hkpDeformableAngConstraintAtom_Default =
	{
		{HK_OFFSET_OF(hkpDeformableAngConstraintAtom_DefaultStruct,m_offset),-1,-1,-1,-1},
		{0.0f,0.0f,0.0f,1.0f}
	};
}
extern const hkClass hkpDeformableAngConstraintAtomClass;
const hkClass hkpDeformableAngConstraintAtomClass(
	"hkpDeformableAngConstraintAtom",
	&hkpConstraintAtomClass, // parent
	sizeof(::hkpDeformableAngConstraintAtom),
	HK_NULL,
	0, // interfaces
	HK_NULL,
	0, // enums
	reinterpret_cast<const hkClassMember*>(hkpDeformableAngConstraintAtomClass_Members),
	HK_COUNT_OF(hkpDeformableAngConstraintAtomClass_Members),
	&hkpDeformableAngConstraintAtom_Default,
	HK_NULL, // attributes
	0, // flags
	hkUint32(1) // version
	);
#ifndef HK_HKCLASS_DEFINITION_ONLY
const hkClass& HK_CALL hkpDeformableAngConstraintAtom::staticClass()
{
	return hkpDeformableAngConstraintAtomClass;
}
HK_COMPILE_TIME_ASSERT2( \
	sizeof(hkIsVirtual(static_cast<hkpDeformableAngConstraintAtom*>(0))) == sizeof(hkBool::CompileTimeFalseType), \
	REFLECTION_PARSER_VTABLE_DETECTION_FAILED );
static void HK_CALL finishLoadedObjecthkpDeformableAngConstraintAtom(void* p, int finishing = 1)
{
	hkFinishLoadedObjectFlag f;
	f.m_finishing = finishing;
	new (p) hkpDeformableAngConstraintAtom(f);
}
static void HK_CALL cleanupLoadedObjecthkpDeformableAngConstraintAtom(void* p)
{
	static_cast<hkpDeformableAngConstraintAtom*>(p)->~hkpDeformableAngConstraintAtom();
}
extern const hkTypeInfo hkpDeformableAngConstraintAtomTypeInfo;
const hkTypeInfo hkpDeformableAngConstraintAtomTypeInfo(
	"hkpDeformableAngConstraintAtom",
	"!hkpDeformableAngConstraintAtom",
	finishLoadedObjecthkpDeformableAngConstraintAtom,
	cleanupLoadedObjecthkpDeformableAngConstraintAtom,
	HK_NULL,
	sizeof(hkpDeformableAngConstraintAtom)
	);
#endif

//
// Class hkpBallSocketConstraintAtom
//

const hkInternalClassMember hkpBallSocketConstraintAtom::Members[] =
{
	{ "solvingMethod", HK_NULL, hkpConstraintAtomSolvingMethodEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, HK_OFFSET_OF(hkpBallSocketConstraintAtom,m_solvingMethod), HK_NULL },
	{ "bodiesToNotify", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpBallSocketConstraintAtom,m_bodiesToNotify), HK_NULL },
	{ "velocityStabilizationFactor", &hkUFloat8Class, HK_NULL, hkClassMember::TYPE_STRUCT, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpBallSocketConstraintAtom,m_velocityStabilizationFactor), HK_NULL },
	{ "enableLinearImpulseLimit", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpBallSocketConstraintAtom,m_enableLinearImpulseLimit), HK_NULL },
	{ "breachImpulse", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpBallSocketConstraintAtom,m_breachImpulse), HK_NULL },
	{ "inertiaStabilizationFactor", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpBallSocketConstraintAtom,m_inertiaStabilizationFactor), HK_NULL }
};
namespace
{
	struct hkpBallSocketConstraintAtom_DefaultStruct
	{
		int s_defaultOffsets[6];
		typedef hkInt8 _hkBool;
		typedef hkFloat32 _hkVector4[4];
		typedef hkReal _hkQuaternion[4];
		typedef hkReal _hkMatrix3[12];
		typedef hkReal _hkRotation[12];
		typedef hkReal _hkQsTransform[12];
		typedef hkReal _hkMatrix4[16];
		typedef hkReal _hkTransform[16];
		hkUint8 /* hkEnum< enum hkpConstraintAtom::SolvingMethod, hkUint8 > */ m_solvingMethod;
		float m_breachImpulse;
	};
	const hkpBallSocketConstraintAtom_DefaultStruct hkpBallSocketConstraintAtom_Default =
	{
		{HK_OFFSET_OF(hkpBallSocketConstraintAtom_DefaultStruct,m_solvingMethod),hkClassMember::HK_CLASS_ZERO_DEFAULT,-1,hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hkpBallSocketConstraintAtom_DefaultStruct,m_breachImpulse),hkClassMember::HK_CLASS_ZERO_DEFAULT},
		hkpConstraintAtom::METHOD_OLD,HK_REAL_MAX
	};
}
extern const hkClass hkpBallSocketConstraintAtomClass;
const hkClass hkpBallSocketConstraintAtomClass(
	"hkpBallSocketConstraintAtom",
	&hkpConstraintAtomClass, // parent
	sizeof(::hkpBallSocketConstraintAtom),
	HK_NULL,
	0, // interfaces
	HK_NULL,
	0, // enums
	reinterpret_cast<const hkClassMember*>(hkpBallSocketConstraintAtom::Members),
	HK_COUNT_OF(hkpBallSocketConstraintAtom::Members),
	&hkpBallSocketConstraintAtom_Default,
	HK_NULL, // attributes
	0, // flags
	hkUint32(5) // version
	);
#ifndef HK_HKCLASS_DEFINITION_ONLY
const hkClass& HK_CALL hkpBallSocketConstraintAtom::staticClass()
{
	return hkpBallSocketConstraintAtomClass;
}
HK_COMPILE_TIME_ASSERT2( \
	sizeof(hkIsVirtual(static_cast<hkpBallSocketConstraintAtom*>(0))) == sizeof(hkBool::CompileTimeFalseType), \
	REFLECTION_PARSER_VTABLE_DETECTION_FAILED );
static void HK_CALL finishLoadedObjecthkpBallSocketConstraintAtom(void* p, int finishing = 1)
{
	hkFinishLoadedObjectFlag f;
	f.m_finishing = finishing;
	new (p) hkpBallSocketConstraintAtom(f);
}
static void HK_CALL cleanupLoadedObjecthkpBallSocketConstraintAtom(void* p)
{
	static_cast<hkpBallSocketConstraintAtom*>(p)->~hkpBallSocketConstraintAtom();
}
extern const hkTypeInfo hkpBallSocketConstraintAtomTypeInfo;
const hkTypeInfo hkpBallSocketConstraintAtomTypeInfo(
	"hkpBallSocketConstraintAtom",
	"!hkpBallSocketConstraintAtom",
	finishLoadedObjecthkpBallSocketConstraintAtom,
	cleanupLoadedObjecthkpBallSocketConstraintAtom,
	HK_NULL,
	sizeof(hkpBallSocketConstraintAtom)
	);
#endif

//
// Class hkpStiffSpringConstraintAtom
//

static const hkInternalClassMember hkpStiffSpringConstraintAtomClass_Members[] =
{
	{ "length", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpStiffSpringConstraintAtom,m_length), HK_NULL },
	{ "maxLength", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpStiffSpringConstraintAtom,m_maxLength), HK_NULL }
};
extern const hkClass hkpStiffSpringConstraintAtomClass;
const hkClass hkpStiffSpringConstraintAtomClass(
	"hkpStiffSpringConstraintAtom",
	&hkpConstraintAtomClass, // parent
	sizeof(::hkpStiffSpringConstraintAtom),
	HK_NULL,
	0, // interfaces
	HK_NULL,
	0, // enums
	reinterpret_cast<const hkClassMember*>(hkpStiffSpringConstraintAtomClass_Members),
	HK_COUNT_OF(hkpStiffSpringConstraintAtomClass_Members),
	HK_NULL, // defaults
	HK_NULL, // attributes
	0, // flags
	hkUint32(1) // version
	);
#ifndef HK_HKCLASS_DEFINITION_ONLY
const hkClass& HK_CALL hkpStiffSpringConstraintAtom::staticClass()
{
	return hkpStiffSpringConstraintAtomClass;
}
HK_COMPILE_TIME_ASSERT2( \
	sizeof(hkIsVirtual(static_cast<hkpStiffSpringConstraintAtom*>(0))) == sizeof(hkBool::CompileTimeFalseType), \
	REFLECTION_PARSER_VTABLE_DETECTION_FAILED );
static void HK_CALL finishLoadedObjecthkpStiffSpringConstraintAtom(void* p, int finishing = 1)
{
	hkFinishLoadedObjectFlag f;
	f.m_finishing = finishing;
	new (p) hkpStiffSpringConstraintAtom(f);
}
static void HK_CALL cleanupLoadedObjecthkpStiffSpringConstraintAtom(void* p)
{
	static_cast<hkpStiffSpringConstraintAtom*>(p)->~hkpStiffSpringConstraintAtom();
}
extern const hkTypeInfo hkpStiffSpringConstraintAtomTypeInfo;
const hkTypeInfo hkpStiffSpringConstraintAtomTypeInfo(
	"hkpStiffSpringConstraintAtom",
	"!hkpStiffSpringConstraintAtom",
	finishLoadedObjecthkpStiffSpringConstraintAtom,
	cleanupLoadedObjecthkpStiffSpringConstraintAtom,
	HK_NULL,
	sizeof(hkpStiffSpringConstraintAtom)
	);
#endif

//
// Class hkpSetLocalTransformsConstraintAtom
//

static const hkInternalClassMember hkpSetLocalTransformsConstraintAtomClass_Members[] =
{
	{ "transformA", HK_NULL, HK_NULL, hkClassMember::TYPE_TRANSFORM, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpSetLocalTransformsConstraintAtom,m_transformA), HK_NULL },
	{ "transformB", HK_NULL, HK_NULL, hkClassMember::TYPE_TRANSFORM, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpSetLocalTransformsConstraintAtom,m_transformB), HK_NULL }
};
extern const hkClass hkpSetLocalTransformsConstraintAtomClass;
const hkClass hkpSetLocalTransformsConstraintAtomClass(
	"hkpSetLocalTransformsConstraintAtom",
	&hkpConstraintAtomClass, // parent
	sizeof(::hkpSetLocalTransformsConstraintAtom),
	HK_NULL,
	0, // interfaces
	HK_NULL,
	0, // enums
	reinterpret_cast<const hkClassMember*>(hkpSetLocalTransformsConstraintAtomClass_Members),
	HK_COUNT_OF(hkpSetLocalTransformsConstraintAtomClass_Members),
	HK_NULL, // defaults
	HK_NULL, // attributes
	0, // flags
	hkUint32(0) // version
	);
#ifndef HK_HKCLASS_DEFINITION_ONLY
const hkClass& HK_CALL hkpSetLocalTransformsConstraintAtom::staticClass()
{
	return hkpSetLocalTransformsConstraintAtomClass;
}
HK_COMPILE_TIME_ASSERT2( \
	sizeof(hkIsVirtual(static_cast<hkpSetLocalTransformsConstraintAtom*>(0))) == sizeof(hkBool::CompileTimeFalseType), \
	REFLECTION_PARSER_VTABLE_DETECTION_FAILED );
static void HK_CALL finishLoadedObjecthkpSetLocalTransformsConstraintAtom(void* p, int finishing = 1)
{
	hkFinishLoadedObjectFlag f;
	f.m_finishing = finishing;
	new (p) hkpSetLocalTransformsConstraintAtom(f);
}
static void HK_CALL cleanupLoadedObjecthkpSetLocalTransformsConstraintAtom(void* p)
{
	static_cast<hkpSetLocalTransformsConstraintAtom*>(p)->~hkpSetLocalTransformsConstraintAtom();
}
extern const hkTypeInfo hkpSetLocalTransformsConstraintAtomTypeInfo;
const hkTypeInfo hkpSetLocalTransformsConstraintAtomTypeInfo(
	"hkpSetLocalTransformsConstraintAtom",
	"!hkpSetLocalTransformsConstraintAtom",
	finishLoadedObjecthkpSetLocalTransformsConstraintAtom,
	cleanupLoadedObjecthkpSetLocalTransformsConstraintAtom,
	HK_NULL,
	sizeof(hkpSetLocalTransformsConstraintAtom)
	);
#endif

//
// Class hkpSetLocalTranslationsConstraintAtom
//

static const hkInternalClassMember hkpSetLocalTranslationsConstraintAtomClass_Members[] =
{
	{ "translationA", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpSetLocalTranslationsConstraintAtom,m_translationA), HK_NULL },
	{ "translationB", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpSetLocalTranslationsConstraintAtom,m_translationB), HK_NULL }
};
extern const hkClass hkpSetLocalTranslationsConstraintAtomClass;
const hkClass hkpSetLocalTranslationsConstraintAtomClass(
	"hkpSetLocalTranslationsConstraintAtom",
	&hkpConstraintAtomClass, // parent
	sizeof(::hkpSetLocalTranslationsConstraintAtom),
	HK_NULL,
	0, // interfaces
	HK_NULL,
	0, // enums
	reinterpret_cast<const hkClassMember*>(hkpSetLocalTranslationsConstraintAtomClass_Members),
	HK_COUNT_OF(hkpSetLocalTranslationsConstraintAtomClass_Members),
	HK_NULL, // defaults
	HK_NULL, // attributes
	0, // flags
	hkUint32(0) // version
	);
#ifndef HK_HKCLASS_DEFINITION_ONLY
const hkClass& HK_CALL hkpSetLocalTranslationsConstraintAtom::staticClass()
{
	return hkpSetLocalTranslationsConstraintAtomClass;
}
HK_COMPILE_TIME_ASSERT2( \
	sizeof(hkIsVirtual(static_cast<hkpSetLocalTranslationsConstraintAtom*>(0))) == sizeof(hkBool::CompileTimeFalseType), \
	REFLECTION_PARSER_VTABLE_DETECTION_FAILED );
static void HK_CALL finishLoadedObjecthkpSetLocalTranslationsConstraintAtom(void* p, int finishing = 1)
{
	hkFinishLoadedObjectFlag f;
	f.m_finishing = finishing;
	new (p) hkpSetLocalTranslationsConstraintAtom(f);
}
static void HK_CALL cleanupLoadedObjecthkpSetLocalTranslationsConstraintAtom(void* p)
{
	static_cast<hkpSetLocalTranslationsConstraintAtom*>(p)->~hkpSetLocalTranslationsConstraintAtom();
}
extern const hkTypeInfo hkpSetLocalTranslationsConstraintAtomTypeInfo;
const hkTypeInfo hkpSetLocalTranslationsConstraintAtomTypeInfo(
	"hkpSetLocalTranslationsConstraintAtom",
	"!hkpSetLocalTranslationsConstraintAtom",
	finishLoadedObjecthkpSetLocalTranslationsConstraintAtom,
	cleanupLoadedObjecthkpSetLocalTranslationsConstraintAtom,
	HK_NULL,
	sizeof(hkpSetLocalTranslationsConstraintAtom)
	);
#endif

//
// Class hkpSetLocalRotationsConstraintAtom
//

static const hkInternalClassMember hkpSetLocalRotationsConstraintAtomClass_Members[] =
{
	{ "rotationA", HK_NULL, HK_NULL, hkClassMember::TYPE_ROTATION, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpSetLocalRotationsConstraintAtom,m_rotationA), HK_NULL },
	{ "rotationB", HK_NULL, HK_NULL, hkClassMember::TYPE_ROTATION, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpSetLocalRotationsConstraintAtom,m_rotationB), HK_NULL }
};
extern const hkClass hkpSetLocalRotationsConstraintAtomClass;
const hkClass hkpSetLocalRotationsConstraintAtomClass(
	"hkpSetLocalRotationsConstraintAtom",
	&hkpConstraintAtomClass, // parent
	sizeof(::hkpSetLocalRotationsConstraintAtom),
	HK_NULL,
	0, // interfaces
	HK_NULL,
	0, // enums
	reinterpret_cast<const hkClassMember*>(hkpSetLocalRotationsConstraintAtomClass_Members),
	HK_COUNT_OF(hkpSetLocalRotationsConstraintAtomClass_Members),
	HK_NULL, // defaults
	HK_NULL, // attributes
	0, // flags
	hkUint32(0) // version
	);
#ifndef HK_HKCLASS_DEFINITION_ONLY
const hkClass& HK_CALL hkpSetLocalRotationsConstraintAtom::staticClass()
{
	return hkpSetLocalRotationsConstraintAtomClass;
}
HK_COMPILE_TIME_ASSERT2( \
	sizeof(hkIsVirtual(static_cast<hkpSetLocalRotationsConstraintAtom*>(0))) == sizeof(hkBool::CompileTimeFalseType), \
	REFLECTION_PARSER_VTABLE_DETECTION_FAILED );
static void HK_CALL finishLoadedObjecthkpSetLocalRotationsConstraintAtom(void* p, int finishing = 1)
{
	hkFinishLoadedObjectFlag f;
	f.m_finishing = finishing;
	new (p) hkpSetLocalRotationsConstraintAtom(f);
}
static void HK_CALL cleanupLoadedObjecthkpSetLocalRotationsConstraintAtom(void* p)
{
	static_cast<hkpSetLocalRotationsConstraintAtom*>(p)->~hkpSetLocalRotationsConstraintAtom();
}
extern const hkTypeInfo hkpSetLocalRotationsConstraintAtomTypeInfo;
const hkTypeInfo hkpSetLocalRotationsConstraintAtomTypeInfo(
	"hkpSetLocalRotationsConstraintAtom",
	"!hkpSetLocalRotationsConstraintAtom",
	finishLoadedObjecthkpSetLocalRotationsConstraintAtom,
	cleanupLoadedObjecthkpSetLocalRotationsConstraintAtom,
	HK_NULL,
	sizeof(hkpSetLocalRotationsConstraintAtom)
	);
#endif

//
// Class hkpOverwritePivotConstraintAtom
//

static const hkInternalClassMember hkpOverwritePivotConstraintAtomClass_Members[] =
{
	{ "copyToPivotBFromPivotA", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpOverwritePivotConstraintAtom,m_copyToPivotBFromPivotA), HK_NULL },
	{ "padding", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 12, 0|hkClassMember::SERIALIZE_IGNORED, HK_OFFSET_OF(hkpOverwritePivotConstraintAtom,m_padding), HK_NULL }
};
extern const hkClass hkpOverwritePivotConstraintAtomClass;
const hkClass hkpOverwritePivotConstraintAtomClass(
	"hkpOverwritePivotConstraintAtom",
	&hkpConstraintAtomClass, // parent
	sizeof(::hkpOverwritePivotConstraintAtom),
	HK_NULL,
	0, // interfaces
	HK_NULL,
	0, // enums
	reinterpret_cast<const hkClassMember*>(hkpOverwritePivotConstraintAtomClass_Members),
	HK_COUNT_OF(hkpOverwritePivotConstraintAtomClass_Members),
	HK_NULL, // defaults
	HK_NULL, // attributes
	0, // flags
	hkUint32(0) // version
	);
#ifndef HK_HKCLASS_DEFINITION_ONLY
const hkClass& HK_CALL hkpOverwritePivotConstraintAtom::staticClass()
{
	return hkpOverwritePivotConstraintAtomClass;
}
HK_COMPILE_TIME_ASSERT2( \
	sizeof(hkIsVirtual(static_cast<hkpOverwritePivotConstraintAtom*>(0))) == sizeof(hkBool::CompileTimeFalseType), \
	REFLECTION_PARSER_VTABLE_DETECTION_FAILED );
static void HK_CALL finishLoadedObjecthkpOverwritePivotConstraintAtom(void* p, int finishing = 1)
{
	hkFinishLoadedObjectFlag f;
	f.m_finishing = finishing;
	new (p) hkpOverwritePivotConstraintAtom(f);
}
static void HK_CALL cleanupLoadedObjecthkpOverwritePivotConstraintAtom(void* p)
{
	static_cast<hkpOverwritePivotConstraintAtom*>(p)->~hkpOverwritePivotConstraintAtom();
}
extern const hkTypeInfo hkpOverwritePivotConstraintAtomTypeInfo;
const hkTypeInfo hkpOverwritePivotConstraintAtomTypeInfo(
	"hkpOverwritePivotConstraintAtom",
	"!hkpOverwritePivotConstraintAtom",
	finishLoadedObjecthkpOverwritePivotConstraintAtom,
	cleanupLoadedObjecthkpOverwritePivotConstraintAtom,
	HK_NULL,
	sizeof(hkpOverwritePivotConstraintAtom)
	);
#endif

//
// Class hkpLinConstraintAtom
//

static const hkInternalClassMember hkpLinConstraintAtomClass_Members[] =
{
	{ "axisIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpLinConstraintAtom,m_axisIndex), HK_NULL },
	{ "padding", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 12, 0|hkClassMember::SERIALIZE_IGNORED, HK_OFFSET_OF(hkpLinConstraintAtom,m_padding), HK_NULL }
};
extern const hkClass hkpLinConstraintAtomClass;
const hkClass hkpLinConstraintAtomClass(
	"hkpLinConstraintAtom",
	&hkpConstraintAtomClass, // parent
	sizeof(::hkpLinConstraintAtom),
	HK_NULL,
	0, // interfaces
	HK_NULL,
	0, // enums
	reinterpret_cast<const hkClassMember*>(hkpLinConstraintAtomClass_Members),
	HK_COUNT_OF(hkpLinConstraintAtomClass_Members),
	HK_NULL, // defaults
	HK_NULL, // attributes
	0, // flags
	hkUint32(0) // version
	);
#ifndef HK_HKCLASS_DEFINITION_ONLY
const hkClass& HK_CALL hkpLinConstraintAtom::staticClass()
{
	return hkpLinConstraintAtomClass;
}
HK_COMPILE_TIME_ASSERT2( \
	sizeof(hkIsVirtual(static_cast<hkpLinConstraintAtom*>(0))) == sizeof(hkBool::CompileTimeFalseType), \
	REFLECTION_PARSER_VTABLE_DETECTION_FAILED );
static void HK_CALL finishLoadedObjecthkpLinConstraintAtom(void* p, int finishing = 1)
{
	hkFinishLoadedObjectFlag f;
	f.m_finishing = finishing;
	new (p) hkpLinConstraintAtom(f);
}
static void HK_CALL cleanupLoadedObjecthkpLinConstraintAtom(void* p)
{
	static_cast<hkpLinConstraintAtom*>(p)->~hkpLinConstraintAtom();
}
extern const hkTypeInfo hkpLinConstraintAtomTypeInfo;
const hkTypeInfo hkpLinConstraintAtomTypeInfo(
	"hkpLinConstraintAtom",
	"!hkpLinConstraintAtom",
	finishLoadedObjecthkpLinConstraintAtom,
	cleanupLoadedObjecthkpLinConstraintAtom,
	HK_NULL,
	sizeof(hkpLinConstraintAtom)
	);
#endif

//
// Class hkpLinSoftConstraintAtom
//

static const hkInternalClassMember hkpLinSoftConstraintAtomClass_Members[] =
{
	{ "axisIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpLinSoftConstraintAtom,m_axisIndex), HK_NULL },
	{ "tau", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpLinSoftConstraintAtom,m_tau), HK_NULL },
	{ "damping", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpLinSoftConstraintAtom,m_damping), HK_NULL },
	{ "padding", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 4, 0|hkClassMember::SERIALIZE_IGNORED, HK_OFFSET_OF(hkpLinSoftConstraintAtom,m_padding), HK_NULL }
};
extern const hkClass hkpLinSoftConstraintAtomClass;
const hkClass hkpLinSoftConstraintAtomClass(
	"hkpLinSoftConstraintAtom",
	&hkpConstraintAtomClass, // parent
	sizeof(::hkpLinSoftConstraintAtom),
	HK_NULL,
	0, // interfaces
	HK_NULL,
	0, // enums
	reinterpret_cast<const hkClassMember*>(hkpLinSoftConstraintAtomClass_Members),
	HK_COUNT_OF(hkpLinSoftConstraintAtomClass_Members),
	HK_NULL, // defaults
	HK_NULL, // attributes
	0, // flags
	hkUint32(0) // version
	);
#ifndef HK_HKCLASS_DEFINITION_ONLY
const hkClass& HK_CALL hkpLinSoftConstraintAtom::staticClass()
{
	return hkpLinSoftConstraintAtomClass;
}
HK_COMPILE_TIME_ASSERT2( \
	sizeof(hkIsVirtual(static_cast<hkpLinSoftConstraintAtom*>(0))) == sizeof(hkBool::CompileTimeFalseType), \
	REFLECTION_PARSER_VTABLE_DETECTION_FAILED );
static void HK_CALL finishLoadedObjecthkpLinSoftConstraintAtom(void* p, int finishing = 1)
{
	hkFinishLoadedObjectFlag f;
	f.m_finishing = finishing;
	new (p) hkpLinSoftConstraintAtom(f);
}
static void HK_CALL cleanupLoadedObjecthkpLinSoftConstraintAtom(void* p)
{
	static_cast<hkpLinSoftConstraintAtom*>(p)->~hkpLinSoftConstraintAtom();
}
extern const hkTypeInfo hkpLinSoftConstraintAtomTypeInfo;
const hkTypeInfo hkpLinSoftConstraintAtomTypeInfo(
	"hkpLinSoftConstraintAtom",
	"!hkpLinSoftConstraintAtom",
	finishLoadedObjecthkpLinSoftConstraintAtom,
	cleanupLoadedObjecthkpLinSoftConstraintAtom,
	HK_NULL,
	sizeof(hkpLinSoftConstraintAtom)
	);
#endif

//
// Class hkpLinLimitConstraintAtom
//

static const hkInternalClassMember hkpLinLimitConstraintAtomClass_Members[] =
{
	{ "axisIndex", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpLinLimitConstraintAtom,m_axisIndex), HK_NULL },
	{ "min", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpLinLimitConstraintAtom,m_min), HK_NULL },
	{ "max", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpLinLimitConstraintAtom,m_max), HK_NULL },
	{ "padding", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 4, 0|hkClassMember::SERIALIZE_IGNORED, HK_OFFSET_OF(hkpLinLimitConstraintAtom,m_padding), HK_NULL }
};
extern const hkClass hkpLinLimitConstraintAtomClass;
const hkClass hkpLinLimitConstraintAtomClass(
	"hkpLinLimitConstraintAtom",
	&hkpConstraintAtomClass, // parent
	sizeof(::hkpLinLimitConstraintAtom),
	HK_NULL,
	0, // interfaces
	HK_NULL,
	0, // enums
	reinterpret_cast<const hkClassMember*>(hkpLinLimitConstraintAtomClass_Members),
	HK_COUNT_OF(hkpLinLimitConstraintAtomClass_Members),
	HK_NULL, // defaults
	HK_NULL, // attributes
	0, // flags
	hkUint32(0) // version
	);
#ifndef HK_HKCLASS_DEFINITION_ONLY
const hkClass& HK_CALL hkpLinLimitConstraintAtom::staticClass()
{
	return hkpLinLimitConstraintAtomClass;
}
HK_COMPILE_TIME_ASSERT2( \
	sizeof(hkIsVirtual(static_cast<hkpLinLimitConstraintAtom*>(0))) == sizeof(hkBool::CompileTimeFalseType), \
	REFLECTION_PARSER_VTABLE_DETECTION_FAILED );
static void HK_CALL finishLoadedObjecthkpLinLimitConstraintAtom(void* p, int finishing = 1)
{
	hkFinishLoadedObjectFlag f;
	f.m_finishing = finishing;
	new (p) hkpLinLimitConstraintAtom(f);
}
static void HK_CALL cleanupLoadedObjecthkpLinLimitConstraintAtom(void* p)
{
	static_cast<hkpLinLimitConstraintAtom*>(p)->~hkpLinLimitConstraintAtom();
}
extern const hkTypeInfo hkpLinLimitConstraintAtomTypeInfo;
const hkTypeInfo hkpLinLimitConstraintAtomTypeInfo(
	"hkpLinLimitConstraintAtom",
	"!hkpLinLimitConstraintAtom",
	finishLoadedObjecthkpLinLimitConstraintAtom,
	cleanupLoadedObjecthkpLinLimitConstraintAtom,
	HK_NULL,
	sizeof(hkpLinLimitConstraintAtom)
	);
#endif

//
// Class hkp2dAngConstraintAtom
//

static const hkInternalClassMember hkp2dAngConstraintAtomClass_Members[] =
{
	{ "freeRotationAxis", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkp2dAngConstraintAtom,m_freeRotationAxis), HK_NULL },
	{ "padding", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 12, 0|hkClassMember::SERIALIZE_IGNORED, HK_OFFSET_OF(hkp2dAngConstraintAtom,m_padding), HK_NULL }
};
extern const hkClass hkp2dAngConstraintAtomClass;
const hkClass hkp2dAngConstraintAtomClass(
	"hkp2dAngConstraintAtom",
	&hkpConstraintAtomClass, // parent
	sizeof(::hkp2dAngConstraintAtom),
	HK_NULL,
	0, // interfaces
	HK_NULL,
	0, // enums
	reinterpret_cast<const hkClassMember*>(hkp2dAngConstraintAtomClass_Members),
	HK_COUNT_OF(hkp2dAngConstraintAtomClass_Members),
	HK_NULL, // defaults
	HK_NULL, // attributes
	0, // flags
	hkUint32(0) // version
	);
#ifndef HK_HKCLASS_DEFINITION_ONLY
const hkClass& HK_CALL hkp2dAngConstraintAtom::staticClass()
{
	return hkp2dAngConstraintAtomClass;
}
HK_COMPILE_TIME_ASSERT2( \
	sizeof(hkIsVirtual(static_cast<hkp2dAngConstraintAtom*>(0))) == sizeof(hkBool::CompileTimeFalseType), \
	REFLECTION_PARSER_VTABLE_DETECTION_FAILED );
static void HK_CALL finishLoadedObjecthkp2dAngConstraintAtom(void* p, int finishing = 1)
{
	hkFinishLoadedObjectFlag f;
	f.m_finishing = finishing;
	new (p) hkp2dAngConstraintAtom(f);
}
static void HK_CALL cleanupLoadedObjecthkp2dAngConstraintAtom(void* p)
{
	static_cast<hkp2dAngConstraintAtom*>(p)->~hkp2dAngConstraintAtom();
}
extern const hkTypeInfo hkp2dAngConstraintAtomTypeInfo;
const hkTypeInfo hkp2dAngConstraintAtomTypeInfo(
	"hkp2dAngConstraintAtom",
	"!hkp2dAngConstraintAtom",
	finishLoadedObjecthkp2dAngConstraintAtom,
	cleanupLoadedObjecthkp2dAngConstraintAtom,
	HK_NULL,
	sizeof(hkp2dAngConstraintAtom)
	);
#endif

//
// Class hkpAngConstraintAtom
//

static const hkInternalClassMember hkpAngConstraintAtomClass_Members[] =
{
	{ "firstConstrainedAxis", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpAngConstraintAtom,m_firstConstrainedAxis), HK_NULL },
	{ "numConstrainedAxes", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpAngConstraintAtom,m_numConstrainedAxes), HK_NULL },
	{ "padding", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 12, 0|hkClassMember::SERIALIZE_IGNORED, HK_OFFSET_OF(hkpAngConstraintAtom,m_padding), HK_NULL }
};
extern const hkClass hkpAngConstraintAtomClass;
const hkClass hkpAngConstraintAtomClass(
	"hkpAngConstraintAtom",
	&hkpConstraintAtomClass, // parent
	sizeof(::hkpAngConstraintAtom),
	HK_NULL,
	0, // interfaces
	HK_NULL,
	0, // enums
	reinterpret_cast<const hkClassMember*>(hkpAngConstraintAtomClass_Members),
	HK_COUNT_OF(hkpAngConstraintAtomClass_Members),
	HK_NULL, // defaults
	HK_NULL, // attributes
	0, // flags
	hkUint32(0) // version
	);
#ifndef HK_HKCLASS_DEFINITION_ONLY
const hkClass& HK_CALL hkpAngConstraintAtom::staticClass()
{
	return hkpAngConstraintAtomClass;
}
HK_COMPILE_TIME_ASSERT2( \
	sizeof(hkIsVirtual(static_cast<hkpAngConstraintAtom*>(0))) == sizeof(hkBool::CompileTimeFalseType), \
	REFLECTION_PARSER_VTABLE_DETECTION_FAILED );
static void HK_CALL finishLoadedObjecthkpAngConstraintAtom(void* p, int finishing = 1)
{
	hkFinishLoadedObjectFlag f;
	f.m_finishing = finishing;
	new (p) hkpAngConstraintAtom(f);
}
static void HK_CALL cleanupLoadedObjecthkpAngConstraintAtom(void* p)
{
	static_cast<hkpAngConstraintAtom*>(p)->~hkpAngConstraintAtom();
}
extern const hkTypeInfo hkpAngConstraintAtomTypeInfo;
const hkTypeInfo hkpAngConstraintAtomTypeInfo(
	"hkpAngConstraintAtom",
	"!hkpAngConstraintAtom",
	finishLoadedObjecthkpAngConstraintAtom,
	cleanupLoadedObjecthkpAngConstraintAtom,
	HK_NULL,
	sizeof(hkpAngConstraintAtom)
	);
#endif

//
// Class hkpAngLimitConstraintAtom
//

static const hkInternalClassMember hkpAngLimitConstraintAtomClass_Members[] =
{
	{ "isEnabled", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpAngLimitConstraintAtom,m_isEnabled), HK_NULL },
	{ "limitAxis", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpAngLimitConstraintAtom,m_limitAxis), HK_NULL },
	{ "minAngle", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpAngLimitConstraintAtom,m_minAngle), HK_NULL },
	{ "maxAngle", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpAngLimitConstraintAtom,m_maxAngle), HK_NULL },
	{ "angularLimitsTauFactor", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpAngLimitConstraintAtom,m_angularLimitsTauFactor), HK_NULL }
};
namespace
{
	struct hkpAngLimitConstraintAtom_DefaultStruct
	{
		int s_defaultOffsets[5];
		typedef hkInt8 _hkBool;
		typedef hkFloat32 _hkVector4[4];
		typedef hkReal _hkQuaternion[4];
		typedef hkReal _hkMatrix3[12];
		typedef hkReal _hkRotation[12];
		typedef hkReal _hkQsTransform[12];
		typedef hkReal _hkMatrix4[16];
		typedef hkReal _hkTransform[16];
		float m_angularLimitsTauFactor;
	};
	const hkpAngLimitConstraintAtom_DefaultStruct hkpAngLimitConstraintAtom_Default =
	{
		{-1,-1,-1,-1,HK_OFFSET_OF(hkpAngLimitConstraintAtom_DefaultStruct,m_angularLimitsTauFactor)},
		1.0
	};
}
extern const hkClass hkpAngLimitConstraintAtomClass;
const hkClass hkpAngLimitConstraintAtomClass(
	"hkpAngLimitConstraintAtom",
	&hkpConstraintAtomClass, // parent
	sizeof(::hkpAngLimitConstraintAtom),
	HK_NULL,
	0, // interfaces
	HK_NULL,
	0, // enums
	reinterpret_cast<const hkClassMember*>(hkpAngLimitConstraintAtomClass_Members),
	HK_COUNT_OF(hkpAngLimitConstraintAtomClass_Members),
	&hkpAngLimitConstraintAtom_Default,
	HK_NULL, // attributes
	0, // flags
	hkUint32(0) // version
	);
#ifndef HK_HKCLASS_DEFINITION_ONLY
const hkClass& HK_CALL hkpAngLimitConstraintAtom::staticClass()
{
	return hkpAngLimitConstraintAtomClass;
}
HK_COMPILE_TIME_ASSERT2( \
	sizeof(hkIsVirtual(static_cast<hkpAngLimitConstraintAtom*>(0))) == sizeof(hkBool::CompileTimeFalseType), \
	REFLECTION_PARSER_VTABLE_DETECTION_FAILED );
static void HK_CALL finishLoadedObjecthkpAngLimitConstraintAtom(void* p, int finishing = 1)
{
	hkFinishLoadedObjectFlag f;
	f.m_finishing = finishing;
	new (p) hkpAngLimitConstraintAtom(f);
}
static void HK_CALL cleanupLoadedObjecthkpAngLimitConstraintAtom(void* p)
{
	static_cast<hkpAngLimitConstraintAtom*>(p)->~hkpAngLimitConstraintAtom();
}
extern const hkTypeInfo hkpAngLimitConstraintAtomTypeInfo;
const hkTypeInfo hkpAngLimitConstraintAtomTypeInfo(
	"hkpAngLimitConstraintAtom",
	"!hkpAngLimitConstraintAtom",
	finishLoadedObjecthkpAngLimitConstraintAtom,
	cleanupLoadedObjecthkpAngLimitConstraintAtom,
	HK_NULL,
	sizeof(hkpAngLimitConstraintAtom)
	);
#endif

//
// Class hkpTwistLimitConstraintAtom
//

static const hkInternalClassMember hkpTwistLimitConstraintAtomClass_Members[] =
{
	{ "isEnabled", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpTwistLimitConstraintAtom,m_isEnabled), HK_NULL },
	{ "twistAxis", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpTwistLimitConstraintAtom,m_twistAxis), HK_NULL },
	{ "refAxis", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpTwistLimitConstraintAtom,m_refAxis), HK_NULL },
	{ "minAngle", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpTwistLimitConstraintAtom,m_minAngle), HK_NULL },
	{ "maxAngle", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpTwistLimitConstraintAtom,m_maxAngle), HK_NULL },
	{ "angularLimitsTauFactor", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpTwistLimitConstraintAtom,m_angularLimitsTauFactor), HK_NULL },
	{ "padding", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 12, 0|hkClassMember::SERIALIZE_IGNORED, HK_OFFSET_OF(hkpTwistLimitConstraintAtom,m_padding), HK_NULL }
};
namespace
{
	struct hkpTwistLimitConstraintAtom_DefaultStruct
	{
		int s_defaultOffsets[7];
		typedef hkInt8 _hkBool;
		typedef hkFloat32 _hkVector4[4];
		typedef hkReal _hkQuaternion[4];
		typedef hkReal _hkMatrix3[12];
		typedef hkReal _hkRotation[12];
		typedef hkReal _hkQsTransform[12];
		typedef hkReal _hkMatrix4[16];
		typedef hkReal _hkTransform[16];
		float m_angularLimitsTauFactor;
	};
	const hkpTwistLimitConstraintAtom_DefaultStruct hkpTwistLimitConstraintAtom_Default =
	{
		{-1,-1,-1,-1,-1,HK_OFFSET_OF(hkpTwistLimitConstraintAtom_DefaultStruct,m_angularLimitsTauFactor),-1},
		1.0
	};
}
extern const hkClass hkpTwistLimitConstraintAtomClass;
const hkClass hkpTwistLimitConstraintAtomClass(
	"hkpTwistLimitConstraintAtom",
	&hkpConstraintAtomClass, // parent
	sizeof(::hkpTwistLimitConstraintAtom),
	HK_NULL,
	0, // interfaces
	HK_NULL,
	0, // enums
	reinterpret_cast<const hkClassMember*>(hkpTwistLimitConstraintAtomClass_Members),
	HK_COUNT_OF(hkpTwistLimitConstraintAtomClass_Members),
	&hkpTwistLimitConstraintAtom_Default,
	HK_NULL, // attributes
	0, // flags
	hkUint32(0) // version
	);
#ifndef HK_HKCLASS_DEFINITION_ONLY
const hkClass& HK_CALL hkpTwistLimitConstraintAtom::staticClass()
{
	return hkpTwistLimitConstraintAtomClass;
}
HK_COMPILE_TIME_ASSERT2( \
	sizeof(hkIsVirtual(static_cast<hkpTwistLimitConstraintAtom*>(0))) == sizeof(hkBool::CompileTimeFalseType), \
	REFLECTION_PARSER_VTABLE_DETECTION_FAILED );
static void HK_CALL finishLoadedObjecthkpTwistLimitConstraintAtom(void* p, int finishing = 1)
{
	hkFinishLoadedObjectFlag f;
	f.m_finishing = finishing;
	new (p) hkpTwistLimitConstraintAtom(f);
}
static void HK_CALL cleanupLoadedObjecthkpTwistLimitConstraintAtom(void* p)
{
	static_cast<hkpTwistLimitConstraintAtom*>(p)->~hkpTwistLimitConstraintAtom();
}
extern const hkTypeInfo hkpTwistLimitConstraintAtomTypeInfo;
const hkTypeInfo hkpTwistLimitConstraintAtomTypeInfo(
	"hkpTwistLimitConstraintAtom",
	"!hkpTwistLimitConstraintAtom",
	finishLoadedObjecthkpTwistLimitConstraintAtom,
	cleanupLoadedObjecthkpTwistLimitConstraintAtom,
	HK_NULL,
	sizeof(hkpTwistLimitConstraintAtom)
	);
#endif

//
// Enum hkpConeLimitConstraintAtom::MeasurementMode
//
static const hkInternalClassEnumItem hkpConeLimitConstraintAtomMeasurementModeEnumItems[] =
{
	{0, "ZERO_WHEN_VECTORS_ALIGNED"},
	{1, "ZERO_WHEN_VECTORS_PERPENDICULAR"},
};
static const hkInternalClassEnum hkpConeLimitConstraintAtomEnums[] = {
	{"MeasurementMode", hkpConeLimitConstraintAtomMeasurementModeEnumItems, 2, HK_NULL, 0 }
};
const hkClassEnum* hkpConeLimitConstraintAtomMeasurementModeEnum = reinterpret_cast<const hkClassEnum*>(&hkpConeLimitConstraintAtomEnums[0]);

//
// Class hkpConeLimitConstraintAtom
//

static const hkInternalClassMember hkpConeLimitConstraintAtomClass_Members[] =
{
	{ "isEnabled", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpConeLimitConstraintAtom,m_isEnabled), HK_NULL },
	{ "twistAxisInA", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpConeLimitConstraintAtom,m_twistAxisInA), HK_NULL },
	{ "refAxisInB", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpConeLimitConstraintAtom,m_refAxisInB), HK_NULL },
	{ "angleMeasurementMode", HK_NULL, hkpConeLimitConstraintAtomMeasurementModeEnum, hkClassMember::TYPE_ENUM, hkClassMember::TYPE_UINT8, 0, 0, HK_OFFSET_OF(hkpConeLimitConstraintAtom,m_angleMeasurementMode), HK_NULL },
	{ "memOffsetToAngleOffset", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpConeLimitConstraintAtom,m_memOffsetToAngleOffset), HK_NULL },
	{ "minAngle", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpConeLimitConstraintAtom,m_minAngle), HK_NULL },
	{ "maxAngle", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpConeLimitConstraintAtom,m_maxAngle), HK_NULL },
	{ "angularLimitsTauFactor", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpConeLimitConstraintAtom,m_angularLimitsTauFactor), HK_NULL },
	{ "padding", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 12, 0|hkClassMember::SERIALIZE_IGNORED, HK_OFFSET_OF(hkpConeLimitConstraintAtom,m_padding), HK_NULL }
};
namespace
{
	struct hkpConeLimitConstraintAtom_DefaultStruct
	{
		int s_defaultOffsets[9];
		typedef hkInt8 _hkBool;
		typedef hkFloat32 _hkVector4[4];
		typedef hkReal _hkQuaternion[4];
		typedef hkReal _hkMatrix3[12];
		typedef hkReal _hkRotation[12];
		typedef hkReal _hkQsTransform[12];
		typedef hkReal _hkMatrix4[16];
		typedef hkReal _hkTransform[16];
		hkUint8 m_memOffsetToAngleOffset;
		float m_angularLimitsTauFactor;
	};
	const hkpConeLimitConstraintAtom_DefaultStruct hkpConeLimitConstraintAtom_Default =
	{
		{-1,-1,-1,-1,HK_OFFSET_OF(hkpConeLimitConstraintAtom_DefaultStruct,m_memOffsetToAngleOffset),-1,-1,HK_OFFSET_OF(hkpConeLimitConstraintAtom_DefaultStruct,m_angularLimitsTauFactor),-1},
		1,1.0
	};
}
extern const hkClass hkpConeLimitConstraintAtomClass;
const hkClass hkpConeLimitConstraintAtomClass(
	"hkpConeLimitConstraintAtom",
	&hkpConstraintAtomClass, // parent
	sizeof(::hkpConeLimitConstraintAtom),
	HK_NULL,
	0, // interfaces
	reinterpret_cast<const hkClassEnum*>(hkpConeLimitConstraintAtomEnums),
	1, // enums
	reinterpret_cast<const hkClassMember*>(hkpConeLimitConstraintAtomClass_Members),
	HK_COUNT_OF(hkpConeLimitConstraintAtomClass_Members),
	&hkpConeLimitConstraintAtom_Default,
	HK_NULL, // attributes
	0, // flags
	hkUint32(0) // version
	);
#ifndef HK_HKCLASS_DEFINITION_ONLY
const hkClass& HK_CALL hkpConeLimitConstraintAtom::staticClass()
{
	return hkpConeLimitConstraintAtomClass;
}
HK_COMPILE_TIME_ASSERT2( \
	sizeof(hkIsVirtual(static_cast<hkpConeLimitConstraintAtom*>(0))) == sizeof(hkBool::CompileTimeFalseType), \
	REFLECTION_PARSER_VTABLE_DETECTION_FAILED );
static void HK_CALL finishLoadedObjecthkpConeLimitConstraintAtom(void* p, int finishing = 1)
{
	hkFinishLoadedObjectFlag f;
	f.m_finishing = finishing;
	new (p) hkpConeLimitConstraintAtom(f);
}
static void HK_CALL cleanupLoadedObjecthkpConeLimitConstraintAtom(void* p)
{
	static_cast<hkpConeLimitConstraintAtom*>(p)->~hkpConeLimitConstraintAtom();
}
extern const hkTypeInfo hkpConeLimitConstraintAtomTypeInfo;
const hkTypeInfo hkpConeLimitConstraintAtomTypeInfo(
	"hkpConeLimitConstraintAtom",
	"!hkpConeLimitConstraintAtom",
	finishLoadedObjecthkpConeLimitConstraintAtom,
	cleanupLoadedObjecthkpConeLimitConstraintAtom,
	HK_NULL,
	sizeof(hkpConeLimitConstraintAtom)
	);
#endif

//
// Class hkpAngFrictionConstraintAtom
//

static const hkInternalClassMember hkpAngFrictionConstraintAtomClass_Members[] =
{
	{ "isEnabled", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpAngFrictionConstraintAtom,m_isEnabled), HK_NULL },
	{ "firstFrictionAxis", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpAngFrictionConstraintAtom,m_firstFrictionAxis), HK_NULL },
	{ "numFrictionAxes", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpAngFrictionConstraintAtom,m_numFrictionAxes), HK_NULL },
	{ "maxFrictionTorque", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpAngFrictionConstraintAtom,m_maxFrictionTorque), HK_NULL },
	{ "padding", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 4, 0|hkClassMember::SERIALIZE_IGNORED, HK_OFFSET_OF(hkpAngFrictionConstraintAtom,m_padding), HK_NULL }
};
extern const hkClass hkpAngFrictionConstraintAtomClass;
const hkClass hkpAngFrictionConstraintAtomClass(
	"hkpAngFrictionConstraintAtom",
	&hkpConstraintAtomClass, // parent
	sizeof(::hkpAngFrictionConstraintAtom),
	HK_NULL,
	0, // interfaces
	HK_NULL,
	0, // enums
	reinterpret_cast<const hkClassMember*>(hkpAngFrictionConstraintAtomClass_Members),
	HK_COUNT_OF(hkpAngFrictionConstraintAtomClass_Members),
	HK_NULL, // defaults
	HK_NULL, // attributes
	0, // flags
	hkUint32(0) // version
	);
#ifndef HK_HKCLASS_DEFINITION_ONLY
const hkClass& HK_CALL hkpAngFrictionConstraintAtom::staticClass()
{
	return hkpAngFrictionConstraintAtomClass;
}
HK_COMPILE_TIME_ASSERT2( \
	sizeof(hkIsVirtual(static_cast<hkpAngFrictionConstraintAtom*>(0))) == sizeof(hkBool::CompileTimeFalseType), \
	REFLECTION_PARSER_VTABLE_DETECTION_FAILED );
static void HK_CALL finishLoadedObjecthkpAngFrictionConstraintAtom(void* p, int finishing = 1)
{
	hkFinishLoadedObjectFlag f;
	f.m_finishing = finishing;
	new (p) hkpAngFrictionConstraintAtom(f);
}
static void HK_CALL cleanupLoadedObjecthkpAngFrictionConstraintAtom(void* p)
{
	static_cast<hkpAngFrictionConstraintAtom*>(p)->~hkpAngFrictionConstraintAtom();
}
extern const hkTypeInfo hkpAngFrictionConstraintAtomTypeInfo;
const hkTypeInfo hkpAngFrictionConstraintAtomTypeInfo(
	"hkpAngFrictionConstraintAtom",
	"!hkpAngFrictionConstraintAtom",
	finishLoadedObjecthkpAngFrictionConstraintAtom,
	cleanupLoadedObjecthkpAngFrictionConstraintAtom,
	HK_NULL,
	sizeof(hkpAngFrictionConstraintAtom)
	);
#endif

//
// Class hkpAngMotorConstraintAtom
//

static const hkInternalClassMember hkpAngMotorConstraintAtomClass_Members[] =
{
	{ "isEnabled", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpAngMotorConstraintAtom,m_isEnabled), HK_NULL },
	{ "motorAxis", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpAngMotorConstraintAtom,m_motorAxis), HK_NULL },
	{ "initializedOffset", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, HK_OFFSET_OF(hkpAngMotorConstraintAtom,m_initializedOffset), HK_NULL },
	{ "previousTargetAngleOffset", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, HK_OFFSET_OF(hkpAngMotorConstraintAtom,m_previousTargetAngleOffset), HK_NULL },
	{ "correspondingAngLimitSolverResultOffset", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, HK_OFFSET_OF(hkpAngMotorConstraintAtom,m_correspondingAngLimitSolverResultOffset), HK_NULL },
	{ "targetAngle", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpAngMotorConstraintAtom,m_targetAngle), HK_NULL },
	{ "motor", &hkpConstraintMotorClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, HK_OFFSET_OF(hkpAngMotorConstraintAtom,m_motor), HK_NULL },
	{ "padding", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 12, 0|hkClassMember::SERIALIZE_IGNORED, HK_OFFSET_OF(hkpAngMotorConstraintAtom,m_padding), HK_NULL }
};
extern const hkClass hkpAngMotorConstraintAtomClass;
const hkClass hkpAngMotorConstraintAtomClass(
	"hkpAngMotorConstraintAtom",
	&hkpConstraintAtomClass, // parent
	sizeof(::hkpAngMotorConstraintAtom),
	HK_NULL,
	0, // interfaces
	HK_NULL,
	0, // enums
	reinterpret_cast<const hkClassMember*>(hkpAngMotorConstraintAtomClass_Members),
	HK_COUNT_OF(hkpAngMotorConstraintAtomClass_Members),
	HK_NULL, // defaults
	HK_NULL, // attributes
	0, // flags
	hkUint32(1) // version
	);
#ifndef HK_HKCLASS_DEFINITION_ONLY
const hkClass& HK_CALL hkpAngMotorConstraintAtom::staticClass()
{
	return hkpAngMotorConstraintAtomClass;
}
HK_COMPILE_TIME_ASSERT2( \
	sizeof(hkIsVirtual(static_cast<hkpAngMotorConstraintAtom*>(0))) == sizeof(hkBool::CompileTimeFalseType), \
	REFLECTION_PARSER_VTABLE_DETECTION_FAILED );
static void HK_CALL finishLoadedObjecthkpAngMotorConstraintAtom(void* p, int finishing = 1)
{
	hkFinishLoadedObjectFlag f;
	f.m_finishing = finishing;
	new (p) hkpAngMotorConstraintAtom(f);
}
static void HK_CALL cleanupLoadedObjecthkpAngMotorConstraintAtom(void* p)
{
	static_cast<hkpAngMotorConstraintAtom*>(p)->~hkpAngMotorConstraintAtom();
}
extern const hkTypeInfo hkpAngMotorConstraintAtomTypeInfo;
const hkTypeInfo hkpAngMotorConstraintAtomTypeInfo(
	"hkpAngMotorConstraintAtom",
	"!hkpAngMotorConstraintAtom",
	finishLoadedObjecthkpAngMotorConstraintAtom,
	cleanupLoadedObjecthkpAngMotorConstraintAtom,
	HK_NULL,
	sizeof(hkpAngMotorConstraintAtom)
	);
#endif

//
// Class hkpRagdollMotorConstraintAtom
//

static const hkInternalClassMember hkpRagdollMotorConstraintAtomClass_Members[] =
{
	{ "isEnabled", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpRagdollMotorConstraintAtom,m_isEnabled), HK_NULL },
	{ "initializedOffset", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, HK_OFFSET_OF(hkpRagdollMotorConstraintAtom,m_initializedOffset), HK_NULL },
	{ "previousTargetAnglesOffset", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, HK_OFFSET_OF(hkpRagdollMotorConstraintAtom,m_previousTargetAnglesOffset), HK_NULL },
	{ "target_bRca", HK_NULL, HK_NULL, hkClassMember::TYPE_MATRIX3, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpRagdollMotorConstraintAtom,m_target_bRca), HK_NULL },
	{ "motors", &hkpConstraintMotorClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 3, 0, HK_OFFSET_OF(hkpRagdollMotorConstraintAtom,m_motors), HK_NULL }
};
extern const hkClass hkpRagdollMotorConstraintAtomClass;
const hkClass hkpRagdollMotorConstraintAtomClass(
	"hkpRagdollMotorConstraintAtom",
	&hkpConstraintAtomClass, // parent
	sizeof(::hkpRagdollMotorConstraintAtom),
	HK_NULL,
	0, // interfaces
	HK_NULL,
	0, // enums
	reinterpret_cast<const hkClassMember*>(hkpRagdollMotorConstraintAtomClass_Members),
	HK_COUNT_OF(hkpRagdollMotorConstraintAtomClass_Members),
	HK_NULL, // defaults
	HK_NULL, // attributes
	0, // flags
	hkUint32(1) // version
	);
#ifndef HK_HKCLASS_DEFINITION_ONLY
const hkClass& HK_CALL hkpRagdollMotorConstraintAtom::staticClass()
{
	return hkpRagdollMotorConstraintAtomClass;
}
HK_COMPILE_TIME_ASSERT2( \
	sizeof(hkIsVirtual(static_cast<hkpRagdollMotorConstraintAtom*>(0))) == sizeof(hkBool::CompileTimeFalseType), \
	REFLECTION_PARSER_VTABLE_DETECTION_FAILED );
static void HK_CALL finishLoadedObjecthkpRagdollMotorConstraintAtom(void* p, int finishing = 1)
{
	hkFinishLoadedObjectFlag f;
	f.m_finishing = finishing;
	new (p) hkpRagdollMotorConstraintAtom(f);
}
static void HK_CALL cleanupLoadedObjecthkpRagdollMotorConstraintAtom(void* p)
{
	static_cast<hkpRagdollMotorConstraintAtom*>(p)->~hkpRagdollMotorConstraintAtom();
}
extern const hkTypeInfo hkpRagdollMotorConstraintAtomTypeInfo;
const hkTypeInfo hkpRagdollMotorConstraintAtomTypeInfo(
	"hkpRagdollMotorConstraintAtom",
	"!hkpRagdollMotorConstraintAtom",
	finishLoadedObjecthkpRagdollMotorConstraintAtom,
	cleanupLoadedObjecthkpRagdollMotorConstraintAtom,
	HK_NULL,
	sizeof(hkpRagdollMotorConstraintAtom)
	);
#endif

//
// Class hkpLinFrictionConstraintAtom
//

static const hkInternalClassMember hkpLinFrictionConstraintAtomClass_Members[] =
{
	{ "isEnabled", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpLinFrictionConstraintAtom,m_isEnabled), HK_NULL },
	{ "frictionAxis", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpLinFrictionConstraintAtom,m_frictionAxis), HK_NULL },
	{ "maxFrictionForce", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpLinFrictionConstraintAtom,m_maxFrictionForce), HK_NULL },
	{ "padding", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 8, 0|hkClassMember::SERIALIZE_IGNORED, HK_OFFSET_OF(hkpLinFrictionConstraintAtom,m_padding), HK_NULL }
};
extern const hkClass hkpLinFrictionConstraintAtomClass;
const hkClass hkpLinFrictionConstraintAtomClass(
	"hkpLinFrictionConstraintAtom",
	&hkpConstraintAtomClass, // parent
	sizeof(::hkpLinFrictionConstraintAtom),
	HK_NULL,
	0, // interfaces
	HK_NULL,
	0, // enums
	reinterpret_cast<const hkClassMember*>(hkpLinFrictionConstraintAtomClass_Members),
	HK_COUNT_OF(hkpLinFrictionConstraintAtomClass_Members),
	HK_NULL, // defaults
	HK_NULL, // attributes
	0, // flags
	hkUint32(0) // version
	);
#ifndef HK_HKCLASS_DEFINITION_ONLY
const hkClass& HK_CALL hkpLinFrictionConstraintAtom::staticClass()
{
	return hkpLinFrictionConstraintAtomClass;
}
HK_COMPILE_TIME_ASSERT2( \
	sizeof(hkIsVirtual(static_cast<hkpLinFrictionConstraintAtom*>(0))) == sizeof(hkBool::CompileTimeFalseType), \
	REFLECTION_PARSER_VTABLE_DETECTION_FAILED );
static void HK_CALL finishLoadedObjecthkpLinFrictionConstraintAtom(void* p, int finishing = 1)
{
	hkFinishLoadedObjectFlag f;
	f.m_finishing = finishing;
	new (p) hkpLinFrictionConstraintAtom(f);
}
static void HK_CALL cleanupLoadedObjecthkpLinFrictionConstraintAtom(void* p)
{
	static_cast<hkpLinFrictionConstraintAtom*>(p)->~hkpLinFrictionConstraintAtom();
}
extern const hkTypeInfo hkpLinFrictionConstraintAtomTypeInfo;
const hkTypeInfo hkpLinFrictionConstraintAtomTypeInfo(
	"hkpLinFrictionConstraintAtom",
	"!hkpLinFrictionConstraintAtom",
	finishLoadedObjecthkpLinFrictionConstraintAtom,
	cleanupLoadedObjecthkpLinFrictionConstraintAtom,
	HK_NULL,
	sizeof(hkpLinFrictionConstraintAtom)
	);
#endif

//
// Class hkpWheelFrictionConstraintAtom::Axle
//
static const hkInternalClassMember hkpWheelFrictionConstraintAtom_AxleClass_Members[] =
{
	{ "spinVelocity", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpWheelFrictionConstraintAtom::Axle,m_spinVelocity), HK_NULL },
	{ "sumVelocity", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpWheelFrictionConstraintAtom::Axle,m_sumVelocity), HK_NULL },
	{ "numWheels", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpWheelFrictionConstraintAtom::Axle,m_numWheels), HK_NULL },
	{ "wheelsSolved", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpWheelFrictionConstraintAtom::Axle,m_wheelsSolved), HK_NULL },
	{ "stepsSolved", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpWheelFrictionConstraintAtom::Axle,m_stepsSolved), HK_NULL },
	{ "invInertia", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpWheelFrictionConstraintAtom::Axle,m_invInertia), HK_NULL },
	{ "inertia", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpWheelFrictionConstraintAtom::Axle,m_inertia), HK_NULL },
	{ "impulseScaling", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpWheelFrictionConstraintAtom::Axle,m_impulseScaling), HK_NULL },
	{ "impulseMax", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpWheelFrictionConstraintAtom::Axle,m_impulseMax), HK_NULL },
	{ "isFixed", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpWheelFrictionConstraintAtom::Axle,m_isFixed), HK_NULL },
	{ "numWheelsOnGround", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpWheelFrictionConstraintAtom::Axle,m_numWheelsOnGround), HK_NULL }
};
const hkClass hkpWheelFrictionConstraintAtomAxleClass(
	"hkpWheelFrictionConstraintAtomAxle",
	HK_NULL, // parent
	sizeof(hkpWheelFrictionConstraintAtom::Axle),
	HK_NULL,
	0, // interfaces
	HK_NULL,
	0, // enums
	reinterpret_cast<const hkClassMember*>(hkpWheelFrictionConstraintAtom_AxleClass_Members),
	HK_COUNT_OF(hkpWheelFrictionConstraintAtom_AxleClass_Members),
	HK_NULL, // defaults
	HK_NULL, // attributes
	0, // flags
	hkUint32(0) // version
	);
#ifndef HK_HKCLASS_DEFINITION_ONLY
const hkClass& HK_CALL hkpWheelFrictionConstraintAtom::Axle::staticClass()
{
	return hkpWheelFrictionConstraintAtomAxleClass;
}
HK_COMPILE_TIME_ASSERT2( \
	sizeof(hkIsVirtual(static_cast<hkpWheelFrictionConstraintAtom::Axle*>(0))) == sizeof(hkBool::CompileTimeFalseType), \
	REFLECTION_PARSER_VTABLE_DETECTION_FAILED );
static void HK_CALL finishLoadedObjecthkpWheelFrictionConstraintAtomAxle(void* p, int finishing = 1)
{
	hkFinishLoadedObjectFlag f;
	f.m_finishing = finishing;
	new (p) hkpWheelFrictionConstraintAtom::Axle(f);
}
static void HK_CALL cleanupLoadedObjecthkpWheelFrictionConstraintAtomAxle(void* p)
{
	static_cast<hkpWheelFrictionConstraintAtom::Axle*>(p)->~Axle();
}
extern const hkTypeInfo hkpWheelFrictionConstraintAtomAxleTypeInfo;
const hkTypeInfo hkpWheelFrictionConstraintAtomAxleTypeInfo(
	"hkpWheelFrictionConstraintAtomAxle",
	"!hkpWheelFrictionConstraintAtom::Axle",
	finishLoadedObjecthkpWheelFrictionConstraintAtomAxle,
	cleanupLoadedObjecthkpWheelFrictionConstraintAtomAxle,
	HK_NULL,
	sizeof(hkpWheelFrictionConstraintAtom::Axle)
	);
#endif

//
// Class hkpWheelFrictionConstraintAtom
//

static const hkInternalClassMember hkpWheelFrictionConstraintAtomClass_Members[] =
{
	{ "isEnabled", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpWheelFrictionConstraintAtom,m_isEnabled), HK_NULL },
	{ "forwardAxis", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpWheelFrictionConstraintAtom,m_forwardAxis), HK_NULL },
	{ "sideAxis", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpWheelFrictionConstraintAtom,m_sideAxis), HK_NULL },
	{ "maxFrictionForce", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpWheelFrictionConstraintAtom,m_maxFrictionForce), HK_NULL },
	{ "torque", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpWheelFrictionConstraintAtom,m_torque), HK_NULL },
	{ "radius", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpWheelFrictionConstraintAtom,m_radius), HK_NULL },
	{ "frictionImpulse", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 2, 0, HK_OFFSET_OF(hkpWheelFrictionConstraintAtom,m_frictionImpulse), HK_NULL },
	{ "slipImpulse", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 2, 0, HK_OFFSET_OF(hkpWheelFrictionConstraintAtom,m_slipImpulse), HK_NULL },
	{ "axle", &hkpWheelFrictionConstraintAtomAxleClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, HK_OFFSET_OF(hkpWheelFrictionConstraintAtom,m_axle), HK_NULL }
};
extern const hkClass hkpWheelFrictionConstraintAtomClass;
const hkClass hkpWheelFrictionConstraintAtomClass(
	"hkpWheelFrictionConstraintAtom",
	&hkpConstraintAtomClass, // parent
	sizeof(::hkpWheelFrictionConstraintAtom),
	HK_NULL,
	0, // interfaces
	HK_NULL,
	0, // enums
	reinterpret_cast<const hkClassMember*>(hkpWheelFrictionConstraintAtomClass_Members),
	HK_COUNT_OF(hkpWheelFrictionConstraintAtomClass_Members),
	HK_NULL, // defaults
	HK_NULL, // attributes
	0, // flags
	hkUint32(0) // version
	);
#ifndef HK_HKCLASS_DEFINITION_ONLY
const hkClass& HK_CALL hkpWheelFrictionConstraintAtom::staticClass()
{
	return hkpWheelFrictionConstraintAtomClass;
}
HK_COMPILE_TIME_ASSERT2( \
	sizeof(hkIsVirtual(static_cast<hkpWheelFrictionConstraintAtom*>(0))) == sizeof(hkBool::CompileTimeFalseType), \
	REFLECTION_PARSER_VTABLE_DETECTION_FAILED );
static void HK_CALL finishLoadedObjecthkpWheelFrictionConstraintAtom(void* p, int finishing = 1)
{
	hkFinishLoadedObjectFlag f;
	f.m_finishing = finishing;
	new (p) hkpWheelFrictionConstraintAtom(f);
}
static void HK_CALL cleanupLoadedObjecthkpWheelFrictionConstraintAtom(void* p)
{
	static_cast<hkpWheelFrictionConstraintAtom*>(p)->~hkpWheelFrictionConstraintAtom();
}
extern const hkTypeInfo hkpWheelFrictionConstraintAtomTypeInfo;
const hkTypeInfo hkpWheelFrictionConstraintAtomTypeInfo(
	"hkpWheelFrictionConstraintAtom",
	"!hkpWheelFrictionConstraintAtom",
	finishLoadedObjecthkpWheelFrictionConstraintAtom,
	cleanupLoadedObjecthkpWheelFrictionConstraintAtom,
	HK_NULL,
	sizeof(hkpWheelFrictionConstraintAtom)
	);
#endif

//
// Class hkpLinMotorConstraintAtom
//

static const hkInternalClassMember hkpLinMotorConstraintAtomClass_Members[] =
{
	{ "isEnabled", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpLinMotorConstraintAtom,m_isEnabled), HK_NULL },
	{ "motorAxis", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpLinMotorConstraintAtom,m_motorAxis), HK_NULL },
	{ "initializedOffset", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, HK_OFFSET_OF(hkpLinMotorConstraintAtom,m_initializedOffset), HK_NULL },
	{ "previousTargetPositionOffset", HK_NULL, HK_NULL, hkClassMember::TYPE_INT16, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, HK_OFFSET_OF(hkpLinMotorConstraintAtom,m_previousTargetPositionOffset), HK_NULL },
	{ "targetPosition", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpLinMotorConstraintAtom,m_targetPosition), HK_NULL },
	{ "motor", &hkpConstraintMotorClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, HK_OFFSET_OF(hkpLinMotorConstraintAtom,m_motor), HK_NULL }
};
extern const hkClass hkpLinMotorConstraintAtomClass;
const hkClass hkpLinMotorConstraintAtomClass(
	"hkpLinMotorConstraintAtom",
	&hkpConstraintAtomClass, // parent
	sizeof(::hkpLinMotorConstraintAtom),
	HK_NULL,
	0, // interfaces
	HK_NULL,
	0, // enums
	reinterpret_cast<const hkClassMember*>(hkpLinMotorConstraintAtomClass_Members),
	HK_COUNT_OF(hkpLinMotorConstraintAtomClass_Members),
	HK_NULL, // defaults
	HK_NULL, // attributes
	0, // flags
	hkUint32(1) // version
	);
#ifndef HK_HKCLASS_DEFINITION_ONLY
const hkClass& HK_CALL hkpLinMotorConstraintAtom::staticClass()
{
	return hkpLinMotorConstraintAtomClass;
}
HK_COMPILE_TIME_ASSERT2( \
	sizeof(hkIsVirtual(static_cast<hkpLinMotorConstraintAtom*>(0))) == sizeof(hkBool::CompileTimeFalseType), \
	REFLECTION_PARSER_VTABLE_DETECTION_FAILED );
static void HK_CALL finishLoadedObjecthkpLinMotorConstraintAtom(void* p, int finishing = 1)
{
	hkFinishLoadedObjectFlag f;
	f.m_finishing = finishing;
	new (p) hkpLinMotorConstraintAtom(f);
}
static void HK_CALL cleanupLoadedObjecthkpLinMotorConstraintAtom(void* p)
{
	static_cast<hkpLinMotorConstraintAtom*>(p)->~hkpLinMotorConstraintAtom();
}
extern const hkTypeInfo hkpLinMotorConstraintAtomTypeInfo;
const hkTypeInfo hkpLinMotorConstraintAtomTypeInfo(
	"hkpLinMotorConstraintAtom",
	"!hkpLinMotorConstraintAtom",
	finishLoadedObjecthkpLinMotorConstraintAtom,
	cleanupLoadedObjecthkpLinMotorConstraintAtom,
	HK_NULL,
	sizeof(hkpLinMotorConstraintAtom)
	);
#endif

//
// Class hkpPulleyConstraintAtom
//

static const hkInternalClassMember hkpPulleyConstraintAtomClass_Members[] =
{
	{ "fixedPivotAinWorld", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpPulleyConstraintAtom,m_fixedPivotAinWorld), HK_NULL },
	{ "fixedPivotBinWorld", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpPulleyConstraintAtom,m_fixedPivotBinWorld), HK_NULL },
	{ "ropeLength", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpPulleyConstraintAtom,m_ropeLength), HK_NULL },
	{ "leverageOnBodyB", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpPulleyConstraintAtom,m_leverageOnBodyB), HK_NULL }
};
extern const hkClass hkpPulleyConstraintAtomClass;
const hkClass hkpPulleyConstraintAtomClass(
	"hkpPulleyConstraintAtom",
	&hkpConstraintAtomClass, // parent
	sizeof(::hkpPulleyConstraintAtom),
	HK_NULL,
	0, // interfaces
	HK_NULL,
	0, // enums
	reinterpret_cast<const hkClassMember*>(hkpPulleyConstraintAtomClass_Members),
	HK_COUNT_OF(hkpPulleyConstraintAtomClass_Members),
	HK_NULL, // defaults
	HK_NULL, // attributes
	0, // flags
	hkUint32(0) // version
	);
#ifndef HK_HKCLASS_DEFINITION_ONLY
const hkClass& HK_CALL hkpPulleyConstraintAtom::staticClass()
{
	return hkpPulleyConstraintAtomClass;
}
HK_COMPILE_TIME_ASSERT2( \
	sizeof(hkIsVirtual(static_cast<hkpPulleyConstraintAtom*>(0))) == sizeof(hkBool::CompileTimeFalseType), \
	REFLECTION_PARSER_VTABLE_DETECTION_FAILED );
static void HK_CALL finishLoadedObjecthkpPulleyConstraintAtom(void* p, int finishing = 1)
{
	hkFinishLoadedObjectFlag f;
	f.m_finishing = finishing;
	new (p) hkpPulleyConstraintAtom(f);
}
static void HK_CALL cleanupLoadedObjecthkpPulleyConstraintAtom(void* p)
{
	static_cast<hkpPulleyConstraintAtom*>(p)->~hkpPulleyConstraintAtom();
}
extern const hkTypeInfo hkpPulleyConstraintAtomTypeInfo;
const hkTypeInfo hkpPulleyConstraintAtomTypeInfo(
	"hkpPulleyConstraintAtom",
	"!hkpPulleyConstraintAtom",
	finishLoadedObjecthkpPulleyConstraintAtom,
	cleanupLoadedObjecthkpPulleyConstraintAtom,
	HK_NULL,
	sizeof(hkpPulleyConstraintAtom)
	);
#endif

//
// Class hkpRackAndPinionConstraintAtom
//

static const hkInternalClassMember hkpRackAndPinionConstraintAtomClass_Members[] =
{
	{ "pinionRadiusOrScrewPitch", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpRackAndPinionConstraintAtom,m_pinionRadiusOrScrewPitch), HK_NULL },
	{ "isScrew", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpRackAndPinionConstraintAtom,m_isScrew), HK_NULL },
	{ "memOffsetToInitialAngleOffset", HK_NULL, HK_NULL, hkClassMember::TYPE_INT8, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpRackAndPinionConstraintAtom,m_memOffsetToInitialAngleOffset), HK_NULL },
	{ "memOffsetToPrevAngle", HK_NULL, HK_NULL, hkClassMember::TYPE_INT8, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpRackAndPinionConstraintAtom,m_memOffsetToPrevAngle), HK_NULL },
	{ "memOffsetToRevolutionCounter", HK_NULL, HK_NULL, hkClassMember::TYPE_INT8, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpRackAndPinionConstraintAtom,m_memOffsetToRevolutionCounter), HK_NULL },
	{ "padding", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT8, hkClassMember::TYPE_VOID, 4, 0|hkClassMember::SERIALIZE_IGNORED, HK_OFFSET_OF(hkpRackAndPinionConstraintAtom,m_padding), HK_NULL }
};
extern const hkClass hkpRackAndPinionConstraintAtomClass;
const hkClass hkpRackAndPinionConstraintAtomClass(
	"hkpRackAndPinionConstraintAtom",
	&hkpConstraintAtomClass, // parent
	sizeof(::hkpRackAndPinionConstraintAtom),
	HK_NULL,
	0, // interfaces
	HK_NULL,
	0, // enums
	reinterpret_cast<const hkClassMember*>(hkpRackAndPinionConstraintAtomClass_Members),
	HK_COUNT_OF(hkpRackAndPinionConstraintAtomClass_Members),
	HK_NULL, // defaults
	HK_NULL, // attributes
	0, // flags
	hkUint32(0) // version
	);
#ifndef HK_HKCLASS_DEFINITION_ONLY
const hkClass& HK_CALL hkpRackAndPinionConstraintAtom::staticClass()
{
	return hkpRackAndPinionConstraintAtomClass;
}
HK_COMPILE_TIME_ASSERT2( \
	sizeof(hkIsVirtual(static_cast<hkpRackAndPinionConstraintAtom*>(0))) == sizeof(hkBool::CompileTimeFalseType), \
	REFLECTION_PARSER_VTABLE_DETECTION_FAILED );
static void HK_CALL finishLoadedObjecthkpRackAndPinionConstraintAtom(void* p, int finishing = 1)
{
	hkFinishLoadedObjectFlag f;
	f.m_finishing = finishing;
	new (p) hkpRackAndPinionConstraintAtom(f);
}
static void HK_CALL cleanupLoadedObjecthkpRackAndPinionConstraintAtom(void* p)
{
	static_cast<hkpRackAndPinionConstraintAtom*>(p)->~hkpRackAndPinionConstraintAtom();
}
extern const hkTypeInfo hkpRackAndPinionConstraintAtomTypeInfo;
const hkTypeInfo hkpRackAndPinionConstraintAtomTypeInfo(
	"hkpRackAndPinionConstraintAtom",
	"!hkpRackAndPinionConstraintAtom",
	finishLoadedObjecthkpRackAndPinionConstraintAtom,
	cleanupLoadedObjecthkpRackAndPinionConstraintAtom,
	HK_NULL,
	sizeof(hkpRackAndPinionConstraintAtom)
	);
#endif

//
// Class hkpCogWheelConstraintAtom
//

static const hkInternalClassMember hkpCogWheelConstraintAtomClass_Members[] =
{
	{ "cogWheelRadiusA", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpCogWheelConstraintAtom,m_cogWheelRadiusA), HK_NULL },
	{ "cogWheelRadiusB", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpCogWheelConstraintAtom,m_cogWheelRadiusB), HK_NULL },
	{ "isScrew", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpCogWheelConstraintAtom,m_isScrew), HK_NULL },
	{ "memOffsetToInitialAngleOffset", HK_NULL, HK_NULL, hkClassMember::TYPE_INT8, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpCogWheelConstraintAtom,m_memOffsetToInitialAngleOffset), HK_NULL },
	{ "memOffsetToPrevAngle", HK_NULL, HK_NULL, hkClassMember::TYPE_INT8, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpCogWheelConstraintAtom,m_memOffsetToPrevAngle), HK_NULL },
	{ "memOffsetToRevolutionCounter", HK_NULL, HK_NULL, hkClassMember::TYPE_INT8, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hkpCogWheelConstraintAtom,m_memOffsetToRevolutionCounter), HK_NULL }
};
extern const hkClass hkpCogWheelConstraintAtomClass;
const hkClass hkpCogWheelConstraintAtomClass(
	"hkpCogWheelConstraintAtom",
	&hkpConstraintAtomClass, // parent
	sizeof(::hkpCogWheelConstraintAtom),
	HK_NULL,
	0, // interfaces
	HK_NULL,
	0, // enums
	reinterpret_cast<const hkClassMember*>(hkpCogWheelConstraintAtomClass_Members),
	HK_COUNT_OF(hkpCogWheelConstraintAtomClass_Members),
	HK_NULL, // defaults
	HK_NULL, // attributes
	0, // flags
	hkUint32(0) // version
	);
#ifndef HK_HKCLASS_DEFINITION_ONLY
const hkClass& HK_CALL hkpCogWheelConstraintAtom::staticClass()
{
	return hkpCogWheelConstraintAtomClass;
}
HK_COMPILE_TIME_ASSERT2( \
	sizeof(hkIsVirtual(static_cast<hkpCogWheelConstraintAtom*>(0))) == sizeof(hkBool::CompileTimeFalseType), \
	REFLECTION_PARSER_VTABLE_DETECTION_FAILED );
static void HK_CALL finishLoadedObjecthkpCogWheelConstraintAtom(void* p, int finishing = 1)
{
	hkFinishLoadedObjectFlag f;
	f.m_finishing = finishing;
	new (p) hkpCogWheelConstraintAtom(f);
}
static void HK_CALL cleanupLoadedObjecthkpCogWheelConstraintAtom(void* p)
{
	static_cast<hkpCogWheelConstraintAtom*>(p)->~hkpCogWheelConstraintAtom();
}
extern const hkTypeInfo hkpCogWheelConstraintAtomTypeInfo;
const hkTypeInfo hkpCogWheelConstraintAtomTypeInfo(
	"hkpCogWheelConstraintAtom",
	"!hkpCogWheelConstraintAtom",
	finishLoadedObjecthkpCogWheelConstraintAtom,
	cleanupLoadedObjecthkpCogWheelConstraintAtom,
	HK_NULL,
	sizeof(hkpCogWheelConstraintAtom)
	);
#endif

/*
 * Havok SDK - Base file, BUILD(#20130912)
 * 
 * Confidential Information of Havok.  (C) Copyright 1999-2013
 * Telekinesys Research Limited t/a Havok. All Rights Reserved. The Havok
 * Logo, and the Havok buzzsaw logo are trademarks of Havok.  Title, ownership
 * rights, and intellectual property rights in the Havok software remain in
 * Havok and/or its suppliers.
 * 
 * Use of this software for evaluation purposes is subject to and indicates
 * acceptance of the End User licence Agreement for this product. A copy of
 * the license is included with this software and is also available from salesteam@havok.com.
 * 
 */
