/*
 *
 * Confidential Information of Telekinesys Research Limited (t/a Havok). Not for disclosure or distribution without Havok's
 * prior written consent. This software contains code, techniques and know-how which is confidential and proprietary to Havok.
 * Product and Trade Secret source code contains trade secrets of Havok. Havok Software (C) Copyright 1999-2013 Telekinesys Research Limited t/a Havok. All Rights Reserved. Use of this software is subject to the terms of an end user license agreement.
 *
 */

//HK_REFLECTION_PARSER_EXCLUDE_FILE

// Autogenerated by generateReflections.py (reflectedClasses.py)
// Changes will not be lost unless:
// - The workspace is re-generated using build.py
// - The corresponding reflection database (reflection.db) is deleted
// - The --force-output or --force-rebuild option is added to the pre-build generateReflection.py execution

// Generated from 'Physics/Physics/Extensions/CharacterControl/Proxy/hknpCharacterProxyCinfo.h'
#include <Physics/Physics/hknpPhysics.h>
#include <Common/Base/Reflection/hkClass.h>
#include <Common/Base/Reflection/hkInternalClassMember.h>
#include <Common/Base/Reflection/hkTypeInfo.h>
#include <Common/Base/Reflection/Attributes/hkAttributes.h>
#include <Physics/Physics/Extensions/CharacterControl/Proxy/hknpCharacterProxyCinfo.h>
#define True true
#define False false


// External pointer and enum types
extern const hkClass hknpShapeClass;
extern const hkClass hknpWorldClass;

//
// Class hknpCharacterProxyCinfo
//
extern const hkClass hkReferencedObjectClass;

// hknpCharacterProxyCinfo_position attributes
static const hkUiAttribute hknpCharacterProxyCinfo_position_hkUi = { False, hkUiAttribute::NONE, "", "", "", false, false, false };
static const hkInternalCustomAttributes::Attribute hknpCharacterProxyCinfo_position_AttributesList[] =
{
	{ "hk.Ui", &hknpCharacterProxyCinfo_position_hkUi, &hkUiAttributeClass }
};
static const hkInternalCustomAttributes hknpCharacterProxyCinfo_position_Attributes = { hknpCharacterProxyCinfo_position_AttributesList, HK_COUNT_OF(hknpCharacterProxyCinfo_position_AttributesList) };
// hknpCharacterProxyCinfo_orientation attributes
static const hkUiAttribute hknpCharacterProxyCinfo_orientation_hkUi = { False, hkUiAttribute::NONE, "", "", "", false, false, false };
static const hkInternalCustomAttributes::Attribute hknpCharacterProxyCinfo_orientation_AttributesList[] =
{
	{ "hk.Ui", &hknpCharacterProxyCinfo_orientation_hkUi, &hkUiAttributeClass }
};
static const hkInternalCustomAttributes hknpCharacterProxyCinfo_orientation_Attributes = { hknpCharacterProxyCinfo_orientation_AttributesList, HK_COUNT_OF(hknpCharacterProxyCinfo_orientation_AttributesList) };
// hknpCharacterProxyCinfo_velocity attributes
static const hkUiAttribute hknpCharacterProxyCinfo_velocity_hkUi = { False, hkUiAttribute::NONE, "", "", "", false, false, false };
static const hkInternalCustomAttributes::Attribute hknpCharacterProxyCinfo_velocity_AttributesList[] =
{
	{ "hk.Ui", &hknpCharacterProxyCinfo_velocity_hkUi, &hkUiAttributeClass }
};
static const hkInternalCustomAttributes hknpCharacterProxyCinfo_velocity_Attributes = { hknpCharacterProxyCinfo_velocity_AttributesList, HK_COUNT_OF(hknpCharacterProxyCinfo_velocity_AttributesList) };
// hknpCharacterProxyCinfo_dynamicFriction attributes
static const hkRangeRealAttribute hknpCharacterProxyCinfo_dynamicFriction_hkRangeReal( 0.000000f, 1.000000f, 0.000000f, 1.000000f );
#ifdef HK_CONFIG_STRIP_hkDescription
static const hkDescriptionAttribute hknpCharacterProxyCinfo_dynamicFriction_hkDescription = { HK_NULL };
#else
static const hkDescriptionAttribute hknpCharacterProxyCinfo_dynamicFriction_hkDescription = { "Controls the default dynamic friction for surfaces hit. A value of 0 maintains character momentum. A value of 1 clips all momentum against the normal of the surface hit." };
#endif
static const hkInternalCustomAttributes::Attribute hknpCharacterProxyCinfo_dynamicFriction_AttributesList[] =
{
	{ "hk.RangeReal", &hknpCharacterProxyCinfo_dynamicFriction_hkRangeReal, &hkRangeRealAttributeClass },
	{ "hk.Description", &hknpCharacterProxyCinfo_dynamicFriction_hkDescription, &hkDescriptionAttributeClass }
};
static const hkInternalCustomAttributes hknpCharacterProxyCinfo_dynamicFriction_Attributes = { hknpCharacterProxyCinfo_dynamicFriction_AttributesList, HK_COUNT_OF(hknpCharacterProxyCinfo_dynamicFriction_AttributesList) };
// hknpCharacterProxyCinfo_staticFriction attributes
static const hkRangeRealAttribute hknpCharacterProxyCinfo_staticFriction_hkRangeReal( 0.000000f, 1.000000f, 0.000000f, 1.000000f );
#ifdef HK_CONFIG_STRIP_hkDescription
static const hkDescriptionAttribute hknpCharacterProxyCinfo_staticFriction_hkDescription = { HK_NULL };
#else
static const hkDescriptionAttribute hknpCharacterProxyCinfo_staticFriction_hkDescription = { "Controls the default static friction for surfaces hit." };
#endif
static const hkInternalCustomAttributes::Attribute hknpCharacterProxyCinfo_staticFriction_AttributesList[] =
{
	{ "hk.RangeReal", &hknpCharacterProxyCinfo_staticFriction_hkRangeReal, &hkRangeRealAttributeClass },
	{ "hk.Description", &hknpCharacterProxyCinfo_staticFriction_hkDescription, &hkDescriptionAttributeClass }
};
static const hkInternalCustomAttributes hknpCharacterProxyCinfo_staticFriction_Attributes = { hknpCharacterProxyCinfo_staticFriction_AttributesList, HK_COUNT_OF(hknpCharacterProxyCinfo_staticFriction_AttributesList) };
// hknpCharacterProxyCinfo_keepContactTolerance attributes
static const hkRangeRealAttribute hknpCharacterProxyCinfo_keepContactTolerance_hkRangeReal( 0.000000f, 1.000000f, 0.000000f, 1.000000f );
#ifdef HK_CONFIG_STRIP_hkDescription
static const hkDescriptionAttribute hknpCharacterProxyCinfo_keepContactTolerance_hkDescription = { HK_NULL };
#else
static const hkDescriptionAttribute hknpCharacterProxyCinfo_keepContactTolerance_hkDescription = { "This parameter is used to determine when a contact point should be considered as part of the character's contact manifold. The default is 0.1f, which means that points .1 above the keep distance will be considered as part of the manifold. This value should be kept at the its default, as changing it from the default value can have undesirable effects." };
#endif
static const hkInternalCustomAttributes::Attribute hknpCharacterProxyCinfo_keepContactTolerance_AttributesList[] =
{
	{ "hk.RangeReal", &hknpCharacterProxyCinfo_keepContactTolerance_hkRangeReal, &hkRangeRealAttributeClass },
	{ "hk.Description", &hknpCharacterProxyCinfo_keepContactTolerance_hkDescription, &hkDescriptionAttributeClass }
};
static const hkInternalCustomAttributes hknpCharacterProxyCinfo_keepContactTolerance_Attributes = { hknpCharacterProxyCinfo_keepContactTolerance_AttributesList, HK_COUNT_OF(hknpCharacterProxyCinfo_keepContactTolerance_AttributesList) };
// hknpCharacterProxyCinfo_up attributes
static const hkUiAttribute hknpCharacterProxyCinfo_up_hkUi = { False, hkUiAttribute::NONE, "", "", "", false, false, false };
static const hkInternalCustomAttributes::Attribute hknpCharacterProxyCinfo_up_AttributesList[] =
{
	{ "hk.Ui", &hknpCharacterProxyCinfo_up_hkUi, &hkUiAttributeClass }
};
static const hkInternalCustomAttributes hknpCharacterProxyCinfo_up_Attributes = { hknpCharacterProxyCinfo_up_AttributesList, HK_COUNT_OF(hknpCharacterProxyCinfo_up_AttributesList) };
// hknpCharacterProxyCinfo_shape attributes
static const hkUiAttribute hknpCharacterProxyCinfo_shape_hkUi = { False, hkUiAttribute::NONE, "", "", "", false, false, false };
static const hkInternalCustomAttributes::Attribute hknpCharacterProxyCinfo_shape_AttributesList[] =
{
	{ "hk.Ui", &hknpCharacterProxyCinfo_shape_hkUi, &hkUiAttributeClass }
};
static const hkInternalCustomAttributes hknpCharacterProxyCinfo_shape_Attributes = { hknpCharacterProxyCinfo_shape_AttributesList, HK_COUNT_OF(hknpCharacterProxyCinfo_shape_AttributesList) };
// hknpCharacterProxyCinfo_world attributes
static const hkUiAttribute hknpCharacterProxyCinfo_world_hkUi = { False, hkUiAttribute::NONE, "", "", "", false, false, false };
static const hkInternalCustomAttributes::Attribute hknpCharacterProxyCinfo_world_AttributesList[] =
{
	{ "hk.Ui", &hknpCharacterProxyCinfo_world_hkUi, &hkUiAttributeClass }
};
static const hkInternalCustomAttributes hknpCharacterProxyCinfo_world_Attributes = { hknpCharacterProxyCinfo_world_AttributesList, HK_COUNT_OF(hknpCharacterProxyCinfo_world_AttributesList) };
// hknpCharacterProxyCinfo_collisionFilterInfo attributes
static const hkUiAttribute hknpCharacterProxyCinfo_collisionFilterInfo_hkUi = { False, hkUiAttribute::NONE, "", "", "", false, false, false };
static const hkInternalCustomAttributes::Attribute hknpCharacterProxyCinfo_collisionFilterInfo_AttributesList[] =
{
	{ "hk.Ui", &hknpCharacterProxyCinfo_collisionFilterInfo_hkUi, &hkUiAttributeClass }
};
static const hkInternalCustomAttributes hknpCharacterProxyCinfo_collisionFilterInfo_Attributes = { hknpCharacterProxyCinfo_collisionFilterInfo_AttributesList, HK_COUNT_OF(hknpCharacterProxyCinfo_collisionFilterInfo_AttributesList) };
// hknpCharacterProxyCinfo_keepDistance attributes
static const hkRangeRealAttribute hknpCharacterProxyCinfo_keepDistance_hkRangeReal( 0.000000f, 1.000000f, 0.000000f, 1.000000f );
#ifdef HK_CONFIG_STRIP_hkDescription
static const hkDescriptionAttribute hknpCharacterProxyCinfo_keepDistance_hkDescription = { HK_NULL };
#else
static const hkDescriptionAttribute hknpCharacterProxyCinfo_keepDistance_hkDescription = { "Attempt to keep the character at least this distance from the surface." };
#endif
static const hkInternalCustomAttributes::Attribute hknpCharacterProxyCinfo_keepDistance_AttributesList[] =
{
	{ "hk.RangeReal", &hknpCharacterProxyCinfo_keepDistance_hkRangeReal, &hkRangeRealAttributeClass },
	{ "hk.Description", &hknpCharacterProxyCinfo_keepDistance_hkDescription, &hkDescriptionAttributeClass }
};
static const hkInternalCustomAttributes hknpCharacterProxyCinfo_keepDistance_Attributes = { hknpCharacterProxyCinfo_keepDistance_AttributesList, HK_COUNT_OF(hknpCharacterProxyCinfo_keepDistance_AttributesList) };
// hknpCharacterProxyCinfo_contactAngleSensitivity attributes
static const hkRangeRealAttribute hknpCharacterProxyCinfo_contactAngleSensitivity_hkRangeReal( 0.010000f, 100.000000f, 0.010000f, 100.000000f );
#ifdef HK_CONFIG_STRIP_hkDescription
static const hkDescriptionAttribute hknpCharacterProxyCinfo_contactAngleSensitivity_hkDescription = { HK_NULL };
#else
static const hkDescriptionAttribute hknpCharacterProxyCinfo_contactAngleSensitivity_hkDescription = { "This value is used when deciding which contact points in the manifold are duplicates. Precisely, it determines when two contact points are found, whether they are to be treated as the same based on the angle between the normals. For the default value of 10, contact points with angles less then 2.56 degrees are considered as identical. If you decrease this to 1, contact points with angles less then 8.1 degrees are considered as identical. A larger value will increase the number of contact points considered in the manifold, and make for a more accurate simulation at slightly higher computational expense." };
#endif
static const hkInternalCustomAttributes::Attribute hknpCharacterProxyCinfo_contactAngleSensitivity_AttributesList[] =
{
	{ "hk.RangeReal", &hknpCharacterProxyCinfo_contactAngleSensitivity_hkRangeReal, &hkRangeRealAttributeClass },
	{ "hk.Description", &hknpCharacterProxyCinfo_contactAngleSensitivity_hkDescription, &hkDescriptionAttributeClass }
};
static const hkInternalCustomAttributes hknpCharacterProxyCinfo_contactAngleSensitivity_Attributes = { hknpCharacterProxyCinfo_contactAngleSensitivity_AttributesList, HK_COUNT_OF(hknpCharacterProxyCinfo_contactAngleSensitivity_AttributesList) };
// hknpCharacterProxyCinfo_userPlanes attributes
#ifdef HK_CONFIG_STRIP_hkDescription
static const hkDescriptionAttribute hknpCharacterProxyCinfo_userPlanes_hkDescription = { HK_NULL };
#else
static const hkDescriptionAttribute hknpCharacterProxyCinfo_userPlanes_hkDescription = { "The maximum number of extra planes the user may add to the simplex input during a processConstraints callback." };
#endif
static const hkRangeInt32Attribute hknpCharacterProxyCinfo_userPlanes_hkRangeInt32( 0, 20, 0, 20 );
static const hkInternalCustomAttributes::Attribute hknpCharacterProxyCinfo_userPlanes_AttributesList[] =
{
	{ "hk.Description", &hknpCharacterProxyCinfo_userPlanes_hkDescription, &hkDescriptionAttributeClass },
	{ "hk.RangeInt32", &hknpCharacterProxyCinfo_userPlanes_hkRangeInt32, &hkRangeInt32AttributeClass }
};
static const hkInternalCustomAttributes hknpCharacterProxyCinfo_userPlanes_Attributes = { hknpCharacterProxyCinfo_userPlanes_AttributesList, HK_COUNT_OF(hknpCharacterProxyCinfo_userPlanes_AttributesList) };
// hknpCharacterProxyCinfo_maxCharacterSpeedForSolver attributes
static const hkRangeRealAttribute hknpCharacterProxyCinfo_maxCharacterSpeedForSolver_hkRangeReal( 0.000000f, 100.000000f, 0.000000f, 100.000000f );
#ifdef HK_CONFIG_STRIP_hkDescription
static const hkDescriptionAttribute hknpCharacterProxyCinfo_maxCharacterSpeedForSolver_hkDescription = { HK_NULL };
#else
static const hkDescriptionAttribute hknpCharacterProxyCinfo_maxCharacterSpeedForSolver_hkDescription = { "This value is used to clip the characters velocity when it is being squeezed by two moving planes. When two nearly parallel planes squeeze the character, the resultant velocity necessary to move the character so that both planes do not penetrate it can be extremely high, which can cause in the character controller to move at a very fast velocity. This value defaults to 10 which is appropriate if your default walking speed is 10. If this velocity is exceeded by the character solver when solving parallel planes, the solver solves the planes independently. The result is that instead of moving at a high velocity, the character may penetrate one of the planes - based on plane priorities." };
#endif
static const hkInternalCustomAttributes::Attribute hknpCharacterProxyCinfo_maxCharacterSpeedForSolver_AttributesList[] =
{
	{ "hk.RangeReal", &hknpCharacterProxyCinfo_maxCharacterSpeedForSolver_hkRangeReal, &hkRangeRealAttributeClass },
	{ "hk.Description", &hknpCharacterProxyCinfo_maxCharacterSpeedForSolver_hkDescription, &hkDescriptionAttributeClass }
};
static const hkInternalCustomAttributes hknpCharacterProxyCinfo_maxCharacterSpeedForSolver_Attributes = { hknpCharacterProxyCinfo_maxCharacterSpeedForSolver_AttributesList, HK_COUNT_OF(hknpCharacterProxyCinfo_maxCharacterSpeedForSolver_AttributesList) };
// hknpCharacterProxyCinfo_characterStrength attributes
static const hkRangeRealAttribute hknpCharacterProxyCinfo_characterStrength_hkRangeReal( 0.000000f, 78999999999999996926548246528.000000f, 0.000000f, 78999999999999996926548246528.000000f );
#ifdef HK_CONFIG_STRIP_hkDescription
static const hkDescriptionAttribute hknpCharacterProxyCinfo_characterStrength_hkDescription = { HK_NULL };
#else
static const hkDescriptionAttribute hknpCharacterProxyCinfo_characterStrength_hkDescription = { "The maximum constant force that the character controller can impart onto dynamic objects. By default this is HK_REAL_MAX, i.e. the character controller is infinitely strong." };
#endif
static const hkInternalCustomAttributes::Attribute hknpCharacterProxyCinfo_characterStrength_AttributesList[] =
{
	{ "hk.RangeReal", &hknpCharacterProxyCinfo_characterStrength_hkRangeReal, &hkRangeRealAttributeClass },
	{ "hk.Description", &hknpCharacterProxyCinfo_characterStrength_hkDescription, &hkDescriptionAttributeClass }
};
static const hkInternalCustomAttributes hknpCharacterProxyCinfo_characterStrength_Attributes = { hknpCharacterProxyCinfo_characterStrength_AttributesList, HK_COUNT_OF(hknpCharacterProxyCinfo_characterStrength_AttributesList) };
// hknpCharacterProxyCinfo_characterMass attributes
static const hkRangeRealAttribute hknpCharacterProxyCinfo_characterMass_hkRangeReal( 0.000000f, 1000.000000f, 0.000000f, 1000.000000f );
#ifdef HK_CONFIG_STRIP_hkDescription
static const hkDescriptionAttribute hknpCharacterProxyCinfo_characterMass_hkDescription = { HK_NULL };
#else
static const hkDescriptionAttribute hknpCharacterProxyCinfo_characterMass_hkDescription = { "The mass of the character. This value is only used to apply an extra downward force to dynamic rigid bodies that the character is standing on.  By default this value is 0, which means no additional downward force is applied.  It should only be set to a positive value if you do not apply gravity from your state machine when the character is on the ground." };
#endif
static const hkInternalCustomAttributes::Attribute hknpCharacterProxyCinfo_characterMass_AttributesList[] =
{
	{ "hk.RangeReal", &hknpCharacterProxyCinfo_characterMass_hkRangeReal, &hkRangeRealAttributeClass },
	{ "hk.Description", &hknpCharacterProxyCinfo_characterMass_hkDescription, &hkDescriptionAttributeClass }
};
static const hkInternalCustomAttributes hknpCharacterProxyCinfo_characterMass_Attributes = { hknpCharacterProxyCinfo_characterMass_AttributesList, HK_COUNT_OF(hknpCharacterProxyCinfo_characterMass_AttributesList) };
// hknpCharacterProxyCinfo_maxSlope attributes
static const hkRangeRealAttribute hknpCharacterProxyCinfo_maxSlope_hkRangeReal( 0.000000f, 1.570796f, 0.000000f, 1.570796f );
#ifdef HK_CONFIG_STRIP_hkDescription
static const hkDescriptionAttribute hknpCharacterProxyCinfo_maxSlope_hkDescription = { HK_NULL };
#else
static const hkDescriptionAttribute hknpCharacterProxyCinfo_maxSlope_hkDescription = { "The maximum slope that the character can walk up. If the character is standing on a slope that is steeper than this, checkSupport will return false, and an additional vertical plane will be added during integrate that will block the character's movement in the direction of the slope. This angle is measured in degrees from the horizontal. By default this value is set to PI / 2, i.e. vertical, which disables this feature." };
#endif
static const hkInternalCustomAttributes::Attribute hknpCharacterProxyCinfo_maxSlope_AttributesList[] =
{
	{ "hk.RangeReal", &hknpCharacterProxyCinfo_maxSlope_hkRangeReal, &hkRangeRealAttributeClass },
	{ "hk.Description", &hknpCharacterProxyCinfo_maxSlope_hkDescription, &hkDescriptionAttributeClass }
};
static const hkInternalCustomAttributes hknpCharacterProxyCinfo_maxSlope_Attributes = { hknpCharacterProxyCinfo_maxSlope_AttributesList, HK_COUNT_OF(hknpCharacterProxyCinfo_maxSlope_AttributesList) };
// hknpCharacterProxyCinfo_penetrationRecoverySpeed attributes
static const hkRangeRealAttribute hknpCharacterProxyCinfo_penetrationRecoverySpeed_hkRangeReal( 0.000000f, 10.000000f, 0.000000f, 10.000000f );
#ifdef HK_CONFIG_STRIP_hkDescription
static const hkDescriptionAttribute hknpCharacterProxyCinfo_penetrationRecoverySpeed_hkDescription = { HK_NULL };
#else
static const hkDescriptionAttribute hknpCharacterProxyCinfo_penetrationRecoverySpeed_hkDescription = { "When a penetrating plane is added to the manifold we set its velocity so it will push the character away from the point of penetration. This variable controls the speed at which this recovery takes place. The velocity applied is proportional to the penetration distance. This values controls the proportion. By default this value is set to 1.0" };
#endif
static const hkInternalCustomAttributes::Attribute hknpCharacterProxyCinfo_penetrationRecoverySpeed_AttributesList[] =
{
	{ "hk.RangeReal", &hknpCharacterProxyCinfo_penetrationRecoverySpeed_hkRangeReal, &hkRangeRealAttributeClass },
	{ "hk.Description", &hknpCharacterProxyCinfo_penetrationRecoverySpeed_hkDescription, &hkDescriptionAttributeClass }
};
static const hkInternalCustomAttributes hknpCharacterProxyCinfo_penetrationRecoverySpeed_Attributes = { hknpCharacterProxyCinfo_penetrationRecoverySpeed_AttributesList, HK_COUNT_OF(hknpCharacterProxyCinfo_penetrationRecoverySpeed_AttributesList) };
// hknpCharacterProxyCinfo_maxCastIterations attributes
#ifdef HK_CONFIG_STRIP_hkDescription
static const hkDescriptionAttribute hknpCharacterProxyCinfo_maxCastIterations_hkDescription = { HK_NULL };
#else
static const hkDescriptionAttribute hknpCharacterProxyCinfo_maxCastIterations_hkDescription = { "The number of iterations the character controller will take to resolve an integrate call. The character controller will iterate if it hits a surface, and needs to change direction to complete the integrate for that timestep.  The default is 10 iterations." };
#endif
static const hkRangeInt32Attribute hknpCharacterProxyCinfo_maxCastIterations_hkRangeInt32( 0, 50, 0, 50 );
static const hkInternalCustomAttributes::Attribute hknpCharacterProxyCinfo_maxCastIterations_AttributesList[] =
{
	{ "hk.Description", &hknpCharacterProxyCinfo_maxCastIterations_hkDescription, &hkDescriptionAttributeClass },
	{ "hk.RangeInt32", &hknpCharacterProxyCinfo_maxCastIterations_hkRangeInt32, &hkRangeInt32AttributeClass }
};
static const hkInternalCustomAttributes hknpCharacterProxyCinfo_maxCastIterations_Attributes = { hknpCharacterProxyCinfo_maxCastIterations_AttributesList, HK_COUNT_OF(hknpCharacterProxyCinfo_maxCastIterations_AttributesList) };
// hknpCharacterProxyCinfo_refreshManifoldInCheckSupport attributes
#ifdef HK_CONFIG_STRIP_hkDescription
static const hkDescriptionAttribute hknpCharacterProxyCinfo_refreshManifoldInCheckSupport_hkDescription = { HK_NULL };
#else
static const hkDescriptionAttribute hknpCharacterProxyCinfo_refreshManifoldInCheckSupport_hkDescription = { "This flag determines whether the character controller refreshes the manifold when checkSupport is called. By default this is set to false, i.e. the manifold is not updated. This leads to a small inaccuracy when the character controller is hit by a rapidly accelerating body, however it is better to accept this inaccuracy, as the extra refresh manifold call can be computationally expensive." };
#endif
static const hkInternalCustomAttributes::Attribute hknpCharacterProxyCinfo_refreshManifoldInCheckSupport_AttributesList[] =
{
	{ "hk.Description", &hknpCharacterProxyCinfo_refreshManifoldInCheckSupport_hkDescription, &hkDescriptionAttributeClass }
};
static const hkInternalCustomAttributes hknpCharacterProxyCinfo_refreshManifoldInCheckSupport_Attributes = { hknpCharacterProxyCinfo_refreshManifoldInCheckSupport_AttributesList, HK_COUNT_OF(hknpCharacterProxyCinfo_refreshManifoldInCheckSupport_AttributesList) };
// hknpCharacterProxyCinfo_presenceInWorld attributes
#ifdef HK_CONFIG_STRIP_hkDescription
static const hkDescriptionAttribute hknpCharacterProxyCinfo_presenceInWorld_hkDescription = { HK_NULL };
#else
static const hkDescriptionAttribute hknpCharacterProxyCinfo_presenceInWorld_hkDescription = { "This flag determines if the character controller should be present in the simulated world as a special phantom. By default this is set to false, i.e., the shape is not added as a phantom body." };
#endif
static const hkInternalCustomAttributes::Attribute hknpCharacterProxyCinfo_presenceInWorld_AttributesList[] =
{
	{ "hk.Description", &hknpCharacterProxyCinfo_presenceInWorld_hkDescription, &hkDescriptionAttributeClass }
};
static const hkInternalCustomAttributes hknpCharacterProxyCinfo_presenceInWorld_Attributes = { hknpCharacterProxyCinfo_presenceInWorld_AttributesList, HK_COUNT_OF(hknpCharacterProxyCinfo_presenceInWorld_AttributesList) };
static const hkInternalClassMember hknpCharacterProxyCinfoClass_Members[] =
{
	{ "position", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hknpCharacterProxyCinfo,m_position), &hknpCharacterProxyCinfo_position_Attributes },
	{ "orientation", HK_NULL, HK_NULL, hkClassMember::TYPE_QUATERNION, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hknpCharacterProxyCinfo,m_orientation), &hknpCharacterProxyCinfo_orientation_Attributes },
	{ "velocity", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hknpCharacterProxyCinfo,m_velocity), &hknpCharacterProxyCinfo_velocity_Attributes },
	{ "dynamicFriction", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hknpCharacterProxyCinfo,m_dynamicFriction), &hknpCharacterProxyCinfo_dynamicFriction_Attributes },
	{ "staticFriction", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hknpCharacterProxyCinfo,m_staticFriction), &hknpCharacterProxyCinfo_staticFriction_Attributes },
	{ "keepContactTolerance", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hknpCharacterProxyCinfo,m_keepContactTolerance), &hknpCharacterProxyCinfo_keepContactTolerance_Attributes },
	{ "up", HK_NULL, HK_NULL, hkClassMember::TYPE_VECTOR4, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hknpCharacterProxyCinfo,m_up), &hknpCharacterProxyCinfo_up_Attributes },
	{ "shape", &hknpShapeClass, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_STRUCT, 0, 0, HK_OFFSET_OF(hknpCharacterProxyCinfo,m_shape), &hknpCharacterProxyCinfo_shape_Attributes },
	{ "world", HK_NULL, HK_NULL, hkClassMember::TYPE_POINTER, hkClassMember::TYPE_VOID, 0, 0|hkClassMember::SERIALIZE_IGNORED, HK_OFFSET_OF(hknpCharacterProxyCinfo,m_world), &hknpCharacterProxyCinfo_world_Attributes },
	{ "collisionFilterInfo", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hknpCharacterProxyCinfo,m_collisionFilterInfo), &hknpCharacterProxyCinfo_collisionFilterInfo_Attributes },
	{ "keepDistance", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hknpCharacterProxyCinfo,m_keepDistance), &hknpCharacterProxyCinfo_keepDistance_Attributes },
	{ "contactAngleSensitivity", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hknpCharacterProxyCinfo,m_contactAngleSensitivity), &hknpCharacterProxyCinfo_contactAngleSensitivity_Attributes },
	{ "userPlanes", HK_NULL, HK_NULL, hkClassMember::TYPE_UINT32, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hknpCharacterProxyCinfo,m_userPlanes), &hknpCharacterProxyCinfo_userPlanes_Attributes },
	{ "maxCharacterSpeedForSolver", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hknpCharacterProxyCinfo,m_maxCharacterSpeedForSolver), &hknpCharacterProxyCinfo_maxCharacterSpeedForSolver_Attributes },
	{ "characterStrength", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hknpCharacterProxyCinfo,m_characterStrength), &hknpCharacterProxyCinfo_characterStrength_Attributes },
	{ "characterMass", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hknpCharacterProxyCinfo,m_characterMass), &hknpCharacterProxyCinfo_characterMass_Attributes },
	{ "maxSlope", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hknpCharacterProxyCinfo,m_maxSlope), &hknpCharacterProxyCinfo_maxSlope_Attributes },
	{ "penetrationRecoverySpeed", HK_NULL, HK_NULL, hkClassMember::TYPE_REAL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hknpCharacterProxyCinfo,m_penetrationRecoverySpeed), &hknpCharacterProxyCinfo_penetrationRecoverySpeed_Attributes },
	{ "maxCastIterations", HK_NULL, HK_NULL, hkClassMember::TYPE_INT32, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hknpCharacterProxyCinfo,m_maxCastIterations), &hknpCharacterProxyCinfo_maxCastIterations_Attributes },
	{ "refreshManifoldInCheckSupport", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hknpCharacterProxyCinfo,m_refreshManifoldInCheckSupport), &hknpCharacterProxyCinfo_refreshManifoldInCheckSupport_Attributes },
	{ "presenceInWorld", HK_NULL, HK_NULL, hkClassMember::TYPE_BOOL, hkClassMember::TYPE_VOID, 0, 0, HK_OFFSET_OF(hknpCharacterProxyCinfo,m_presenceInWorld), &hknpCharacterProxyCinfo_presenceInWorld_Attributes }
};
namespace
{
	struct hknpCharacterProxyCinfo_DefaultStruct
	{
		int s_defaultOffsets[21];
		typedef hkInt8 _hkBool;
		typedef hkFloat32 _hkVector4[4];
		typedef hkReal _hkQuaternion[4];
		typedef hkReal _hkMatrix3[12];
		typedef hkReal _hkRotation[12];
		typedef hkReal _hkQsTransform[12];
		typedef hkReal _hkMatrix4[16];
		typedef hkReal _hkTransform[16];
		float m_dynamicFriction;
		float m_keepContactTolerance;
		float m_keepDistance;
		float m_contactAngleSensitivity;
		hkUint32 m_userPlanes;
		float m_maxCharacterSpeedForSolver;
		float m_characterStrength;
		float m_maxSlope;
		float m_penetrationRecoverySpeed;
		hkInt32 m_maxCastIterations;
	};
	const hknpCharacterProxyCinfo_DefaultStruct hknpCharacterProxyCinfo_Default =
	{
		{-1,-1,-1,HK_OFFSET_OF(hknpCharacterProxyCinfo_DefaultStruct,m_dynamicFriction),hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hknpCharacterProxyCinfo_DefaultStruct,m_keepContactTolerance),-1,-1,-1,-1,HK_OFFSET_OF(hknpCharacterProxyCinfo_DefaultStruct,m_keepDistance),HK_OFFSET_OF(hknpCharacterProxyCinfo_DefaultStruct,m_contactAngleSensitivity),HK_OFFSET_OF(hknpCharacterProxyCinfo_DefaultStruct,m_userPlanes),HK_OFFSET_OF(hknpCharacterProxyCinfo_DefaultStruct,m_maxCharacterSpeedForSolver),HK_OFFSET_OF(hknpCharacterProxyCinfo_DefaultStruct,m_characterStrength),hkClassMember::HK_CLASS_ZERO_DEFAULT,HK_OFFSET_OF(hknpCharacterProxyCinfo_DefaultStruct,m_maxSlope),HK_OFFSET_OF(hknpCharacterProxyCinfo_DefaultStruct,m_penetrationRecoverySpeed),HK_OFFSET_OF(hknpCharacterProxyCinfo_DefaultStruct,m_maxCastIterations),hkClassMember::HK_CLASS_ZERO_DEFAULT,hkClassMember::HK_CLASS_ZERO_DEFAULT},
		1.0f,0.1f,0.05f,10,4,10,7.9E+28f,1.57079633f,1.0f,10
	};
}
extern const hkClass hknpCharacterProxyCinfoClass;
const hkClass hknpCharacterProxyCinfoClass(
	"hknpCharacterProxyCinfo",
	&hkReferencedObjectClass, // parent
	sizeof(::hknpCharacterProxyCinfo),
	HK_NULL,
	0, // interfaces
	HK_NULL,
	0, // enums
	reinterpret_cast<const hkClassMember*>(hknpCharacterProxyCinfoClass_Members),
	HK_COUNT_OF(hknpCharacterProxyCinfoClass_Members),
	&hknpCharacterProxyCinfo_Default,
	HK_NULL, // attributes
	0, // flags
	hkUint32(0) // version
	);
#ifndef HK_HKCLASS_DEFINITION_ONLY
const hkClass& HK_CALL hknpCharacterProxyCinfo::staticClass()
{
	return hknpCharacterProxyCinfoClass;
}
HK_COMPILE_TIME_ASSERT2( \
	sizeof(hkIsVirtual(static_cast<hknpCharacterProxyCinfo*>(0))) == sizeof(hkBool::CompileTimeTrueType), \
	REFLECTION_PARSER_VTABLE_DETECTION_FAILED );
static void HK_CALL finishLoadedObjecthknpCharacterProxyCinfo(void* p, int finishing = 1)
{
	hkFinishLoadedObjectFlag f;
	f.m_finishing = finishing;
	new (p) hknpCharacterProxyCinfo(f);
}
static void HK_CALL cleanupLoadedObjecthknpCharacterProxyCinfo(void* p)
{
	static_cast<hknpCharacterProxyCinfo*>(p)->~hknpCharacterProxyCinfo();
}
static const void* HK_CALL getVtablehknpCharacterProxyCinfo()
{
	#if HK_LINKONCE_VTABLES==0
	#if HK_HASHCODE_VTABLE_REGISTRY==1
	return ((const void*)(typeid(hknpCharacterProxyCinfo).hash_code()));
	#else
	return ((const void*)(typeid(hknpCharacterProxyCinfo).name()));
	#endif
	#else
	union { HK_ALIGN16(void* ptr); char buf[sizeof(hknpCharacterProxyCinfo)]; } u;
	hkFinishLoadedObjectFlag f;
	new (u.buf) hknpCharacterProxyCinfo(f);
	return u.ptr;
	#endif
}
extern const hkTypeInfo hknpCharacterProxyCinfoTypeInfo;
const hkTypeInfo hknpCharacterProxyCinfoTypeInfo(
	"hknpCharacterProxyCinfo",
	"!hknpCharacterProxyCinfo",
	finishLoadedObjecthknpCharacterProxyCinfo,
	cleanupLoadedObjecthknpCharacterProxyCinfo,
	getVtablehknpCharacterProxyCinfo(),
	sizeof(hknpCharacterProxyCinfo)
	);
#endif

/*
 * Havok SDK - Base file, BUILD(#20130912)
 * 
 * Confidential Information of Havok.  (C) Copyright 1999-2013
 * Telekinesys Research Limited t/a Havok. All Rights Reserved. The Havok
 * Logo, and the Havok buzzsaw logo are trademarks of Havok.  Title, ownership
 * rights, and intellectual property rights in the Havok software remain in
 * Havok and/or its suppliers.
 * 
 * Use of this software for evaluation purposes is subject to and indicates
 * acceptance of the End User licence Agreement for this product. A copy of
 * the license is included with this software and is also available from salesteam@havok.com.
 * 
 */
